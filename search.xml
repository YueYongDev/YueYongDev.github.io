<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>未雨绸缪，小米前端实习面经</title>
      <link href="p/ec8b.html"/>
      <url>p/ec8b.html</url>
      
        <content type="html"><![CDATA[<p>前一篇文章中说到了我准备开一个新系列用于整理周围人面试的一些经历，本文是她面试小米的一份经历，也是这个系列的第一篇文章，投稿人是我同校同学，虽然本科就是一个学校的，但直到研究生才认识，之所以说她未雨绸缪是因为在我还没开始投实习简历的时候她就已经拿到了小米的实习 offer 了。作为一个米粉，我其实挺羡慕的，因为小米一直是我很向往的公司。</p><p>她是在 boss 直聘上投的小米，base 南京，因为是部门直招，看完了简历就约了面试，速度还是很快的。据她说虽然只有一轮面试，但是持续了将近一个小时，面试官还是比较随意的，问的问题都很基础，以下是她的面试记录。</p><p>一开始自然是老生常谈的自我介绍，一个好的自我介绍应该包含这几点要素：</p><ol><li>用简单的话说清楚自己主要的技术栈于擅长的领域；</li><li>把重点放在自己在行的地方以及自己的优势之处；</li><li>重点突出自己的能力比如自己的定位的 bug 的能力特别厉害；</li></ol><p>好的自我介绍会让面试官对你产生兴趣，毕竟换做你是面试官，一定也希望面试者不是客套地说说自己喜欢编程、平时花了很多时间来学习、自己的兴趣爱好是打球吧。</p><p>接下来就是一些基础方面的问题了，按照类别进行了整理。</p><h3 id="css-js-html"><a href="#css-js-html" class="headerlink" title="css/js/html"></a>css/js/html</h3><ol><li>css 块元素和行内元素</li><li>css 如何实现水平居中？</li><li>position 有哪四个属性？谈一谈你的理解</li><li>谈一谈你对盒模型的理解</li><li>flex 属性以及使用的一些问题</li><li>什么是 rem 布局？</li><li>js 原型链是什么？</li><li>js 闭包以及相关的使用</li><li>es6 新增了什么</li><li>基本数据类型(es6 新增)</li><li>var 和 let 区别</li><li>什么是事件委托机制</li><li>es6 的 promise 以及回调函数的使用</li><li>es7 的 async 和 await</li><li>LocalStorage 和 sessionStorage 区别以及 API</li></ol><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ol><li>MVVM 怎么理解</li><li>vue-router</li><li>说一下 vue 和 jQuery 的区别，哪个好</li></ol><h3 id="向面试官问问题"><a href="#向面试官问问题" class="headerlink" title="向面试官问问题"></a>向面试官问问题</h3><ol><li>实习生培养方式</li><li>实习期间的主要工作</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>问题基本都回答出来了，面试官可能也比较满意，主要运气比较好吧，面试官说没什么问题的应该只有这一轮技术面。</p><p>技术面试大概用了三十分钟，面试官说时间可能有点短，再随便聊聊吧。。。</p><p>随后又问了些问题，比如平时逛什么社区，遇到问题怎么解决，平时看什么书，对小米前端的看法等等</p><p>一周之后就收到了 hr 的电话，问了能去上班的时间以及薪资等，又过了一周收到了<code>offer</code></p><p>感觉运气挺好的，面试官人也很好，实习不会问什么太难的问题，最重要的是把基础打好，祝大家都能拿到心仪的<code>offer</code>~</p>]]></content>
      
      
      <categories>
          
          <category> 面试学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机相关专业实习指北</title>
      <link href="p/e834.html"/>
      <url>p/e834.html</url>
      
        <content type="html"><![CDATA[<p>相信很多人都知道，第一份实习/工作对于日后的发展尤其重要，在职场上接触的第一个 leader，也会对未来的工作思维、工作态度产生重要的影响。因此第一份实习，可不能随便找个兼职糊弄一下就过去了。</p><p>那么在选择企业实习的时候，我们应该做些什么呢？事实上，博主自己也是最近才找到实习，没有办法以长远的眼光来判断这个实习究竟对自己未来的作用有多大，所以这里仅仅是谈一下我自己所做的一些准备，以及我自己在找实习过程中的感悟和想法。</p><h2 id="明确你所处的阶段"><a href="#明确你所处的阶段" class="headerlink" title="明确你所处的阶段"></a>明确你所处的阶段</h2><p>明确你所处的阶段是指，先看看你现在到底是要找暑期实习还是秋招。相信很多要找实习/工作的同学都听说过<strong>“金三银四”、“金九银十”</strong>这样的词，也有很多人疑惑春招、秋招、暑期实习到底是什么？什么时候开始？这里有一张时间表 👇</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdqzrbeszhj30iu09o3z0.jpg"></p><h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>实习一般分成两种：日常实习和<strong>暑期实习</strong>。</p><ul><li>日常实习：日常实习是任何时候都可以找的，通常是根据具体部门的需求，由公司 HR、部门主管或者部门员工发布招聘消息，相对较为零散也比较灵活。</li><li><strong>暑期实习</strong>：很多公司，特别是大公司（如 BAT 等大厂），都会组织专项的暑期实习生招聘活动。一方面是针对在校学生的情况（很多学生只有暑期才有假期，或者导师暑假才放人），另一方面就是为了秋季校招（大规模招聘）吸引人才。暑期实习具有很大的意义，对学生来说，最直接的好处就是转正机会。暑期实习，一般 6 月底左右实习入职（也可以根据自己的时间，提前入职），一般 8 月底或 9 月份会有专项暑期实习答辩，根据综合表现，答辩通过后就可以基本结束秋招了。</li></ul><blockquote><p>因为大多数人是没多少时间日常实习的，所以 3 ～ 5 月找一个暑期实习是一个非常好的丰富简历的机会。</p></blockquote><h3 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h3><p>秋招就是正式开始找工作了，一般也分为两种：提前批和正式批。</p><ul><li>秋招提前批：时间是<strong>6 ～ 8 月</strong>，大多以<strong>内推</strong>为主，就和保研的夏令营/预推免一样，这个时间段的参与秋招提前批的大佬特别多，同时岗位 hc 并不多（因为企业要考虑正式批的情况，会控制招聘人数），所以可以把这段时间简单理解为<strong>神仙打架期</strong>。</li><li>秋招正式批：时间是<strong>9 ～ 11 月</strong>，这个阶段就是所谓的<strong>“金九银十”</strong>了，一般到这个时候就很考验心态了，因为如果到 9 月份或 10 月份了，你手里还没有 Offer，再看看身边已经拿到 Offer 的同学，一定化身成柠檬精 🍋。不过这个时候心态千万别崩，继续投继续干，<strong>广撒网才能多捕鱼</strong>。</li></ul><blockquote><p>因为楼主还没有经历到秋招，所以下面的内容都是围绕着找到一份实习来说的。</p></blockquote><h2 id="岗位选择"><a href="#岗位选择" class="headerlink" title="岗位选择"></a>岗位选择</h2><p>岗位选择其实很好理解，会什么就去找什么岗位呗。但是行业发展到现在，单会一门技术肯定是没办法闯荡江湖的。而且还有很多人在找工作之前其实什么都不会，比如我就曾在知乎上刷到下面这个问题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr0e6jh0ej311e08st9x.jpg"></p><p>于是这就回到了我们一开始学习编程时的一个困境了。我究竟应该选什么方向？</p><p>其实和互联网相关的岗位大类来看并不多，也就<strong>开发、算法、测试、产品等</strong>。分小类来看的话可能才会有些难以选择。开发里有前端、后端、客户端等，算法有数据岗、视觉岗等等。那么我们选择的时候就可以从下面三个方向去考虑了：</p><ol><li>你<strong>会做</strong>这个吗？</li><li>做这个<strong>钱多</strong>吗？</li><li>你<strong>喜欢</strong>做这个吗？</li></ol><p>可能会有人说容不容易找到工作也是另一个值得考虑的问题。是的，这的确是一个值得考虑的点，但是我觉得并不是最重要的，因为如果你真心喜欢做一个方向的话，你就会不断提升自己的能力，有了能力还担心找不到工作吗？如果因为某个岗位容易找到工作你就去做，那就不是你选择工作，而是<strong>工作选择你</strong>了。</p><p>不过如果还是有人想知道什么岗位容易找到工组的话，博主这里看到了某大厂一份 2020 年实习生的录用比，供大家参考。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr0wwtw07j30m808hmyj.jpg"></p><h2 id="实习地点选择"><a href="#实习地点选择" class="headerlink" title="实习地点选择"></a>实习地点选择</h2><p>在投简历前，我们除了需要选择实习岗位外，我们还要选好实习地点，如果就在本地实习那肯定会方便很多，如果要去外地实习的话，需要考虑的事情就会很多了。</p><p>这里我分成两类来说下：</p><h3 id="因为一些特殊原因必须要去某个城市"><a href="#因为一些特殊原因必须要去某个城市" class="headerlink" title="因为一些特殊原因必须要去某个城市"></a>因为一些特殊原因必须要去某个城市</h3><p>这种就很好理解了，比如男/女朋友在某个城市，为了感情稳定，那肯定是要去的（羡慕）。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr176f8bzj30l00m475t.jpg" style="zoom:25%;" /><p>或者说自己特别喜欢某个城市，想去感受下那个城市的风土人情，那这种的话就不需要考虑太多了，直接投这个城市的公司就好了啊。</p><h3 id="没有必须要去的城市"><a href="#没有必须要去的城市" class="headerlink" title="没有必须要去的城市"></a>没有必须要去的城市</h3><p>那如果没有必须要去的地方呢？那我的建议是<strong>“大城市+海投”</strong>，比如北京、上海、杭州、深圳这样的。毕竟你都不知道去哪，那说明其实去哪对你来说并不重要，那为啥不去大城市看看，去见识一下<strong>外面的世界</strong>，去<strong>结交更加优秀的人</strong>呢？当然我并不是说去了大城市就一定能遇到优秀的人，只是概率会比你待在舒适圈里更大些，机会也会更多一些。</p><p>不过这里我想说的是，不要因为选择了某个实习城市后就给自己非常大的压力，实习有一个好处就是未来我们还有秋招、春招的机会，不要因为这次没去什么城市感到遗憾，也不要因为去了某个大城市压力太大就会觉得没有未来，要相信自己<strong>未来可期</strong>！</p><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><p>确定了去哪工作，以及想做什么岗位后，我们要做的就是面试准备了。第一关就是简历了。</p><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>我们都知道简历对于求职来说很重要，那为什么重要呢？</p><h3 id="先从面试前来说"><a href="#先从面试前来说" class="headerlink" title="先从面试前来说"></a>先从面试前来说</h3><p>假如你是网申，你的简历必然会经过 HR 的筛选，一张简历 HR 可能也就花费 10 秒钟看一下，然后 HR 就会决定你这一关是 Fail 还是 Pass。</p><p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p><p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p><p>所以，简历就像是我们的一个<strong>门面</strong>一样，它在很大程度上决定了你能否进入到下一轮的面试中。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr56v5vfbj30aq07bq3g.jpg"></p><h3 id="再从面试中来说"><a href="#再从面试中来说" class="headerlink" title="再从面试中来说"></a>再从面试中来说</h3><p>相信大家面试前都会看很多面经 ，这点无可厚非，但是大部分面经都没告诉你很多问题都是在特定条件下才问的。举个简单的例子：我之前在<a href="https://mp.weixin.qq.com/s/siqmHsHyEYxNIwj26R6tNA">《搏一搏，单车变摩托，记录一下我的淘宝实习面试》</a>一文中提到有一轮面试中面试官问了我很多和深度学习有关的问题，但其实我投递的是 Java 后端岗，之所以会问我是因为我在简历里提到了这个点。</p><p>所以，首先，你要明确的一点是：<strong>不会的东西就不要写在简历上</strong>。另外，你要考虑你该如何才能让你的亮点在简历中凸显出来，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个项目里使用了什么技术后整体性能和并发量提升了很多等等。</p><h3 id="如何写简历？"><a href="#如何写简历？" class="headerlink" title="如何写简历？"></a>如何写简历？</h3><p>其实写简历是一件挺麻烦的事情，内容要斟酌，排版要美化，如果要投外企的话还要准备英文简历。经常会到处找简历模版，有的还要收费。针对简历排版这里我推荐一个我之前在做简历时用的网站<a href="https://www.wondercv.com/">超级简历</a>，可以免费生成一份专业简历，很方便。（不是广告）</p><h4 id="简历上写什么？"><a href="#简历上写什么？" class="headerlink" title="简历上写什么？"></a>简历上写什么？</h4><p>那简历上我们应该放什么内容呢？</p><p>最重要的就是<strong>个人经历、专业技能和项目经历</strong>。</p><p><strong>个人经历</strong></p><p>个人经历就是你作为学生经历了哪些事情，比如参加什么比赛？去某家公司实习？组织过什么活动？这些都是你的个人经历，并且如果取得一定成果，还有可能会成为你的亮点。</p><p><strong>专业技能</strong></p><p>说白了就是让别人知道你会什么。这里我们需要注意的就是，不会的技能千万不要写，以及注意一些技术名词的书写，不要弄错了大小写，比如 MySQL 不要写成 mysql，Java 不要写成 java。有些人会计较这些。</p><p><strong>项目经历</strong></p><p>谈到项目经历就是一件很好玩的事情了，找实习就是希望可以有一个项目经历，但是没有项目经历的话我就不好写简历找实习了。嗯，这就成了一个鸡生蛋，蛋生鸡的问题了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr2htb9stj30c807w746.jpg"></p><p>找实习的话，大多数人在实习经历上可能确实没有多少优势，但是并不代表真的一句话都写不出来。项目经历可以是学校期间做的一些小项目，也可以是课设、毕设这样的，或者去网上找一些开源的项目跟着做也是可以的。但如果你问我，这些都没有那怎么办，还有最后一招，去找一些实战课程，自己跟着视频的进度完整的写完一遍代码，把整个项目吃透也是可以的。</p><blockquote><p>关注微信公众号「01 二进制」后台回复「实战课程」即可领取相关实战课程。</p></blockquote><h4 id="注意几点"><a href="#注意几点" class="headerlink" title="注意几点"></a>注意几点</h4><ol><li><p>大部分公司的 HR 都说我们不看重学历（骗你的！），但是如果你的学校不出众的话，很难在一堆简历中脱颖而出，除非你的简历上有特别的亮点，比如：某某大厂的实习经历、获得了某某大赛的奖等等。</p></li><li><p>大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作</p></li><li><p>写在简历上的东西一定要慎重，这是面试官大量提问的地方；</p></li><li><p>将自己的项目经历完美的展示出来非常重要。</p></li></ol><p>关于简历方面，如果想了解更多的信息，推荐阅读这篇文章 👉<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/PreparingForInterview/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AE%80%E5%8E%86%E4%B9%8B%E9%81%93.md">《程序员简历就该这样写》</a></p><h2 id="简历投递"><a href="#简历投递" class="headerlink" title="简历投递"></a>简历投递</h2><p>简历写好了，那我们就要开始投递了。主要有以下两种途径：</p><h3 id="网站投递"><a href="#网站投递" class="headerlink" title="网站投递"></a>网站投递</h3><p>网站投递就是去公司官网，或者第三方渠道，例如牛客网、BOSS 直聘或者实习僧这样的平台。不过官网投递不好的地方就在于，很难看到你简历投递的进度，很有可能石沉大海。所以一般都会选择部门内推。</p><h3 id="部门内推"><a href="#部门内推" class="headerlink" title="部门内推"></a>部门内推</h3><p>内推听起来是一个很高大上的词，但是吧，有些内推可能也仅仅表示你的简历可以被筛选（这说明如果不走内推的话可能你的简历都不会被筛选）。所以这时候一个靠谱的内推就很重要了，一般来说，在校学生最直接的内推来源就是自己的<strong>学长/学姐</strong>以及<strong>班级/学院群</strong>了。如果没有上面这些渠道的话，其实也是可以关注一些公众号或者内推群的信息。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr57on6d3j30ku0kuq3g.jpg" style="zoom:50%;" /><h2 id="面试准备-1"><a href="#面试准备-1" class="headerlink" title="面试准备"></a>面试准备</h2><p>如果简历筛选通过，那很快就可以收到面试通知了。我始终认为，面试过程中最重要的一点就是<strong>展示自己的核心竞争力</strong>。为什么公司要选你不选其他人？对于他们公司来说，和其他人相比，你为什么是更好的选择？这些都是我们要在面试中展示出来的。那我们应该做些什么呢？</p><h3 id="面试前的准备"><a href="#面试前的准备" class="headerlink" title="面试前的准备"></a>面试前的准备</h3><h4 id="搞清楚技术面会问什么"><a href="#搞清楚技术面会问什么" class="headerlink" title="搞清楚技术面会问什么"></a>搞清楚技术面会问什么</h4><p>既然上面提到了核心竞争力，那对于我们这些弄技术的人来说，最最核心的竞争力就一定是我们的<strong>技术能力</strong>了。如果你技术能力不过关，企业也不大可能会录取你。</p><p>所以我们需要在面试前就知道技术面一般会问些什么。以 Java 后端为例，就很可能会问你 Java 基础、数据库、框架、系统设计之类的东西。技术面会问什么其实是一个很宽泛的话题，一篇文章肯定是写不完的，后面会用专门的一篇文章去介绍面试中常见的问题。</p><h4 id="多看他人的面经"><a href="#多看他人的面经" class="headerlink" title="多看他人的面经"></a>多看他人的面经</h4><p>看别人面经有几个好处，其一就是看看哪些是高频考点，可以起到不断巩固自己知识的作用。另一方面就是看看如果遇到不按套路出牌的面试官，自己应该怎么样去应对，争取做到以不变应万变。</p><blockquote><p>我的公众号最近出了一个新的「跟我来面试」系列，有兴趣的可以关注公众号「01 二进制」查看。</p></blockquote><h4 id="反复复习"><a href="#反复复习" class="headerlink" title="反复复习"></a>反复复习</h4><p>其实面试准备这个过程就和我们高三一样，先来一遍一轮复习，把知识点都过一点，然后二轮复习突击高频考点，最后再做个几轮试卷模拟下，因此反复复习对于我们来说是不可避免的环节。</p><h3 id="面试时"><a href="#面试时" class="headerlink" title="面试时"></a>面试时</h3><h4 id="不要爽约，有事提前通知"><a href="#不要爽约，有事提前通知" class="headerlink" title="不要爽约，有事提前通知"></a>不要爽约，有事提前通知</h4><p>一般面试之前 hr 都会和你打电话确认时间，如果确定好时间，就尽量不要爽约，如果突发急事，也要做好提前通知，毕竟换位思考下，面试官也要在百忙之中抽出时间面试你，被放鸽子的话之后对你的面试大概率不会有好处。</p><h4 id="言简意赅的回答问题"><a href="#言简意赅的回答问题" class="headerlink" title="言简意赅的回答问题"></a>言简意赅的回答问题</h4><p>面试官问问题时，最好可以做到言简意赅的回答问题，不要乱扯一通。虽然说我们需要在面试时可以做到引导面试官提问对自己有利的问题，但也要适可而止。如果说面试官问你一个问题，你不断在那扩展，如果他不是很愿意听你讲课的话，那大概率会厌烦。</p><p>所以，言简意赅的回答问题很重要，用简单的话将问题的重点说出来。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr54ysdqaj30dk0abglz.jpg" style="zoom:50%;" /><h4 id="不要不懂装懂"><a href="#不要不懂装懂" class="headerlink" title="不要不懂装懂"></a>不要不懂装懂</h4><p>这应该就没什么好说的了，不会就直接说不会吧，千万不要不会，然后就开始扯了，换做你是面试官，你会喜欢一个跟你扯的人吗？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr3y5jb4wg305k05jqf8.gif"></p><h3 id="面试后"><a href="#面试后" class="headerlink" title="面试后"></a>面试后</h3><p>面试后，无论结果如何，记得做一个面试复盘。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜。</p><p>不过虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。通过复盘也可以不断巩固自己学到的知识，让自己的能力更上一层楼。</p><h2 id="Offer-选择"><a href="#Offer-选择" class="headerlink" title="Offer 选择"></a>Offer 选择</h2><p>在文章一开始时我就说了要广撒网，多捕鱼。如果说你能力很强，那就很可能收到好几个 Offer，成为让众人吃柠檬的“Offer 收割机”。但这样的人其实也挺难的，毕竟最后也只能选一家公司，没法做到雨露均沾。</p><p>那我们应该怎么选择 Offer 呢？</p><p>其实这点我没有太多的经验，因为我不是 offer 收割机，也没办法预知未来选择这个 Offer 会对我有什么影响，所以这里只能把我目前的想法说出来和大家交流。</p><p>除去实习地点、实习岗位（参考文章开头），我们接下来要考虑的就是<strong>成长路径、实习待遇和企业氛围</strong>了。</p><p><strong>成长路径</strong></p><p>因为是实习，所以我们更应该看重成长路径，如果说你在一家公司里得不到成长，那待遇再好，对于一个年轻人来说，也是不应该考虑的。毕竟没成长的实习就能拿到这么好的待遇，等你去其他地方历练过后再去岂不是会更好？</p><p><strong>实习待遇</strong></p><p>然后是实习待遇的问题，现在大多数互联网公司的实习待遇相较于其他行业来说都是很不错的。大厂的实习工资高，有的还会有租房补贴，一些地方政府也有补贴。零零散散加起来有些人的实习工资可能比某些行业的正式员工工资还高。而且据我所知，有些专业实习竟然还要自费。所以在薪资待遇不会太差的情况下，我还是建议选择更能让自己成长的 Offer，毕竟之后还有一轮秋招。如果实习的薪资待遇并不满意，可以趁着实习先历练一番，然后秋招时再选择待遇更好的 Offer。</p><p><strong>企业氛围</strong></p><p>其实我觉得企业氛围是在实习前进行 Offer 选择时最不重要的一个因素，因为你还没去那个公司实习，你怎么就知道那个企业的氛围不适合你？企业氛围，主管影响很大，不能因为有人说这个企业太压抑了，你就觉得自己一定不适合，兴许对别人来说很压抑的环境，对你来说就会如鱼得水呢？</p><p>实践才是检验真理的唯一标准，只有自己亲身经历过了才好评价一个企业的氛围对你来说是否合适。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是我在找实习期间的一些总结和感悟，欢迎各位在留言区交流讨论。如果你觉得我的文章对你有所帮助，不妨扫描下方二维码支持一下。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdr588gq46j31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 面试学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搏一搏，单车变摩托，记录一下我的淘宝实习面试</title>
      <link href="p/4fa2.html"/>
      <url>p/4fa2.html</url>
      
        <content type="html"><![CDATA[<p>楼主这段时间一直在找暑期实习，前几天刚结束了阿里巴巴淘系的 HR 面，现在在等通知，正好趁着这段空窗期整理回顾下前段时间的面试。</p><p>目前我是研一在读，投递的岗位是 Java 后端的暑期实习，我是在今年 2 月份开始准备实习的事情，虽然简历投递的很早，但是到面试已经是 3 月的事情了。接下来说说我前期做的一些准备吧。</p><p>不知道为什么，今年好像很多公司都加入了笔试环节，这里就要求我们对一些算法题进行针对性的训练，这里推荐力扣和牛客的剑指 offer 系列，把那 70 多道题刷两遍，心里多少就会有点底了。其次就是对于知识点的针对性复习，这个过程就跟我们高三时的一轮复习一样，力求将知识点都过一遍，包括但不限于 Java 基础、数据库、计算机网络、操作系统、组成原理、框架源码、设计模式等。这些知识点可以根据网上其他人的面经针对性学习，也可以根据市面上流传的各种面试宝典针对性复习。这里我推荐一个仓库，我复习时的知识点都是按照这上面来的，<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p><p>下面的内容是我整理的面试题目。大家可以参考着复习。</p><hr><h2 id="提前交流"><a href="#提前交流" class="headerlink" title="提前交流"></a>提前交流</h2><p>我是找的学长内推的，刚开始有一次交流，也不知道算不算一面，主要问了下面的东西：</p><ol><li>说一下 cas，主要应用在哪</li><li>说一下 Java 中的锁，自旋锁会升级成什么？</li><li>项目中的限流是怎么做的</li><li>说一下 Java 是如何加载一个类的？</li><li>什么是双亲委派模式？</li><li>TCP 滑动窗口了解吗？</li><li>用的是什么数据库？说一下 mysql 的的事务隔离</li><li>InnoDB/MYINSAM 的区别和应用场景</li><li>介绍下 MYSQL 的索引</li><li>进程和线程的定义</li><li>进程调度算法有哪些？</li><li>说一下你对线程池的理解</li><li>用过什么模式（除了 JDK 以外。自己实现的 /除了单例模式外）</li><li>单例模式为什么要有两个 null 判断，一个不可以吗？</li><li>排序（归并排序 /堆排序/快排）</li><li>说一下你对 Spring 的理解，AOP 的原理是什么？</li><li>有什么想问面试官的</li></ol><p>因为是提前交流，感觉就是摸一下底，问的知识点都很基础，只不过因为是刚开始复习，所以有些知识点还不是很清楚，后来交流的学长也给了一些建议和指导。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>然后就是正式的一面了，一面比较细致，上来先做了一道算法题，题目很简单，剑指 offer 里的原题，顺时针打印矩阵，<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/</a></p><p>还有道多线程编程题，大致意思就是提供一个多线程的工具类，打印数组。</p><p>下面是问题的记录：</p><ol><li>自我介绍、说一下最近在做什么事？</li><li>可以跟我介绍下卷积神经网络吗？</li><li>可以说一下逻辑回归是什么吗？</li><li>你觉得反向传播和动态规划之间有什么样的联系吗？</li><li>我看你的微信公众号叫「01 二进制」，那你能说一下为什么计算机会使用二进制，而我们人类会使用 10 进制呢？</li><li>计算机是怎么做加法的？那如何用加法代替减法？</li><li>使用过 Linux 吗？可以说下常用的 Linux 命令吗？</li><li>用什么命令可以查询文本中的文字？用什么命令可以查询磁盘存储的容量？</li><li>Vim 使用过吗？可以说下有哪些快捷键吗？</li><li>我看你的博客里有一篇博客写到了区块链，你可以说下去中心化对我们的生活有什么影响吗？你觉得区块链有价值吗？</li><li>在区块链的世界中，那些数据怎么样会变得有效？（广播机制、共识机制）</li><li>类比打电话，两个系统的通信我们可以采用哪些方式？（我说了 http）</li><li>说一下 HTTP 和 HTTPS 的区别</li><li>HTTPS 中用了什么加密方式，在什么阶段体现的？</li><li>分布式的 CAP 理论了解过吗？</li><li>你了解的一些集群有哪些选举方式？</li><li>公众号里写了很多和 python 有关的文章，那你觉得这两个语言使用起来有什么差异？</li><li>最近有看什么书吗？</li><li>HashMap 为什么线程不安全？是否模拟过不安全的场景？</li><li>说一下 Java 的值传递和引用传递</li><li>SpringBoot 和 SpringMVC 的区别</li><li>说一下 Spring 中 bean 的加载过程</li><li>JVM 的垃圾回收器了解吗？垃圾回收算法有哪些？JDK8 默认的垃圾回收器是什么？</li><li>有什么想跟我沟通的吗？</li></ol><p>总的来说这一次的面试体验不是很好，因为那个时候刚大致过完一遍知识点，脑袋里的知识都混在一起了，而且偏偏问的东西也很杂，就连公众号里的文章他也看了，这点是我没想到的。不过面试官很 nice，一直都在和我探讨这些问题，气氛也不是很紧张，之后几天就迎来了二面。</p><blockquote><p>这里插句题外话，在投简历的时候，一定要确保简历上的东西的真实性，你需要对你简历上的每个字负责，而且最好可以保证你写的东西自己是很熟悉清楚的。</p></blockquote><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>不知道为什么，总觉得二面问的问题和一面比起来侧重点是平常学习生活中的，而不是基础知识了。</p><ol><li>自我介绍</li><li>自己做的 app 上线了吗？是自己做的吗？简单说一下</li><li>学校的课程中你觉得哪一门学的最好？（都差不多）</li><li>你学习了挺久的 Java，对于这门语言有什么认识？或者和其他编程语言比起来有什么不一样的地方？</li><li>那你在学习的过程中有什么事情会让你坚持做下去？</li><li>开发这个 app 的动力是什么？</li><li>有参加过什么学科竞赛吗？</li><li>数据结构你觉得你学的怎么样？做一道编程题（用数组模拟一个栈）</li><li>智力题：你雇佣一个工人，他每天工作应该获得一份金条，你有一根金条可以分成 7 份，但你只能对你的金条切 2 刀，请问怎么保证你的工人每天都得到一份金条？</li><li>你有什么想问我的？</li></ol><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>到了三面，基础知识问的不如前面几轮了，更多的是项目经验方面的东西，说实话这里也是我欠缺的地方，面试的问题如下：</p><ol><li>介绍一下项目</li><li>项目是否复盘，如果说用户量/数据量/访问量非常大之后，你了解到的可以做哪些改造？</li><li>SpringBoot 有深入了解吗？和 Spring Cloud 有什么差别吗？</li><li>SpringBoot 核心框架包含什么？SpringCloud 一套微服务的框架中间有什么部分你是比较熟悉的，详细介绍一下。</li><li>SpringBoot 容器启动的大致流程（这个不会）</li><li>SpringCloud 在 SpringBoot 的基础上扩展了什么？（我提到了注册中心，作用是什么说了下）</li><li>多线程，几种线程的创建方式（thread、runnable、callable），使用的时候有什么场景约束（在什么场景下使用什么方式）</li><li>多线程情况下临界区的资源保护有哪些方式？（比如锁）</li><li>场景编程题（卡了很长时间）<br>不考虑高并发/分布式/集群/网络调用等问题，不依赖消息队列/缓存这些东西。希望你可以提供一个医院类，这个类有一个核心的方法给外部调用，这个方法实现如下功能：5 个医生，每个医生可以挂 10 个号，然后医院有 10 个窗口，也就意味着同时只能有 10 个病人挂号，那第 11 个人要挂号的话就不能立刻拿到号，得前面的用户挂完号才可以挂号，病人挂号的时候，医院给病人返回的结果是：1. 如果当前有空余号可用，就取最前的号；2. 如果没有号，就给调用的病人返回没有号的错误。注意：如果有号的话是不能允许返回给病人说没号，如何设计这个类以及这个类中的方法。（附加：如果在分配号的时候偶然出现时间抖动，你该怎么解决）</li></ol><p>这一面说实话是我最没有把握的一轮面试，因为自己对于微服务这块确实没有实际操练过，经验很少，源码看的也不多，而且那个场景编程题答的也不是很好，没有很细致的说该怎么实现。</p><p>不过这轮面试里，面试官有句话让我印象很深刻，他说作为一个技术人，经验是没有办法衡量的，但是思维可以，我们在日常生活中，应该要善于<strong>用代码思考问题</strong>。对于一个功能/事物，我可能会想着这个功能可以通过一个消息队列去实现，可以用 redis 去实现，但这样思考还不够深入，应该在思考的时候就在脑海里构建出代码结构。不然也只能算是纸上谈兵。</p><h2 id="交叉面"><a href="#交叉面" class="headerlink" title="交叉面"></a>交叉面</h2><p>三面结束，慌张了几天之后迎来了交叉面，我看牛客网上的帖子说交叉面基本上就不刷人了，但还是有些担心，可能我运气比较好吧，简单问了我一些问题就结束了，没有太刁难我：</p><ol><li>你可以讲一下做的最有成就感的项目吗？</li><li>这个项目是如何变现，如何带来价值？</li><li>是如何吸引用户的？怎么获取用户增长的数据？</li><li>那如果重新接收这个项目有什么想法吗？</li><li>之后对自己有什么规划吗？</li><li>你对手淘有什么样的认知？（产品很优秀，团队的技术能力也很强）</li><li>还有什么要问的？</li></ol><p>交叉面的面试官跟我说因为之前每一轮面试的面试官都有记录，所以就不问我一些技术方面的问题了，另外就和我说了下在阿里工作是什么样的感受，为什么换了部门，交叉面一共就面了 20 分钟，气氛还是很轻松的。</p><h2 id="hr-面"><a href="#hr-面" class="headerlink" title="hr 面"></a>hr 面</h2><p>隔了两天接到了 hr 的电话，前面几轮面试都拖了挺久的，hr 这里反倒比较快了，问的问题也很正常：</p><ol><li>有没有帮助他人的案例可以分享一下的吗？</li><li>你是怎么规划你未来的职业方向的呢？</li><li>对于以下案例，你有什么想法？</li><li>商家在我们这进货，为了加快货物的流通，会有赊账，在这个过程中，用户增长非常快，然后需要做一个系统，在这个系统上线的前一周，运营过来说，我们需要加一个子功能，你作为技术，是选择将原版本上线之后再升级，还是说把新系统的功能全部做完了再上线？（我选的第一个）<br>那按照第一个方法做了，系统也上线了，后期升级的时候你本以为 2 个星期就可以升级完成，但是你突然发现你可能搞不定，数据上出现了一些问题，产品经理此时也在国外，没办法及时沟通，作为一个技术人员你会怎么办？</li><li>大概什么时候可以实习？实习地点？</li></ol><p>hr 面更多的就是看看这个人的一些性格特点以及遇到一些事情时的处理方式，大多数人走到这一步基本只要回答的不太有偏差应该都不会有太大的问题的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在面试期间我也看了很多其他人的面经，对比一下发现自己遇到的面试题难度上比他们要小一些，可能是因为自己也没做过什么太复杂的项目，所以也没深入问了。不过阿里的面试官人很 nice，面试的过程也不是单向的询问与回答，更像是一种讨论。总的来说，除了进度比较慢（将近 1 个月），其他方面的体验还是很不错，这里许波愿，希望可以收到暑期实习的 offer。</p><p>最后打波广告，如果我的文章对你有所帮助，不妨搜索一下微信公众号「梁注」，或者扫描下方二维码，后期我会不定时分享互联网上有趣的内容，也可以后台回复「微信」与我交流。</p><hr><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdj7kf8saej31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 面试学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刚完一波蚂蚁金服的面试后，他说他累了</title>
      <link href="p/d04f.html"/>
      <url>p/d04f.html</url>
      
        <content type="html"><![CDATA[<p>这是「跟我来面试」系列的第二篇，被面试人是我隔壁宿舍的好友，近期刚刚结束了蚂蚁金服的三轮技术面试，面完之后他跟我说很累，直言不想再体验了。</p><p>因为学院的安排，我们被要求暑期实习，近期也有各种内推信息发在群里，和大多数人边面试边复习不同，我的这位好友在我们疯狂投简历的时候就一直踏踏实实准备，因为我们会在自己的小群里分享自己的面试经过，他就一直潜水，直到有一天突然告诉我们蚂蚁金服的 hr 说他通过了我们才知道他已经成功上岸了。这种人，我们一般只能用五个字来形容：闷声发大财。</p><p>他的面试经历我仔细看了看，一面重点在基础知识的考查，二面重点在项目以及对框架的使用与理解上，三面压力面，是很熟悉的套路，考察的知识点也是经常问到的，具有一定的参考价值，接下来我们就来看看他的这几轮面试经历吧。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>笔试题很简单，多线程循环打印 1-100 奇偶数</p><ol><li>你觉得项目中用了 MQ 给你带了什么好处，设计初衷是什么？会带来什么缺点嘛？（项目针对性比较强，不细说）</li><li>在网页键入 taobao.com，到返回一个页面，这期间都发生了什么？</li><li>你说到了 session 和 cookie，这两者有什么区别，应用场景是啥？</li><li>返回界面的文字，图片，链接，你觉得是从哪里来的，或者说储存在哪里?</li><li>描述一下 TCP 三次握手，这期间可以携带数据吗？携带了数据会造成什么后果？</li><li>描述一下四次分手，第二次和第三次中间处于何种状态？</li><li>说一下 object 类的所有方法以及他们的功能（真的是所有：clone，notify/all，finalize，wait，hashcode，equals，tostring，getclass）</li><li>抽象类和接口有什么区别？说一下你的个人理解。</li><li>详细说一下 final 关键字，修饰变量，方法，类都有什么不同？能想到什么具体应用场景吗？</li><li>说一下 equals 方法，hashmap 的底层，跟 hashtable，concurrentHashMap 都什么区别</li><li>静态分派和动态分派的区别？具体应用场景？</li><li>1.8concurrentHashMap 有什么变化，优化的意义在哪？</li><li>hashmap 除了结点数大于 8，还有什么情况会树化（这个我没想出来，也可能是我没听清楚）</li><li>hashcode 方法有什么特点？hashset 的底层是如何实现的？为什么用 hashmap？</li><li>说说 JVM 内存结构（这里要问清楚是 JMM 还是运行时常量池）</li><li>你刚说 1.8 后方法区移动到内存中变成元空间，为什么要移过去呢？</li><li>那为什么常量池没有移动到内存，而是转移到堆了呢？</li><li>最后一个问题，说一下线程池的饱和策略</li></ol><p>因为项目中使用到了 MQ，所以就顺便问了下，好在并没有提问太过深入的东西，随后问题几乎每个都是高频考点，2、4、5 主要考察计算机网络中的通信过程，例如三次握手/四次挥手，7-14 考察 Java 基础，随后就是和 JVM 以及多线程有关的问题了。有需要的小伙伴可以参考这个进行针对性的复习。</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol><li>从项目启动到现在，介绍一下你的工作以及遇到的难点，怎么解决的？</li><li>讲一下微服务架构都有哪些模块？他们是怎么一起工作的？</li><li>让你实现一个 eureka，你会怎么实现？</li><li>用户认证，为什么要用 JWT，而没用 session-cookie，应用场景？优劣？加密用的是什么算法？</li><li>为什么使用 rabbitMQ，没用别的 mq？</li><li>说一说你项目应用了什么设计模式？适配器模式什么应用场景？</li><li>让你实现 AOP，你怎么实现？</li><li>spring 事务有了解吗？是如何传播的？在你项目里的实际业务中是如何传播的？</li><li>例如有 ABC 三个事务，分别原子性，整体也原子性，A 事务出错回滚，整体事务也会回滚，你会怎么设计呢？</li><li>ZooKeeper 有了解吗？redis 和 Mencache 的选型问题?</li><li>你之前的 webServer 项目介绍一下整个流程?你是如何做的多线程？socket 相关?</li><li>你怎么使用线程池？参数怎么选择？</li><li>你写线程的时候会给他们起个可爱的名字吗？为什么要起？线程错误排查工具用过哪些？</li><li>spring framework 都有哪些模块？你使用到了哪些模块？怎么使用的？</li><li>使用的时候有没有对某模块功能进行扩展？</li><li>说一下集合类（线程安全角度）</li></ol><p>到了二面，就会发现提问的重点发生了明显的变化，从之前的基础知识变成了项目架构方面的，这一轮考察的是平常学习过程中对于架构的使用与理解，现在都偏爱微服务架构，那是否思考过背后的原理？天天在用 Spring，你对他到底又有多少认知呢？都知道消息队列好，那好在哪？这些东西都是实际的项目中能接触到，但是又经常会被忽略的东西，就看你是不是一个有心人了。</p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><ol><li>详细介绍一下点云扩增工具项目</li><li>你对分布式架构有什么理解？</li><li>总结一下你的本科与研究生阶段有过的成就？可以拿来说的那种？</li><li>参加过竞赛吗？</li><li>你的项目中或在学习过程中有没有遇到过很难的点？然后专心研究去解决掉他的？</li><li>周围有没有优秀的人？有没有值得你学习的点，并且你现在在跟着做的？</li><li>平时看什么书？</li><li>有没有根据兴趣学习过一些额外的计算机知识，AI 领域?</li><li>在 github 研究过哪些开源项目？</li><li>你的职业规划是什么样的？</li></ol><p>三面是压力面，所谓压力面是指面试官有意制造紧张气氛，以了解求职者将如何面对<strong>工作压力</strong>。面试人通过提出生硬的、不礼貌的问题故意使候选人感到不舒服，针对某一事项或问题<strong>做一连串的发问</strong>，打破沙锅问到底，直至无法回答。其目的是<strong>确定求职者对压力的承受能力、在压力前的应变能力和人际关系能力。</strong></p><p>这一轮的重点不在于对技术的考察，而在于对人的考察。我一直认为，面试最重要的是<strong>将你的核心竞争力摆上台面</strong>。之所以会问你基础知识，是因为技术能力是你的核心竞争力之一，但并不只是技术。如果面对压力，如何与人相处，是否有探索精神，这些都是很重要的，毕竟每个老板都喜欢越有压力就越有动力的员工吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，这三次面试是很经典的套路，一面基础，二面架构，三面个人。我看完后觉得很有参考价值，便征求了原作者的同意分享给大家了。虽然他只面了这一家，但事后他说，如果可以，宁愿再也没有面试。</p><hr><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdlmqqtb92j31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 面试学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从三本到985再到微软，他做了这些</title>
      <link href="p/1109.html"/>
      <url>p/1109.html</url>
      
        <content type="html"><![CDATA[<p>对大多数人来说，在即将到达大学终点的时候通常会出现两条路，一条是步入社会就业，另一条是踏入高校读研深造。</p><p>往年，研究生复试和春招基本是同时进行的，这也就导致考研结束后很多人觉得自己没考好就直接放弃了复试。今年由于疫情的原因很多学校的复试都推迟到了 4 月底 5 月初，这就让很多 2、3 月开始工作的人，又多了一次选择的机会。</p><p>其实每年的这个时候都会有很多人讨论究竟是读研好还是工作好，不过毕竟没有人可以同时涉足两条道路，所以选择就变得格外重要。毕业之后我选择读研这条路，我的朋友寒食君也曾和我交流过并写了一篇文章<a href="https://mp.weixin.qq.com/s/miAfPzrI9tIDhqRMcwiZhQ">《保研之路：从双非到南大》</a>，现在很难确定这个决定对我来说是否正确，对其他人也同样如此。我们需要全方面的考量自己，从性格、抗压能力、未来期望、家庭条件等多个方面去考虑。</p><p>今天写这篇文章，不是为了告诉大家如何去选，而是想介绍一个我在读研期间认识的一个人，他的经历让我有些惊讶，完全可以拿去当考研成功的案例，这里给大家做选择时提供一些参考。他是我的舍友，本科来自于<strong>烟台大学材料科学工程中韩合作</strong>。高考时遭遇滑铁卢无奈去了这个<strong>三本</strong>，后来<strong>跨考考研</strong>时逆袭到南京大学读软件工程专业，读研时开始自学 Java，在这次的春招实习中斩获了网易、腾讯和微软的 Offer，最后选择了<strong>微软</strong>。从三本到 985 读研，再到斩获数个大厂 Offer ，这样的人，实在是少有。</p><p>最近一直有更新面经系列，本来也想记录下他的面试过程的，但是一想到他这励志的经历，便想请他谈谈自己这几年的心路历程，留下一点文字，给正在看文章的人一些指引和参考。下面我将会采用 Q&amp;A 形式记录一些重要的内容。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gegvquii7xj30dw099t8z.jpg"></p><h3 id="为什么选择考研？"><a href="#为什么选择考研？" class="headerlink" title="为什么选择考研？"></a>为什么选择考研？</h3><p>因为我本科是中韩合办的材料专业，所以专业课是由韩国语教授的。又因为我韩语不行，所以专业课都听不懂，说实话对我来说毕业都挺困难的。最简单的原因就是找不到工作，得想办法混个饭吃。放在面前的选择有三个，一是去韩企。我不会韩语，所以去不了。二是考公务员，我不知道你们了解山东不，在山东公务员首先很难考，其次像我这种不会喝酒的感觉也没啥前途。三就是考研了，也算是个没有办法的办法？</p><h3 id="为什么考研选择了南京大学，而且还是跨考软件工程？"><a href="#为什么考研选择了南京大学，而且还是跨考软件工程？" class="headerlink" title="为什么考研选择了南京大学，而且还是跨考软件工程？"></a>为什么考研选择了南京大学，而且还是跨考软件工程？</h3><p>我高考考了两年，最后压本科线上的这个专业。本科挂了一万个科，在本科其实有想过修软件工程的双专业，也不是没报名，可惜第一天上课就和高数补考撞了。所以我就放弃了双专业（其实是因为懒得去了），去了补考（也没补过，最后重修了）。考研考了两年，第一年考南航差一分上线（吃鸡太好玩了，而且上线也不一定能录取），看到现在你肯定觉得我在装逼。其实我说这些是想表达，你想学习其实不一定来不及。第一年考研结束后，切实感受到了生活压力（同学大四回家生孩子了，导致没顺利毕业，爸妈帮他看孩子他也不好意思要钱，只能在我租的房子里睡沙发）。也好好想了想自己想要什么，所以决定好好冲个猛的，猛的冲不动就回家打工混吃等死。我认为我唯一比别人猛的方面，就是用搜索工具。我要散播第一个消费主义观点：<strong>扔了百度，快想想办法用谷歌吧。</strong>然后说几个关于考研择校的观点，不一定对，抛砖引玉：</p><blockquote><ol><li>招人越多的越好，这样如果你初试分足够高，复试就会特别稳。不用担心会因为奇奇怪怪的事情把你黑掉。而且招人足够多，分数线的波动就不会特别大。招三个人，有两个猛男一个关系户你考第三不也无能为力嘛。</li><li>如果你想考好学校，出身又很垃圾，那就直接冲猛的，在你能力范围内越猛的越好。这样可以一定意义上避免学历歧视，因为在好学校看来你们学历都挺垃圾的。（这是我的个人看法）</li><li>现在每个学校基本都能搞得到历年真题，尽量选变化不大的。学校出题变化大，对于猛男来说没啥，但是我们小弱鸡不能拿二十几岁的一年时光来赌这个。</li></ol></blockquote><p>想要完成以上的筛选工作困难并不大，特别是在你搜索工具用的得心应手的情况下。南大软院在我考研那年来看性价比是特别高的。你可以试着问问你的亲戚朋友，如果不在江苏省内的，可能很多人都不知道南大是个什么级别的学校，说不定你说南大很多人都以为是南开大学。但是这又是个极好的学校，所以很适合捡漏。又因为考英二数二（对高考英语 80 分且四级没过的我比较友好），会导致调剂困难（大部分学校都是考英一数一的），有一部分人就会因此不敢报名。而我的打算就是考不上就回家打工嘛，我也没想调剂，所以比较适合我。确定南大之后就是计算机院和软院之间的选择了，南大计算机院有国重，用屁股想想就知道对科研要求高，我啥也不会还跨考，本科也不好也没啥科研能力，别人咋也不可能要我。经过一通排除，我就选择南大的软工（当时在考研群里看了几个考人工智能院的大佬，第一届参考书都整不明白就敢冲，瑞思拜）。</p><p>然后是我考研的一点小心得。我太讨厌我家乡的生活了，导致我有无穷的动力来压迫我自己好好学习。考研第二年，真的是拼了命在学，不然像我这种啥也不会的不努力想考上南大肯定是不可能的。我要在这里散播我的第二个消费主义观点，<strong>能花钱省时间的，价格不是太离谱就别犹豫。</strong>跨考相较于不跨考的人来说，你的时间肯定是更宝贵的。保证时间，一是需要延长学习时间，二就是要在单位时间内学多一点。我完成这两点的方式如下：</p><blockquote><ol><li>建立起学习的工作流。<ul><li>通过番茄钟来保证单位时间的效率，也可以有效统计每天的学习时间。</li><li>使用 anki 和思维导图来进行知识的复习，保证你学完的东西不会白学。</li></ul></li><li>花钱让自己学习的效率更高。（别人售卖的，声誉良好的课和资料一定是有原因的，他至少花费了课程数倍的时间来沉淀知识，这也是我觉得为啥听话的孩子普遍吃亏少发展好的原因）</li></ol></blockquote><p>但是我认为学了两年是最重要的一点，说到底就是磨出来的。当然我也吃了一些亏，我经常会纠结哪个课最好，然后对比很久。方法总是第二步，开始学习才是最重要的第一步。找到一个差不多的尽快开始，会比花时间在比较上好很多。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gegvupku81j30dw098t8r.jpg"></p><h3 id="你本科是材料专业的，考研时才接触的软件工程，现在研一也快结束了，有什么收获吗？"><a href="#你本科是材料专业的，考研时才接触的软件工程，现在研一也快结束了，有什么收获吗？" class="headerlink" title="你本科是材料专业的，考研时才接触的软件工程，现在研一也快结束了，有什么收获吗？"></a>你本科是材料专业的，考研时才接触的软件工程，现在研一也快结束了，有什么收获吗？</h3><p>从一个啥也不会的小菜鸡到能写出来点能动弹的东西，还是挺有成就感的。</p><p>一个好的环境很重要，我能有这些大公司的面试机会就是吃了南京大学的红利。而我研一能有这些进步，主要在于身边有太多优秀的人。说实话第一次上课我是挺震惊的，虽然没有很多人在听课，但是所有人都在学自己的东西。这个公众号的主人也给了我很大帮助，我刚上学真是一头雾水啥也不懂。没他指路现在估计我还在慌着面试呢。披头士几个人都猛，但他们肯定不能都是天才吧。<strong>持续训练，刻意练习</strong>，才是我们这些笨逼的归宿。虽然现在我在他们之间还是最菜的，但是比较来看，说刚开学的时候我和他的编程能力差一百个我是不过分的，但现在估计也就差几个我了。</p><h3 id="这次春招，你面试了哪些公司？最终选择了哪家呢？"><a href="#这次春招，你面试了哪些公司？最终选择了哪家呢？" class="headerlink" title="这次春招，你面试了哪些公司？最终选择了哪家呢？"></a>这次春招，你面试了哪些公司？最终选择了哪家呢？</h3><p>面了一万个公司。你能想到的说的出名字的说不出名字的基本都面了，阿里、腾讯、头条、美团、网易、微软等等等等等等等。拿到 offer 的就只有微软、腾讯和网易，没拿到的就是都挂了。这其实还是一个笨逼多锻炼的故事，多试试总有运气好的时候吧。而且面试官的问题都是类似的，有一次我上午面网易，下午面腾讯，问的问题几乎一模一样。只要你在面试之间多总结，总能磨进去。最后还是选择了巨硬，第一是因为从小就想去巨硬，第二是因为比尔盖茨是我的爱豆，第三就是因为身体不太好，想养老发自内心。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gegw4lh5w1j30dw07u74s.jpg"></p><h3 id="可以简单说下，面试这些公司的过程吗？"><a href="#可以简单说下，面试这些公司的过程吗？" class="headerlink" title="可以简单说下，面试这些公司的过程吗？"></a>可以简单说下，面试这些公司的过程吗？</h3><p>大伙开始投阿里提前批的时候，我很慌，不敢投。导致错过了很多锻炼面试的机会，因为最开始是不进系统的。你一个部门挂了其实就只是那一个部门有你的记录，建议大伙还是阿里提前批多锻炼。小公司练手是个美好的想法，但是不切实际。为啥小公司是小公司，他们效率真的不太高，像有的同学阿里、腾讯或者头条都拿到 offer 了小公司还没有开始面试。</p><p>最开始面试肯定是慌得一逼，话都说不顺溜。面多了感觉其实还是在于多吹，你吹得面试官和你都开心，这次面试基本就没啥问题。下面说一些我的经验，不一定对，毕竟还是挂了很多面试。</p><blockquote><ol><li>别人问你一个问题你最好把你知道的都说出来。如果我当时遇到了这个问题，我就会把我是咋解决的过程说出来。</li><li>代码题需要疯狂判断边界条件。写之前就要和面试官沟通时间复杂度和空间复杂度，说不定面试官心情好会给你点提示。会写英文注释就用英文注释装逼。</li><li>最后问问面试官对你的建议，过来人说话还是好使的。</li><li>把面试官对你项目的质疑，提炼出来，下次在详细介绍项目的时候把它变成你对你的项目的思考。</li></ol></blockquote><h3 id="为什么会选择微软，你觉得微软相较于其他几家公司，更吸引你的地方在哪呢？"><a href="#为什么会选择微软，你觉得微软相较于其他几家公司，更吸引你的地方在哪呢？" class="headerlink" title="为什么会选择微软，你觉得微软相较于其他几家公司，更吸引你的地方在哪呢？"></a>为什么会选择微软，你觉得微软相较于其他几家公司，更吸引你的地方在哪呢？</h3><p>前面回复啦~</p><h3 id="为了去这家公司，你做了哪些准备呢？"><a href="#为了去这家公司，你做了哪些准备呢？" class="headerlink" title="为了去这家公司，你做了哪些准备呢？"></a>为了去这家公司，你做了哪些准备呢？</h3><ol><li>刷 leetcode，我刷的题目说实话挺少的，但是一直比较在意代码的简洁程度。代码题其实都不会很难，难得一逼你实在不会，考官可能会暗示你，还有可能给你换题。不用慌。外国公司大部分就是考察你做算法题的能力，你买个会员把这个公司的题库都刷完必能过（公司肯定也想要你这样的，不管是聪明的一逼算法题随便秒的，还是对着公司题库全刷一遍的，都是公司想要拥有的人，我从网上看的）。</li><li>项目肯定还是要整明白的，在多次面试之后就算你整不明白你的项目，面试官也会把你问明白的。</li><li>基础知识需要过一遍，JVM、操作系统、计算机网络等等。争取要比别人写的资料深一点点。这些问题千篇一律，你回答的多一点，就显得你猛一点。</li></ol><h3 id="可以晒一下你的-offer-吗？"><a href="#可以晒一下你的-offer-吗？" class="headerlink" title="可以晒一下你的 offer 吗？"></a>可以晒一下你的 offer 吗？</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geguhzjo8fj3094045aa1.jpg"></p><h3 id="最后有什么想说的吗？"><a href="#最后有什么想说的吗？" class="headerlink" title="最后有什么想说的吗？"></a>最后有什么想说的吗？</h3><p>我感觉发烧了，所以写的迷迷糊糊的，祝我健康！祝你们能看懂！</p>]]></content>
      
      
      <categories>
          
          <category> 面试学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个科班小前端的大厂面经</title>
      <link href="p/9fb0.html"/>
      <url>p/9fb0.html</url>
      
        <content type="html"><![CDATA[<p>「跟我来面试」系列的第一篇文章是关于前端的，发出后看到有读者反馈说内容较少，问的问题比较基础。因为博主是后端的，前端方面并不是非常了解，所以我找到了同组的小伙伴，让他分享一下自己春招时的一些经历。</p><p>他和我是同一个实验室的，就叫他 x 吧，目前研一，两年制硕士，今年实习。x 的本科前半段迷茫在科班的基础理论学习和课程作业中，大一大二对前端一无所知，没想关心太多，只想保研就好。大二暑假参加一项学校项目，机缘巧合接触到了前端，发现软件工程还有很多值得探寻的地方。大三时他的保研形势已定，于是参加各种比赛，摸索自己的兴趣所在，终于在一系列比赛中尝到了前端的甜头，于是决定正式入坑，带着起初“前端能让页面好看”这般粗浅好笑的见识，打开新世界，一步步丰富自身。终于在这次春招中取得了一些小成果：</p><ol><li>网易雷火三轮技术+HR，拿到 offer。</li><li>字节跳动教育业务三轮技术+HR，拿到 offer。</li><li>美团两轮技术，leader 给了口头 offer。</li><li>阿里淘系目前三面结束，被大 leader 全方位调教，拿到 offer</li><li>腾讯 PCG 到第四面，战线很长，后续没有继续面腾讯，淘系 offer 拿到后就推掉了这里。</li></ol><p>说实话，你可能不知道花一个月时间拿到 4 个大厂 offer 是什么体验，我们一般都管这种人叫“offer 收割机”。</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdmaftry7hj30u00va7ee.jpg" style="zoom: 25%;" /><p>在这里分享下面经，附带他的简要回答和思考。对于基础问题，大家可以查漏补缺，建议收藏；对于场景或者高层思考型问题，大家参考即可，这些都是面试官根据自己部门或每个人的履历定制的。轮次越多，问题也就越偏向高层，需要大家更多的总结思考，找到平衡，甚至再生产。</p><p>点击文章底部<strong>「阅读原文」</strong>，即可查看他的个人主页。以下是他的整理，篇幅较长，建议大家<strong>收藏</strong>，方便复习 👇</p><hr><h2 id="网易雷火三轮技术-HR"><a href="#网易雷火三轮技术-HR" class="headerlink" title="网易雷火三轮技术+HR"></a>网易雷火三轮技术+HR</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面一般都是基础，在回答问题的基础上，最好能主动发散广度深度，面试官印象会很好。</p><ul><li>介绍下自己并聊聊项目。<br><br>这个因人而异，要大方得体，讲出重点。主要围绕项目是什么，为何要做这个项目，解决了什么痛点，你在其中负责了什么工作，遇到并解决了什么问题，如何和不同模块合作，把控了多少架构。后两点需要一定思考和积累，把前面的讲清楚能满足一些面试官，但是大厂面试官常常会希望你说一些架构和整体方面的理解，是加分项。</li><li>如何用 await 和 async 写一个睡眠函数？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sleep(time)&#123;</span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;resolve(&#39;over&#39;),time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function run(time)&#123;</span><br><span class="line">    let result &#x3D; await sleep(time);</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(3000);复制代码</span><br></pre></td></tr></table></figure><ul><li>说说 inline 元素和 inline-block 元素的区别。<br><br>CSS 基础题，我从布局方面不换行和尺寸方面 inline 设置宽高无效，inline-block 可以来讲，还发散了一些 CSS 元素体系讲了讲。</li><li>inline 元素的 margin 有用吗？<br><br>是一个很刁钻的切入口，大家常常忽略对 inline 元素的研究，还好我平时比较喜欢捣鼓 CSS，其实再默认水平方向的文档下，设定水平方向 margin 是有效的，垂直方向无效。</li><li>讲讲 html 如何添加事件监听，事件处理有哪些阶段？<br><br>添加事件监听很简单，document.addEventListener 就能直接来，事件阶段按时间顺序有捕获，目标，冒泡三段。</li><li>说出三个你知道的不常用的 html 标签。<br><br>一般都问那些常用的，结果面试官反其道行之，很佩服。当时只答出<code>&lt;iframe&gt;&lt;strong&gt;&lt;i&gt;&lt;audio&gt;</code>，可以百度一下，其实有很多。</li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>因为我 React 技术栈比较多，所以这方面问题也多，大家按需食用。</p><ul><li>React 中函数组件和类组件的区别。<br><br>React16.9 之后，加入了钩子，给组件体系带来了很多新变化，函数组件也拥有了生命周期方面的特性，useEffect 钩子其实就是对几个生命周期的封装定制。</li><li>React 是如何将 redux 包装到组件上的？<br><br>React 的 react-redux 库，通过给根组件包装一层<code>&lt;Provider&gt;</code>，并将 store 绑定上去，需要进行状态管理的组件通过 connect 包装生成容器组件，并将状态和事件映射到 props 上。redux 其实有很多细节，可以视情况引申。</li><li>React 类组件能在 componentShouldUpdate 中比较属性是否改变来判断是否应该重新 render，那函数组件如何实现同样功能？<br><br>函数组件通过 React16.6 的包装函数 React.memo()得到一个优化后的组件。</li><li>ES6 的 proxy 讲一下。<br><br>代理，拦截对象的各种类型操作如 get 和 set 等，常常在讲到 Vue3.0 时，用来和 Vue2.0 的 Object.defineProperty 对比，其实提到 proxy 面试官就希望你提到 Vue 方面的变化。</li><li>Object.defineProperty 和 Proxy 对比，有什么优劣？<br><br>Proxy 对整个对象进行代理，并且返回新对象，是单一职责原则的良好实践，而 Object.defineProperty 不得不对对象每个属性进行重复的劫持操作，且无法劫持数组的原生方法如 push、pop 等，只能使用 hack 的方式改变原型链。相比之下，Proxy 就功能全面且不需要额外工作，内聚性良好。</li><li>如何实现文字溢出显示点点点？</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>讲一下 OAuth2.0 认证的过程。<br><br>因为我的项目有用到 Google 的 API，所以被问到，阮一峰老师博客讲的很清楚：<a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">OAuth 2.0 的四种方式</a></li><li>讲一下登录之后，身份认证的过程。<br><br>使用 cookie 和 session，用户登陆后，后端 session 以键值对形式存储用户信息，将 sessionId 返回浏览器，浏览器只要在 cookie 种携带该 sessionId，即可让服务器确认用户信息。当然这个过程并不安全，如果能引申一些安全方面的见解，是加分项。</li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul><li>项目中访问其他网站比如 Google Drive 需要登录认证吗，登陆一次后再次进入还要认证吗？<br><br>用的是第三方授权形式，所以当时得不断重新认证。和面试官进行了一些交流。</li><li>你的项目是前后端分离吗，架构描述一下。<br><br>不是，架构问题基于项目真实情况回答即可，不需要因为自己的项目有些不足就避而不谈，其实能够点出不足并进行思考，反而是不错的答案。</li><li>React 中函数组件和类组件的区别。<br><br>又被问了，可能是考察我这方面扎不扎实，也可能就是碰巧。</li><li>Hook 用过吗，有什么作用？<br><br>从代码重构和性能优化来讲钩子。可以看看官方文档。</li><li>Ref 用过吗，一般是用来干什么的？<br><br>获得组件实例，React 虽然是数据驱动的，但是或多或少需要 dom 操作，这个时候通过 ref 实例即可得到组件的真实 dom。由此可见 React，Vue 早就不能称为 MVVM 了。</li><li>如何在父组件中获得子组件内部的 ref？<br><br>可以使用传递回调函数或者 React.forwardRef API 的方式转发 ref。</li><li>你对 React 中组件的状态管理有什么良好实践或见解？<br><br>状态提升到父组件便于统一管理，使用 redux 等等之类。</li><li>跨域问题如何解决？<br><br>这个网上资料铺天盖地，除了传统 jsonp，CORS 等回答之外，我还结合自己项目中的代理讲了讲。</li><li>Restful 接口规范了解吗，状态码 200 代表什么，201 呢？<br><br>200 就是 GET 获取数据成功，当时没背状态码，201 这里答不出来，后来看了知道是用户新建或修改数据成功。</li><li>用过 webpack 吗？<br><br>这是我一直用的不多的点，只提了提 tree-shaking 相关原理，面试官没有继续为难。</li><li>用过什么类型的服务器，用来干什么？<br><br>学院服务器，各种云，都用过，用来做自己的项目，大概做了什么也提了一点。</li></ul><h3 id="HR-面"><a href="#HR-面" class="headerlink" title="HR 面"></a>HR 面</h3><p>走到 HR 面一般稳住不浪就没什么问题了，千万不要头铁，和“腾讯 HR 说不想去深圳”之类的话，或者聊一些公司的负面消息，你真没兴趣或者就是牛逼哪都求着你就当我没说咯。在 HR 面，只要心平气和了解公司，分享一些个人爱好，聊聊人生就行了。</p><ul><li>你的前端学习途径有哪些？</li><li><strong>为何选择前端？</strong><br><br>关于这个问题，我单独写过一段吐槽：<a href="https://juejin.im/post/5e7365ed5188252bea6f3ccf">HR 终极一问：为啥选择前端？答：混口饭吃。卒。</a></li><li>职业规划是什么？</li><li>你的兴趣有哪些？</li></ul><h2 id="字节跳动三轮技术-HR"><a href="#字节跳动三轮技术-HR" class="headerlink" title="字节跳动三轮技术+HR"></a>字节跳动三轮技术+HR</h2><p>字节非常注重基础和编码能力，几乎所有问题都希望你能写上几笔，平时需要注重基础能力的培养。</p><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍一下你自己和项目。</li><li>TCP 和 UDP 有什么区别?<br><br>UDP 无连接，TCP 有连接。更多细节见<a href="https://zhuanlan.zhihu.com/p/24860273">这篇专栏</a></li><li>TCP 建立连接和断开连接的过程。<br><br>网络基础，也是 web 入门的一步，三次握手和四次挥手，都是为了双方互相确认状态。</li><li>GET 和 POST 请求有何不同。<br><br>经典问题，其实就是语义不同，本质上都是发送 http 请求报文。</li><li>前端缓存讲一下。<br><br>主要是 http1.1 的 cach-control 属性，分三个递进的情况：no-store、no-cache 和 max-age，然后配合 etag 确认后端资源是否更新了。有兴趣的还可以把 http1.0 的 expires 和 cach-control 对比。</li><li>js 基本类型有哪些？<br><br>加上 Symbol 有六个。</li><li>盒子模型讲一下。<br><br>当时讲了很多 CSS 布局标准，最后面试官说其实只想听我说一下宽高，content-box 和 border-box 就行。</li><li>写代码，写一个闭包的应用。<br><br>大家发散思维可以有很多，我当时写了个很简单的单例函数。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getInstanceFactory(instance)&#123;</span><br><span class="line">  return function getInstance()&#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let getInstance &#x3D; getInstanceFactory(&#123;a:1&#125;);</span><br><span class="line">const instance &#x3D; getInstance();</span><br><span class="line">console.log(instance.a);</span><br></pre></td></tr></table></figure><ul><li>写代码，判断一个变量是否为字符换或者数组。<br><br>用 instanceof,constructor 指向，Object.prototype.toString 都可以。</li><li>写代码，显示一个文档树的章节结构，附带小节标号。<br><br>深度遍历，当时写完还有一点小节标号没调好，面试撕代码总是难以一遍过啊。</li></ul><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ul><li>平时通过什么渠道学习前端，为什么选择前端？</li><li>好几道肉眼看代码写输出结果的代码题。<br><br>这种题往往乍一看没什么难度，实际上可出得很绕，平时没事多玩玩原生 js，不然容易被绕进去，比如 this 的指向、变量的作用域等等。</li><li>子元素宽度未知，如何居中子元素，写 CSS。<br><br>直接在面板上写了 tansform 的方式</li><li>有哪些跨域方法？<br><br>重复的问题就略过了。</li><li>Promise 的 all 和 race 方法讲一下？<br><br>all 是要所有子 promise 都完成才 resolve，有一个失败就立刻 reject；race 是只要有一个 promise 返回结果，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，当时甚至想写一个原生 js 实现的 race，不过面试官反而说不用。</li><li>写代码，写一个事件监听注册器。<br><br>阴沟里翻船，本以为顺利写完，结果出了好几个复制粘贴以及变量名写错的问题，看了半天，最后都没有调好。吃了这次教训，之后写代码更加谨慎了，提交前会先自己顺着逻辑理一遍。后面才知道牛客网的面板可以全屏，之前一直是缩小形式，写起来很容易遗漏。</li><li>讲讲你在写代码的过程中为什么出了 bug，整个思路是什么？<br><br>这是顺着前一题出的 bug，算是面试官给的一次机会，好好描述了下自己的思路和心理。</li></ul><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><ul><li>介绍项目。不断追问，从技术使用到架构。<br><br>这种时候一定要撑住，从容思考，就算不会也要把思路讲出来。</li><li>哪个项目令你收获最大？讲讲收获。</li><li>React 项目中你遇到过什么问题？如何解决的？<br><br>版本更新后的重构问题主要讲了讲。</li><li>http 请求有哪些方法?<br><br>GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH。当时之说出来五个</li><li>用过什么 ajax 请求的库？<br><br>只说了 antd 和 axios，后面和面试官交流了一些库封装问题。</li><li>写代码，js 算法题，老师给孩子分饼干，最多能满足多少孩子。写完之后问为什么要这样写。</li></ul><h3 id="HR-面-1"><a href="#HR-面-1" class="headerlink" title="HR 面"></a>HR 面</h3><p>小姐姐很活泼爱笑，还懂技术，全程轻快交流。</p><ul><li>描述一下大前端<br><br>和 HR 交流大前端感觉很独特，无法言喻。</li><li>你觉得前端就是界面吗？</li><li>为什么选择前端？<br><br>发现每个公司必问至少一次，出现频率最高的问题非他莫属。</li><li>平时怎么学习前端？</li></ul><h2 id="美团两轮技术"><a href="#美团两轮技术" class="headerlink" title="美团两轮技术"></a>美团两轮技术</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><ul><li>介绍下自己和项目。</li><li>平时学习前端有什么方式？</li><li>写代码，写一下 js 中的各种继承方式。<br><br>主流三套方式：ES6 中 class 的 extends；原型链；通过 call 方法借用别的构造函数；</li><li>默写 react 的生命周期函数。<br><br>但是默写了一下，mount 阶段 4 个，update 阶段 5 个，umount 阶段 1 个，异常情况有个 componentDidCatch。</li><li>描述一下 React 的数据流传递方式。<br><br>单向数据流，父组件到子组件单向，数据到视图单向。</li><li>描述一下 redux 的数据流。<br><br>最外层 Provider 上挂载一个 store，从上到下以瀑布流的形式传递，途经的每个组件都可以取得数据并添砖加瓦，但是不能直接修改，只能通过 dispatch。</li><li>React 的 setState 之后如何进行更新和渲染的？<br><br>新旧版本 React 更新由同步变为异步，尽量把两种版本对比着讲，讲出为什么要进行异步更新，并且引入新的数据结构 Fiber。</li><li>描述一下 MVC 模式。<br><br>画了一下 M,V,C 三者之间的数据流向图。</li></ul><h3 id="二面："><a href="#二面：" class="headerlink" title="二面："></a>二面：</h3><p>本来二面是交叉面，不过直接跳到了主管面。</p><ul><li>介绍下你的项目。也是被不断追问。</li><li>Angularjs 如何进行前端渲染？<br><br>讲讲双向绑定，脏检查那套。</li><li>主流前端框架机制讲一下？<br><br>很大的话题，从 React 入手，讲了它的渲染机制和优化。</li><li>平时怎么学习前端？</li></ul><h2 id="阿里淘系三轮技术"><a href="#阿里淘系三轮技术" class="headerlink" title="阿里淘系三轮技术"></a>阿里淘系三轮技术</h2><h3 id="一面（提前批）"><a href="#一面（提前批）" class="headerlink" title="一面（提前批）"></a>一面（提前批）</h3><ul><li>介绍下自己的项目。</li><li>AngularJS 和 React、Vue 有什么区别？结合开发经历描述。<br><br>这个纯看理解和个人发挥了，面试官估计仔细看了我的简历，三个框架都用过所以这么问。当时扯了很久关于框架的见解，在这种方面，千万不要背 MVC 或 MVVM 之类的概念</li><li>项目中遇到什么问题，如何解决的？</li><li>Node.js 用过么，讲一讲<br><br>用的不多，就把 node 的事件循环讲了下，nextTick 和 setImmediate 跳出来讲了讲。</li><li>平时用哪些渠道进行学习？</li></ul><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><p>突击面试，不约时间，11 点来电就直接开始了。这种没有准备的情况下一定要冷静，可以先让面试官稍等片刻自己准备下设备，同时调整下状态。</p><ul><li>近两年在前端领域有什么成果和贡献？<br><br>很有魄力的问题，突击面试外加上来就丢这个问题很有压迫感。讲了自己 release 的项目，实验室的项目，社区博客（开始学前端就在写 CSDN 博客，近期迁到掘金）分享，flutter 等等</li><li>请讲讲三大框架为何会产生？<br><br>很宽广同时又很精确的主观题，从前端技术史讲起，各大公司的立足点和开发诉求。</li><li>你对前端框架的发展方向有什么自己的见解？<br><br>很广泛，从动态化，兼容性入手，有时间想谈谈新编码下的 JIT 和 AOT。</li><li>玩过 IOT 一类的嵌入式开发吗？<br><br>玩过树莓派，以前在学校搞过小车竞赛。</li><li>解决过哪个技术问题最令你大呼过瘾？<br><br>技术上从 0 到 1 最痛快，比如在一张白纸的情况下完成 Google OAuth2.0 认证，调通接口。</li><li>你在技术方面最佩服或最感谢的人<br><br>身边的人。</li><li>你有什么想想我了解的？<br><br>问了很多问题，关于淘系现在的结构组成，阿里在 Flutter、BFF、Serverless 方面的生态建设，还问了下当天淘宝 IOS 出现的 S1 级事故。学到了很多。</li></ul><h3 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h3><p>面试官是 P9 的前端团队大 leader，什么都会，什么都比你深，只能稳住别慌，尽力发挥。</p><ul><li>讲一下你价值最大的一个项目。<br><br>讲了大三实习的项目 AngularJS+.Net Framework。</li><li>我看见你还用 Flutter，讲一讲 Flutter 的原理吧<br><br>底层有一个用于跨端的嵌入层，中层用 C++实现自绘引擎，封装成 dart ui 库，上层用 dart 开发，对象化组件化。</li><li>Flutter 和 ReactNative 比，性能孰优孰劣<br><br>RN 首屏性能相对弱，组件重绘代价大，JSBridge 涉及进程切换，这个固有代价导致 RN 的渲染性能弱于 Flutter，所以 RN 才有了架构重建计划，将 JSBridge 替换为 JSI。</li><li>微信小程序的结构和原理又是什么样的？<br><br>回答的不好，印象中的小程序也是和 RN 类似的派系，但是底层实现 ui 的方式我犯迷糊了。</li><li>现在的 Flutter 肯定是直接不能用于大项目开发的，你觉得它的瓶颈在何处？<br><br>讲讲 Flutter 在状态管理方面的不足，提到了大厂在 Flutter 方面的定制。</li><li>你有什么要问我的?<br><br>赶紧问下之前小程序原理的问题，面试官说上层是用 html，js 那套 web 跑在浏览器内核（如 V8，JSCore 等），再往下层是用 webview，外加一些 native code 实现对 webview 做得不太好的组件的补充。</li><li>还问了一直关注的 severless 问题，面试官高屋建瓴，分两点进行教学：<br><br>基础设施方面，云原生的支持必须达到足够高的稳定性，满足扩容收缩等硬性要求才能将关键基础链路演化为 severless，目前还存在一定差距，不过一些非关键业务链路已经完成迁移。 - 人的方面，应用工程师得拥有该方面的维护技术和解决问题的能力。虽然还有很多细节不甚理解，但认真听完还是收获满满。</li></ul><h3 id="四面（交叉面，钉钉）"><a href="#四面（交叉面，钉钉）" class="headerlink" title="四面（交叉面，钉钉）"></a>四面（交叉面，钉钉）</h3><ul><li>你收获最多的项目是什么？<br><br>大三外企实习项目，全栈开发，让我对架构和服务化甚至是敏捷开发的项目把控和工程实践有了不少的体验和理解。</li><li>项目中使用 websocket 开发，在和后端对接之前如何进行开发？<br><br>这个问题被问住了，因为项目比较小前端用完 mock 数据，甚至连 mock 服务器都没有就直接和后端对接，后端推送数据也是在前端直接查看，就老老实实和面试官交流了一阵。</li><li>关于网站性能优化问题，SPA 过大导致首屏时间太长怎么解决？<br><br>性能优化问题我一直没有特意去“背诵”，毕竟自己的项目都没到前端性能的瓶颈。谈了谈懒加载、打包策略。</li><li>如果老板和你说网站首屏加载时间太长，但不知道什么原因，你如何一步步定位并解决问题？<br><br>先要定位问题，打开控制台看 timeline，如果那些阶段占用过长时间就会有长条的瀑布图显示。结果面试官追问如果 timeline 看起来很正常怎么办？我只能回答可能出现页面报错，js 文件出错没能正确进行一些 dom 操作，导致元素没有正常显示。</li><li>如果某个 js 文件必须在 header 中被加载，而它又操作了 body 中才有的 dom 元素，怎么办？<br><br>可以在该 js 文件之前加一个适配的 js 文件，手动 append 一个可供该文件选择的 dom 元素，然后再页面 onload 之后删除适配该元素。</li></ul><h3 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h3><ul><li>目前的 offer 有哪些，想如何选择？</li><li>你做前端的目标是什么</li><li>在学校的学习成绩怎么样？</li><li>对工作地点有要求吗？<br><br>这个不能头铁乱讲，想稳拿 offer 就老实回答杭州。</li></ul><h2 id="腾讯-PCG-三轮技术"><a href="#腾讯-PCG-三轮技术" class="headerlink" title="腾讯 PCG 三轮技术"></a>腾讯 PCG 三轮技术</h2><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><p>几乎所有前端问题都问了一遍，刷新面试时长记录，记录几个我回答的不好或者印象深的。</p><ul><li>从 URL 输入到页面展现到底发生什么？<br><br>经典问题，用于全面考验一个前端的网络基础，甚至能看出是否具有一定全栈能力，标准回答可以直接百度，然后可以结合一些自己的项目。</li><li>父元素和子元素宽高不知道的情况如何居中子元素？<br><br>这个问题其实和父元素高度知不知道无关，因为文档流中父元素默认包裹子元素，高度是由子元素撑开的。</li><li>Webpack 用过吗，讲一讲。</li><li>如何用 ES5 实现 promise？<br><br>有各种版本的，思想就是 then 的链式调用先返回 promise，然后将具体回调推入队列等待延迟执行，延迟执行通过 setTimeOut 模拟。</li><li>前端性能优化有哪些方式？<br><br>掘金上有一篇文章：<a href="https://juejin.im/post/5a966bd16fb9a0635172a50a">2018 前端性能优化清单</a></li></ul><h3 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h3><p>几乎没问基础知识问题，一直考验对问题的解决能力，问了很多特定的场景题，也和面试官的团队负责内容相关。</p><ul><li>平时怎么学习前端？</li><li>富文本编辑器怎么实现？<br><br>给标签设置 contenteditable 属性，然后使用浏览器支持的 document.execCommand 命令模式 API</li><li>富文本编辑器会面临怎么样的攻击风险？如何避免？<br><br>就是变相问网络安全，把 XSS 和 CSRF 具体到场景里去作答。</li><li>如果要实现在离线情况下编辑且不丢失数据，怎么办？<br><br>先回答的是使用 localStorage，回答之后不断追问，还问了能否直接用对象存，后面扯到了引擎方面的问题。</li><li>如何实现一个可编辑的可以无限延伸的表格？<br><br>这里只能受虐了，尽力讲讲自己的想法，比如延时加载，滚动节流等等，但是仍然被不断追问直到没辙。</li><li>CSS 基础好么，知道 DEN 么？<br><br>CSS 基础还可以，但是 DEN 真不知道。。。</li><li>Webpack 用过么？里面的 tree-shaking 什么原理？<br><br>tree-shaking 是因为 import 静态引入的能力，得以对文件内容进行浅层比较，去掉未被使用的代码。</li><li>如何衡量一个软件的质量？如何保证产品的质量？<br><br>讲了一些软甲工程的思想，又讲了些敏捷中的测试驱动开发，科班的知识终于在这里用到一点。</li><li>写过测试么？有没有用过测试的框架？<br><br>程序员自己写的测试能叫测试吗（狗头）。</li><li>你觉得自己对比其他人的优势在哪里？<br><br>此问让人很慌，只能不害臊地稍微讲讲自己的优点。</li></ul><h3 id="三面-3"><a href="#三面-3" class="headerlink" title="三面"></a>三面</h3><ul><li>介绍自己的项目。</li><li>你的项目怎么实现后端推送？<br><br>websocket 那一套。</li><li>除了 websocket 外还有什么方法能实现后端推送？<br><br>只能回答轮询了。</li><li>开发过微信小程序么，你感觉小程序和传统 web 以及 Flutter,ReactNative 之间的关系是什么？<br><br>一个很广的话题，从 html 静态页面开始说起，讲讲前端发展历史和趋势。</li><li>看你框架用得很多，说说 React 和 Vue 的区别？<br><br>直接从原理上，React 是 setState 那一套自己实现的更新体系，Vue 是 nextTick，并且每个属性都被劫持（2.0）或代理（3.0），可以精确定位，触发 watcher。</li><li>http2 知道么，讲讲它和 http1 的区别，有什么新特性。<br><br>多路复用、新的二进制编码、头压缩、服务端推送等。</li><li>你还有什么自己的项目或者开源贡献讲一讲？<br><br>自己写的 flutter 项目，博客以及在关注的新技术新方向都讲了一遍。这种问题就是考察技术热情和活跃程度。</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>本文应该是面试系列中最长的一篇了，面的多，问的也多，希望看到这里的读者可以不断总结，完善自身。也祝愿所有看到此文的人能得到帮助，收获理想的 offer。</p><p>最后，如果你觉得本篇文章对你有所帮助，或者想再看看其他面试者的经历，不如扫描文章底部二维码给个关注，或者点个「在看」支持一下，你们的支持是我前进的最大动力！</p><h3 id="更多阅读："><a href="#更多阅读：" class="headerlink" title="更多阅读："></a>更多阅读：</h3><p><a href="https://mp.weixin.qq.com/s/9ssXDvG3AAWxCpZl2WqiYQ">未雨绸缪，小米前端实习面经</a></p><p><a href="https://mp.weixin.qq.com/s/mv4OSgo28Y1-PVxbQpt9Eg">刚完一波蚂蚁金服的面试后，他说他累了</a></p><p><a href="">搏一搏，单车变摩托，记录一下我的淘宝实习面试</a></p><hr><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdmap1wt2uj31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 面试学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是环境变量？</title>
      <link href="p/f226.html"/>
      <url>p/f226.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkfri6jactj30p00andgu.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在初学 Java 时，相信大家下载安装完 JDK 后的第一件事就是 <strong>「配置环境变量」</strong>，几乎所有的教程都会告诉你当你在命令行工具中输入了 java 命令和 javac 命令后看到类似如下的结果就说明你的 Java 环境配置好了 👇</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc3xq2o61j31c00u01ah.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkc3z9g40nj31c00u0h5v.jpg"></p><p>不知道你有没有思考过这个「环境变量」究竟是什么？为什么配置了之后就会显示这样的内容，为什么不配置，就会提示你一个错误：<code>&#39;javac&#39; 不是内部命令或外部命令，也不是可运行的程序或批处理文件。</code></p><p>如果你也有这样的疑问，不要着急，我们今天就来一探究竟。</p><blockquote><p>文内相关的演示，均在 Windows10 操作系统下执行</p></blockquote><h2 id="从打开软件的两种方式说起"><a href="#从打开软件的两种方式说起" class="headerlink" title="从打开软件的两种方式说起"></a>从打开软件的两种方式说起</h2><p>我们平时打开一个应用程序，一般是双击桌面图标或在开始菜单链接，无论是桌面的快捷图标还是菜单链接都包含了应用程序的安装位置信息，打开它们的时候系统会按照这些位置信息找到安装目录然后启动程序，这里以 QQ 这个软件为例：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkfpy9syooj30mw0xmmzh.jpg"></p><p>上面是我们最常用的打开软件的方式，当然了，既然知道了一个应用程序的安装目录位置，我们也可以通过命令行工具进入启动程序所在的文件，通过命令打开，如笔者 QQ 的位置为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Tencent\QQ\Bin\QQScLauncher.exe&quot;</span><br></pre></td></tr></table></figure><p>QQ 的启动程序名为 QQScLauncher，那么我们打开终端工具，使用 cd 命令进入该目录，再输入<code>.\QQScLauncher.exe</code>，即可通过命令启动 QQ。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkfq29dyg0j31mr0u0aiv.jpg"></p><h3 id="做一点改进"><a href="#做一点改进" class="headerlink" title="做一点改进"></a>做一点改进</h3><p>如果想要炫技，每次都先进入安装目录再打开文件显然有些麻烦，那有没有什么简单的方式，直接在命令行工具中输入 QQScLauncher 甚至直接输入 QQ 就能打开软件呢？</p><p>当然是可以的，我们只需要在<strong>用户变量</strong>名<code>Path</code>中添加安装路径的字符，我们在命令行工具无需进入软件的安装路径即可打开软件了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfq3y2wn4j31eb0u0b29.jpg"></p><p>我们来试下直接在命令行工具中输入 QQScLauncher，果然可以直接打开软件了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkfq810x2fj31gr0u0wly.jpg"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>为什么配置环境变量前，直接输入 QQScLauncher 无法打开软件呢？</p><p>这是因为操作系统并不知道你的 QQScLauncher.exe 这个文件在哪里，所以无法执行对应的文件。</p><p>你在命令行里输入的那几个符号，其实就是一些可执行程序的名字(标签、别名)，是可以直接被当前系统直接执行的程序。如果是在 Windows 系统中，则这些被输入的符号就是可以直接被 windows 系统执行、后缀为’.exe’的程序(文件)。</p><p>那么为了能够让操作系统找到这个可执行文件，我们就需要把 QQScLauncher.exe 这个 可执行文件所在的目录作为 PATH 环境变量的一部分设置起来，这样当你在命令行输入一个命令的时候，操作系统就会<strong>自动搜索 PATH 变量</strong>中所指定的所有目录 了。</p><p>在 Windows 系统中 PATH 变量中的所有路径采用分号分割，如果在 Linux 系统中采用冒号分割。</p><blockquote><p>如果你设置好了环境变量，在命令行中还是出现同样的错误，那么有两种可能，一种就是你的设置不正确，另一种就是你的设置没有生效，一般你可以关闭命令行窗口再重新打开就可以了。</p></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>上面所说的 PATH 变量其实就是环境变量，和他的名字一样，环境变量是<strong>描述环境的变量</strong>，是指在操作系统中用来指定操作系统运行环境的变量。它包含了一个或者多个应用程序所将使用到的信息。</p><p>例如 Windows 和 DOS 操作系统中的 PATH 环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到 PATH 中指定的路径去找。用户通过设置环境变量，来更好的运行进程。</p><h3 id="系统变量-OR-用户变量"><a href="#系统变量-OR-用户变量" class="headerlink" title="系统变量 OR 用户变量"></a>系统变量 OR 用户变量</h3><p>相信细心的小伙伴已经发现了，在上图的页面中除了<strong>用户变量</strong>还有一个叫<strong>系统变量</strong>的。</p><p>事实上，环境变量是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。系统变量就是系统级别的变量，用户需要使用系统变量。如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。他们之间的关系图如下如所示：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkc7x4h8nsj30z60idmxr.jpg"></p><p>看到这，想必在验证 Java 环境是否安装成功的时候，我们在终端工具中输入 <code>java</code> 和 <code>javac</code> 命令显示出相应的字符的原理想必你也就知道了吧。</p><p>一图说明：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc8ufipqvj32is0lin5x.jpg"></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>作为一个计算机专业的学生，一定要学会使用命令行工具，你可以选择自己喜欢的终端软件，这里我使用的是 <strong>「Windows Terminal」</strong>，一方面是因为他是微软官方推出的终端工具，更有一点就是他的颜值很高，你可以在微软的应用商店搜索下载安装。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc3vtgdwaj31qy0sk433.jpg"></p><p>以上就是本文的全部内容了，如果你觉得对你有所帮助，不妨点赞关注支持一波 👍</p>]]></content>
      
      
      <categories>
          
          <category> 每周一问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么非对称加密比对称加密慢？</title>
      <link href="p/e87f.html"/>
      <url>p/e87f.html</url>
      
        <content type="html"><![CDATA[<p>这个问题是一个读者面试时遇到的一个问题，准备过面试的人应该都记得，非对称加密与对称加密的区别之一就是非对称加密的速度慢，但是我们做业务开发的时候通常都是直接调用算法，对其原因并没有过多深究，因此如果有面试官问到了这个问题，的确会让人措手不及。正好借着这篇文章来说一说。</p><h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><p>首先我们先来说一下到底什么是对称加密，什么是非对称加密，这一节主要是用一些例子来介绍一下对称加密和非对称加密是什么，如果你已经了解了，可以跳过本节。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>高中生小明和小红是一对“地下情侣”，可偏偏他们一个坐在教室前，一个坐在教室后，所以晚自习的时候也只能通过纸条传情。这时一个很尴尬的事情就出现了，由于无法直接将纸条交给对方，因此纸条必须要经过多个人的传递，可总有一两个八卦的人喜欢看纸条里写的什么。为了避免被班主任抓包以及被同学们窥视，他们两约定，用现代汉语词典当作“密码本”，以后传纸条时，纸条上的内容是要写的字在词典里的页码及顺序，这样即使纸条被别人看了，不知道密码本是什么的人也就不会得知纸条里的真正内容了。<br>在上述的例子中，纸条是承载信息的<strong>载体</strong>，纸条里的内容是<strong>信息</strong>，汉语词典是<strong>密钥</strong>，将文字映射到汉语词典的页码和顺序是<strong>加密方式（算法）。</strong><br>类似于上面这种，在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥的加密方式就是<strong>对称密钥加密</strong>（Symmetric-key algorithm），简称对称加密。常见的对称加密算法有：<strong>AES、DES、3DES</strong><br>所以你可以将对称加密简单理解为：一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下图所示（这里借用一下@寒食君的图）：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibafkal10j30u009zdmo.jpg"></p><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><p>这种加密方式虽然简单，但是其弊端也是非常明显的。在上面的例子中，如果传递纸条的人知道了他们这种加密方式，那就同样可以通过查阅汉语词典解析出他们的纸条内容。如下图所示。这样为什么众多抗战片中会出现疯狂抢夺密码本这一情节也就很好理解了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibagjgbesj30u0084agn.jpg"></p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>再举一个生活中非常常见的例子。小区里的小伙伴们经常可以在自家的邮箱里收到信件，比如你的录取通知书，当然更多可能是广告。不过，虽然说所有人都可以往里面扔邮件，但是只有你可以打开这个邮箱查看这个邮件。<br>上面这个过程就是一个很形象的非对称加密。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibah0moj8j317s0qa0we.jpg"></p><p>非对称加密不同于对称加密，它有一对秘钥，一个称为<strong>公钥（publicKey）</strong> ，另一个称为<strong>私钥（privateKey）</strong>，并且<strong>*只知道公钥是无法推算出私钥</strong>。*就和上面的例子中只知道邮箱位置却并不能打开邮箱是一个道理。常见的非对称加密算法有：<strong>RSA、DSA、ECC</strong><br>另外，这种算法还有一个特别神奇的功能，那就是<strong>通过公钥加密的内容，只有私钥才可以解开，而通过私钥加密的内容，只有公钥才可以解开。</strong></p><h4 id="公钥-私钥的用法"><a href="#公钥-私钥的用法" class="headerlink" title="公钥/私钥的用法"></a>公钥/私钥的用法</h4><p>第一种用法：公钥加密，私钥解密。—用于<strong>加解密</strong><br>第二种用法：私钥签名，公钥验签。—用于<strong>签名</strong><br>其实很容易理解：<br>既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；<br>既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</p><blockquote><p>这里提一点：<strong>签名 ≠ 加密</strong>，通俗点说加密就是你哪怕看到了不该看到的东西，也理解不了。而签名就是你做了任何事，都抵赖不了。</p></blockquote><h3 id="为什么非对称加密比对称加密慢？"><a href="#为什么非对称加密比对称加密慢？" class="headerlink" title="为什么非对称加密比对称加密慢？"></a>为什么非对称加密比对称加密慢？</h3><p>介绍了这两种加密方式后，我们终于可以回到本篇文章的开头了，为什么非对称加密会比对称加密慢？<br>这是因为对称加密主要的运算是<strong>位运算</strong>，速度非常快，如果使用硬件计算，速度会更快。以 AES 算法为例，如下图所示，其运算本质上来说就是位移和替换。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibahgqfvdj30u013ik3l.jpg"></p><p>但是非对称加密计算一般都比较复杂，比如 RSA，它里面涉及到大数乘法、大数模等等运算。其加解密可以用下面的公式来表示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibaik391mj30d802yweh.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibaj2ppz9j30cs03e0sq.jpg"></p><p>我们知道，幂运算的本质是乘法，乘法的基础单位是加法，也就是我们最常见的整数加。学过数字逻辑电路的同学想必都知道，在电路上实现“加法”比异或（XOR）要麻烦的多，况且后面还有一个模运算。因此非对称加密的速度自然而然是比不过对称加密的。<br>当然，我想另外还有一个原因是，AES 中的许多中间计算过程是可以事先计算好的。加密数据时许多中间过程可以直接查表，而不需要实时地计算。</p><blockquote><p>通常情况下，非对称加密（如 RSA）的解密速度会比加密速度更慢，详情可参考<a href="https://security.stackexchange.com/questions/57205/why-is-rsa-decryption-slow">Why is RSA decryption slow?</a></p></blockquote><h3 id="时空性"><a href="#时空性" class="headerlink" title="时空性"></a>时空性</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibajih78pj30e80dptgl.jpg"></p><p>这里另外提一点，我们在学习算法的时候，一定听过时间复杂度和空间复杂度这两个名词。鱼和熊掌不可兼得，通常情况下，一个算法如果运行比较快，那么空间消耗相对来说就会高一些，反之亦然。因此才会有拿空间换时间的说法。<br>从上一节我们可以知道，非对称加密运行起来通常比对称加密慢，那么这时就有一个问题了，对于密钥的存储情况也是这样吗？非对称加密对于密钥的存储会比对称加密的密钥存储少吗？<br>答案是的确如此，在对称加密中，当信息量大的时候，要求密钥量也要足够大，需要每两个人之间都有一个密钥，也就是对于 n 个人来说，一共需要  <img src="https://cdn.nlark.com/yuque/0/2020/svg/1711761/1595323641496-a3382868-b282-4a6c-ba51-043a73d96cb0.svg#align=left&display=inline&height=23&margin=%5Bobject%20Object%5D&originHeight=23&originWidth=87&size=0&status=done&style=none&width=87">  个密钥才能确保两两之间对话不被其他人知道。<br>而在非对称加密中，每个人都有公钥和私钥，对于 n 个人来说，一共要  <img src="https://cdn.nlark.com/yuque/0/2020/svg/1711761/1595323676761-41e181eb-b73e-4f53-a7ee-aab16368cec3.svg#align=left&display=inline&height=17&margin=%5Bobject%20Object%5D&originHeight=17&originWidth=20&size=0&status=done&style=none&width=20">  个密钥，就能保证两两之间对话不被其他人知道。</p><blockquote><p>什么？你问我这个公式怎么来的？数学归纳法了解一下？</p></blockquote><p>这么看，非对称加密虽然效率低下，但是存储成本低且相对安全，这也就解释了为什么非对称加密应用如此广泛了。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>既然无法做到既安全又快速的加解密，那我们在实际使用时只能尽量达到一个动态的平衡。<br>因此我们在项目中通常会采用如下这种将两种加密算法结合在一起的使用方式：</p><ol><li>首先随机生成单次请求加密密钥(clientAesKey，长度为 16 位，可以用 26 个字母和数字组成)</li><li>RSA 负责加密一个字符串（clientAesKey）、</li><li>AES 负责用这个字符串（clientAesKey）、明文加密为一个密文。</li><li>解密时首先要用 RSA 获取这个字符串（clientAesKey）、然后再用 AES 解密密文。</li></ol><p>之所以本节的标题是 HTTPS，是因为在 HTTPS 中就使用了上述这种加解密的方式。关于 HTTPS 的详解，可以参考我的好朋友寒食君的这篇<a href="https://juejin.im/post/5be66e345188254b0917ede9">《谈恋爱也要懂 HTTPS》</a>。<br>现在如果有面试官问你，在 https 中采用了哪种加密方式，我想你应该知道答案了吧。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibakqhxr3j30nn0fd1kx.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 每周一问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我们需要批量操作？</title>
      <link href="p/e0c9.html"/>
      <url>p/e0c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实习的时候被问过一个问题，为什么 redis 会有 pipline，mysql 会有 batch，这些东西都具有<strong>批量操作</strong>的共性，是什么原因让我们在处理数据时需要批量操作？</p><p>这么说可能有些抽象，举一个和 API 调用有关的例子 🌰：</p><p>现有三个服务 service A、service B 和 service C。因业务需要，我们需要在 service A 中调用 service B 获取一组 id，然后根据 id 从 service C 中读取最终内容。然后组织成结果返回前端。由于 service C 只提供了单个 id 查询内容的 API，所以如果我们想要获取批量的信息，最先想到的办法是通过 for 循环多次调用 service C。但是这样的办法是极其不优雅的，接下来我们从以下两个方面来分析。</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>鉴于现在的分布式架构，每个 service 都分布在<strong>不同的服务、不同的机器</strong>中，所以我们每次调用都要通过 RPC 来实现，这就要求我们不得不构造同等数量的请求来获取数据。这样就会导致了一些效率问题。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gilmcpyi0jj30uu0c6t96.jpg"></p><p>所以我们通常会通过在 service C 中提供一个批量查询的接口来解决多次通信的问题。如下图所示 👇</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gilmcwzfm4j30uu0c6mxk.jpg"></p><p>我们知道，并不是每一次网络传输都非常稳定，中途可能会遇到<strong>丢包</strong>等一系列问题，而用批量查询代替 for 循环单个查询，这样做的好处是，我们可以减少网络通信的次数，一定程度上可以增加整个系统的健壮性。</p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>解释完多次 rpc 调用可能造成的网络延迟的问题后，我们再往深一点的地方看。</p><p>一般情况下，数据都是存放在数据库中的，所以无论是单个查询还是批量查询，我们最终都是要访问到<strong>数据库</strong>的。</p><p>现假设，我们需要从数据库中查询一个 id 为 123 的用户信息，我们可以用类似下面这样的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> id = <span class="number">123</span>;</span><br><span class="line">Person p = serviceA.getPersonById(id);</span><br></pre></td></tr></table></figure><p>那如果我们需要查询一组 id 为 123、456、789 的用户信息，在没有批量查询接口的情况下，我们可以用 for 循环的方式实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span>[] ids = &#123;<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>&#125;;</span><br><span class="line">List&lt;Person&gt; ps=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> id : ids)&#123;</span><br><span class="line">ps.add(serviceA.getPersonById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看虽然符合逻辑，但在数据库查询时，会有一定的性能损耗。</p><p>以 MySQL 为例，不论是 MyISAM 存储引擎还是 InnoDB 存储引擎，锁这个概念一直都是贯穿其中的，MyISAM 存储引擎默认是使用表锁，InnoDB 存储引擎默认使用的是行锁，这就意味着，在查询数据时，mysql 会将相关记录“锁起来”，只有当结果查询完毕时才会释放锁。</p><p>相较于批量查询只有一次上锁、开锁这种情况，循环里的每次查询都要先拿到锁，然后再释放锁，这个操作自然会更加耗时。这也就是为什么 mysql 会提供 batch 操作的原因。</p><h3 id="Redis-中的-pipline"><a href="#Redis-中的-pipline" class="headerlink" title="Redis 中的 pipline"></a>Redis 中的 pipline</h3><p>这里我们再来扩展一下，为什么 redis 中会需要 pipline 这样一种实现机制。</p><p>pipline，中文翻译为管道，它可以将一组 redis 命令进行<strong>封装</strong>，一次性将多个命令传输到 redis 服务端，并将数据一次性带回。这样就可以通过一次 RTT （Round Trip Time 往返时间），将多个数据带回，减少了数据传输的 RTT 消耗。如下图所示 👇</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gilmd4zz72j30ya0nsq44.jpg"></p><p>redis 的命令执行是微妙级别的，这个速度相对于网络延时是非常小的，因此才有了 redis 的性能瓶颈在网络的说法。并且事实上网络确实已经是 redis 的性能瓶颈之一。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gilmdjmrdrj310u08cq64.jpg"></p><p>这就更凸显了批量操作的重要性了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>回到这一篇的主题，为什么我们需要批量操作？</p><p>虽然现在已经是“云”的时代，在云内部的 rpc 请求几乎不消耗时间，但我们仍然需要意识到构造请求、解析请求、查询数据库等方面的时间和资源消耗。</p><p>如果不能批量操作，那么，需要操作的资源越多，操作执行的次数也会越多。这是一个线性上升的模型。就像数据库导入数据，一条两条，手写个 sql 完全没问题。那如果是，100 万+数据呢？一条一条手动导入？这显然是不合理的。</p><p>这就是批量操作的现实意义。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gilmdue9faj30go0go40v.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 每周一问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么不在 for 循环里捕获异常？</title>
      <link href="p/1b55.html"/>
      <url>p/1b55.html</url>
      
        <content type="html"><![CDATA[<p>在回答标题这个问题之前，我们先试想一下，在没有 try…catch 的情况下，如果想要对函数的异常结果进行判断，我们应该怎么做？</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>第一个想法肯定就是 if…else 了，一般情况下，相关的代码段我们都是放在一起的，如果此时你的程序中有大量的代码段要做这做判断，这就意味着后面执行的逻辑会依赖你前面语句的执行情况，也就意味着你每调用一个可能会出现错误的函数的时候，都要先判断是否成功，然后再继续执行后面的语句。这就会导致你的代码中会充斥着大量的 if…else。<br>Java 是一门工程性的语言，而工程也是一种艺术，因此采用这样的做法显然是很不优雅的。《Thinking in Java》中提到“badly formed code will not be run.”，意思是结构不优雅的代码不应该被执行，于是一个适用于 Java 的异常处理机制便应运而生了。<br>Java 的异常处理其目的在于通过使用少于目前数量的代码来简化大型程序，举个简单的例子 🌰<br><strong>不用 try…catch</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fr == <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Open File Error&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">    <span class="keyword">while</span> (br.ready()) &#123;</span><br><span class="line">        String line = br.readLine();</span><br><span class="line">        <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Read Line Error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用了 try…catch</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">    <span class="keyword">while</span> (br.ready()) &#123;</span><br><span class="line">        String line = br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显我们可以看出来，下面这种写法主线明确，可读性更高。<br>当然，try…catch 也并不是百利而无一害。如果程序员在代码中滥用了 try…catch，并且没有做好异常处理，很有可能会导致一些 bug 被隐藏，无法跟踪。不过这些不是本文的重点。有兴趣的可以去阅读下《Thinking in Java》的第 12 章「通过异常处理错误」。</p><h2 id="单独捕获异常"><a href="#单独捕获异常" class="headerlink" title="单独捕获异常"></a>单独捕获异常</h2><p>在探究将异常捕获与循环结合起来之前，我们先看一下单独捕获一个异常会发生什么？<br>这是一段异常代码<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi9reu2vuij30kq0fkmzf.jpg"><br>我们用 <code>javap -c ExceptionDemo.class</code> 来打印出他的字节码来看一下<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi9rf1h8xzj30kq0irjuu.jpg"><br>指令含义不是本文的重点，所以这里就不介绍具体的含义，感兴趣可以到 Oracle 官网查看相应指令的含义 👉<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">The Java Virtual Machine Instruction Set</a></p><h3 id="异常表的四个参数"><a href="#异常表的四个参数" class="headerlink" title="异常表的四个参数"></a>异常表的四个参数</h3><p>从输出看，字节码分两部分，code（指令）和 exception table（异常表）两部分。当将 java 源码编译成相应的字节码的时候，如果方法内有 try catch 异常处理，就会产生与该方法相关联的异常表，也就是<code>Exception table:</code>部分。<br>每一个条目有<strong>四列信息</strong>: 异常声明的开始行, 结束行, 异常捕获后跳转到的代码计数器(PC)所指向的行数, 还有一个表示捕获的异常类的常量池索引。<br>那这些信息是从哪来获得的呢？这里我们先来来复习一下 JVM 的相关知识：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi9rf8wdirj30kq0a175s.jpg"><br>一个线程就是一个栈，由栈帧组成，一个方法就是一个栈帧，内部保存着：  局部变量表、操作数栈、动态链接、方法出口。<br>JVM 在构造异常实例时需要生成该异常的栈轨迹。这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息。而这些信息就会存储在刚才所说的<code>Exception table:</code>中。</p><h3 id="四个参数的作用"><a href="#四个参数的作用" class="headerlink" title="四个参数的作用"></a>四个参数的作用</h3><p>那刚才所说的那些信息又有什么用呢？<br>如果在执行方法时有一个异常被抛出, JVM 就会从异常表中按照条目所出现的顺序查找对应的条目。如果异常抛出时 PC 计数器所指向的行数正好落在异常表中某一条目包含的范围内, 并且所抛出的异常正好是异常表中 type 列所指定的异常(或者所指定异常的子类), 那么 JVM 就会将 PC 计数器指向 Target 偏移量所指向的地址, (进入 catch 块)继续执行。<br>如果没有在异常表中找到异常, JVM 就会将当前栈帧弹出并重新抛出这个异常。当 JVM 弹出当前栈帧的时候, 它就会中止当前方法的执行, 返回到调用当前方法的外部方法中, 不过并不会像正常没有异常发生时那样继续执行外部方法, 而是在外部方法中抛出相同的异常, 这样将会导致 JVM 会在外部方法中重复查询异常表并处理异常的过程。</p><h3 id="为什么捕获异常消耗性能"><a href="#为什么捕获异常消耗性能" class="headerlink" title="为什么捕获异常消耗性能"></a>为什么捕获异常消耗性能</h3><p>其实从上面的分析中，我们就已经可以理解为什么捕获异常是一个消耗性能的操作了，当你 new 一个 exception 的时候，JVM 已经在 exception 里构建好了所有的 stacktrace：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi9rfjt5kpj30i00c0jse.jpg"><br>现在 Java 领域最火的框架莫过于 Spring 系列了，在一个 web 项目中，调用栈的深度是相当大的，由此可见这里花费的代价是可观的，因此，当你对 stacktrace 不感兴趣的时候，不需要这样的信息时，最好不要随便的 new exception。</p><h2 id="异常-for-循环"><a href="#异常-for-循环" class="headerlink" title="异常+for 循环"></a>异常+for 循环</h2><p>说了那么多其实都是前置知识，现在我们终于来到了标题提到的问题了。<br>for 循环和异常有两种结合方式：<br><strong>try+for 循环</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryFor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            Math.sin(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for 循环+try</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Math.sin(j);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我先给出结论：<br><strong>在没有发生异常时，两者性能上没有差异。如果发生异常，两者的处理逻辑不一样，虽然已经不具有比较的意义了，但 for 循环+try 的耗时更明显。</strong></p><h3 id="字节码比较"><a href="#字节码比较" class="headerlink" title="字节码比较"></a>字节码比较</h3><p>我们对这两种方式进行一个字节码的比较：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi9rfrl9lij30kq05v0tz.jpg"><br>通过第二节的分析我们知道，当程序出现异常时，java 虚拟机就会查找方法对应的异常表，如果发现有声明的异常与抛出的异常类型匹配就会跳转到 catch 处执行相应的逻辑，如果没有匹配成功，就会回到上层调用方法中继续查找，如此反复，一直到异常被处理为止，或者停止进程。而在 for 循环中进行 try…catch 操作，会不断的进行这一过程，性能损耗自然会很恐怖。</p><h3 id="测试比较"><a href="#测试比较" class="headerlink" title="测试比较"></a>测试比较</h3><p>说了这么多我们一直都是纸上谈兵，口说无凭，实际的效果肯定是要跑一下才知道，这里我们采用 Java 的一个微基准测试框架<a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a>来进行此次测试。<br>测试结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Benchmark              Mode  Cnt   Score   Error   Units</span><br><span class="line">ExceptionDemo.forTry  thrpt   <span class="number">20</span>  <span class="number">70.236</span> ± <span class="number">8.945</span>  ops/ms</span><br><span class="line">ExceptionDemo.tryFor  thrpt   <span class="number">20</span>  <span class="number">85.864</span> ± <span class="number">3.272</span>  ops/ms</span><br></pre></td></tr></table></figure><p>score 的结果是 xxx ± xxx，单位是每毫秒多少个操作。最终结果也验证了我们的结论。tryFor 的确会比 forTry 更节省性能。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文从异常出发，分析了单独捕获异常和将异常与 for 循环结合的几种不同的情况，然后通过 JMH 进行了一次测试，最终验证我们标题所说的，不建议在 for 循环里捕捉异常。<br>当然，try…catch 对性能的影响除了第二节所提到的需要维护一个异常表之外，还有一个原因，那就是 try 块会阻止 java 的优化（例如<strong>重排序</strong>），try catch 里面的代码是不会被编译器优化重排的。当然重排序是需要一定的条件触发。一般而言，只要 try 块范围越小，对 java 的优化机制的影响是就越小。所以保证 try 块范围尽量只覆盖抛出异常的地方，就可以使得异常对 java 优化的机制的影响最小化。<br>以上就是本文的全部内容了，如果你觉得有所帮助，不妨点个赞支持一下。</p><hr><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi9rgb0465j30go0goaeo.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 每周一问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 地址怎么定位？</title>
      <link href="p/4670.html"/>
      <url>p/4670.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gks6hp0s49j30p00andjv.jpg"></p><p>我们经常可以在影视作品中见到某某组织通过对某个人的 IP 地址进行监控，定位其位置，甚至精确到某栋大楼的某一层，如此可怕的场景在现实生活中真的有可能会发生吗？</p><p>先来说结果，仅通过 IP 地址最精确能够达到街道级别。而且在不通过<strong>运营商</strong>的用户数据库查询情况下，定位到家庭住址和单元楼的情况难度很高。</p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>在<a href="">《互联网是如何工作的》</a>一文中，我们介绍道，IP 地址是类似于现实世界中的地址这样的东西，通过 IP 地址，我们就可以在网络上定位到一台计算机，在现实世界中，IP 地址是由一个叫<strong>互联网服务提供商</strong>，即 ISP 提供的。</p><p>回想一下我们上网的过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">去运营商（移动、电信、联通）办理宽带业务 -&gt; 业务员上门拉线 -&gt; 电脑连接宽带 -&gt; 访问互联网</span><br></pre></td></tr></table></figure><p>在这一过程中，三大运营商就是我们能接触到的 ISP 的，ISP 可以从互联网管理机构申请到很多 IP 地址，然后一些机构和个人从某个 ISP 获取 IP 地址的使用权，并可通过该 ISP 连接到互联网。</p><p>那么 ISP 又是如何标记 IP 地址的地理位置的呢？</p><p>我们先来说说 ISP 的三层结构。</p><p>三层 ISP 结构分为主干 ISP，地区 ISP，本地 ISP。本地 ISP 给用户提供最直接的服务，本地 ISP 可以连接到地区 ISP，也可以连接到主干 ISP。从原理上讲。只要每一个本地 ISP 都安装了路由器连接到某个地区 ISP，而每一个地区 ISP 也有路由器连接到主干 ISP，那么在这些相互连接的 ISP 的共同作用下，就可以完成互联网中的所有的分组转发任务。</p><p>这里我们通过计算机网络教材中的一张图来理解三层结构，如图 1 所示 👇</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkrzivfnuhj31kn0tiqfy.jpg" alt="图1 基于 ISP 的多层结构的互联网的概念示意图"></p><p>也就是说，当你向好友发了一条微信，这条微信首先会从你所在公司/学校的内网上发到当地的服务器，再从当地服务器发送到地区服务器，之后从地区服务器通过移动/联通/电信的服务器向你好友所在地的地区服务器转发，再通过本地服务器最终转发到好友所在公司/学校的内网。</p><p>如此一来，既然你的 IP 地址是由当地的 ISP 分配给你的，自然也就知道了你所在的 IP 地址的<strong>大致位置</strong>了。</p><h3 id="IXP"><a href="#IXP" class="headerlink" title="IXP"></a>IXP</h3><p>在图 1 中，我们发现图中还有一个叫 IXP 的东西，这里简单扩展一下，还是以发微信为例，如果每次发微信的都将数据先发到本地 ISP，然后发到地区 ISP，然后再发到主干 ISP，通过这样的链路将数据传输到对方的设备上，显然是不合理的，如果流量过大，有没有什么优化方案？</p><p>显而易见，当然是有的，我们可以通过在低层 ISP 之间搭桥的方式，让流量不走主干 ISP，直接在地区 ISP 之间直接相连进行交换分组，这样一来可以降低延时，二来还可以降低费用（走高层主干 ISP 收费一定比直接走底层地区 ISP 贵）。</p><h2 id="精确定位"><a href="#精确定位" class="headerlink" title="精确定位"></a>精确定位</h2><p>通过上一小节的讲解我们知道了可以通过申请的运营商的地址判断你的 <strong>大致位置</strong> ，这个大致位置可以精确到省市，如图 2 所示，我们在百度搜索 IP，就可以给我们返回本机 IP 所在的城市。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkrzqdyu7pj318o0h2dif.jpg" alt="图2 百度获取本机 IP 位置"></p><p>2016 年 8 月 26 日，百度地图高精度 IP 定位服务 API 正式上线。但是一年后，也就是 2017 年 7 月，开发者陆续收到百度终止高精度 IP 定位服务 API 的通知邮件。这里我不想讨论工程伦理问题，仅就其高精度 IP 定位服务，谈一谈个人理解。</p><ol><li>用户手机里安装了百度的服务，比如百度地图 SDK</li><li>用户手机运行了百度的服务，比如使用百度地图进行导航，公交查询等等过程，都会让百度的服务运行起来</li><li>百度提供服务的同时，将当前的坐标，跟 IP 地址数据，当前时间，定位方式，WI-FI 信息，移动联通电信等运营商的基站信息，传送给百度的后台服务器中，后台服务器留存了这些数据，然后也用这些数据给用户返回了用户需要的内容。这个过程也就是百度的匿名采集信息过程。用户使用前必然都是许可了百度可以使用这些匿名数据。</li><li>百度提供了服务同时，自己收集了匿名数据。而这些数据中，就包括 IP 和 GPS 的对照数据。</li><li>利用这些数据，就可以计算出一个 IP 曾经在哪些范围被使用过，从而得到一个精确的范围数据，这个范围的中心点，就被认为是最接近用户的地点，同时还会把误差半径也计算出来。</li></ol><p>通过上述分析可知，百度的高精度 IP 定位服务，其根本来源于百度匿名收集服务，它的源头则是：手机位置服务。可能百度收集这些数据并非出于泄露隐私目的，但是，大数据发展导致我们可以用各个数据源去拼凑一个完整画像，这也有意无意导致一个泄露隐私的结果。所以百度下线这一功能也是情理之中的。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>延伸一下，获取到精确的定位我们可以做些什么？</p><p>在一篇名为《一种基于地理位置和兴趣点信息的用户细分方法》专利申请中曾写道：</p><blockquote><p>通过将客户去过的地方来量化的勾勒出用户的类型，即所有客户不再被看成简单的数字，而是具有不同兴趣点（标签）的 个体。用用户的兴趣点来量化地勾勒出用户的具体细节轮廓。采用本发明方法得出的对用 户兴趣点的诠释在某些时候甚至能超过个体本人对自身的诠释和了解。</p></blockquote><p>简单翻译一下上面的话就是，通过对你不同时间段所处的位置进行分析，可以将你进行一个归类，例如，喜欢运动的用户、学生用户以及喜欢购物的用户。在通过多维度的分析后，这套系统可能会比你自己更了解你。</p><p>当然了，这样的专利并不是只有这一家，国内互联网巨头们都有着类似的专利，比如腾讯的<a href="https://patents.google.com/patent/CN103456233A/zh">CN103456233A</a>，阿里巴巴的<a href="https://patents.google.com/patent/CN106534392B/zh">CN106534392B</a>，这些早就不是什么遮遮掩掩的东西了。就像李彦宏说的，中国人多数情况下愿意用隐私换取便捷性。虽然这是一种“被愿意”。</p><hr><p>最后说一点，我写公众号也有 2 年多了，虽然每次都是看心情更新的，但总感觉通过写公众号的方式分享内容总还是有些单向，而且因为申请的晚，我的公众号也没有留言功能，总觉得自己的文章有些一言堂，但又觉得建立一个读者群会没时间管理。现在临近毕业，工作也基本定下来了，想着未来几年可能都会在这一领域发展，所以还是决定建一个读者群。我会在群里邀请我的一些同学和朋友，前后端的都有，这样也可以方便大家更主动的双向沟通，不知道会有多少人响应，就先试试看。如果群二维码失效了，你可以通过第二个二维码添加我的微信拉你进群。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gks713cd93j30kw0r20zf.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gks739fxamj30kw0r2aex.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 每周一问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API 与 SDK：有什么区别？</title>
      <link href="p/d340.html"/>
      <url>p/d340.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glvvc8x4t9j30p00anq38.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是 API？</p><p>什么是 SDK？</p><p>两者之间有何关系？</p><p>欢迎来到本次的每周一问系列。</p><p>既然点进来了，相信你或多或少都听说过这两个名词了，因此，在为你解答之前，让我们先从一个例子出发。<br>假如你想开发一个 OCR 应用（通俗的说就是文字识别应用），他的功能是识别用户上传的一张图片，然后将图片中的文字识别出来返回给用户。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvgk72lf5j31ds0p44a4.jpg"></p><p>通常，OCR 应用的后端服务都会部署在云上，那么我们应该如何在移动应用程序与基于云的服务之间进行通信呢？</p><p>这就是 API 和 SDK 的用武之地了。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="API-的特点"><a href="#API-的特点" class="headerlink" title="API 的特点"></a>API 的特点</h3><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>首先我们要明白的是 API 是和<strong>通信</strong>有关的，是用于应用（服务）与其他应用（服务）对话所定义的协议。在上述例子中，你可以简单理解为 API 是 OCR 应用和云端服务之间沟通的桥梁。</p><p>那么 API 到底是什么？</p><p>API 全称 Application Programming Interface，即<strong>「应用程序接口」</strong>。</p><p>一般是指一些预先定义的<strong>函数</strong>，目的是供应用程序与开发人员基于某软件或硬件得以访问一组程序的能力，而又无需访问源码，或理解内部工作机制的细节。</p><p>以 Java 为例，当你想要实现一个数组排序的功能时，你是会先手写一个排序算法，还是直接使用<code>Arrays.sort()</code>函数？我想你心里是有答案的。</p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>其次，我们要理解，API 的另一个重要特点——<strong>抽象。</strong></p><p>抽象指的又是什么？</p><p>还是以这个 OCR 应用为例，当我们在使用云端提供的文字识别能力时（比如百度文字识别），他的背后可能会有成千上万的代码，比如提供识别能力的机器学习的代码、提供 Web 能力的后端代码等等。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvgle151qj315g0by4bl.jpg"></p><p>但是你作为一个 APP 的开发者，你需要去看这些代码是怎么写的吗？难道不知道背后的源码就不能调用百度提供的文字识别能力了吗？当然不是。</p><p>通常服务商已经给你提供了文档，告诉你如何去调用相应服务，只要你按照他的要求来即可。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvglptfn5j31k70u0gy9.jpg"></p><p>因此，在你的 APP 和 OCR 服务之间，API 抽象出所有复杂的逻辑，<strong>简化了调用过程</strong>，这使得你只需要考虑获取所需的数据即可。</p><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>API 是标准化的，这意味着存在有关如何定义 API 的行业标准，比如 SOAP、REST、GraphQL 等。</p><blockquote><p>我在<a href="https://book.liangyueyong.cn/00-1/01">《你的第一本 SpringBoot 书》</a>中写到什么是 RESTful API，有兴趣的小伙伴可以点击阅读，这是我正在写的一本 SpringBoot 入门教程，目前还没完工，欢迎读者们不要吝啬自己的建议 🙏。</p></blockquote><h3 id="API-的构成要素"><a href="#API-的构成要素" class="headerlink" title="API 的构成要素"></a>API 的构成要素</h3><p>那么，API 通常由什么组成呢？</p><p>首先，我们要发送一些数据到云端，即所谓的「请求」。</p><p>从本地应用发请求到云端，我们需要分几步完成，以 REST 为例。</p><p>对于 REST API 调用请求，第一步是指定传输的方法，通常是和 HTTP 方法对应的，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvgm7gognj31iq0be759.jpg"></p><p>当你想要上传一张图片时，通常会使用 POST 方法，然后是传递一些参数，包括请求的内容（图像本身）。然后加上需要请求的地址，即可构成一个完整的请求。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvgmgs1quj31b80ja44u.jpg"></p><p>之后，服务器再以 JSON 等形式将数据返还给你，在你使用的云服务的文档中也会有所标注。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvgmo8l29j31940fmq4g.jpg"></p><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p>说了这么多，你应该对 API 有所了解了，那么这时候问题就来了，作为开发人员，你如何在实际的项目中调用 API？</p><p>你要自己构造 HTTP 请求、拼接 URL、添加需要的参数、处理返回的 JSON 对象，麻烦吗？</p><p>麻烦。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvgmubuwcj30ny0hqtax.jpg"></p><p>那有没有什么好的办法简化这些操作，使得我只需要给一张图片然后就给我返回结果的呢？</p><p>自然是有的，这就是接下来我们要说的 SDK 了。</p><p>SDK 全称 Software Development Kit，<strong>软件开发工具包</strong>。</p><p>一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。</p><p>通俗来讲就是<strong>第三方服务商提供的实现产品软件某项功能的工具包</strong>。例如 JDK 就是一种 SDK。</p><p>还是以上面的 OCR 应用为例，如果使用了某厂商的 SDK 服务，那么我们连 HTTP 请求的构建都不需要了，仅调用一个方法，可能的代码如下图所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OCRResult res = ocrClient.ocr(<span class="string">&quot;pic.jpg&quot;</span>).getResult();</span><br></pre></td></tr></table></figure><p>通过调用这行代码，SDK 会自动封装 API 请求，而且作为响应，你获得的结果也不一定是 JSON 对象，也有可能是代码，例如上述代码段里的<code>OCRResult</code>，这是因为 SDK 也已经将 JSON 对象<strong>反序列化</strong>成你需要的对象，比如一个 Java Model。</p><p>SDK 相当于开发集成工具环境，API 就是数据接口。API 可以在 SDK 提供的“环境”里请求。同样的，这里的“环境”也是一个抽象的概念。如果不使用 SDK，也可以直接调用 API，只不过，这个环境就要由开发者自己实现了。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>其实从上面的内容，我们也已了解到，API 在更多场合下更像是 SDK 的一个子集，他们的区别如下：</p><ul><li>API 通常是一个函数，有特定的功能；而 SDK 是一个很多功能函数的<strong>集合体</strong>，更像是一个工具包。</li><li>API 通常扮演数据接口的形象，SDK 相当于一个工具环境，通常是需要在 SDK 的环境下调用 APl。</li><li>SDK 相较于 API 封装层次更高。</li></ul><hr><p>以上就是本篇文章的全部内容了，如果你觉得文章对你有所帮助，随手点个关注转发给你的小伙伴们，这对我真的很重要，你们的支持是我继续更文的动力，谢谢大家！</p>]]></content>
      
      
      <categories>
          
          <category> 每周一问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赢在起跑线还是智商税？聊一聊少儿编程</title>
      <link href="p/afc8.html"/>
      <url>p/afc8.html</url>
      
        <content type="html"><![CDATA[<p>今天正好是六一儿童节，本期作为儿童节特辑，来聊一聊一个正在兴起的行业——少儿编程。</p><p>几年前路过一家店，上面赫然写着“少儿编程”四个大字，着实把我吓了一跳，那个时候我才大二，还是一个只会 ctrl+c/v 的代码搬运工（有机会和大家聊一聊我这些年的编程之路），现如今，b 站的上小学生都已经开始在教我写代码了，作为一个学了几年计算机的新人程序员，借着这次儿童节，来聊（ceng）一（re）聊（dian）这个新的行业「少儿编程」究竟是让孩子赢在起跑线还是收割家长们的智商税？</p><p><img src="https://cdn.ytools.xyz/uPic/8i9Zclunnamed%20(1).png"></p><p>本期邀请了我的一个朋友<strong>季节</strong>，她本科学的是软件工程，硕士学的是现代教育技术，是一个典型的学科交叉人才了，因此本期以 Q&amp;A 的形式来聊一聊这个话题。</p><h2 id="Q：少儿编程都学一些什么？"><a href="#Q：少儿编程都学一些什么？" class="headerlink" title="Q：少儿编程都学一些什么？"></a>Q：少儿编程都学一些什么？</h2><p>A：Scratch、python、Arduino、乐高、C++</p><h2 id="Q：这些东西小孩子能懂吗？"><a href="#Q：这些东西小孩子能懂吗？" class="headerlink" title="Q：这些东西小孩子能懂吗？"></a>Q：这些东西小孩子能懂吗？</h2><p><img src="https://cdn.ytools.xyz/uPic/oS81HPimage.png"></p><p>能懂。对于不同年级的学生在学习编程的内容也会所不同。</p><p>从我带的学生来看，有的学生虽然才一年级，但是很愿意思考，从一开始的内向也渐渐地开始愿意与老师沟通交流，部分家长会认为学生年龄较小，注意力不集中，很难专心做事，更何况编程是一个需要动手、眼、脑全身心投入的过程。</p><p>学生在设计编程时，实际上都是注意力很集中的，如果在某个环节出错，整个程序将无法达到预期效果，这都有利于培养学生的注意力。很多学生能够专心投入，完成编程任务，即使遇到困难，只要观察思考，加之教师的适当指导，种种困难将会迎刃而解。</p><h2 id="Q：送孩子去学少儿编程的家长们是怎么想的？"><a href="#Q：送孩子去学少儿编程的家长们是怎么想的？" class="headerlink" title="Q：送孩子去学少儿编程的家长们是怎么想的？"></a>Q：送孩子去学少儿编程的家长们是怎么想的？</h2><p>从小接触少儿编程，也并不是让他以后当程序员，而是用编程解决问题时，会经历<strong>「识别问题类型」、「建立数学模型」、「寻找合适算法」、「代码实现」</strong>解决等几个过程，这些对培养孩子的思维都会有很大帮助。<br>以 Scratch 为例。</p><ol><li>Scratch 的入门简单,无须编程基础，适合青少年初次学习编程语言时使用。</li><li>Scratch 内容丰富,提供绘画、动画、游戏,读书报告、科学实验等处理功能，其可视化的特点便于初学者集中乐于动手实践，领略编程的魅力。</li><li>Scratch 不仅是编程工具，它还有助于提升解决问题的能力,拉近了使用者与计算思维的距离。Scratch 提供及时反馈，便于快速检查逻辑正确与否，使学生在动画游戏设计过程中逐渐形成逻辑分析、独立思考创新的思维方式，学会提出问题，解决问题。</li><li>Scratch 还能将数学、美术、音乐与信息技术有机结合起来，让计算思维渗透到其他学科，在不断尝试、实践、体验和创新中获取经验并提升能力。</li></ol><p><img src="https://cdn.ytools.xyz/uPic/Iju6xrimage%20(1).png"></p><h2 id="Q：少儿编程有什么推荐的工具吗？"><a href="#Q：少儿编程有什么推荐的工具吗？" class="headerlink" title="Q：少儿编程有什么推荐的工具吗？"></a>Q：少儿编程有什么推荐的工具吗？</h2><p>我将从以下几个方面进行回答。</p><p><strong>第一阶段——入门</strong></p><p><img src="https://cdn.ytools.xyz/uPic/ljYsLMimage%20(2).png"></p><p>推荐——Scratch</p><p>适合年龄：6-12 岁</p><p>让零基础的孩子爱上编程的启蒙课</p><p><strong>第二阶段——过渡</strong></p><p><img src="https://cdn.ytools.xyz/uPic/Yk4qjNimage%20(3).png"></p><p>推荐——Python</p><p>适合年龄：9-15 岁</p><p>思维由具体向抽象转变的艺术编程</p><p><strong>第三阶段——进阶</strong></p><p><img src="https://cdn.ytools.xyz/uPic/M6Zlheimage%20(4).png"></p><p>推荐：C/C++语言</p><p>适合年龄：10-17 岁</p><p>系统性的学习语法指令等算法知识</p><p><strong>第四阶段——拓展</strong></p><p><img src="https://cdn.ytools.xyz/uPic/ciTd5Aimage%20(5).png"></p><p>推荐：HTML + CSS + JS</p><p>适合年龄：12-18 岁</p><p>网页游戏开发</p><h2 id="Q：有哪些在线少儿编程，价格怎么样？少儿编程线上和线下的比重是多少"><a href="#Q：有哪些在线少儿编程，价格怎么样？少儿编程线上和线下的比重是多少" class="headerlink" title="Q：有哪些在线少儿编程，价格怎么样？少儿编程线上和线下的比重是多少?"></a>Q：有哪些在线少儿编程，价格怎么样？少儿编程线上和线下的比重是多少?</h2><p>我将两者结合以表格的形式进行回答。（价格不太清楚）</p><p>国内外具有代表性的少儿编程平台</p><table><thead><tr><th>教育平台</th><th>时间</th><th>课程内容</th><th>年龄阶段</th><th align="left">管理模式</th><th>平台特点</th></tr></thead><tbody><tr><td>Scratch &nbsp; ScratchJr</td><td>2003 &nbsp; 2004</td><td>Scratch &nbsp; ScratchJrAPP</td><td>8-16 &nbsp; 5-7</td><td align="left">线上 &nbsp; 线下</td><td>MIT 媒体实验室终身幼儿园小组创立的项目，提供免费的 Scratch 课程</td></tr><tr><td>ShawAcademy</td><td>2013</td><td>Scratch</td><td>全龄阶段</td><td align="left">线上</td><td>爱尔兰在线教育平台，提供面向初学者的实时和互动编程课程</td></tr><tr><td>GoogleCSFirst</td><td>2013</td><td>Scratch</td><td>9-14</td><td align="left">线上</td><td>Google 用于创建、管理和教授中学计算机科学，已有九个领域和 72 个编程探索和课程</td></tr><tr><td>做梦编程</td><td>2014</td><td>Scratch/Python/C++</td><td>6-18</td><td align="left">线上</td><td>编程及数学逻辑思维开发，7 种主流编程语言、17 个级别的课程进阶体系</td></tr><tr><td>编程猫</td><td>2015</td><td>Scratch/Python/数据结构/操作系统</td><td>7-16</td><td align="left">线上线下</td><td>从兴趣出教算法，在游戏中发觉创造力，探索学科融合奥秘</td></tr><tr><td>编玩边学</td><td>2015</td><td>Scratch/Python/Arduino</td><td>7-18</td><td align="left">线上</td><td>在线小班教学、进阶式课程，PBL 游戏化教学</td></tr><tr><td>小码王</td><td>2016</td><td>Scratch/Python/JAVA</td><td>6-16</td><td align="left">线上线下</td><td>资深教育顾问，侵入式学习体验</td></tr><tr><td>优必选</td><td>2012</td><td>Jimu 系列编程机器人</td><td>6-18</td><td align="left">线上线下</td><td>从人形机器人起步，逐步推出 steam 教育智能编程机器人</td></tr><tr><td>乐博乐博</td><td>2012</td><td>UARO 机器人/积木机器人/单片机/python</td><td>4-16</td><td align="left">线上线下</td><td>基于 PDCA 教学法开展编程教育</td></tr></tbody></table><p>从上述平台本身来看，各有自己的亮点和特色。</p><p>“优必选”通过创意搭建、逻辑编程学习以及亲子、伙伴间的分享，来培养青少年的创造力和跨学科综合运用知识解决问题的能力；</p><p>“乐博乐博”于 2008 年自韩国引入我国少儿编程教育领域，它采用项目管理中的“P-D-C-A”（情境导入、探索体验、反思学习、总结重构）模式开展教学；</p><p>“编程猫”以游戏、动画、图形化为主要特色，采用 PBL 项目式教学，利用 AI 定制学习规划，目前已有超过 200 万中小学用户。</p><p><img src="https://cdn.ytools.xyz/uPic/c8eXVGimage%20(6).png"></p><p>从适用年龄来看，各大平台都涵盖从学前至中学段的青少年编程教育内容。从课程内容来看，各大平台主要围绕<strong>「机器人教育」</strong>以及<strong>「编程教育」</strong>，讲授的语言主要有 Python，Scratch 以及 C++。其中，多个平台将全国<strong>青少年信息学奥林匹克联赛（NOIP）</strong>作为授课的重点之一，这与国内考试升学的制度紧密联系在一起。此外，结合 Arduino 等开发的 STEAM 教育智能机器人，是当前国内青少年编程教育中主要的教学模式之一。</p><p>从运营模式来看，越来越多的平台采用线下线上相结合的教学模式，总结线下教学经验，利用线上平台展示教学深度，来吸引家长与学习者。不难发现，国内外该领域的发展势头十分强劲，且发展特点同异并存。</p><p>相较而言，国外青少年编程涉及的语言更为多样，且存在各类非营利组织为学习者提供学习机会。同时，还有平台专门关注女性学生群体的编程学习与发展。反观国内，青少年编程教育多为编程机器人、信息学奥赛以及图形化编程等，注重小班教学以及利用各类教学方式（游戏化、PDL 等)，以打造更优的编程学习体验。</p><p>因青少年的注意力还不够集中，还是推荐<strong>线下</strong>比较好，但是各大平台大多数都是以线上线下相互结合。</p><h2 id="谈一谈我的看法"><a href="#谈一谈我的看法" class="headerlink" title="谈一谈我的看法"></a>谈一谈我的看法</h2><p>上面就是整个 Q&amp;A 的主要内容，最后谈一谈我的想法。首先我自己就是写代码的，深知这一行「<strong>天赋」</strong>的重要性，如果只是想通过这一行赚钱，做一个只会 C&amp;V 的 Coder 虽然没什么太大的难度，但是这样也就没必要让孩子提早接触编程。但如果是希望锻炼孩子的思维能力，可能要等少儿编程的成本不那么高之后才会是一个稍微好点的选择。对我来说，少儿编程更多是是培养兴趣、锻炼逻辑思维能力的“手段”，这两点有很多软件自己带着孩子玩就完全可以。</p><p>什么，你问我愿不愿意教孩子？你说呢 🥸</p><p><img src="https://cdn.ytools.xyz/uPic/GxlkvSimage%20(7).png"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 少儿编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云盘——新的屠龙勇士？</title>
      <link href="p/dbd2.html"/>
      <url>p/dbd2.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkux7qw2u0j30dw06nace.jpg"></p><p>天下苦度盘久矣！</p><p>遥想当年，各家网盘百家争鸣，115 网盘，360 云盘，金山快盘，百度云盘，腾讯微云等，他们都曾在中国互联网上掀起一场轰轰烈烈的网盘大战，可如今，他们中的大多数都已折戟沉沙。随着各家公司纷纷关闭其网盘业务，国内网盘行业进入百度的时代。</p><p>时间来到 2020 年，现在大家提到百度网盘会想到什么？龟速下载？付费分级？</p><p>如果不是付费用户，你的下载速度可能会停留在 20KB/s，而且，哪怕你是 VIP 也没有办法体验满速下载，你还得是 SVIP！</p><p>一般来说，付费网盘只有小额度的免费空间或者流量，相当于让用户试用（有些甚至没有免费配额）。这样免费用户产生的成本开销并不大，相当于营销费用而且最终由付费用户买单。例如 iCloud，onedrive 和小米的云服务。</p><p>因为付费用户群体相对较小，相对于<strong>流量产生利润</strong>的免费互联网而言收入主要来自<strong>订阅收费</strong>。那么为了吸引用户付费，服务上会很重视<strong>用户体验</strong>，这就包括上传下载的速度还有客户端的使用体验——广告一般也不会有，毕竟为了这点流量带来的微不足道的收益去破坏用户体验损失付费用户得不偿失。</p><p>而对于免费网盘则一般提供大空间/大流量（甚至不限制流量）的组合给免费用户，自身通过<strong>广告</strong>等其他手段盈利。</p><p>可百度网盘，既舍不得大量的免费用户带来的流量，又要面子没法像小牌网盘那样肆无忌惮的通过广告压榨用户体验，还想通过付费订阅盈利。属实有点又当又立。</p><p>可是哪怕百度网盘问题如此之多，在国内却还是没能出现百度网盘的替代者，一来是因为用户习惯已经养成，<strong>迁移成本</strong>过高；二是小网盘随时有跑路的风险，不一定值得信赖。这也就是为什么现在一提到百度网盘就让大家既无奈又没办法不用的原因。</p><p>但就在前不久，国内另一个互联网巨头——阿里巴巴下场了，并且一出手就是两个网盘，颇有一番要重新搅局的意思。这两款网盘，一个是 Teambition 的网盘，一个是阿里云盘。Teambition 暂且不说，毕竟他的网盘只是作为其团队协作工具的的一个附属功能。</p><p>可他的兄弟阿里云盘一出来就说自己是一款定位于个人用户的云盘，要为用户提供更优异的个人云体验。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkuwzrzoo2j31a50mp4qp.jpg"></p><p>我是不懂更优异的个人云体验是什么样的，毕竟我对于网盘的要求就只是上传/下载不限速、分享链接别动不动被和谐，空间足够即可。</p><p>就目前放出的 beta 版来说，阿里云盘确实做到了。满速的上传与下载、清爽简洁的界面以及差不多够用的空间，这些特性都足够吸引我继续使用下去。</p><p>其他功能我也没有体验，一来因为我的需求就这么简单，二来我又不是写软文，整那些花里胡哨的干嘛？</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkux01k2b8j30m30j4di1.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkux05h391j30m80cnq4s.jpg"></p><p>目前我对他的态度是：继续观望。我是挺不喜欢很多人一出来就各种尬吹的（当然不排除那些是水军的可能性），但目前阿里云盘的横空出世确实给消费者提供了一个新的选择，虽然不知道阿里云盘的最终结果会怎么样，但是有一个良性竞争，对我们用户来说肯定是极好的。目前来看算是高开，但最后是否高走就要看阿里的后续操作了。毕竟阿里也不是慈善企业，也不会总想着用爱发电。</p><p>目前阿里云盘已经公测了，申请方法很简单，在官网<a href="https://www.aliyundrive.com/">https://www.aliyundrive.com</a>首页，点击<strong>「“个人云种子用户”报名入口」</strong>后填写一些信息后，过段时间就会发邮件到你所填的邮箱中了。</p><p>如果不想等待申请时间，我这给大家分享几个我刚从同事那要来的邀请码，每个邀请码每天激活的次数有限，先到先得，如果激活失败，大家可以第二天再试一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VF4UBZ</span><br><span class="line">2F9H4S</span><br><span class="line">HMTGU7</span><br><span class="line">7U8K7C</span><br><span class="line">TQXGC3</span><br></pre></td></tr></table></figure><p>就让我们拭目以待，看看这个新出的屠龙勇士会不会变成恶龙？</p><hr><p>最近为了方便和读者们进行双向交流，我新建了一个读者群，如果我的文章对你有所帮助，并且愿意与我和群里的小伙伴们一起交流的，不妨扫描下方二维码加入读者群。或者关注我的微信公众号「01 二进制」，现在关注以后就是老粉了哦 😯</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkux0bgb8yj30n00si0yw.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈自己的保研</title>
      <link href="p/b66d.html"/>
      <url>p/b66d.html</url>
      
        <content type="html"><![CDATA[<p>2018 年 9 月 28 日 10:11，在我点击系统上的确认按钮后，我终于结束了为期一年的保研历程，拿到了南京大学软件工程专业的录取名额，也算是给我这三年画上了一个圆满的句号了。写这篇文章一方面是为了记录下自己的这段时光，另外也是希望可以给学弟学妹们一些建议。<br>其实现在回过头看一看我的保研经历，我真的只能说我在保研上的运气非常非常好，因为我自身的条件很差，差到什么程度呢？列个表就知道了：<br>key | value<br>—-|——<br>本科院校 | 江苏科技大学（四非大学）<br>专业 | 软件工程（应该是 c-）<br>绩点 | 3.21/5.0<br>专业排名 | 11/80<br>英语能力 | 四级 519 六级 474<br>推免名额 | 2/80</p><p>这么一看基本上就是咸鱼的命了，大多数保研的条件都会比我好，但事实上我也不是一无所有，尽管成绩是我的硬伤（毕竟大一大二玩的太过），但是我有一些加分项侧面弥补了成绩上的不足（当然这些东西和那些大佬相比就相形见绌了）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一作者软件著作权1篇、第一作者科技核心期刊1篇</span><br><span class="line">「全国大学生智能互联创新大赛」全国二等奖</span><br><span class="line">「中国软件杯双创大赛」全国三等奖</span><br><span class="line">「博创杯」全国大学生嵌入式设计大赛华东赛区特等奖</span><br><span class="line">「计算机设计大赛」全国二等奖</span><br><span class="line">「蓝桥杯」江苏省二等奖</span><br><span class="line">优秀学生干部、先进个人</span><br><span class="line">校友奖学金、人民奖学金、镇江安徽商会奖学金</span><br></pre></td></tr></table></figure><p>这些东西真的都只是包装用的，我接下来提到的为保研做的准备才是我觉得最重要的。</p><hr><h2 id="保研的前期准备"><a href="#保研的前期准备" class="headerlink" title="保研的前期准备"></a>保研的前期准备</h2><h3 id="资讯了解"><a href="#资讯了解" class="headerlink" title="资讯了解"></a>资讯了解</h3><p>开始之前，先推荐一个资讯网站–<br><a href="https://link.jianshu.com/?t=http://www.eeban.com">保研论坛 http://www.eeban.com</a><br>各种夏令营的信息里面都会发布，然后大家也会在里面讨论啥的，我的信息初期都是从这里面来的，之后也是通过这个论坛加了计算机的保研群，里面的人长得好看，说话还好听，我超喜欢那里的。<br>然后需要说一下，两个重大事项：夏令营和预推免。这两个项目都是各个学校自己组织的，准确的来说是非官方的选拔，但是基本上所有推免的学生都将从这两次非官法选拔中录取，如果等到教育部的系统开通之后，再走国家推免的路线，基本上是没有名额了，就算有，也是别人挑剩下的了。<br>这两个事项的关系是这样的，有的学校会在 5 月–8 月期间组织一次夏令营选拔学生，然后再在 9 月份组织一个预推免再次补录一批学生，比如南京大学，一般来讲，夏令营会比预推免难度大一些，而且参加过夏令营但未被录取的同学将不能参加第二次的预推免，也就是说夏令营和预推免只能二选一。如果想更深入的了解推荐阅读<a href="https://zhuanlan.zhihu.com/p/38919161">《夏令营、预报名、九月推免有什么不同》</a></p><h3 id="个人定位"><a href="#个人定位" class="headerlink" title="个人定位"></a>个人定位</h3><p>说白了就是要想想自己以后要学啥，这个时间段最好定在<strong>大三的寒假</strong>（这样你就有充足的时间去准备），是想读计算机还是继续读软件（毕竟读研阶段计算机和软件的差距还是有些大的）；然后确定一个专业方向（这个是很必要的，不能到了这个时候，你连自己想读什么都不知道吧！这就很不应该了！）<br>就我而言，我知道自己想学啥，我喜欢软件，我喜欢那种做软件时创造的感觉（哪怕是创造出了 bug），所以填志愿的时候我基本上还都是选了软件工程。</p><h3 id="择校"><a href="#择校" class="headerlink" title="择校"></a>择校</h3><p>其实选学校在保研过程中是非常重要的，有几个关键因素（排名不分先后）：</p><ol><li>学校的知名度（清北，华五人，航济开等）</li><li>专业实力（有的学校很厉害，但是没有你想要的专业）</li><li>导师（包括导师的能力，导师的人品，所处实验室的氛围等等，参考 × 理工“爸爸事件”）</li><li>地理位置（这个不用多说，一线城市二线城市的优缺点相信你们自己也都清楚）</li><li>个人能力（这个才是核心，一定要量力而行，自己几斤几两心里一定要有数）</li></ol><p>这几个因素的重要性在不同的人眼中其实是不一样的，如果你是一个四非大学而且急于通过保研摘掉本科学校的帽子，我想读研学校的知名度对你来说一定就很重要了；但如果你本身读研就是为了追求学术，那考虑的重心自然是要放在专业实力和导师的能力上了。<br>以上几个因素我分别说下：</p><h4 id="学校和专业"><a href="#学校和专业" class="headerlink" title="学校和专业"></a>学校和专业</h4><p>对于 1 和 2，我这有份表，大家可以参考下（只有计科和软工的）：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-25a80ec8dadc7282.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="排名"><br>如果有保研想法的可以根据上面的排名表给自己定一个目标了。</p><h4 id="导师选择"><a href="#导师选择" class="headerlink" title="导师选择"></a>导师选择</h4><p>接下来就是导师的选择了，同样是机器学习的老师，如何判断这个老师的科研水平呢？第一个看老师的个人主页（每个学校的网站上都有的），看他／她的论文情况，近几年有没有发论文，论文中是第几作者，和他／她一起发论文的是学生还是其他的研究员。然后 google scholar 一下，看这个老师的 h 值，搜索的时候如果中文名没有，换成拼音试一下。另外，在这里推荐一个非常棒的网站：<a href="https://www.mysupervisor.org/index.php?sid=567e911f7cfd69539308ca0bdaecf8a3">导师评价网</a><br><img src="https://upload-images.jianshu.io/upload_images/5666077-2abb44bed084e72e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="导师评价网首页"><br>当然如果你觉得我对于选导师说的不明白你还可以自己去知乎上搜索下怎么挑选导师，总之，导师的选择很重要一定要多方面了解，如果可以面谈自然是最好了。</p><h4 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h4><p>这个更多的是你对于你未来的考虑了，如果你家是北方的你愿不愿意去南方读书呢?你以后是愿意留在南京发展还是去上海奋斗?这些都是自己需要考虑的因素。拿我自己举例子，我家在南京，自然是不愿意跑去北京广州这么远的地方去读书的（当然如果清华北大要我的话地理位置是可以忽略的）。上海不用多说，谁都知道她好，金融中心，机会多，而且上海高校毕业，并在上海就业的话，拿到上海户口很 easy（虽然买不起房要户口也没啥用）。但是就今年而言，复旦的专硕没有宿舍啊（说到底还是因为自己能力不够拿不到学硕），一个月将近 2k 的房租，加上零零散散的开销，以我家目前的经济实力是负担不起的。</p><blockquote><p>小结下，总的来说就是，学校的选择，适合你的才是最好的！。</p></blockquote><hr><h2 id="文书的准备"><a href="#文书的准备" class="headerlink" title="文书的准备"></a>文书的准备</h2><p>简单来说就是你的支撑材料。对方学校的老师毕竟和你不认识，只能通过你给他的材料了解你，所以你需要在你自己的材料中充分的表现自己。材料主要包括以下两个：</p><ol><li>简历</li><li>个人陈述</li></ol><p>在这里需要说明下，简历的重点在“简”，你需要的是让老师通过一页的文档就能大致的了解你的<strong>重要情况</strong>，比如你的专业技能，获得的奖项，学习的情况，研究方向，社会实践等。这些都要往好的方面上说，俗称报喜不报忧。当然如果你想详细的介绍自己，这个时候就需要写个人陈述了，个人陈述可以作为发给老师的邮件，也可以用单独做成文档发给老师，这个看个人喜好，我当时是把个人陈述当做邮件内容的，简历作为附件的。如果想看我的简历和个人陈述的，可以微信联系我，二维码在文末。<br>具体怎么写个人简历和个人陈述这里就不多说了，篇幅较长，推荐观看视频：<a href="https://www.bilibili.com/video/av20718742/?p=2&t=1493">《保研课程：告诉你怎么写保研个人简历、推荐信、个人陈述以及给导师发邮件》</a></p><hr><h2 id="机试和面试的准备"><a href="#机试和面试的准备" class="headerlink" title="机试和面试的准备"></a>机试和面试的准备</h2><h3 id="机试准备"><a href="#机试准备" class="headerlink" title="机试准备"></a>机试准备</h3><p>一般计算机类的保研都会有机试的（如果这个学校没有机试的，那也没必要去了），这个没办法，就是要多做题，如果你之前有参加 ACM 等算法比赛经验的，自然没多大问题，但是这篇文章更多的是给双非（或者四非）学生保研看的，像我本科这种学校能参加 ACM 的机会几乎为 0，自身能力不足加学校没那条件培养 ACMer，但是为了机试还是得硬着头皮上，刚开始可以做做简单点的题目，后期再把难度提上去，推荐两个地址：</p><ol><li><a href="https://leetcode-cn.com/problemset/algorithms/?difficulty=%E7%AE%80%E5%8D%95">《Leetcode 简单题》</a></li><li><a href="https://www.nowcoder.com/ta/kaoyan?query=&asc=true&order=&page=1">《牛客网计算机历年考研复试上机题》</a></li></ol><p>我本科阶段 Java 用的比较多，所以准备机试的时候是用的 Java 学习和做题的，推荐书籍：</p><ol><li><a href="http://product.dangdang.com/22880871.html">《算法 4》</a>，号称算法的圣经，Java 版</li><li><a href="http://product.dangdang.com/24214704.html#ddclick_reco_reco_relate">算法图解</a>，如果觉得上面那本书太厚太难不好理解，也可以先看看这本书，图解很详细，而且编程语言是 python，上手快，毕竟也只是为了看思想。</li><li>如果是用 c/c++做题的，推荐刘汝佳的《算法竞赛入门经典》，时间充足，使用<a href="https://link.jianshu.com/?t=https://item.jd.com/11469701.html">第二版紫色的</a>，时间紧迫，使用<a href="https://link.jianshu.com/?t=https://item.jd.com/10080192.html">第一版蓝色的</a>。<blockquote><p>另外提一句，为什么不推荐《算法导论》，因为他太难了，准备保研的情况下，时间是很宝贵的，没必要研究的那么深入，毕竟只是为了过机试（如果你想去清华，那另当别论）。</p></blockquote></li></ol><p>我推荐按照专题来学习，毕竟大三开始准备算法的，也没多少时间海量刷 oj 了，把机试题中常考的题型分类攻克，比如：</p><ol><li>字符串操作</li><li>逻辑题</li><li>动态规划</li><li>DFS/BFS</li></ol><p>leetcode 上的分类非常的详细，分专题学习，然后分专题练习，如果书看不懂或者看不下去，就去找视频资源，一定要利用好互联网资源（尤其是<a href="https://www.bilibili.com/">b 站</a>这个海量学习库）。这里我推荐一个 b 站的 up 主：<a href="https://space.bilibili.com/24014925/#/">正月点灯笼</a><br><img src="https://upload-images.jianshu.io/upload_images/5666077-ebf7c8f897d8f58b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800"><br>推荐几个他的视频，讲的非常详细：</p><ol><li><a href="https://www.bilibili.com/video/av16544031?from=search&seid=686888468998928807">动态规划第一讲</a></li><li><a href="https://www.bilibili.com/video/av18512769?from=search&seid=686888468998928807">动态规划第二讲</a></li><li><a href="https://www.bilibili.com/video/av25761720">DFS 和 BFS</a></li></ol><h3 id="面试的准备"><a href="#面试的准备" class="headerlink" title="面试的准备"></a>面试的准备</h3><p>面试有三宝，英语，自信，扯得好。</p><h4 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h4><p>一般来说，去对方学校面试的第一步就是英语，这个时候口语好的同学就太占优势了，试想一下，面试时你能说出一口流利的英语，那面试的老师对你的印象自然就会非常的好，但是这个真没办法速成，只能自己平常多花些时间练了。推荐英语流利说 app。</p><h4 id="自信"><a href="#自信" class="headerlink" title="自信"></a>自信</h4><p>第二步就是自信了，处事不惊、遇事不慌，展现出最真实的自己，这在面试中是最重要的，记住，一定一定不能慌，知道的就自信的回答，不知道的就诚实的说不知道。切勿慌慌张张，自然的肢体语言，从容的笑容，响亮的回答都是给你加分的点。毕竟能够保研的同学都是不差的，所以你的思考方式，处事态度成为很重要的评判标准。</p><h4 id="扯得好"><a href="#扯得好" class="headerlink" title="扯得好"></a>扯得好</h4><p>扯得好并不是让你胡说八道，而是能够很好的转移话题，或者说牵引着面试官提问。临场发挥的能力真的很重要。面试只有这么几分钟，应当在这几分钟内，最好的表现出自己知道的东西。<br>前提是<strong>你的专业基础一定要扎实</strong>，来面试你的基本都是学院的大牛，你肚子里有没有货一问便知，知识储备一定要足。主要包括：</p><ol><li>计算机网络、操作系统、数据结构、数据库等专业性知识。</li><li>高等数学、线性代数、概率论等基础课程。</li></ol><p>还是那句话，不要求明白的多么深入，但一定不能一知半解。</p><hr><h2 id="填志愿"><a href="#填志愿" class="headerlink" title="填志愿"></a>填志愿</h2><p>高考的时候我们就知道，三分考试定，七分志愿拼，保研同样也是如此，三个平行志愿，不分主次，就像下面那样：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-58985bb569900992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800">你先点了哪个学校的录取，其他的学校就不会再给你发待录取通知了，三个志愿是互斥的，这里有份简单的说明：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-e5382ab2eec2ec98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"><br>具体怎么填志愿，推荐阅读<a href="https://zhuanlan.zhihu.com/p/29219054">《2017 保研必读 | 详解教育部推免系统》</a><br>志愿填完就可以安安心心等待录取了。</p><hr><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后我想说的是保研过程中最最最重要的就是你的实力，而不是那些虚无缥缈的加分项，只有提升了硬实力和软实力你才会有核心竞争力。硬实力主要就是你的专业课知识，技术素养，科研/工程能力；软实力就是你的口语水平，思维的方式，说话的方式，临场发挥随机应变等能力。</p><p>希望我的这篇文章可以对有保研想法的学弟学妹有用。如果想和我交流的可以添加我的微信，记得加上备注。<br><img src="https://upload-images.jianshu.io/upload_images/5666077-fc60caa5028389c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挪威的森林——书中的女孩们</title>
      <link href="p/91d7.html"/>
      <url>p/91d7.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5kjzy3xqnj309o0dwweq.jpg"></p><p>这是一本很神奇的书，说他神奇的原因是，我既可以把这本书作为言情小说看，也可以当作色情小说看，甚至可以把它当作讲大道理的鸡汤书看，而且作为一个情窦初开的年轻人，总能在书中的几个人中找到和自己相似的影子。</p><p>其实整本书都是围绕了几个主要人物的情感展开的，包括四男（渡边、永泽、木月、敢死队）和四女（还有直子、绿子、玲子、初美）。读这本书其实就是读书中的这几个人物。本文主要讲下书中的四个女孩。</p><p><strong>绿子</strong></p><p>先说这里面我最喜欢的绿子吧，她是一个活得很通透的人，在她身上我看到了一个敢爱敢恨的女生。相较于书中的另一个女主角直子，绿子像个春天里的熊，大胆又有活力，她是生动的，鲜活的。他爱绿子，爱她的率真、洒脱。“我可是有血有肉活生生的女孩，而且现在就在你的怀抱里表白说喜欢你。只要你一声令下，赴汤蹈火都在所不惜，虽然我多少有蛮不讲理的地方，但心地善良，正直勤快能干，脸蛋也相当俊俏，乳房形状也够好看，饭菜做的又好，父亲的遗产也办了信托存款，你还不以为这是大甩卖？你要是不买，我很快就到别处去。”说实话，如果是我，遇到这样的女孩子想必很快就会沦陷了。只是开篇的种种都暗示着渡边最终也没能和绿子在一起，不免有些唏嘘。</p><p>虽说绿子是个大大咧咧的丫头，但对待感情却也会有些自私的（谁又不是呢？），绿子知道渡边心中有一个没法忘记的人，却还是选择等待他处理好自己的事情，她对渡边的要求也仅仅只是要我时就只要我，抱我时就得只想我，以及千万别做伤感情的事，毕竟在过去的生活里绿子已经被伤害得够厉害了，不想再被伤害下去了。好在书的最后绿子等来了她的渡边。</p><p><strong>直子</strong></p><p>对于直子，我感觉她更像是我们年少时的执念，一个爱而不得的人。她和绿子是一个对立面，生与死的对立面（不单单是因为两个人的人生分别选择了生与死）。书中提到过“死并非生的对立面，死潜伏在我们的生之中。”这句话结合着整本书来看很奇怪，直子的死并不是渡边选择绿子的原因，而是因为直子的死让渡边更好的明白了需要好好地爱着绿子（感觉有些奇怪）。引申到我们身上，年少时的执念并不是让你用来和已有情人对比的，相反的，正是经过了那种执念才更能体会到要好好爱着已有的幸福。直子的死，一定程度上其实也是反映了我们应该要学会放下心中的执念，把握当下已有的幸福。</p><p>那为什么直子还是会和渡边做爱呢？一方面可能是因为日本的性文化我们确实难以理解吧，不过更重要的我想其实是因为直子也有想过要从木月死去的创伤中走出来，她也挣扎过，努力过。只是她失败了。从之前的直子与渡边的街头暴走，到直子进入那个疗养院，再后来病情不断恶化直至自杀，个人认为其实也反映了直子内心世界的挣扎。我认为她挣扎的原因是因为她挣扎努力的方式就错了，她错把渡边当成第二个木月，与他做爱，甚至赤裸着给他看，可她终究没有意识到渡边只是渡边，不会也不可能是她心爱的那个木月。于是，在明白了这些道理之后的直子，终于决定要追随木月的脚步，与这个世界说再见。</p><p><strong>初美</strong></p><p>初美是一个相处了会让人特别有好感的女孩。虽然外表普普通通，但她“娴静、理智、幽默、善良，穿着也总是那么华贵而高雅。”以至于对渡边来说“东大也罢外务省也罢，唯一羡慕的，就是你有一位初美小姐那样完美的恋人。”其实在读本书的时候，我也在思考，渡边对初美究竟抱着一种什么样的情感。说渡边喜欢初美吧，感觉不像，说不喜欢吧，字里行间又能表达出因为“永泽有一个地地道道的女朋友，名叫初美。”而羡慕不已。这对渡边来说是一个很矛盾的人，我个人倾向于渡边其实是喜欢初美的，只是这种喜欢存放在渡边内心的深处以至于他自己都没有发现。在渡边心中，初美是那样的完美，完美到自己只能远远的看着而不会心生情谊。</p><p>绿子梦想中的爱情是：如果她想吃饼，男人就跑几条街去给她买来，然后她说又不想吃了，那个男人会十分抱歉又问她想吃什么，满头汗地再跑去给她买。绿子想找的是个爱她的人，然后好好爱他回报他。可初美与绿子截然相反，初美的梦想是：“结了婚，每晚给心上人抱在怀里，生儿育女，就足够了，别无他求。我所追求的只是这个。” 初美想找的是个她爱的人，然后和他在一起生活。不然也不会接受和永泽这样的男生在一起三年之久了。她是真心的爱着永泽的，因为她愿意相信人是会变的，她坚信只要自己等下去，永泽就一定会改变，但永泽偏偏就是“亲切热情倒是不假，但就是不能打心眼里爱上某个人，而总是有个地方保持清醒，并且有一种饥渴感，如此而已”。</p><p>如果初美不是爱永泽就好了，如果她后来结婚遇到一个她爱的人就好了，如果她哪怕少爱一点，少执着一点，少迂腐一点，混日子过下去就好了，如果她能学永泽自给自足一点，而不是一味等待，如果……</p><p><strong>玲子</strong></p><p>这个人物是最让我感到奇怪的，对于本书，我也看了一些读书笔记，但是几乎写的都是直子&amp;绿子，描述玲子的实属不多。而且我也不是很能理解这个人物的出现是为了什么，以至于最后一章玲子和渡边仿佛是为了完成任务一样做爱更是让我莫名其妙，兴许是因为自己境界还不够高吧。对于玲子，网上有人说因为玲子和直子长期生活在一起，所以最后来看望渡边君的时候是以玲子的心态来的，算是代表直子和渡边君的一个告别。呃呃呃，反正我是没法理解的，对于她，我就写到这吧，如果以后有新的理解了，再来更新。</p><hr><p>总的来说，这是一本非常好的书，书中很多句子的语言也非常优美，书中的人物在现实中也会多多少少的映射在我们的身上，豆瓣上有过一个问题，对于直子&amp;绿子，哪个才是你的选择。其实这个问题就是红白玫瑰，于我而言，如果非要选的话可能是绿子吧，毕竟那样的女孩，会让人有活力和生存下去的意志。</p><p>当然，如果未来的伴侣既有绿子的活泼可爱洒脱又有直子的安静温柔岂不美哉。（哈哈哈，我在想peach😂）</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少年维特的烦恼——一个中二少年的烦恼？</title>
      <link href="p/b392.html"/>
      <url>p/b392.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img3.doubanio.com/view/subject/l/public/s29744095.jpg"></p><p>这本书是🐔哥送的， 是一本很薄的书， 讲的故事内容也很简单， 就是主人公维特来到了一个小镇， 在一次舞会上他认识了一个叫绿蒂的少女， 她的一颦一笑、 一举一动都让维特倾倒； 绿蒂也喜欢他， 却不能予以爱的回报， 她已与维特的好友订婚。 维特陷入了尴尬和痛苦， 他毅然离开此地， 力图从事业上得到解脱， 有所成就， 然而鄙陋的环境、 污浊的人际关系、 压抑个性窒息自由的现存秩序， 都使他无法忍受， 当他怀才不遇地重返绿蒂身边时， 发现绿蒂已结婚， 决定以死殉情， 于是用一支手枪结束了自己的生命（上述内容摘自豆瓣的内容简介）。 </p><p>说实话， 我刚读完这本书的感觉就是这本书相当中二， 前半本的抒情真的让我感觉十分尴尬， 就跟小时候写作文老师让我描写一个人时的感觉一样， 类似——啊！ 她的眼睛多单纯啊！ 她真的好迷人啊！ 大自然多美啊！ 之类的。 后半本干脆就是直接在发牢骚了， 之前查资料的时候有说过拿破仑也曾看过这本书， 我真的无法想象他当时看这本书的心情。 </p><p>我看豆瓣的评论时有人说这是西式的浪漫与伤感， 可能真的是因为我的文学素养不够吧， 我看见的不过是一个发春的中二少年无限的YY和碎碎念。 诚然主人公维特那种从心中涌动出的纯真的感情我们很多人都有过， 可早已不纯真的我们很难再有青春时期的那种细腻， 而且书中所描述的故事太过完美主义， 太过倾向纯洁， 兴许放在当时那个自杀是一种反宗教行为的时代， 会在有着巨大的影响力， 但流传至今后则明显是过誉太多了。 </p><p>不过我也不是完全否定这本书， 有些字句个人感觉还是不错的， 这里做了一些摘抄。 </p><ol><li>这儿的人怎么样, 我只能回答： 跟到处一样！ 人类嘛都是一个模子铸出来的。 多数人为了生活, 不得不忙忙碌碌, 花去大部分时间; 剩下一点点余暇却使他们犯起愁来, 非想方设法打发掉不可。 这就是人类的命运啊！ </li><li>人从某些探索结果中得到的自慰， 其实只是一种梦幻者的怠惰， 正如一个囚居斗室的人， 把四面墙壁统统画上五彩缤纷的形象与光辉灿烂的景物一般。 </li><li>我们人呵, 常常抱怨好目子如此少， 坏目子如此多依我想来， 这种抱怨多半都没有道理。 只要我们总是心胸开阔, 享受上每天赏赐给我们的欢乐, 那么, 我们也会有足够的力量承担一且到来的痛苦。 </li><li>乖僻就跟惰性一样, 要知道它本来就是一种情性呵。 我们生来都是有此惰性的, 可是, 只要我们能有一次鼓起勇气克服了它, 接下去便会顺顺当当, 并在活动中获得真正的愉快。 </li><li>世界上的一切事情, 说穿了全都无聊。 一个人要是没有热情， 没有需要， 仅仅为了他人的缘故去逐利追名， 苦苦折腾, 这个人便是傻瓜。 </li><li>人之幸福， 全在于心之幸福。 </li><li>我们生来就爱拿自己和其他人反反复复比较。 所以， 我们是幸福或是不幸， 全取决于我们与之相比的是些什么人。 所以， 最大最大的危险， 就莫过于孤身独处了。 我们的脑子生就是朝上想的， 加之受到诗里的幻境的激发， 便常常臆造出一些地位无比优越于我们的人来， 好像他们个个都比自己杰出， 个个都比自己完美。 而这似乎理所当然。 </li><li>世间最纯粹、 最暖人胸怀的乐事， 恐怕莫过于看见一颗伟大的心灵对自己开诚相见吧。 </li><li>以自己去衡量别人是很愚蠢的。 </li><li>我们这些有教养的人， 实际上是被教养成了一塌糊涂的人！ </li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我喜欢生命本来的样子——一本高级鸡汤书</title>
      <link href="p/5219.html"/>
      <url>p/5219.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g58ndg3xg7j305807k0so.jpg" alt="我喜欢生命本来的样子"></p><p>这本书其实放在书架里已经很久了，但是直到最近才打开这本书阅读，当时购买的时候看评论称这本书是年轻人必读的一本书，再加上当时当当网做活动便入手了。高中时就听过周国平的名字，奈何当时对语文这一学科毫无兴趣，这个人是谁对我来说也无所谓。如今，大学四年已经结束，趁着暑假空闲就打开看了看，才后悔没能早些阅读。</p><p>本书刚开始就提到人生有三个基本的觉醒，分别是生命的觉醒，自我的觉醒和灵魂的觉醒。其实生命的觉醒我觉得很好理解，就是要意识到自己是生命，周围的花草树木、鸟兽鱼虫也都是生命，我们需要对那些同为自然界的生命抱有敬畏之心。</p><p>本书在阐述自我的觉醒的时候，提出了很多读起来非常有道理的观点，以至于有一种这是一本高级鸡汤书的错觉。想要实现自我觉醒，我们需要成为真正的自己，那怎样才算成为了自己？本书给出了两个观点：一是在人生的态度上自己做主，二是在事业的选择上自己做主。说实话，如果现实生活中有这么一个人告诉你你要在人生态度上自己做主，要在事业选择上自己做主，你一定会觉得这个人太不真实了。因为有些人光是活着就已经很不容易了，他这种居高临下的姿态确实有些让人觉得不够真实。</p><p>可是为什么我还是比较喜欢这本书呢？</p><p>因为生活中那些光是活着就不容易的年轻人太少太少了，大多数都还是像我一样普普通通、平平凡凡的人。我们这个时代的年轻人（90后）有一个特点，就是小时候经历着不太富裕的日子，等到长大了生活又被各种考试、学习所填充，以至于精神生活普遍很平庸，主要体现在：一、信仰生活的失落；二、情感生活的缩减；三、文化生活的粗鄙。</p><p>但并不代表我们这个时代的年轻人会就此陨落了。相反，我们已经开始逐渐接管这个社会，我们有梦想、我们有冲劲，我们渴望成功，渴望在这个时代建功立业。如果说成功是青春的一个梦，那么追求即是青春本身，是一个人心灵年轻的最好证明。有人说17、18岁是一个人最好的年华，可我们那个时候在学校准备高考，白白错过了最好的青春。但我不这么认为，一个人的青春是在他不再追求的那一天结束的。</p><p>当然，话是这么说不错，周围懈怠的人也还是不在少数，个人认为原因有二，一是不知道自己要什么，二是没有选好合适的追求。</p><p>人生在世，必须知道自己要什么。一是应该要什么。二是能够要什么。这是一个逐渐清晰起来的过程。如果不知道自己到底要什么，那至少必须知道自己不要什么。</p><p>其次是追求的选择，能被失败阻止的追求是一种软弱的追求，它暴露了力量的有限。能被成功阻止的追求是一种浅薄的追求，它证明了目标的有限。</p><p>现在回过头看我的大学四年，感触颇深。从大二开始，我便开始不断奋斗，参加比赛、培养各种技能、冲击名校的保研，以至于我读到这里的时候暗自庆幸原来自己和作者站在了一个高度上，直到我看到了下面一句话：</p><p>人生真正重要的不是目标，而是状态。</p><p>我停了下来想了想，回想过去的几年，自己究竟是喜欢追求还是喜欢那个为了目标奋斗的自己呢？我想应该是后者吧。那时的我可以为了一个功能修改到深夜，可以为了一个动画不断优化，可以为了保研承受各种压力。兴许目标的价值真的就是为了让人生有一个更好的状态吧。</p><p>当然啊，个人认为追求某个目标的时候一定要是真心喜欢的，我们无论做什么事，如果只是因为喜欢这件事本身，做事的过程就是享受，如果是把这件事当作达到某个功利目的的手段，做事的过程就会是痛苦。毕竟“享受”是人生的天经地义。</p><p>上面都是在谈一些个人目标、奋斗之类的，但是我们也都知道生活不只是有奋斗这一个主题的。还有爱情、婚姻、家庭等，只是因为自己对于这个主题有些小小的感悟便记录下来。</p><p>本书还谈了谈对于两性关系、婚姻、为人处事等很多方面，虽然有高级鸡汤的嫌疑（以至于有些篇章我都没有完整读完），但是对于处在我们这个年龄段的年轻人来说多少还是有些启发的，值得暑期好好阅读一下。</p><p>最后放一句我很喜欢的话作为结尾：<br>活在世上，最重要的事就是活出你自己的特色和滋味来。你的人生是否有意义，衡量的标准不是外在的成功，而是你对人生意义的独特领悟和坚守，从而使你的自我闪放出个性的光华。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小王子——爱与责任</title>
      <link href="p/354f.html"/>
      <url>p/354f.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/bmiddle/006tNc79ly1g4mv8vei9yj30u017steu.jpg"></p><p>因为想锻炼自己的英文能力，所以开始尝试阅读英文书，第一本便是这本小王子，其实选它的原因很简单，一是自己之前读过，大致情节都还记得些；二是因为小王子里面的词汇比较简单，阅读起来的压力会小一些。</p><p>第一次看的时候觉得内容蛮无厘头的，可能是因为自己当初太年轻，经历的事情太少了吧，再读这本书的时候，才渐渐明白小王子、玫瑰和狐狸都扮演着什么角色。曾经我也很好奇为什么小王子明明已经来到了地球，却仍然心心念他那个星球上的玫瑰。直到后来经历了和初恋分手，才渐渐明白，正因为小王子与玫瑰，彼此驯化，彼此需要，小王子和玫瑰对彼此来说才都是独一无二的，哪怕聪明如狐狸，也无法替代。</p><p>恋人该是如此，我与千千万万人中遇见你，本是沧海一粟，但正因为为你花过心思，付出真心，彼此陪伴，我们才变成彼此间心目中的独一无二。</p><p>扯的有点远了，整本书有很多金句，但是我最喜欢的是下面这句：</p><blockquote><p>What is a rite?</p><p>Those also are actions too often neglected. They are what make one day different from other days, one hour from other hours.</p></blockquote><p>仪式是什么？它就是使某一天与其他日子不同，使某一时刻与其他时刻不同。</p><p>生活还是多点仪式感的好，因为它代表你对生活的态度，这种态度，会让你活的更高级。简单说，就是会让你过的更幸福。</p><p>就像王小波说的：一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。我们的生活需要一些仪式感，它是一种敬畏，一种美好，一种精致，一种态度，它无需做给别人看，只需要你从内到外的用心，让平凡的生活里充满着独一无二的感动。</p><p>希望自己可以以自己喜欢的方式过一生，不愧对别人，亦不辜负自己。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届互联网架构峰会心得</title>
      <link href="p/102.html"/>
      <url>p/102.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzpyt13pqjj30k00b4af2.jpg"></p><p>前两天参加了在南京举办的第二届互联网架构峰会，因为个人能力有限，只听了两场和AI有关的，在这里做个简单的总结记录下此次峰会的心得。</p><h3 id="第一场-企业级人工智能平台化之路"><a href="#第一场-企业级人工智能平台化之路" class="headerlink" title="第一场 企业级人工智能平台化之路"></a>第一场 企业级人工智能平台化之路</h3><h5 id="在当前企业中实施人工智能的主要障碍有以下几点："><a href="#在当前企业中实施人工智能的主要障碍有以下几点：" class="headerlink" title="在当前企业中实施人工智能的主要障碍有以下几点："></a>在当前企业中实施人工智能的主要障碍有以下几点：</h5><ol><li>交叉型人才需求大，但是供应少</li></ol><blockquote><p>个人认为就是会做ai的大多数业务能力都不是很强，企业需要那种可以将ai落地到实际项目中的人。</p></blockquote><a id="more"></a><ol start="2"><li>数据整合但是和业务没有联系起来；数据量大但标记困难；</li></ol><blockquote><p>在实际业务操作过程中产生的数据并不适合直接用来作为机器学习的样本。监督学习是需要对样本数据进行标记的，虽然在业务操作过程中会产生大量的数据，但是却并没有预见性的将这些数据进行标记，所以当数据累积到一定程度后，标记也会变得越来越复杂。</p></blockquote><ol start="3"><li>企业业务分析过程难以标准化</li></ol><blockquote><p>目前对于AI在企业业务的落地上并没有一套标准化的流程，每家企业都有各自的解决方案。</p></blockquote><ol start="4"><li>业务场景复杂，客户需求很难在平台上一站式实现</li></ol><blockquote><p>简单来说就是现在的AI太笨了，客户的需求还不能通过AI满足。</p></blockquote><h5 id="人工智能开发者的工作场景"><a href="#人工智能开发者的工作场景" class="headerlink" title="人工智能开发者的工作场景"></a>人工智能开发者的工作场景</h5><ol><li><p>小团队或者初创公司</p><ul><li><p>收集、清理、建模、部署</p></li><li><p>scratch from code，端到端完成一切</p></li></ul></li><li><p>中型公司</p><ul><li><p>机器学习研究人员与业务专家合作</p></li><li><p>使用某个平台帮助训练海量模型</p></li></ul></li><li><p>大型企业</p><ul><li><p>构建自己的机器学习平台</p></li><li><p>抽象各业务单元的共性需求，在标准的开源模型和架构上开发支撑业务的平台</p></li><li><p>大规模推进人工智能技术嵌入产品</p></li></ul></li></ol><blockquote><p>因为公司体量的问题，小公司没有足够的人力和物力去构建自己的机器学习的平台，所以只能将精力放到收集/清理数据上，然后利用数据完成建模并部署到大型企业的机器学习平台上。而中型公司有一定的数据量和人力，此时为了自身数据的安全性等方面的问题，除了训练模型可能会放在平台上，尽可能的在企业内部完成机器学习和业务的相关合作。而大型企业有足够的能力去搭建自己的机器学习平台甚至是开源机器学习的框架，比如Google的TensorFlow，百度的PaddlePaddle等，同时他们也会有相对成熟的人工智能的落地产品比如Google的<em>Google Assistant</em>，百度的小度等，他们需要引领整个时代的前进，因而对他们来说是需要大规模的推广自己的人工智能的产品，而不是单纯的人工智能和业务的结合。</p></blockquote><h5 id="企业内部落地人工智能产品的关键步骤"><a href="#企业内部落地人工智能产品的关键步骤" class="headerlink" title="企业内部落地人工智能产品的关键步骤"></a>企业内部落地人工智能产品的关键步骤</h5><ol><li><p>确定商业价值的应用场景</p></li><li><p>准备数据，关注数据的完备性和可用性</p><ul><li><p>关键业务数据缺失</p></li><li><p>基础数据完整但组织内存在信息孤岛</p></li><li><p>数据整合但是和业务无法联系</p></li><li><p>数据驱动的决策，但是无法快速响应</p></li><li><p>数据驱动，实时响应业务的变化</p></li></ul></li><li><p>快速迭代验证和实施</p></li></ol><h5 id="人工智能是如何融入产品的研发流程的？"><a href="#人工智能是如何融入产品的研发流程的？" class="headerlink" title="人工智能是如何融入产品的研发流程的？"></a>人工智能是如何融入产品的研发流程的？</h5><ul><li><p>迭代开发</p><ul><li><p>人工智能更多的时候是融入一个大产品中，减少成本，改善用户体验或者代替人力。</p></li><li><p>结合具体业务专家迭代算法，并逐步进行标准化落实到平台内。</p></li><li><p>人工智能的模型不是一次就能成型的，需要根据数据的不断变化，模型也需要改变。</p></li><li><p>在没有多面手的情况下，业务专家和开发人员更要密切协作。</p></li><li><p>MVP 开发节奏依然可用。从开始就构建出端到端的业务流程非常重要。</p></li></ul></li><li><p>以云平台的形式提供企业内部服务</p><ul><li><p>降低用户使用的成本</p></li><li><p>便于沟通和分享</p></li></ul></li><li><p>产品经理和工程师的沟通方式改变</p></li></ul><h5 id="机器学习开发流程和支撑平台"><a href="#机器学习开发流程和支撑平台" class="headerlink" title="机器学习开发流程和支撑平台"></a>机器学习开发流程和支撑平台</h5><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ce0a414c347a2898.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><h3 id="第二场-基于移动端的tensorflow相关技术进展"><a href="#第二场-基于移动端的tensorflow相关技术进展" class="headerlink" title="第二场 基于移动端的tensorflow相关技术进展"></a>第二场 基于移动端的tensorflow相关技术进展</h3><p>听这场主要是因为自己最近在学习tensorflow，再者就是想见识下Google大佬，其实干货不多，更多的就是介绍了下tensorflow目前的发展状况，</p><h5 id="TensorFlow-现状"><a href="#TensorFlow-现状" class="headerlink" title="TensorFlow 现状"></a>TensorFlow 现状</h5><ol><li>前端有<a href="https://js.tensorflow.org/">TensorFlow.js</a></li></ol><blockquote><p>TensorFlow.js是一个利用 WebGL 来进行加速的机器学习类库，它基于浏览器，提供了高层次的 JavaScript API 接口。</p></blockquote><ol start="2"><li>移动端有 <a href="https://www.tensorflow.org/lite/">TensorFlow Lite</a></li></ol><blockquote><p>Google 表示 Lite 版本 TensorFlow 是 TensorFlow Mobile 的一个延伸版本。此前，通过TensorFlow Mobile API，TensorFlow已经支持手机上的模型嵌入式部署。TensorFlow Lite应该被视为TensorFlow Mobile的升级版。有了TensorFlow Lite，应用开发者可以在移动设备上部署人工智能。</p></blockquote><ol start="3"><li>同时支持swift语言使用TensorFlow</li></ol><blockquote><p>使用swift运行TensorFlow——<a href="https://www.tensorflow.org/swift/api_docs/">Swift for TensorFlow</a></p></blockquote><ol start="4"><li>开源的TensorFlow资源库——<a href="https://tfhub.dev/">TensorFlow Hub</a></li></ol><h5 id="TensorFlow-Lite的架构"><a href="#TensorFlow-Lite的架构" class="headerlink" title="TensorFlow Lite的架构"></a>TensorFlow Lite的架构</h5><p><img src="http://upload-images.jianshu.io/upload_images/5666077-30daf57befb2682f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>组件包括：</p><ul><li><p>TensorFlow 模型（TensorFlow Model）：训练后的 TensorFlow 模型，保存在磁盘中。</p></li><li><p>TensorFlow Lite 转换器（TensorFlow Lite Converter）：该程序将模型转换成 TensorFlow Lite 文件格式。</p></li><li><p>TensorFlow Lite 模型文件（TensorFlow Lite Model File）：该格式基于 FlatBuffers，经过优化以适应最大速度和最小规模。</p></li></ul><p>然后将 TensorFlow Lite 模型文件部署到移动 App 中：</p><ul><li><p>Java API：安卓设备上适用于 C++ API 的便利封装。</p></li><li><p>C++ API：加载 TensorFlow Lite 模型文件，启动编译器。安卓和 iOS 设备上均有同样的库。</p></li><li><p>编译器（Interpreter）：使用运算符执行模型。解释器支持选择性加载运算符；没有运算符时，编译器只有 70KB，加载所有运算符后，编译器为 300KB。这比 TensorFlow Mobile（具备一整套运算符）的 1.5M 要小得多。</p></li><li><p>在选择的安卓设备上，编译器将使用安卓神经网络 API 进行硬件加速，或者在无可用 API 的情况下默认执行 CPU。</p></li></ul><p>开发者还使用 C++ API 实现自定义 kernel，它可被解释器使用。</p><h5 id="Google-移动端硬件最新进展"><a href="#Google-移动端硬件最新进展" class="headerlink" title="Google 移动端硬件最新进展"></a>Google 移动端硬件最新进展</h5><ul><li><p>2018.7.24~26 日，Google Cloud Next’18 上公布了 Edge TPU</p></li><li><p>2025 年，数据总量将超过 40 万亿千兆字节。</p></li><li><p>智能的实时决策，即所谓的“边缘”。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5666077-8d1f558d1f812213.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><blockquote><p>目前来看，Edge TPU的尺寸约为1美分硬币的1/8大小，它可以在较小的物理尺寸以及功耗范围内提供不错的性能（目前具体性能指标不清楚，官方称可以在高清分辨率的视频上以每秒30帧的速度，在每帧上同时执行多个最先进的AI模型），支持PCIe以及USB接口。</p><p>Edge TPU优势在于可以加速设备上的机器学习推理，或者也可以与Google Cloud配对以创建完整的云端到边缘机器学习堆栈。在任一配置中，Edge TPU通过直接在设备本地处理数据，这样不仅保护隐私，而且消除对持久网络连接的需要，减少延迟，允许使用更少的功率和性能。</p></blockquote><h5 id="EDGE-TPU的功能"><a href="#EDGE-TPU的功能" class="headerlink" title="EDGE TPU的功能"></a>EDGE TPU的功能</h5><table><thead><tr><th></th><th>边缘（设备/节点，网关，服务器）</th><th>谷歌云</th></tr></thead><tbody><tr><td>任务</td><td>ML推理</td><td>ML训练和推理</td></tr><tr><td>软件，服务</td><td>云物联网边缘，Android事物</td><td>Cloud ML Engine，Kubernetes Engine，计算引擎，Cloud IoT Core</td></tr><tr><td>ML框架</td><td>TensorFlow Lite，NN API</td><td>TensorFlow，scikit-learn,XGBoost,Keras</td></tr><tr><td>硬件加速器</td><td>边缘TPU，GPU，CPU</td><td>云TPU，GPU和TPU</td></tr></tbody></table><table><thead><tr><th>类型</th><th>推理加速器</th></tr></thead><tbody><tr><td>性能示例</td><td>EDGE TPU是用户能够以高效率的方式在高分辨率视频上以每秒30帧的速度同时执行多帧最先进的AI模型</td></tr><tr><td>NUMERICS</td><td>Int8，Int16</td></tr><tr><td>IO接口</td><td>PCIe，USB</td></tr></tbody></table><h5 id="CLOUD-IOT-EDGE"><a href="#CLOUD-IOT-EDGE" class="headerlink" title="CLOUD IOT EDGE"></a>CLOUD IOT EDGE</h5><ul><li><p>提高运营可靠性。</p></li><li><p>更快的实时预测</p></li><li><p>提高设备和数据的安全性</p></li></ul><p>其实这里我也记不太清了，而且之前也不清楚是干啥的就google了一下，<code>Deliver Google AI capabilities at the edge.</code>意识是说在边缘设备上使用Google的AI能力。</p><blockquote><p>Cloud IoT Edge extends Google Cloud’s powerful data processing and machine learning to billions of edge devices, such as robotic arms, wind turbines, and oil rigs, so they can act on the data from their sensors in real time and predict outcomes locally. Cloud IoT Edge can run on Linux-based operating systems. Cloud IoT Edge is composed of two runtime components, Edge Connect and Edge ML, and also takes advantage of Google’s purpose-built hardware accelerator ASIC chip, Edge TPUTM.</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ba29c8ef1da0bbb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>这才是一家由技术，有理想，有追求，有责任心的公司该做的事情啊！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于时间关系和自身能力的因素，当时在会场只听了两场半，虽然时间并没有多久，但是大致让我了解到了一些目前有关AI领域的一些企业的现状，对自身的学习方向也有了一些指引，推荐大家如果有机会可以多参加这样的技术交流会。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生死看淡，不服就干</title>
      <link href="p/a824.html"/>
      <url>p/a824.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>其实这是一篇水文，虽然知道我的公众号没什么人，我的文笔也很烂，但是发出来就只是想凑下公众号的活跃度顺便证明自己还活的挺好的。</p></blockquote><h3 id="生死看淡，不服就干"><a href="#生死看淡，不服就干" class="headerlink" title="生死看淡，不服就干"></a>生死看淡，不服就干</h3><p>我周围的人可能比较清楚，我对华为一向都是路人态度，对他的一些行为做法也是持观望态度的（甚至时不时还黑一下）。然而就在今天，一则消息刷新了我对华为的看法：今天下午，华为正式起诉美国政府。针对美国《2019财年国防授权法》第889条的合宪性，请求法院判定这一针对华为的销售限制条款违宪，并判令永久禁止该限制条款的实施。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0undcual4j314x0n2nhj.jpg"></p><p>当时我在地铁上刷到这个新闻的时候，脑海里想到的第一句话竟然是雷总的那句“生死看淡，不服就干”。细细数来，真替雷总感到可惜，几次自己造出来的热点被别人抢掉了😂</p><p>我不想过多谈论华为的这次诉讼，不过个人来看，不管这次华为的诉讼结果到底怎样，只要这个态度摆了出来，对华为来说就已经有正面影响了。至于我们这些韭菜还是不要跟着起哄，安心支持国产就好，剩下的事，华为公司自然会好好处理的。</p><blockquote><p>接下来是这几天的反思文，文笔很烂，而且各种负能量，不想看的就过了吧。</p></blockquote><h3 id="你焦灼只是因为你菜"><a href="#你焦灼只是因为你菜" class="headerlink" title="你焦灼只是因为你菜"></a>你焦灼只是因为你菜</h3><p>公众号已经有几天没更新了（上一篇虽是周一发的，但很早就弄好了），我的QQ好友应该比较清楚（因为导师也逛朋友圈，所以没敢在朋友圈发牢骚），这几天我的状态很差，几近崩溃。在别人眼中我是一个很乐观的人，我自己也是这么认为的。可自从我3月1号去了南大之后，各种焦灼涌上心头。</p><p>导师很早就叫过我，前前后后估计有三四次了，我总是推脱。后来老师说就是来<strong>熟悉下环境</strong>的，而且觉得总是推脱不好，便答应3月1号过去。本想着提前去实验室能多学一些东西，哪怕是干活，只要能学到东西，心里也是舒服的。可曾想，去的第一天就被拉去接手项目，一个后台项目。也不怕被笑话，我本科期间接触最多的是安卓，后台主要是依赖我们组里的两个大佬。虽说对前后台交互有所了解，但真要仔细追究的话也只是一知半解。而且保研之后的我基本上就没做过项目（纯粹是因为自己贪图享乐），觉得只要保研结束我的任务就完成了。所以当看到代码的时候我一脸茫然，不知所措，我开始质疑自己，质疑自己来到这的目的是什么，质疑自己当初是为何要读研？（当然之后还发生了很多事情）</p><p>说实话，这几天我很焦灼，前所未有的焦灼。不仅仅是因为宿舍环境不好，更多的是内心的冲击。为什么这些任务是我来做？明明我只是想来这熟悉一下环境的，为何要让我承受这么多？</p><h3 id="欲戴王冠，必承其重"><a href="#欲戴王冠，必承其重" class="headerlink" title="欲戴王冠，必承其重"></a>欲戴王冠，必承其重</h3><p>今早起来刷到了公众号「也谈钱」的一片文章，说的是冥想，于是今早趁着没人我在宿舍也试了试这个方法。我想了想这几天的经历，一是老师给的任务的确是挺重的（代码都不给熟悉的时间就直接让上手做了）。二是同为保研的同学扮猪吃老虎，明明他们什么都会，却还是在说自己什么都不会。三是因为终于发觉自己的实力还远远不够却又觉得没有时间弥补的那种无力感。很多人都叫我大佬，叫着叫着我也真的以为自己是大佬了，这几天才知道，原来自己真的是渣渣。都说“欲戴王冠，必承其重”，按理说，既然都来到这了，我就应该有来到这的实力。可是直到近期我才发现，我的实力还远远不够。我现在所有的焦虑仅仅是因为自己太<strong>菜</strong>。</p><h3 id="所有的硬气都来自于自身实力的强大"><a href="#所有的硬气都来自于自身实力的强大" class="headerlink" title="所有的硬气都来自于自身实力的强大"></a>所有的硬气都来自于自身实力的强大</h3><p>突然有了标题的这个想法也是因为下午看到了华为的那条新闻，如果不是对自己的产品有着十足的把握，又怎么会如此硬气的对美国政府提起诉讼？再想想自己，如果不是因为潜意识中发觉自己能力不够又怎么会如此焦灼？所有的硬气都来自于自身实力的强大。如果我真的厉害到可以应付那些工作，我又怎么会有时间在这困惑而不是安心编码呢？所以我告诉我自己接下来我要做的就是放下自己的沾沾自喜，沉下心来，不断的修炼。只有自己实力强大了，才能无惧任何挑战！</p><p>就像华为的新闻发布会上，演讲人手持Mate X发布战斗檄文，最好的产品就是我们的信心和底气！</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0unupu3jag309w05k4lx.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消失的这几个月，我做了些什么？</title>
      <link href="p/c8ed.html"/>
      <url>p/c8ed.html</url>
      
        <content type="html"><![CDATA[<p>一转眼 2020 年都已经过去了四分之一，大家是不是就光忙着见证历史了？</p><p>因为疫情，寒假放完变暑假，钉钉慕课齐召唤，高考农历六月半，说实话，如果不是亲身经历，你都不会相信瑞幸股票能跌大半，美股竟能四熔断，查尔斯王子等来了新冠，就连各国企业倒闭都变得连贯。</p><p>作为一个韭菜，既然没能力参与到这些事中，那自然是只能作为历史的见证者了。</p><p>跑题了跑题了，我们言归正传，这段期间虽然见证了很多历史性的时刻，但作为一个“精致的利己主义者”，过好自己的生活才是最重要的，距离上一篇文章的发布已经过去了三个月，那我这三个月到底经历了些什么呢？</p><h3 id="报复性长肉-减肥"><a href="#报复性长肉-减肥" class="headerlink" title="报复性长肉+减肥"></a>报复性长肉+减肥</h3><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhs3n53w9j30fa0f8t9e.jpg" style="zoom:50%;" /><p>这年一过完，既不能出门，也没啥消遣的，再加上那段期间心情比较低落，就选择了暴饮暴食，其后果就是体重飙升到 160，去年减肥所做的努力统统付诸东流，好在最后通过控制饮食+keep 运动又重新回到了正常体重。</p><h3 id="争取变成老司机"><a href="#争取变成老司机" class="headerlink" title="争取变成老司机"></a>争取变成老司机</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhs04l2ixg306o05v0x1.gif"></p><p>另外，这段时间我学会了一项新技能，开车。虽然去年就已经拿到了驾照，但是一直没敢正式上路开过，好在这次疫情给了我机会，由于我所在的小区附近没出现病例，也没有非常严格的限制我们的进出，所以那段期间每天晚上都会出门练车，既可以体验高架/隧道等真实路况，也不用担心路上有太多的车会担惊受怕，而且期间呆在车里也不会和陌生人有接触，不知道那些拿了驾照但没怎么上过路的小伙伴们有没有把握住这次的机会呢？</p><h3 id="剪视频"><a href="#剪视频" class="headerlink" title="剪视频"></a>剪视频</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhs5aggfyj30690693yj.jpg"></p><p>其次就是视频剪辑，机缘巧合，我体验了号称 Mac 下最好用的视频剪辑软件 Final Cut Pro X，体验了几天之后，我觉得这个称号它当之无愧，只能说相见恨晚。至于为什么突然想起来学视频剪辑，那这就要从一只蝙蝠说起了。今年因为疫情的原因，各个视频平台大火，其中最突出的是我想应该就是抖音和 b 站了，前不久 b 站迎来了 BV 时代，而且就在昨天，b 站第一位千万 up 主诞生，这次疫情让人看到视频这一媒介的潜力，以后人们发视频可能就会像前几年我们发 qq 空间那样频繁（这么一说突然好有年代感），所以在这样的一个时代，又有什么理由不去尝试下这些新鲜事物呢？如果可以，我也希望自己的视频可以大火，不过这些都是后话了。</p><h3 id="找实习"><a href="#找实习" class="headerlink" title="找实习"></a>找实习</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdhs22cznqj306v07b3yq.jpg"></p><p>其实这几个月我的大头任务就是找到一份暑期实习，尤其在今年这个环境下找到一份心仪的工作实在是太难太难了，好在自己即将上岸，我在准备期间也发生了很多有趣的事情，这里就先点到为止，之后准备写篇文章详细说下这部分内容。</p><h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p>最后就是关于公众号的问题了，前不久我把公众号改名为「梁注」了（不过头像还没想好换成啥），但是一直没有推送新的文章，许久不更一方面是因为太忙了，另一方面也确实是因为自己实在没有心情，这里给每个关注我的读者们道个歉，最近因为忙着找实习，每天都处于焦虑之中，只能靠着上网课学视频剪辑来缓解一些焦虑，好在找实习的进程已经进入尾声，接下来一段时间我准备开一个新的系列，名字暂定「跟我来面试」，这个系列我准备收集一些我身边同学朋友春招/暑期实习的面试经历和经验，当然也欢迎读者们投稿。另外我还想开一个系列，主要用来讲解一些面试中常问的知识点，偏向技术博文，不过这个系列和我的好基友『寒食君』的一个系列冲突了，所以后期可能会以转载的方式呈现在各位面前。还望各位观众老爷们支持。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果要用一个词概括我这几个月做的事，那应该就是<strong>『沉淀』</strong>了，沉淀了几个月，学了一些新的技能，也想开了很多事情，眼下疫情也快结束了，生活也要步入正轨了，你们准备好迎接 2020 剩下的四分之三了吗？</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>此生无悔入漫威</title>
      <link href="p/84ea.html"/>
      <url>p/84ea.html</url>
      
        <content type="html"><![CDATA[<p>​    <img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2dkwd6mzkj30u00x1wl1.jpg"></p><p>​    ★★★★★</p><p>​    漫漫英雄路，终有落幕时。《复仇者联盟4》，我给五星好评！</p><p>​    今天凌晨去看了复仇者联盟4的首映，看完我只想说，漫威，真有你的。作为一个90后，我起初并不懂为什么30年前的星战系列会如此火爆；也并不懂10多年前的指环王为什么被那么多人说堪称史诗，如今看完这部长达3小时的终局之战，我才明白了十年一役所承载的份量。</p><p>​    我第一次接触漫威还是在小学，那个时候每天中午回家就是打开中央少儿看《蜘蛛侠》的动画，就是下面这个。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2dl43x5cuj31860e0qdl.jpg"></p><p>​    当时我也不知道什么是漫威，也不知道他是国外的一个超级英雄，只觉得他好帅。然后后来出了超凡蜘蛛侠的动画，再然后家里有了电脑就开始看蜘蛛侠的电影（那时候还是<a href="http://so.iqiyi.com/so/q_%E6%89%98%E6%AF%94%C2%B7%E9%A9%AC%E5%A5%8E%E5%B0%94">托比·马奎尔</a>的三部曲）。也是那时我才知道原来蜘蛛侠的背后是一个叫漫威的公司。因为高中的学业太过紧张，直到高考结束我才重新接触到漫威电影。</p><p>​    那时候看的电影是《复仇者联盟2奥创纪元》，初看我对里面的人物关系一窍不通，不懂他们集结的目的，不懂他们为何要战斗（当时纯粹是高考结束想放松才去看的）。所幸后来在油管上看到一个YouTuber，他叫超粒方，我当时关注他的时候他还是一个只有几百订阅的影评人，如今已经有过59w的订阅量了。通过他我开始了解漫威，开始了解美漫，也理解了什么是“everything is connected my ass”。</p><blockquote><p>超粒方在复仇者联盟3上映前做了一个叫《迈向无限之战》的系列解说，不会科学上网的可以在b站找到搬运，这是一个非常优秀的MCU解说系列，不仅可以帮你理清漫威的电影情节，更可以让你体会漫威电影独有的深度。</p></blockquote><p>​    回到复仇者联盟4，这部长达三个小时的终局之战，有笑有泪，惊喜连连！如果你对漫威电影和漫威的漫画非常熟悉的话你会发现从头到尾有无数数不清的梗（everything is connected my ass）。观影期间，一到关键人物的爆发，全场尖叫、鼓掌，那种狂欢、热血、共鸣，是一个漫威粉丝对漫威11年22部电影铺垫出来的情绪的彻底释放和宣泄。私以为这是最好的漫威电影，首映观毕，全场掌声雷动，肆意狂欢，多年来一切属于漫威的记忆犹如昨日重现，涌上心头。一句“I AM IRONMAN! ” 既是开始也是结束。谢谢钢铁侠，谢谢漫威给我们带来的欢笑、泪水和感动，谢谢你给我带来的最好的漫威电影以及爱你的3000遍！</p><p>​    此生无悔入漫威！</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2dktpwn2yj31mg0u07wk.jpg" alt="7d309cdda144ad34c5767db3dca20cf430ad85c9"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦回2009——QQ for Linux</title>
      <link href="p/74e.html"/>
      <url>p/74e.html</url>
      
        <content type="html"><![CDATA[<p>我时常会想起 10 年前的某个夏日午后，阳光灿烂，微风习习。那一年，我 12 岁。</p><p>那时候没有工作，没有烦恼，有新鲜空气可以呼吸，有假期可以期待。我喜欢的那个打着辫子的姑娘，就坐在我前面。而我刚刚考了全班第一，走上人生的巅峰。</p><p>想回到过去，你可能需要一个小叮当；但想体验过去，你只需要 <strong>QQ for Linux！</strong></p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8br5h9hfpj30po0pmq3w.jpg" style="zoom: 33%;" /><p>作为国内聊天软件的头头，QQ 陪伴了很多人的青春，在使用 MacOS 前，我很享受使用 Linux 的便捷体验，但QQ、微信这类软件只能通过 wine 在 Linux 上使用却又让我十分头疼，刚在 Windows 上打游戏，头一回被腾讯拉回 Linux。</p><p>10月24日，在这几乎没人关注的节日里，QQ 的程序员们给自己送上了一份大礼，QQ for Linux。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8britamtgj31jg0s8jxy.jpg"></p><p>并且支持x64、ARM64和MIPS64架构</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bp79p6t1j31lo0qwabm.jpg"></p><p>官网的安装帮助也十分详细，详情点击👉<a href="https://im.qq.com/linuxqq/download.html">https://im.qq.com/linuxqq/download.html</a></p><h2 id="安装体验"><a href="#安装体验" class="headerlink" title="安装体验"></a>安装体验</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bpcq0g1xj31qw0gojt1.jpg"></p><p>上图是官网给出的部分的安装建议，这里我选择 <strong>shell 脚本的通用安装方式</strong>，使用这种方式安装有一个好处就是不需要考虑不同Linux发行版的包结构问题，相比于<strong>繁琐的wine</strong>，我们只需要两条命令即可梦回2009。</p><p>我使用的是Ubuntu 18.04，centos/manjaro等其他Linux发行版的安装过程类似。</p><p><strong>首先先将安装脚本下载到本地</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bpir96jjj31cy0m4abv.jpg" alt="WX20191026-165703@2x"></p><p><strong>然后在该路径空白处右键打开 terminal</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bpjulho4j31cy0tkacm.jpg"></p><p><strong>修改脚本执行权限</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod -R 777 linuxqq_2.0.0-b1-1024_x86_64.sh</span><br></pre></td></tr></table></figure><p><strong>执行安装脚本</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./linuxqq_2.0.0-b1-1024_x86_64.sh</span><br></pre></td></tr></table></figure><blockquote><p>这里一定要以root用户进行操作，否则会无法安装。执行脚本的结果如下图所示。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bpqmna47j311i0ci415.jpg"></p><p>到这里我们就安装成功了，打开应用程序就可以看见熟悉的QQ了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bpspmyzrj31c00u01kx.jpg" alt="WX20191026-170805@2x"></p><p>相较于在Linux下使用wine来安装QQ，正规军QQ for Linux的安装过程简直过于简洁，只是当我打开这个程序的时候，一股浓浓的历史感扑面而来。</p><p>对比下QQ 2009 的UI，我这是穿越了🐎</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bqb18u8mj30r20r00va.jpg" alt="102617251877_0WX20191026-171401@2x" style="zoom:50%;" /><p>等我打开了聊天界面后</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bqi1nv9rj30je0xuwfu.jpg" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8bqvmxqc7j30tk0w8tdb.jpg" alt="541572082960_.pic" style="zoom:50%;" /><p>看到这个上古时代的UI，内心十分感慨，QQ for Liunx终于想起了他最重要的作用——<strong>传文件</strong>，相信之后手机和Linux系统互传文件就会方便很多了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>简单体验了下，因为我现在对 QQ 的依赖程度越来越小，QQ for Linux 基本满足了我对QQ的需要，除了界面有些复古外，和花里胡哨的PC版一比较，竟像是一股清流。虽然是诈尸更新，但能把老项目捡起来再次维护，总的来说还是值得鼓励。</p><p>我个人比较关注的是它是否打算继续维护下去，之前有传出华为开卖预搭载Deepin Linux的笔记本，不知道是不是这些国产厂商达成了某些交易，准备构建国产 Linux 软件生态了。如果确实有这方面的打算那就更好了，希望这并不是回光返照。</p><hr><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8br78mptij31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近做的一些事</title>
      <link href="p/5c5e.html"/>
      <url>p/5c5e.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3epl0m4sbj31hc0u04bq.jpg"></p><blockquote><p>图文均本人😆</p></blockquote><p>一大早起来迷迷糊糊的以为今天是周六，打开电脑才发现今天已经是周日了，给导师发完今天的文章海报后登陆公众号后台看到了上篇的文章数据，真是好惨一男的，怎么才78个阅读量😂</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3ep9mksv8j314e066gpz.jpg"></p><p>不过虽然阅读量少，但还是非常感谢给我赞赏的那几个人，吃水不忘挖井人，等我的号有一定规模了，可以像其他号一样可以发福利的时候一定不会忘了你们的🌹</p><p>上篇文章是我的”AI画家”系列的第四弹，我在后台收到了有小伙伴回复让我赶紧更新第五弹，说实话不是我不想更新，实在是最近事情太多了，昨天刚刚结束论文的第二次查重，这几天翻来覆去的降重弄的我头疼，原计划今天写下这周的文章回顾的，翻了翻才发现这周一篇文章都没有写，所以干脆趁着今天下雨没办法出去放松的机会把最近做的一些事情好好整理下。</p><h2 id="毕业论文的两大难题"><a href="#毕业论文的两大难题" class="headerlink" title="毕业论文的两大难题"></a>毕业论文的两大难题</h2><h3 id="降重"><a href="#降重" class="headerlink" title="降重"></a>降重</h3><p>作为一个临近毕业的大四狗，这段期间最头疼的就是莫过于毕业论文了，其实毕业论文最头疼的地方不在于怎么写，毕竟本科生能力有限，做的东西也不可能太牛逼到哪去，用的技术、实现的方法多半也都是现成的，所以写的时候还是很快的。可是麻烦就是麻烦在这，正因为是现成的技术和方法，你写的东西，往年的学长学姐多半也都写过了，算法类的论文可能还稍微好点，如果是那种应用实现类的论文，介绍前后端分离，介绍数据存储的时候你能保证能有多大的概率和前人不太一样呢？有人说中华文化博大精深，把一个句子颠过来倒过去的说就可以了，但是你能想到的，前辈们基本也都能想到，哪怕你把中文=&gt;英文=&gt;中文也很难保证不被认为不是重复的了，所以各位骚年们，往后写毕业论文的时候还是安安心心自己手写吧，不然的话就真的是”写文一时爽，降重火葬场”了。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>毕业论文里面第二个让人头疼的肯定就是格式了。说真的，就那个格式真的差点没把我这个钢铁直男逼疯，学校要求毕业论文用word写，查重过了满心欢喜发给老师，结果没一会就被老师叫到实验室劈头盖脸说一顿，你这英文没用罗马字体，你这图表的标注字号有问题，你这参考文献格式不对，还有页眉页脚到哪去了，论文的公式也没公式的样子。没办法，退回来重新改了一下午格式，这里我就真的要实名吐槽下Mac版的Word了，竟然连自动目录都没有，害得我只能把文件发到windows的电脑上调格式，结果这时候又出幺蛾子了，我的公式格式咋回事，咋全变样了😂真的，我改格式的时候真的就下面这个表情。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3eq4k1aq0j306o06oq2u.jpg" alt="088C89ACBC6B5543A1924061BCD9AE3D"></p><p>对于格式我真的不想多说什么了，懂得自然懂，这里推荐一个我在写论文的时候粘贴LaTeX公式的一个神器——<strong>mathpix</strong>，这个神器强悍到什么程度呢？你们自己欣赏下吧：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3eqar2m3ej31ww0k4grh.jpg"></p><p>强到连爱因斯坦、牛顿、图灵都来为他们代言了。</p><p>当然这里就是开个玩笑，下载地址👉<a href="https://mathpix.com/%EF%BC%8C%E7%94%A8%E6%B3%95%E5%AE%98%E7%BD%91%E5%86%99%E7%9A%84%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%A4%9A%E8%AF%B4%E4%BA%86%E3%80%82">https://mathpix.com/，用法官网写的通俗易懂，这里就不多说了。</a></p><h2 id="最近做了一个小程序"><a href="#最近做了一个小程序" class="headerlink" title="最近做了一个小程序"></a>最近做了一个小程序</h2><p>最近除了忙毕业论文的事情，还顺带做了一个小程序（我并不是因为做这个玩意才没有更新文章的），他是一个工具的集合，我知道这样的小程序有很多，但是那又怎么样呢？那些又不是我的小程序。</p><p><img src="http://ww2.sinaimg.cn/bmiddle/006tNc79ly1g3eqny9n3mj30no15i420.jpg"></p><p>界面比较简洁，基本沿用我之前做的那个校园小程序，我给他取名”开挂”，寓意是希望使用它的人在生活中体验开挂的感觉。就比如压马路的时候看见一辆不知道什么牌子的车的时候就可以用🚗识别看看到底是保时捷还是法拉利；再比如你可以测测你的颜究竟是真的好看还是你自己认为的好看。</p><p>其实做这个小程序的初衷比较简单，你们也都看到了有个AI油画的模块，本来就打算做个小程序当毕业设计就行了，但是后来想想既然都做了那就做大点吧，所以后来就把其他的功能加了上去，技术栈也很简单，就是前端小程序+后端Flask+数据库MySQL，代码我就不公开了，有兴趣的可以加我微信和我交流，这里附上小程序码，欢迎大家体验尝鲜（或者直接在公众号底部点击”开挂Lite”也可以体验），觉得好玩的可以点下小程序里面的广告就当是给我支持了哈。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3eqxr8qqgj3076076gmg.jpg"></p><h2 id="学了摄影"><a href="#学了摄影" class="headerlink" title="学了摄影"></a>学了摄影</h2><p>因为总觉得有必要发展些兴趣爱好，正巧前段时间买了一个富士相机，这里说是<strong>学了</strong>摄影，其实就找了一些和摄影有关的书籍看看，然后请教了一些认识的摄影爱好者拍了些照片，开头的那个图就是我拍的，其实这里没啥好写的，要不就自恋点放两张我觉得拍的不错的图片吧😆（摄影小白的作品，不喜轻喷啊）</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3er6m8fahj31hd0u01kd.jpg"></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3er7w5ijzj31hc0u016o.jpg"></p><h2 id="减肥"><a href="#减肥" class="headerlink" title="减肥"></a>减肥</h2><p>终于到了这个沉重的话题了，说这个话题沉重的原因是因为我本身比较重，去年年末写的一篇年终总结里面定了几个小目标，如今已经年中了，有些已经完成了，有些仍在进行中，然而只有减肥我没给自己定个明确的目标，因为我自己也不确定我究竟有没有决心把减肥这件事做下去。最胖的时候我有180斤，现在我已经到166了，给你们看看我的体重变化趋势（这里给小米体脂秤2点个赞👍）😁</p><p><img src="http://ww2.sinaimg.cn/bmiddle/006tNc79ly1g3erjh3aeqj30u01fodi8.jpg"></p><p>虽然效果还不是很明显，但是为了健康，该做的我还是会继续做下去的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实这篇文章就是想把最近的一些事情做些总结，就算我们做不到吾日三省吾身，也该时不时总结下自己的一些经历，也方便为之后的生活做些规划。可能大家关注我的公众号是因为之前的一些技术文，但是我在公众号的介绍里也说了，除了技术我也想给我的读者带来一些不一样的东西，这篇文章就是我的一个小小的尝试。虽然我不是一个优秀的人，但是我也不会放弃去成为一个优秀的人，与君共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑假了，你是不是该做点什么？</title>
      <link href="p/4728.html"/>
      <url>p/4728.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rcnuu8jlj31hc0p4drm.jpg"></p><blockquote><p>文：「雇个城管打天下」 | 图：Pixabay </p></blockquote><p>眼瞅着时间到7月了，中小学生都放假了，现在还有多少大学生试还没考完啊，不知道考完试的大学生现在是不是跟下面一样。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4rc9cnd7uj30dw091t9f.jpg" alt="1562486805185"></p><p>然鹅，竟有一些学弟私聊问我：“学长，暑假到了，我想学点新东西，能不能给点建议？”</p><p><img src="http://ww4.sinaimg.cn/bmiddle/006tNc79ly1g4rcickagyj30jg0c674l.jpg"></p><p>现在的学弟都这么认真的吗？暑假也不放过自己吗？这让我们这些寒暑假都没有得人情何以堪啊。</p><p> 不过作为一个知心学长，我还是认真地搜索了「大学生暑假」这类问题，然后：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4rcsxrqowj30z0064gne.jpg"></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rct343ucj310e06q40c.jpg"></p><p>搜索结果这么真实的吗？竟然还有六成的大学生在家当“肥宅”？难不成那些想要学习的学弟都是些不放过自己的“变态”？</p><p>抱着对搜索结果怀疑的态度，我问了下周围的人，他们之前的暑假都是怎么过的。果然，很多人在暑期刚开始制定了超多超多的计划，然后，执行了两天之后就被空调、WIFI、西瓜打回原形，最后还要受到爸妈的数落和嫌弃。</p><p>但是学弟好心来问，总不能直接劝退吧，多少还是要给些建议吧。</p><p><img src="http://ww1.sinaimg.cn/bmiddle/006tNc79ly1g4rd3vuf6ej30k00f0t93.jpg"></p><p>结合搜索结果和我自己前几年的假期经历，我总结出作为一个有假期的大学生，你要做的三件事：</p><p><strong>必须做的事、正确的事、喜欢的事</strong></p><h3 id="必须做的事"><a href="#必须做的事" class="headerlink" title="必须做的事"></a>必须做的事</h3><p>举个简单的例子，<strong>学车</strong>。作为一个已经成年的大学生，在暑假你最该做的事就应该是学车，因为学车这个事需要大把的空闲时间，除了教师，也就是放荡不羁爱自由的大学生才有空能找出整块的空闲时间了。而且现在学车的难度和学费都在涨，你确定不早点拿个证？还能加学分哦～</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rdgmsjerg306o050dhu.gif"></p><p>再比如，如果你现在已经大三了，这个暑假是不是该好好想想自己是考研还是好好准备出去实习呢？（保研党除外）</p><p>当然，无论什么事情都是因人而异的，毕竟有些人光是“活着”就已经很不容易了。比如对我来说现在必须要做的事就是好好减肥。看到这，期末挂科的还不赶紧复习去？</p><h3 id="正确的事"><a href="#正确的事" class="headerlink" title="正确的事"></a>正确的事</h3><p>啥是正确的事，看到下面这张图你还不明白吗？</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4rdkl00kej304j04jq2s.jpg"></p><p>正所谓，活到老学到老，作为受过“高等教育“的我们，学习二字必定会贯穿我们的一生，所以为期两个月的空闲期又怎么能放过呢？</p><p>不过这里的学习并不是单纯的指那些考试挂科的要应付补考的学习，而是指那些能提升自己的事。</p><p>举个例子，对于男同胞来说，有一件事一定非常正确，那就是<strong>拍照</strong>！</p><p>提到拍照就想起了那些不堪的往事，开开心心和心仪的女孩子出去玩，对方主动提出让你给她拍照片，然后？？？？</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4re0az9c9j30go03v3ym.jpg" alt="20180528024231936"></p><p>所以，掌握正确的拍照技术对很多直男来说是一项必须要去学习的事情。</p><p>当然还有件值得去做的正确的事就是<strong>「读书」</strong>了，书单就不推荐啦，每个人喜好不一样，自己在知乎搜索「年轻人读的书」，你会有新发现的～</p><h3 id="喜欢的事"><a href="#喜欢的事" class="headerlink" title="喜欢的事"></a>喜欢的事</h3><p>夏天最喜欢的事是什么？当然是<strong>「空调、WI-FI、西瓜」</strong>啊🤪</p><p>好吧好吧，不皮了，虽然喜欢「空调、WI-FI、西瓜」无可厚非，但是我之所以把<strong>喜欢的事</strong>放在<strong>正确的事</strong>后面其实也是想说，虽然现在还年轻的我们就应该去做自己喜欢做的事，但是也该分清主次。</p><p>在经济条件允许的情况下，趁着暑假的时间出去旅旅游、和多年不见的好友聚聚餐、亦或是好好和自己的男朋友/女朋友经营下感情，或者去做一件自己以前不敢做的事情，挑战一下自己。比如自己摆地摊，比如主动跟陌生人说话，或是去学一个从来不敢想的新事物。<strong>很多事情，没做的时候你会觉得自己做不了，没有能力，但真正去做了，你才会发现，原来也不过如此。</strong></p><hr><p>然鹅，对于绝大多数大学生来说，刚放假的那几天肯定还是会选择好好浪一把，不过持续不了几天，你就会发现</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4retjx0yvj30bz0bxaaf.jpg" alt="tlbts5-1561013013"></p><p>于是开始制定超多超多的计划，再然后，执行了两天之后就被空调、WIFI、西瓜打回原形，最后在家受尽白眼，仿佛自己是垃圾堆里捡来的。</p><p><img src="https://ww2.sinaimg.cn/large/006APoFYjw1fb1e0x0lxtj3064064t8w.jpg"></p><p>最后说一句，个人认为在执行计划的时候，我们应该注重过程，至于结果尽力就好，做事只求问心无愧，享受过程比注重结果更有意义。</p><hr><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g446nr6eaoj30x80jwast.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是时候和学生时代说再见了</title>
      <link href="p/89a3.html"/>
      <url>p/89a3.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.ytools.xyz/uPic/PWqNyOfarewell-3258939_1920.jpg"></p><p>年前和朋友吃饭，聊到了一个问题，如果可以重新选择职业方向，你还会坚持现在的选择吗？她很坚定的告诉我虽然很累，但还是会毫不犹豫的选择学医，只是单纯因为热爱。随后她便反问我，如果你可以重新选，你会换吗？</p><p>我犹豫了，我今年 22 岁，这个月硕士毕业，很快就会加入互联网打工人的大军，这一行起薪很高，甚至是很多其他行业奋斗打拼几年都追不上的高薪，我承认我是一个世俗的人，这一行的高薪让我很满意，但我总是会想，我真的热爱它吗？</p><h2 id="梦开始的地方"><a href="#梦开始的地方" class="headerlink" title="梦开始的地方"></a>梦开始的地方</h2><p>我从小就是一个很闹腾的人，属于那种上课爱搞小动作，下课爱讲话的人，为此年少时免不了被老师“请去喝茶”。中学时也曾沉迷游戏无法自拔，差点成为一个网瘾少年，好在后来幡然醒悟。虽然戒了游戏，但阴差阳错的对计算机产生了浓厚的兴趣，大学填志愿时也曾纠结过是选择计算机科学还是软件工程，现在想想倒也不那么重要了。</p><p><img src="https://cdn.ytools.xyz/uPic/S6OKfWfantasy-4063619_1920.jpg"></p><p>本硕我都是学习的软件工程，算是一条路走到黑了。很多人说软件工程和计算机科学的区别着重在后面两个字，一个是<strong>「工程」</strong>，一个是<strong>「科学」</strong>，软工更偏应用，计科更偏研究。这个说法没什么不对的，因为这两者的路线确实有很多交叉，没有理论指导的工程只会是无源之水、无本之木；理论研究再好不演化成工程落地那也只是空中阁楼，因此我觉得对于刚踏入或者即将踏入计算机领域的人来说不必纠结于「软件工程」还是「计算机科学」的选择。而应将重点放在对兴趣的培养上。</p><h2 id="兴趣是最好的老师"><a href="#兴趣是最好的老师" class="headerlink" title="兴趣是最好的老师"></a>兴趣是最好的老师</h2><p>每当有人问我为什么会喜欢计算机时，我都会告诉他，我喜欢<strong>创造</strong>（creating）的感觉。《哈利波特》是我很喜欢的一部作品，而在计算机这一个由“01 二进制”构成的世界里，我就是“霍格沃茨”的魔法师。在这里我可以指点江山、激扬文字，实现我任何天马行空的想法，仔细想想这是一件多爽的事情啊。</p><p><img src="https://cdn.ytools.xyz/uPic/14JmaXiShot2021-06-02%2017.02.24.png"></p><p>在《黑客与画家》一书中，作者说编程是一种技术创作，黑客就是艺术家，开发软件与画家画画、雕刻家雕刻、建筑师设计房屋并没有本质不同。他们都是在尽情的将脑海中的想法创造出来，而这就是我喜欢编程的原因。</p><p>每当我说到这的时候，都会有朋友跟我吐槽，说他们压根没有这种想法，选择这个专业纯粹是不知道选啥，或者因为这行钱多。</p><p>的确，很多人选择计算机更多是迫于无奈，我理解。但是我没办法好为人师，也没办法告诉你们怎么样对编程提起兴趣。人生是由无数个选择构成的，如果真的无感，趁早放手对彼此都好；但如果你坚定的选择了这一行，用心做下去就好了。</p><h2 id="一万小时定律与十万行代码"><a href="#一万小时定律与十万行代码" class="headerlink" title="一万小时定律与十万行代码"></a>一万小时定律与十万行代码</h2><p>Malcolm Gladwell 在他的《异类：不一样的成功启示录》书中讲到了 10000 小时法则：“人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。1 万小时的锤炼是任何人从平凡变成超凡的必要条件”。</p><blockquote><p>如果按比例计算的话，每天工作 8 个小时，一周工作 5 天，那么成为一个领域的专家至少需要 5 年的时间。</p></blockquote><p>也有人说，从初学者成长为一名合格的程序员，需要 10 万行代码的积累，那么从你开始学习编程到现在，你写了多少行代码呢？</p><p><img src="https://cdn.ytools.xyz/uPic/3OUMDWimage.png"></p><p>当然了，写代码的行数和程序员的能力没有太直接的关系，代码数只是编程能力的一个体现，不能以偏概全。而且不同的岗位代码能力数量差异非常大，一万小时定律与十万行代码更多是想要告诉人们想要学好编程，<strong>实践</strong>是万万不可缺少的。</p><p>熟悉我的朋友都知道，我在现实生活中的兴趣爱好并不多，除了摄影可能就是看书喝咖啡了。但是我在二进制的世界中爱好广十分广泛，移动 App、桌面应用、爬虫、Vue/React、Java Web、Python Web、AI、容器、分布式等等我都或多或少接触过并实践过，可能会有人觉得你完了这么多东西都没有一个精通的没什么用。的确，这里面的东西我没有一个敢保证我是精通的，但是六年的校园时光你不广撒网，多涉猎新奇的东西，难不成等以后工作了，每天 996 了再去涉猎新东西？</p><p><img src="https://cdn.ytools.xyz/uPic/jYO6GNimage%20(1).png"></p><p>而且，在涉猎新玩意的同时，我的实践能力得到了质的飞跃，有了很多前置知识之后，再接触一些新东西时往往都会有“哦～，这玩意不是和那 xxx 差不多吗！”的感觉，很多东西都会「触类旁通」，上手新东西自然会越来越快。</p><p>所以，赶紧行动起来，现在就去。不要找任何借口！</p><h2 id="动手去做，Just-do-it！"><a href="#动手去做，Just-do-it！" class="headerlink" title="动手去做，Just do it！"></a>动手去做，Just do it！</h2><p><img src="https://cdn.ytools.xyz/uPic/9LJy4cjust-do-something-370229_1920.jpg"></p><p><strong>做东西是最好的学习方法。</strong></p><p>无论是软件工程还是计算机科学，都被划分到了<strong>「工学」</strong>的领域，而工学最重要的就是实践。上面我说了一万小时定律和十万行代码的理论，相信很多人都会问应该怎么去学习计算机领域那些专业课的知识，怎么去提高自己。毕竟很多人觉得《计算机网络》、《操作系统》、《计算机组成原理》这些课学了没什么用，还非常枯燥，我当时也是这么认为的，好在我一位老师曾回答过这个问题，他对此的看法是：</p><blockquote><p><em>本科阶段不要先花大量的时间去啃一本厚厚的上百元的专业书，而应该先去做一个相关的可以迭代的项目，这样才是更好的学习方式。在项目中锻炼，遇到了问题，难点，然后针对性的进行知识学习，效率也是最高的。另外学了以后不能活用的知识实际上都很容易被遗忘，而课程的学习能够帮助你了解概括，了解全貌，可以更准确的找到相关的知识进行学习，这样经过实践学习后你会发现那种大部头的书实际上已经被啃掉了不少，再回头去啃厚书的时候，你会比一开始就啃要获益多得多！</em></p></blockquote><p>对这个观点我深有体会。本科有一段时间我对制作 App 非常感兴趣，便抱着郭霖大神的《第一行代码》反复钻研学习，后来机缘巧合和两个朋友制作了一个校园应用《果核》，那是我们仨的第一个作品。在制作这个小玩意的过程中遇到了很多很多的问题，爬虫方面的、计算机网络方面的、操作系统里的多线程等。</p><p><img src="https://cdn.ytools.xyz/uPic/SgJqp7image%20(2).png"></p><p>在解决这些问题的过程中，不光涨了经验值，对这些枯燥的知识点的理解也加深了。再之后，为了方便苹果用户使用，我们又学习了微信小程序的制作。Flutter 横空出世后，我又用 Flutter 重构了整个 App 使其可以跨平台运行，这一过程中加深了对设计模式的理解。虽然从现在的角度看，整个过程非常粗糙，无论是代码编写还是后来的推广运营，我们都是以一个萌新的身份在探索，但也正是那段经历造就了现在的我们。</p><p>再到后来，每学习一个新的东西时，我都会想着用这些知识点搞一些小玩意，学习 Electron 时做了「MediaPub」，学习神经网络时参考论文整了一个「图像风格迁移」的小程序，还拿他做了本科的毕设，直到现在还有人在公众号后台留言要代码。</p><p>说这么多，其实想表达的观点就是，你在做东西的过程中会知道你该学习哪些知识，这是比直接读枯燥的编程书籍认识和掌握知识更有效的途径。</p><h2 id="更多的探索"><a href="#更多的探索" class="headerlink" title="更多的探索"></a>更多的探索</h2><p>我时常会思考自己的核心竞争力到底是什么，毕竟从事这一行的人越来越多，总有人年轻着，也总有人被后浪拍死在沙滩上。很惭愧，我至今仍在寻找，这么些年也一直在探索着。</p><p>我是一个爱分享的人，无论是在生活中还是技术上。微博、即刻、朋友圈都有我活跃的身影，我会发一些搞笑段子，也会发发自己觉得拍的比较好的照片，当然有时候也会时不时阴阳怪气的 diss 某些事情，大概率未来几年我可能还是这样。</p><p><img src="https://cdn.ytools.xyz/uPic/2GNw0Qmoving-forward-4777506_1920.jpg"></p><p>技术上，我自己运营着一个微信公众号，同时我的文章也会发布在掘金、简书、知乎等平台上，虽然已经坚持了几年，但和那些大 V 相比，我的数据简直可以用惨不忍睹来形容。时至今日我的粉丝数也只有 3200 人，单篇文章的阅读量也只有 300 左右，我知道这和我的佛系更新是脱不了干系的，虽然我一直秉着追求质量而非数量的原则，但是当看到我的文章被人转载后的阅读量是我的数十倍时你说不羡慕那肯定是假的。</p><p>如今的公众号圈子同质化太严重了，要么是放些笔记上去，要么就是各种吊打面试官。说实话，我是真的懒得写这些东西，我觉得这些内容只要有第一个大佬总结好了，后面的人再怎么写也不会差到哪去，这就跟论文降重似的，翻来覆去就这些文字。公众号的老粉们都知道我很少写这些（当然之前也走过很多弯路），我更多是希望多分析生活中所反映出这个领域里的一些有趣的、好玩的点，并用通俗的语言表达出其原理、使用感想。我觉得学习是没有 KPI 的，唯有不断的去接受新的事物，才会更好的成长。</p><p><img src="https://cdn.ytools.xyz/uPic/0HrnPr124.png"></p><p>除去自己写文章之外，我之前也会翻译一些英文文章。自从大一过了四六级后，之后也没想到要刷分，所以基本上都不怎么接触英语了，读研期间多少要阅读些英文文献，干脆就参与了掘金的翻译计划翻译了一些文章。说来惭愧，原本给自己定的目标是翻译 40 篇文章，结果到现在也只翻译了 23 篇，上一篇还是去年年底的时候翻译的。当然了，这一切都是因为自己在忙着毕设和论文（疯狂给自己找理由)，相信等这段时间结束后一切都会步入正轨的。</p><p>抛开图文，在视频制作方面，最近我也在考虑我可以做什么类型的，之前有试水过制作一些视频，但都不是很满意，之后我也会积极的去尝试，也希望到时候各位老粉们可以支持一下。</p><h2 id="前路漫漫"><a href="#前路漫漫" class="headerlink" title="前路漫漫"></a>前路漫漫</h2><p><img src="https://cdn.ytools.xyz/uPic/nmFodwforward-1274244_1920.jpg"></p><p>上面说了那么多说到底还是以一个学生的身份在回顾过去这几年，去年我在淘宝实习了三个月，初步感受到了所谓大厂的福报，随后就又回来学校享受生活了。下个月再去淘宝，就真的是以一个打工人的身份去闯荡阿里这个江湖了。前路漫漫，鬼知道我能在那江湖中混成什么模样。有句话说，别人会关心你飞的高不高，而我却只关系你飞的累不累，毕竟如果你飞的高又不累的话那可就太气人了。</p><p>前路漫漫，愿出走半生，归来仍是少年。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本篇文章的全部内容了，之前就说会找个时间来聊一聊我学习编程的这些年，但一直忙着毕业的相关事宜，现在总算是空下来有时间把欠下的文章补上了，这一篇既是我学习编程的心路历程，也是这十八载学生时代结束时做的一个小总结。所以，回到一开始的那个问题，如果可以重新选择职业，我会换吗？</p><p>不会！</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春节记</title>
      <link href="p/cb44.html"/>
      <url>p/cb44.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g03zyl6uxzj30hs0af74s.jpg"></p><p>小时候最喜欢的节日就是春节，那时候的幸福也很简单，有新衣服穿，有好吃的，有红包拿，就很开心了。也不知道从什么时候开始，年味变得越来越淡了，以前过年的感觉也不知道去哪了。虽然有可能是因为现在不能随意燃放烟花爆竹了，但更多的恐怕是因为现在过年的快乐已经不属于我们了吧。</p><p>今年是我上大学后第一次回老家过年，最近几年都是在春节前或春节后抽个一天时间回家看望下家里老人，这也让我在全家决定今年回老家过年时有一些激动，以至于我没有跟我爸妈一起回家而是提前买了票溜了回去。既然是坐高铁回去的，那么与之相随的必定是我坐的车晚点了🙄，也是那天让我成为了朋友圈里的快乐源泉🙂，当然这是题外话了。 </p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g03wegn9cij30dw099q3k.jpg"></p><p>几年没回老家过年了，明显感觉今年的春节和往年不一样了，虽然年三十我家的年夜饭依旧“硬核”，但聚在一起的人少了好多，没人看春晚了，能约牌的人也几乎没了。原先的年夜饭我总是早早的下了桌去和弟弟妹妹唠嗑，今年却开始端起酒杯不断的和长辈亲戚们轮番敬酒，兴许这就是成长的烦恼吧（事实上我并不喜欢酒的味道）。</p><p><img src="https://ws3.sinaimg.cn/bmiddle/006tNc79gy1g03wmvvm48j30u0140npg.jpg" alt="我家的&quot;硬核&quot;年夜饭"></p><p>时间是公平的，我变老了，我的老家也发生了很多的变化。下面说说我自己这几天的一些感受吧。</p><h3 id="新农村的建设"><a href="#新农村的建设" class="headerlink" title="新农村的建设"></a>新农村的建设</h3><p>回到老家，远远望去我家门前竟然停着几辆挖掘机，原先的田地也被翻新了，听家里人说是今年要全面建设新农村了，国家投资了几千万把周边的田地全部重新翻了一遍，附近的房子也要拆了。其实从我的角度来看这是件好事，因为直到现在我们村子的路都还是土泥路，哪怕隔壁的村庄几年前就铺上了水泥路了。以前过年回家总是会下雨，出去上个坟回来鞋子和裤脚都是泥巴，就算开车回家，也只能停在村外，这也是这几年不想回去的原因之一。</p><p>既然都要建设新农村了，村里的老房子自然也是要拆掉的了，应我爸的要求，我带着我堂弟去了我自己家的老房子贴春联（吃年夜饭是在爷爷家，这个老房子是我爸妈结婚的时候在农村盖的），就是下图这个。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g03xdaq98sj313y0u01l6.jpg" alt="我家的老房子"></p><p>因为将近20年没住过人了，老房子早已破旧不堪，周围也是杂草丛生。之前我妈总说，等以后我成家了，就和我爸回来老家把这房子重新装修下养老。现在想想，怕是没机会了，爸妈结婚后在外漂泊打拼这么多年，这房子也没住过几次，就这样等着拆掉也算是回了之前盖房子的本了吧。</p><h3 id="春节期间的“乡村爱情故事”"><a href="#春节期间的“乡村爱情故事”" class="headerlink" title="春节期间的“乡村爱情故事”"></a>春节期间的“乡村爱情故事”</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g03znryrj2j30gy0bv0t6.jpg"></p><p>我因为上学比较早，因而周围同学的年龄普遍比我大2-3岁，也正直大四毕业期，用家里老人的话说就是在他们那个年代这个年纪的时候孩子都多大了。有男女朋友的家里开始忽悠着赶紧带回来给七大姑八大姨看看，没女朋友的家里干脆直接安排了相亲。</p><p>今年回来的氛围明显和以前不一样了，仿佛周围的朋友都在经历着相亲或者被暗示相亲。“相亲”、“恋爱“这几个字眼在我耳边出现的尤其频繁，兴许是在家里大人眼中，我们已经到了可以谈婚论嫁的年纪了吧。一个不愿透露姓名的学弟告诉我，他的外甥女已经结婚了，家里也已经开始疯狂暗示他了，期间竟然还以外出带他见父母朋友的理由介绍对方女儿认识。更直接的，在我和几个高中好友相聚的时候，一个好友告诉我他的父母早已为他安排了相亲。我不知道现在的父母都在着急些什么，都是新时代的大学生，有理想有抱负，想要成就一番事业，又不是不恋爱，不结婚了，为何急于这一时的相亲呢？</p><p>所幸我还要再上两年学，单身青年的生活也不是那么糟，一个人其实也挺好的✌️</p><h3 id="年味变得越来越淡"><a href="#年味变得越来越淡" class="headerlink" title="年味变得越来越淡"></a>年味变得越来越淡</h3><p>今年的年味和往年相比，尤其的淡。根本不敢想象大年初二的时候村里就已经没什么人了，外出散步的时候发现只有少数老人还住在农村。那些家里老人已经去世了的，门前已经十分荒凉了。可能很多的人都觉得现在生活条件好了，逢年过节农村应该会停很多的车，可我们村子门口车的数量却还是和几年前的差不多，一方面是我上面提到的村子还没水泥路不好停车，另一方面恐怕就是因为大多数人的生活水平提高了，在城市里住惯了的人再怎么也不愿意回老家去忍受那糟糕的生活环境了。初三去巢湖玩的路上就遇到了很多从县城回老家的车辆，都是白天去农村看看老人走亲戚访友，然后吃完饭再回去县城的。</p><p>当然年味变淡的另一个原因我觉得是因为互联网在农村的普及。现在过年，围在电视机前看春晚的人变少了，玩手机的人变得多了，像我们这样的学生党还有全国流量不限量的活动，没了流量的限制，哪怕家里没有Wi-Fi，大家照样可以开开心心的了刷手机。就像下图。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g03yfadtxsj31400s8ahn.jpg"></p><h3 id="农村成为了互联网的新机会"><a href="#农村成为了互联网的新机会" class="headerlink" title="农村成为了互联网的新机会"></a>农村成为了互联网的新机会</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g03zvq9atdj30fm09eweo.jpg"></p><p>作为一个互联网人，这几天在农村的经历让我觉得农村成为了互联网的新机会。一二线城市的人由于接触互联网较早，用户已逐渐开始饱和。与此同时，现在的农村由于生活条件上去了，不说家家都通了Wi-Fi，但覆盖率至少也有70-80%。而且由于大多数成年人都外出工作了，现在的农村人口大多是小孩和老人。现在的小孩子精成什么样子不用我说也都能感觉到，他们刚刚学会熬夜，拥有很多的注意力和时间。同时，成年人在外打工的钱很多都会寄一部分回去给家里老人，使得他们具有一定的消费能力，拥有大把时间和一定消费能力的老人，很可能成为未来互联网红利的一块大的蛋糕，就看那些互联网巨头怎么分了。</p><p>今年过年回去，还有一个发现就是玩抖音/微视这类短视频的人变多了，我个人是对这种app比较反感的，总感觉有点low，但是小孩子和老人觉得只要看的开心就好了啊，这些短视频反而成为了他们接触互联网的第一媒介了。</p><p>之前看到一个新闻，说拼多多的市值已经逼近了京东（没错，就是那个卖假货出名的拼多多），此前一直无法理解为何靠着假货出名的“并夕夕”竟然可以追上自营快递的“狗东”，直到过年回家我才是理解了为什么会这样。他的用户基本是四五线城市消费者，与快手、抖音等直播 APP 用户非常吻合，消费没有高低之分，这些经常浏览快手、抖音的消费者对于低价有超乎寻常的敏感度，尤其家庭妇女和中老年人。拼多多上面低于市场价的产品正好符合这些用户的需求，而这些用户又非常容易被借势传播。就像当年淘宝刚出来的时候，传统线下企业看不起淘宝一样，现在做淘宝、天猫电商的看不起玩拼多多的，殊不知拼多多积极贯彻毛爷爷的“农村包围城市”策略已经取得了巨大的成功，拼多多的成功证明中国人对于价格的敏感，低价市场还是主流市场。</p><p>相信未来还会有越来越多的互联网企业来到农村去分一杯羹。</p><h3 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h3><p>这是我第一次尝试写这种非技术类的文章，我知道我的文笔不好，但还是想借着自己的公众号/博客锻炼下写作的能力。如今农历的新年也已经过去了，新的一年希望自己可以好好投身硕士阶段的学习，同时运营好自己的公众号。当然最重要的还是好好经营下自己，未来仍然还有许多机会！</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手淘实习百日记</title>
      <link href="p/af33.html"/>
      <url>p/af33.html</url>
      
        <content type="html"><![CDATA[<p>知乎上有一个问题：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6bj17j3fj30kq042wfc.jpg"><br>说实话，虽然我的编程能力没有突飞猛进过，不过一些重要的转折点还是有的。第一次对编程起了兴趣还是在大学的软件协会里看到学长演示了一个 flappy bird，其实就是一个很简单的 Swing 小程序，可正是这个小程序帮我打开了编程的大门。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6bj53e8bj30a305fgmw.jpg"></p><p>第二个转折点是大二的暑假，从那年开始，我陆陆续续参加了一些软件设计比赛，第一款作品是一个智能家居 APP，功能很简单，就是用语音控制空调、风扇等家电，硬件部分由我的队友实现，我负责软件，包括后端服务和 app。现在回过头看那一套东西做的是真的粗糙，不过那一年 AIoT 的概念还没被人提出，智能家居也远不如现在这么普及，所以对他的印象还是比较深刻的。</p><p>而第三次的转折点就是这次实习了，阿里巴巴是我实习的第一家企业，在淘系的这三个月里，我认识了很多前辈，也结交了很多非常优秀的同龄人，感慨良多。如今，我就快要回学校去度过我人生中最后一段校园时光了，想着在这里记录下来，作为对自己这几个月的一个小总结，也希望能对你有所帮助。</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>魔幻的 2020，让很多本就不顺的人生际遇变得更加奇妙，这场新冠疫情让我度过了人生中最长的一段寒假（现在还没开学）。其实我挺感谢年初政府号召的”居家令”，如果没有这段无聊到让我只能去学习的时光，我可能也进不了淘宝去实习。那段时间，整理复习各种基础知识，在 leetcode 上疯狂刷算法题，也一直和舍友们相互分享各自看到的知识点，复盘各种面试经历，这种和舍友们一起并肩作战的感觉，上一次经历应该还是高三那年吧。</p><p>幸运的是，那段时间学院的通知群每天都被各种公司的内推信息刷屏，其中最疯狂的莫过于字节跳动了，感觉他们每个部门都缺人（现在好像也是），群里的学长们也都很好，有的学长不仅会帮你修改简历，还会帮你进行一次模拟面试，这些操作对我的实习面试有很大的帮助。有关我是怎么找实习的以及实习过程中有哪些注意点，可以参考我的这一篇文章 👉<a href="https://mp.weixin.qq.com/s/A3HiLWg3i36LCRJaVUSqdA">计算机相关专业实习指北</a><br>最终，在两家都很不错的公司里我选择了一直想去的阿里巴巴。（终于也是有小牌牌的人了）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6bjey7zlj308c0agdkk.jpg"></p><h2 id="缘聚"><a href="#缘聚" class="headerlink" title="缘聚"></a>缘聚</h2><p>知乎上还有一个很好玩的问题，找对象和找工作哪个更难？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6bjxr39jj30at069mz3.jpg"></p><p>之所以会有人把找对象和找工作一起比较，我觉得是因为这两者都是一个双向选择的过程，找对象需要双方看对眼，找工作也是。对我们来说，大厂的平台、技术积累是我们需要的。对于公司来说，需要有<strong>勤奋、靠谱、有潜力</strong>的实习生作为人才储备。u1s1，和字节跳动疯狂招年轻人的情况相比，阿里这几年校招的 hc 越来越少，对实习生的要求越来越高，甚至出现了“大量 hc=2 人，海量 hc=3 人”的调侃。这里我不得不吐槽一下，我不知道这样的做法是出于什么考虑，但年轻人太少，总觉得缺少了一些活力。</p><p>而且，在和主管沟通的过程中，我发现了一个很有趣的现象。他们毕业的时候，阿里还处在快速发展期，虽然薪资不高，但是他们都相信马爸爸那句“让天下没有难做的生意”，和他聊天的时候我真的可以感受到当年他们做事时的冲劲，可现在来阿里的年轻人又有多少人愿意相信画的“大饼”（很庆幸我的主管是一个非常务实的人，到底是弄技术出身的人），再加上现在阿里对招进来的实习生要求越来越高，和校招难度几乎是一样的，能来阿里实习的秋招去其他大厂基本也不会有太大问题，可薪资和其他大厂相比却并没什么优势，在如今年轻人越来越不好忽悠的情况下，我不知道公司靠什么再去吸引那些有能力留在阿里的年轻人，难不成真像外界流传的那样《阿里巴巴不再需要年轻人》，然后拱手送给竞争对手吗？这点，我也有些迷惑。</p><p>当然了，这些还是有点扯远了，回到本节的话题，我觉得还是找对象更难一点，毕竟努努力我可以找到工作，但是找对象这个事，光靠我努力就有点难了 🙃。</p><h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6bkc8aq8j30kq07mn2h.jpg"></p><p>阿里内部有很多优秀的自研中间件，像配置中心、RPC 框架、分布式缓存、Arthas 等，这些对于拓宽知识面起到了很重要的作用，当然还有很多秀到飞起的大神在内网里分享一些文章，有讲量子力学的，也有连载小说的，简直是摸鱼必备。</p><p>文章开头说，实习的这几个月是我编程生涯的又一个转折点，并不仅仅是因为在这里了解到了一些技术，更多是在编程的规范和遇到问题的态度上。</p><p>以前，自己的角色更像是一个野生程序员，编码没有规范，对日志也不做监控（也不一定会打日志），写代码更多的也只在于实现功能，而不去考虑性能优化。而现在，你写的代码会被上千万人使用，小小的性能问题，都会影响众多用户的使用体验，这使得你不得不谨慎对待你所写的每一行代码。</p><p>这里我再来吐槽一下在阿里的开发体验，由于各种中间件“优秀“的封装以及严格的权限管理，我来这里三个月了，不知道数据库长啥样（据说师兄也没有见过），再加上每个项目依赖众多，管理混乱，几乎没有一个项目可以在本地调试，硬是肉眼 debug 了三个月（朝着人肉逻辑机进化 🙃），即使可以尝试将项目部署到日常/预发环境进行远程 debug，但是项目的庞大使其部署一次就需要花费 20 分钟左右的时间，而且由于数据太多，根本没有办法很好的做到数据隔离，如果数据异常，就有可能触碰安全红线，所以与其花时间想怎么远程 debug，倒不如做好日志监控、花些心思好好锻炼下肉眼 debug 的能力。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6bkttsdbj309d01wq2u.jpg" alt="image (4)"></p><p>成年人的世界里除了长胖没有什么是容易的。今天是我来阿里的第 100 天，说长不长，说短也不短，可我却很成功的从 145 斤涨到 155 斤（等回学校之后又要开始减肥了），当然这一切都要归功于离我只有 2 分钟路程的食堂 😂。其实本来坐在电脑前不知道写些什么，可还是流水账似的写了这么多。这是一家让我又喜欢又讨厌的公司，喜的是他技术氛围、可以让上亿人用到你的代码的成就感，厌的是他的文化（不仅仅是加班文化，不过现在国内好像没有不加班的互联网公司了），我不知道接下来我会不会继续留在阿里，但很感谢能在这度过充实的 100 天，阿里，我们江湖再见！</p><hr><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44da44b0f5040f7940b8a7e1a404a56~tplv-k3u1fbpfcp-zoom-1.image"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的大学四年</title>
      <link href="p/6bb.html"/>
      <url>p/6bb.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g48nha90pcj31400u0e5y.jpg"></p><p>终于还是到了毕业的日子，按照惯例每到一个人生的关键点时总要写点东西记录一下，如今本科四年已经过去，也是时候好好回顾下，只是这次我不想单单只从自己的角度去回顾我的大学四年，为此我给许多大学好友私发了一条信息：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g45o4ifrbfj30hq032wf6.jpg"></p><h2 id="别人眼中我的大学四年"><a href="#别人眼中我的大学四年" class="headerlink" title="别人眼中我的大学四年"></a>别人眼中我的大学四年</h2><p>收到的回答也是各不相同，有长有短，这里选几个：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g45oomenb5j315y04kwj0.jpg"></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g45onycmxhj316a0cyajr.jpg"></p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g45phhbd9yj30uy0bk40b.jpg"></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g45os861y5j30y402y0tl.jpg"></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g45p3aloghj30he01amxh.jpg"></p><p>可能会有人觉得奇怪为什么要从别人的角度看自己这四年？怎么说呢，不知道你们周围有没有那种明明觉得自己很努力，但是却一直没什么成果的人。我同样担心自己也是这样的。毕竟只有站在不同角度，才有可能看到问题的真相。</p><h2 id="我眼中我的大学四年"><a href="#我眼中我的大学四年" class="headerlink" title="我眼中我的大学四年"></a>我眼中我的大学四年</h2><p>那我自己认为的大学四年是什么样的呢？如果要给我的大学打个分，我打8分（满分10分）。</p><p>回顾我的大学四年，自认为是比较充实的，结交了一众好友、学到了很多技能、去过很多城市，也有明确的目标。到现在，父母身体健康，学业也算有成，自然在别人眼中我可能是过了一个让人羡慕的大学生活。</p><p>可是成功的花儿，人们只惊羡她现时的美丽。这几年因为无人指点，自己摸索，在很多事情上都踩过坑，浪费了很多时间，错过了很多机会，自然也留下了很多遗憾。</p><p>人生中什么最珍贵，失去的东西和得不到的东西。那些我们走过的每一段路，经历的每一件事，现在都已经成为过去了，它不会给我们机会重新来过，我们能做的就是把它好好珍藏，作为美好的回忆。</p><p>从前有人对我说，将来你一定要上大学，而且要好好珍惜大学4年的生活，大学的生活不同于中学，你可以更自由，远离父母，去支配自己的生活、学习。那时候的我真的充满了对大学的向往，可是高考的失利击碎了这一切。</p><p>我以过一本线60多分的成绩来到了一所双非大学，内心自然是不甘的，可我也明白”既来之则安之”的道理，在一个差一点的学校，最关键的一点就是让环境对你的影响降到最低。</p><p>为此我把**”被窝是青春的坟”**当作大学期间的信条。这里借用🐔哥的一句话：大学男生宿舍，有时候就是屌丝的培养皿。对于这句话，我感触颇深，因为我的宿舍就是一个这样的培养皿。所幸，终于可以后会无期了。</p><p>那有什么遗憾的事情吗？恐怕就是最后离开学校的时候还是单身吧！不过感情这种事也不是可以强求的，有句话说的好，所遇非良人，故独善其身。</p><p>当然，我这四年最不后悔的一件事情就是选择了软件工程这个专业。如果你身处一个三流大学，而又偏偏选择了计算机/软件，那真应该祝你选择了一个好的专业。因为在这个专业，只要自己够努力，学校之间的差距是可以被弥补的。</p><p>之前有人问过我为什么喜欢编程，我说因为我是一个喜欢创造的人，编程让我体会到了创造的乐趣，我可以用手中的键盘，把我脑海中构建的世界通过代码展示出来，哪怕在别人眼中这是一个脆弱的、混乱不堪的世界，但他出自我手，旁人便不可亵渎（护犊子）。</p><p>说了这么多，总算到了最后。今天，毕业典礼已经结束，我的本科时光也终于落下帷幕。虽然不愿承认，但有些<strong>成长（分别）</strong>是避免不了的。大学这四年，或许是人生中仅有的最自由的年华。总的来说，我不后悔，因为我奋斗过，拼搏过，我相信只要肯努力，世界必定会给予回报。</p><p><strong>假如你还在校园中，就去做你一直想做的事吧，去成为你想要成为的样子。</strong></p><hr><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g46w4l1880j30x80jwast.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的MacBook应用清单</title>
      <link href="p/96c9.html"/>
      <url>p/96c9.html</url>
      
        <content type="html"><![CDATA[<p>我是2018年10月份入手了这台MacBook pro，之前一直用的Windows，换成Mac多少有些不太习惯，系统安装好之后就是设置基本的工作环境了。基础工作做好了后续工作会节省大量时间，提高效率，提高生产力，提高安全性。看看Mac周边软件，数不胜数，质量也参差不齐。根据工作的不同，对专业软件的要求也不尽相同。但是基本的必备软件，大约就这么几个，经过一番试用，筛选出来，推荐给大家。希望大家有好的Mac软件也无私分享一下。</p><h3 id="Magnet：窗口管理工具"><a href="#Magnet：窗口管理工具" class="headerlink" title="Magnet：窗口管理工具"></a>Magnet：窗口管理工具</h3><p>Magnet 是窗口管理工具，提供了上下左右，左上角、右上角。左下角、右下角以及全屏，恢复之前窗口尺寸等多种窗口定位，这是我入手的第一个收费软件，我很好奇为什么隔壁田牌系统早就有的功能在Mac上竟然还要我花钱来买一个软件来实现。不过还好，这个软件只收6个软妹币，算是对得起他的价格吧。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-6b560569b3dd1117?imageMogr2/auto-orient/strip%7CimageView2/2/w/600"></p><blockquote><p>下载地址：<a href="http://magnet.crowdcafe.com/">http://magnet.crowdcafe.com/</a></p></blockquote><h3 id="The-Unarchive：解压缩工具"><a href="#The-Unarchive：解压缩工具" class="headerlink" title="The Unarchive：解压缩工具"></a>The Unarchive：解压缩工具</h3><p>macOS 对于压缩文件的处理不是很好。如果你没有安装任何软件，你只能选择压缩成 <strong>.zip</strong> 或者解压 <strong>.zip</strong> 文件，可能听起来有点鸡肋。而 The Unarchiver 作为 Mac 上一款相当良心的解压工具，支持解压 <strong>RAR</strong>、<strong>7-zip</strong>、<strong>Tar</strong> 等常用压缩格式的文件，同时也可以打开 <strong>ISO</strong>、<strong>EXE</strong> 等类型的文件，功能齐全并且免费。无广告，不流氓，在日常使用中，你甚至不会发现有这个软件的存在</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-4c164f1fe9a15903?imageMogr2/auto-orient/strip%7CimageView2/2/w/600"></p><blockquote><p>下载地址：<a href="https://theunarchiver.com/">https://theunarchiver.com/</a></p></blockquote><h3 id="Airmail3：邮件管家"><a href="#Airmail3：邮件管家" class="headerlink" title="Airmail3：邮件管家"></a>Airmail3：邮件管家</h3><p>一款很出色的Email客户端，支持众多邮件提供商，可轻松集成国外大牌的21个邮箱服务商，包括Dropbox、Box、Fantastical、2do、Todoist、Wunderlist、OmniFocus、Trello、BusyCal、Droplr等。当然不占用dock栏这一点好评！    </p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-c493bf06caf2bfe4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-bccc21f4816ad9fd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>下载地址：<a href="http://airmailapp.com/">http://airmailapp.com/</a></p></blockquote><h3 id="Folx：下载利器"><a href="#Folx：下载利器" class="headerlink" title="Folx：下载利器"></a>Folx：下载利器</h3><p>Mac上免费的网络下载管理器,Folx拥有现代的界面，支持Retina显示效果。同时支持种子下载，比国内的X雷不知道高到哪里去。<img src="http://upload-images.jianshu.io/upload_images/5666077-444c1162736821c1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="329984"></p><blockquote><p>下载地址：<a href="https://mac.eltima.com/cn/download-manager.html">https://mac.eltima.com/cn/download-manager.html</a></p></blockquote><h3 id="Tencent-Lemon-Cleaner：清理工具"><a href="#Tencent-Lemon-Cleaner：清理工具" class="headerlink" title="Tencent Lemon Cleaner：清理工具"></a>Tencent Lemon Cleaner：清理工具</h3><p>不知道是不是在Windows上养成的坏习惯，总感觉电脑上如果没有一个清理软件的话就会显得不自在，虽然知乎众多大佬都推荐cleanmymac，但是穷学生的我一看到收费二字不免心中一颤，好在国内也有一个清理软件<strong>腾讯柠檬清理</strong>，无论是UI还是功能上，都可以看出腾讯爸爸对这款软件的用心程度。</p><p>当然功能上也还是比较齐全的，除了日常的垃圾清理还支持<strong>“相似照片清理”</strong>和<strong>“应用卸载”</strong>等功能。可以自定义菜单栏上的选项，也可以选择关闭主界面后不再dock栏驻留，简直就是强迫症的福音啊！</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-49892e3f7a833880?imageMogr2/auto-orient/strip%7CimageView2/2/w/640"></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-51ffa0d7516da0b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/640"></p><blockquote><p> 下载地址：<a href="https://mac.gj.qq.com/">https://mac.gj.qq.com/</a>，内测码在升级日志里。</p></blockquote><h3 id="KanTu（看图）：快捷的看图软件"><a href="#KanTu（看图）：快捷的看图软件" class="headerlink" title="KanTu（看图）：快捷的看图软件"></a>KanTu（看图）：快捷的看图软件</h3><p>Kantu (看图)是腾讯在 macOS 平台出品的优质看图工具，轻轻松松从万张照片中找到你想要的。说实话，打开图片的速度是真的快，而且界面也比较好看：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-f42a5369da363740?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-71491b449f63c992?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>没想到有一天我也会变成腾讯吹。</p><blockquote><p>下载地址：<a href="https://kantu.qq.com/">https://kantu.qq.com/</a></p></blockquote><h3 id="Tickeys：让你的每次敲击都有江湖的感觉"><a href="#Tickeys：让你的每次敲击都有江湖的感觉" class="headerlink" title="Tickeys：让你的每次敲击都有江湖的感觉"></a>Tickeys：让你的每次敲击都有江湖的感觉</h3><p>Tickeys就是一款模拟机械键盘打字的声音，当然还有很多其他的音效方案，个人喜欢<strong>“剑气”</strong>，每次敲击都会有种江湖的感觉。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-441143cd759e264f?imageMogr2/auto-orient/strip%7CimageView2/2/w/340"></p><blockquote><p>下载地址：<a href="http://www.yingdev.com/projects/tickeys">http://www.yingdev.com/projects/tickeys</a></p></blockquote><h3 id="HandShaker：Mac和安卓的文件传输工具"><a href="#HandShaker：Mac和安卓的文件传输工具" class="headerlink" title="HandShaker：Mac和安卓的文件传输工具"></a>HandShaker：Mac和安卓的文件传输工具</h3><p>锤子科技出品，主要用于在 Mac 和安卓手机之间方便的传输文件。可以通过在同一 Wi-Fi 网络下无线传输，也可以使用数据线连接 Mac 与安卓手机传输。虽然锤子快要凉了，不过这个软件对于我这个安卓党来说还是福音啊。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-bf4b825480a7cc96?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>下载地址：<a href="https://www.smartisan.com/apps/#/handshaker">https://www.smartisan.com/apps/#/handshaker</a></p></blockquote><h3 id="Office2019-for-Mac"><a href="#Office2019-for-Mac" class="headerlink" title="Office2019 for Mac"></a>Office2019 for Mac</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-b3d06c464b067509?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这个的话我觉得没啥好说的，不是不支持国产，实在是国产的WPS太伤人心了。支持正版的请自动忽略下面一句话。</p><blockquote><p>下载地址：<a href="https://pan.baidu.com/s/1pmqlTVMAPvgBbC1lNheXYw">https://pan.baidu.com/s/1pmqlTVMAPvgBbC1lNheXYw</a> 提取码: i2y4 </p></blockquote><h3 id="iText：OCR利器"><a href="#iText：OCR利器" class="headerlink" title="iText：OCR利器"></a>iText：OCR利器</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-74e921de1a9bbd9a?imageMogr2/auto-orient/strip%7CimageView2/2/w/240"></p><p>这个软件可以进行OCR识别，支持多个源，百度谷歌腾讯都有，免费版一个月只能识别20次，基本够用，有订阅版，需要多的，可以订阅，识别率很好，识别完以后可以直接复制。效率神器，强烈推荐！</p><blockquote><p>下载地址：<a href="https://itunes.apple.com/cn/app/id1314980676?ls=1&mt=12">https://itunes.apple.com/cn/app/id1314980676?ls=1&amp;mt=12</a></p></blockquote><h3 id="Pap-er：壁纸软件"><a href="#Pap-er：壁纸软件" class="headerlink" title="Pap.er：壁纸软件"></a>Pap.er：壁纸软件</h3><p>免费的壁纸更换软件。可以定时每天或者每小时更换壁纸，也可以自己手动更换。也支持图片保存到本地。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9752511018abc341?imageMogr2/auto-orient/strip%7CimageView2/2/w/240"></p><blockquote><p>下载地址：<a href="http://paper.meiyuan.in/">http://paper.meiyuan.in/</a></p></blockquote><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora 是一款极简 Markdown 编辑器，第一次使用给人的感觉就是「干净、纯粹」。虽然界面简洁，却对 Markdown 有着比较强大的支持。如果你只是需要一款纯粹的 Markdown 编辑器，Typora 是不二之选。配上Pandoc还可以导出诸如docx，pdf等格式的文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-07e9691efae67a98?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-22723404baecdc35?imageMogr2/auto-orient/strip%7CimageView2/2/w/440"></p><blockquote><p>下载地址：<a href="https://typora.io/">https://typora.io/</a></p></blockquote><h3 id="Flow-for-Mac：时常统计软件"><a href="#Flow-for-Mac：时常统计软件" class="headerlink" title="Flow for Mac：时常统计软件"></a>Flow for Mac：时常统计软件</h3><p>Flow是一款Mac上的时长统计软件，它可以识别你使用的不同应用和在浏览器中访问的具体网站，从而告诉你在每天使用Mac电脑的过程中，占用时间最多的十个地方是哪儿。除此之外，所有的时长使用数据都保存在本地，绝不用担心隐私泄露的问题。除了帮你发现自己的时长信息之外，它还会根据连续使用的时长来提醒你应该休息一下，是一个非常贴心的小工具。</p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232ad40e24fb4?w=1378&h=766&f=jpeg&s=123050" style="zoom:50%" /><blockquote><p>下载地址：<a href="https://xclient.info/s/flow.html">https://xclient.info/s/flow.html</a></p></blockquote><h3 id="泼辣修图：适合小白的修图软件"><a href="#泼辣修图：适合小白的修图软件" class="headerlink" title="泼辣修图：适合小白的修图软件"></a>泼辣修图：适合小白的修图软件</h3><p>难得的国产精品，体积小，滤镜好看，操作容易，小白修图必备！顺便提一句升级pro版可以解锁全部滤镜.</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-f7cd222bf0ff5b55?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>下载地址：<a href="http://www.polaxiong.com/editor/0">http://www.polaxiong.com/editor/0</a></p></blockquote><h3 id="Mounty-for-NTFS：NTFS读取器"><a href="#Mounty-for-NTFS：NTFS读取器" class="headerlink" title="Mounty for NTFS：NTFS读取器"></a>Mounty for NTFS：NTFS读取器</h3><p>这个软件顾名思义是解决NTFS读取问题的，由于MacOS默认对NTFS的文件格式没有写的权限，所以需要有个软件可以挂载NTFS格式的文件，之前找过好多个，终于找到了一个开源免费的软件。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-01a6e36da9f44e3c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>下载地址：<a href="https://mounty.app/">https://mounty.app/</a></p></blockquote><h3 id="uTools：你的专属工具集"><a href="#uTools：你的专属工具集" class="headerlink" title="uTools：你的专属工具集"></a>uTools：你的专属工具集</h3><p>uTools是一个极简、插件化、跨平台的现代化桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。<br><img src="http://upload-images.jianshu.io/upload_images/5666077-9506b10af2815218?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上面是官网的介绍，功能也如截图所示，就个人体验来说，<code>⌥（option）+ 空格(space)</code>的快捷键还是很舒服的。</p><blockquote><p>下载地址：<a href="https://u.tools/">https://u.tools/</a></p></blockquote><h3 id="Vanilla：菜单栏管理神器"><a href="#Vanilla：菜单栏管理神器" class="headerlink" title="Vanilla：菜单栏管理神器"></a>Vanilla：菜单栏管理神器</h3><p>上面都推荐了那么多软件了，都有一个通病，就是使用的时候必须会停留在菜单栏的，久而久之菜单栏就全是图标了，无意中发现了这个软件，话不多说，直接看效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-d0a1592cd0bea813?imageMogr2/auto-orient/strip"></p><p>这个小工具可以大大的减少你菜单栏占据的空间，非常方便，最关键的是，免费！！！</p><blockquote><p>下载地址：<a href="https://matthewpalmer.net/vanilla/">https://matthewpalmer.net/vanilla/</a></p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果之后还发现了什么好用的软件或者一些Mac上的骚操作的话，我会继续更新的。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我今天开学啦～</title>
      <link href="p/76d2.html"/>
      <url>p/76d2.html</url>
      
        <content type="html"><![CDATA[<p>今天是我第一天来南大报道的日子。累了一天了，总算是有时间坐在电脑前写点东西了。</p><p>一大早起床就来到学院楼办理报到手续，提交完录取通知书、英语免修申请等一系列材料之后，终于拿到了期盼已久的校园卡。从今天开始就正式成为一名南京大学的学生了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwO0OMM96re93vtLiag7vJUDkRIpI6RW98n87pBPWWctdacRkdsgdTXFhfsWIGQsSZAkSgKY4ryefQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>学校还贴心的送了我们新生一个开学小礼品（虽然我觉得这个笑容有点嘲讽我太菜的意思）。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwO0OMM96re93vtLiag7vJUDNg7w3iaiaE83Gqicw06jicGyKGzXAqCvuf2YITxlBMesLdlbuKHyibRMMYw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>随后便是让我非常紧张的新生入学汇报工作。收到实验室通知的时候我就很奇怪，这人还没入学咋就开始汇报自己的工作了。但是一想大家都是刚入学应该不会说啥吧，顶多就是说说自己的技能，未来读研时期的计划啥的吧。可是当看到实验室同学的报告后我傻眼了，放几张照片感受一下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwO0OMM96re93vtLiag7vJUDVBdQKWTXELLBQgqzjAl3HOVZmeEJEfQ7ALEgDWHQtbrkXXC4ErH6Zg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwO0OMM96re93vtLiag7vJUDK2zW3NxYCcsr5DhKaeLic58X8pT7EuZGLp1ynjRQ9IjZWq0xrxcDFqA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwO0OMM96re93vtLiag7vJUDTF375BOTdFwXx4v4fDh1qib73F9hbm2yia9rmYxiaYHPC1nM1UgWsGqxA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>真的，当自己的ppt里面全是假大空的未来计划什么的，再看到这些人的东西真是想哭的心都有了。而且最最让我害怕的是，为什么他们汇报的东西我都听不懂。一想到自己这么长时间几乎都处于划水状态，我在台下真的是无地自容，心想着总不能第一天就被导师骂吧。接下来的过程我就不愿再回忆了，好在最后还算是平稳度过了。</p><p>晚上实验室举行开工宴，虽然知道实验室在团建方面一向是大手笔，但是看到下面的阵势还是惊了一下。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwO0OMM96re93vtLiag7vJUDvH1DITvggmjQsYSU2wxy2EDRicqIl5DTlqYOZHcwNbGXkSf7gEPa37g/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>（嗯。这只是其中一桌～）</p><p>总的来说，刚来的第一天过的紧张而又充实。深深的意识到了自己和周围人之间的差距，好在接下来还有几年时间可以提升自己，毕竟起点低才有上升的可能性啊！</p><p>开学了更新公众号的频率可能会有所下降（虽然原本更新的频率就很慢），但我仍会好好努力给大家分享优质的内容。如果大家有读研方面的问题也可以后台留言或者加我微信和我探讨。</p><p>最后给自己一个祝愿，希望接下来几年的研究生生涯可以过得充实又有趣，加油💪</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我不想加班，您看我还有机会吗？</title>
      <link href="p/9f8a.html"/>
      <url>p/9f8a.html</url>
      
        <content type="html"><![CDATA[<p>为什么大晚上更新，因为突然想写点东西，所以 7 点 40 就走了。走的时候心里竟然有点负罪感，不知道是不是我的问题。</p><p>今天早晨刚到公司的时候，看了老季的那篇《不要把周末主动加班的人当成异类》，虽然我很赞同老季在文章中的观点，但说实话，大多数人是没办法做到在周末主动加班的，毕竟国情在此，有双休的互联网公司也没多少了。</p><p>最近这段时间有关加班的消息貌似又出来了，刚有鹅厂工程师因「每天在岗不足 8 小时」被辞退，后脚就出来个海淀某互联网公司鼓励员工尽量住在公司。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyxhtxc4wj316607ydhm.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyxhylww2j31540pe7qq.jpg"></p><p>我知道这些公司是何居心，也知道员工们的无奈，可现实就是残酷的，996 喊出来才多久，007 就已经有多少了？今日割五城，明日割十城，然后得一夕安寝。起视四境，而秦兵又至矣。然则诸侯之地有限，暴秦之欲无厌，奉之弥繁，侵之愈急。故不战而强弱胜负已判矣。</p><p>2 个月前的今天，我满怀期待来到淘宝实习，毕竟这里是国内首屈一指的大厂，有高额的收入，有顶尖的技术人才，还有所谓互联网大厂的光环。我的主管很活泼（请原谅我用活泼这个词来形容我的主管），人很 nice，我的师兄也是一个非常努力、代码能力很强的人。在来这里之前，我一直以为我是喜欢写代码的，作为一个还没毕业的实习生，以前在学校看代码、打比赛、刷题，弄到凌晨 2、3 点都很有精神。可这两个月，让我越来越觉得对自己的兴趣爱好是不是有什么误解。每次回到家后，不仅不想看代码，甚至连电脑都不想打开。都说国内的安卓手机推送不行，可为什么我这大半夜还能收到钉钉的消息推送？</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyxia2qctj314h0u04r0.jpg" alt="image-20200721214622306" style="zoom:50%;" /><p>的确，阿里的技术积累很丰富，这两个月我也确实学到了很多很多东西，但这并不意味着我觉得工作到深夜是理所应当的。合同上写了工作 8 个小时，那么我就应该只要认认真真工作 8 个小时就好了。但是在目前国内这个氛围就不太对，似乎你 996 每天工作 12 个小时才是本分。要是 8 个小时准时下班，那么就是偷工减料。毕竟大家都加班，你走人岂不是成了“另类”？劣币驱逐良币就是这么来的吧。</p><p>回到开头，今天之所以回来早，是因为在实验室的群里看到了学长发的一条招聘信息，看完我就当场下班走人了：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyxis1shnj31520jm4ac.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyxil20zyj31rc0f0dk2.jpg"></p><p>我很纳闷，都这样明明白白的写出来了，真的不违反劳动法吗？我也不懂法律，不知道读者里有没有学法的普及一下知识点。🌚</p><p>当时春招找实习的时候之所以拒了字节跳动，很大程度就是因为字节是大小周，而双休已经是我的底线了。所以秋招大概率我也会扔掉他。我知道会有人说我过于矫情，你这每天 9 点就能下班，还有双休，抱怨个啥？我就纳闷了，8 小时工作日+双休不应该是我应得的吗？敢情我这 9 点下班还是资本家赏给我的？然而刚刚我才发现，可怕的并不是我 7 点 40 才下班回家，而是回家的时候心里有了负罪感。</p><p>当然，我写这篇也纯属是吐槽，毕竟这是行业现状，改变不了了，所以你问我支不支持，我当然说支持啊！已经到了这个程度，回头是不可能回头了，最佳的解决方案就只有加速了。90 后是独生子女的一代（虽然我不是），受父母的宠爱，心中有梦想和傲气。他们中很大一部分人，不懂“忍让”或者“权衡”，只是有那么一股骨气。这是一个非常好的趋势。现在我就想看看 007 普及以后社会主义市场经济体制下的人民富豪/前浪还能出啥新招？毕竟我们大家都有光明的未来！</p><p>今加一小时，明加二小时，然后得一夕薪水。起视公司，而加班又至矣。然则员工之时有限，老板之欲无厌，奉之弥繁，侵之愈急。故不战而强弱胜负已判矣。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyxn6t26dj30go0goabc.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开挂Lite | 一次简单的尝试</title>
      <link href="p/ffc5.html"/>
      <url>p/ffc5.html</url>
      
        <content type="html"><![CDATA[<p>官网：<a href="http://www.ytools.xyz/">www.ytools.xyz</a></p><p>我个人对软件开发是有一定偏爱的，我的梦想就是能做出一款让所有人都用上的软件，「开挂Lite」就是这个大梦想的一次简单尝试。</p><p>保研结束后，时间相对充裕起来了，再加上毕业设计是要做一个风格迁移的小工具，所以干脆就想把这个工具的功能拓宽一点，于是便有了「开挂Lite」。</p><p>其实这个小程序的功能非常简单，就是提供一些日常生活中可能会使用到的工具，例如车辆识别、食物卡路里识别、QQ音乐下载等功能。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g43zuht5dkj315t0u019c.jpg"></p><p>功能介绍什么的我就不多说了，直接看上面的图片吧。</p><h4 id="名字和logo的由来"><a href="#名字和logo的由来" class="headerlink" title="名字和logo的由来"></a>名字和logo的由来</h4><p>其实这个小程序刚做出来的时候想名字我也想了好久，但是总感觉哪里怪怪的，毕竟ios端有「捷径」，android端有「一个木函」，我这个小程序怎么也该有个能记住的名字啊，后来在和同学打游戏的时候遇到了几个开挂的，当时便想到既然游戏能靠程序开挂，生活为什么不能靠着程序<strong>开挂</strong>呢？</p><p>相比名字，logo的由来就很简单了，灵感来自雷神1中索尔重新举起雷神之锤的场景，因为锤子代表的是工具，锤哥又是我最喜欢的超级英雄之一，所以干脆就借鉴了这个画面。这里说句题外话，logo的制作网站是<a href="https://www.designevo.com/%EF%BC%8C">https://www.designevo.com/，</a></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g446qfigcxj31c00u0npe.jpg"></p><h4 id="下面简单说说这个小程序的架构吧"><a href="#下面简单说说这个小程序的架构吧" class="headerlink" title="下面简单说说这个小程序的架构吧"></a>下面简单说说这个小程序的架构吧</h4><ul><li>平台：微信</li><li>能力来源：百度AI，自己训练的模型</li><li>前端：html+css+js（官网）、微信小程序</li><li>后台：Flask,Nginx,Gunicorn,MySQL…</li></ul><p>因为不是第一次做小程序了，遇到的坑还是比较少的，代码我就不公开了，有兴趣的可以加我微信和我交流，觉得好玩的可以点下小程序里面的广告，就当是给我支持了哈。</p><h4 id="再谈点其他的"><a href="#再谈点其他的" class="headerlink" title="再谈点其他的"></a>再谈点其他的</h4><p>caoz在《你凭什么做好互联网》一书中提到了创业的四种冷启动方式：单点启动，单边启动，双边启动，多边启动，其难度和成本依次递增，而一旦启动成功，其竞争门槛则从低到高。</p><p>单点启动，简单说就是，一个人，一个客户，也能用起来。这种项目的特征非常明显，个体用户使用你的产品和服务时不会受到其他人、其他服务商的影响。因此对于一个穷学生/个人开发者，在没有资金注入、时间相对充裕的情况下，单点启动可以说是最好的选择了。因为这样的产品 ，启动推广可以慢慢来，不用担心说，我没有很多的用户，就会导致大量的流失，可以慢慢磨产品，针对每一个用户，客户的反馈去调整优化，直到产品打磨成熟，然后逐步推广做大。最常见的就是各种单机游戏、各种工具类应用。</p><p>很明显，「开挂Lite」就属于单点启动。不过就像开头说的，我只是把它当作是一次简单的尝试，并没有想着他能走多远，只要它真的可以为我、为周围人的生活带来一点点便捷，「开挂Lite」在我心中就已经成功了。</p><hr><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g446nr6eaoj30x80jwast.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何一步步 get 大厂前端 offer，你也许可以参考这份成长经历。</title>
      <link href="p/43d8.html"/>
      <url>p/43d8.html</url>
      
        <content type="html"><![CDATA[<p>之前在<a href="https://mp.weixin.qq.com/s/MgKYMxyhzHK80jKwYFXypQ">《前端菜鸟的阿里实习百日之旅》</a>一文中，我的好友「承和」分享了一些作为前端开发实习生的感悟，文章发出后，很多人在后台询问能不能谈谈前端的学习路径，以及作为一个萌新如何拿到大厂的前端 offer。的确，秋招已过去大半，下一波待就业的应届生们也可以开始考虑实习和春招了，为此，本文以 Q&amp;A 形式邀请了他来讲述他是如何一步步 get 大厂的前端 offer，希望他的成长经历可以为正在准备的人带来一些启发。</p><h3 id="Q：初来乍到，先做个简单的自我介绍吧"><a href="#Q：初来乍到，先做个简单的自我介绍吧" class="headerlink" title="Q：初来乍到，先做个简单的自我介绍吧"></a>Q：初来乍到，先做个简单的自我介绍吧</h3><p>「01 二进制」的读者，你们好，我是承和，目前是一名计算机专业的研三学生，就读于杭州电子科技大学，本科就读于马爸爸的母校，也就是杭州师范大学。在此次秋招中，很幸运的拿到了阿里，字节，拼多多等公司的 Offer，希望我的成长经历能对你们有所启发。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjn7cczlj308w06o42v.jpg"></p><h3 id="Q：能不能简单说说你这些年的前端学习经历呢？"><a href="#Q：能不能简单说说你这些年的前端学习经历呢？" class="headerlink" title="Q：能不能简单说说你这些年的前端学习经历呢？"></a>Q：能不能简单说说你这些年的前端学习经历呢？</h3><p>说起前端，其实我最早接触的是 iOS 客户端开发。在我大二的时候，苹果发布了最新的开发语言 Swift，恰巧在当时，我在编程上的启蒙老师所在的实验室正在招新，听说加入还会分配 MacBook，于是我马上联系了他。就这样我顺理成章的白嫖到了一台 MacBook Air 笔记本，而当时分配到的任务是开发一款 App，也正是从这个任务开始，我走上了软件开发这条不归路。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjnky0cij30ff0a9mxl.jpg"></p><p>后来实验室为了减少开发和维护的成本，导师让我学习有关跨平台应用开发技术，也正是从那时起，我逐渐接触到前端开发。在学习过程中，我发现，相对于客户端，前端开发有更广的发展空间，再加上当时客户端的就业形势是**”49 年入国军”**，因此，毅然决然地选择了前端开发。</p><p>再后来，读研期间，学习了点深度学习的相关知识，发现这玩意儿极其烧脑，加上国内学术圈又相当浮躁，多数研究生基本都是为了发论文而发论文，很少有能实际落地应用到工程之中的。加之现在算法岗 hc 非常少，大厂的算法岗几乎是神仙打架，想着肯定是没办法靠算法吃饭了，所以又重新投入到了前端的怀抱中，从 0 开始学起，好好沉淀自己的前端技术。</p><h3 id="Q：你这也算是有了几年开发经验的老鸟了，要不简单谈谈你是如何学习前端技术的？"><a href="#Q：你这也算是有了几年开发经验的老鸟了，要不简单谈谈你是如何学习前端技术的？" class="headerlink" title="Q：你这也算是有了几年开发经验的老鸟了，要不简单谈谈你是如何学习前端技术的？"></a>Q：你这也算是有了几年开发经验的老鸟了，要不简单谈谈你是如何学习前端技术的？</h3><p>我个人认为，学习编程就和练武一样，学习任何一门技术都是<strong>修炼内功</strong>和<strong>学习招式</strong>的过程。内功指的就是基础，就前端领域而言，也就是我们常说的前端三板斧：<strong>HTML、CSS 和 JS</strong>。我们可以根据网上较流行的知识图谱或者一个面试宝典，进行初步的学习。若想要深刻了解的话，便要通过阅读大量相关的专业书籍来加强理解（后面我也会推荐一些，此处没有广告，可放心食用）。</p><p>招式指的便是各种<strong>前端框架</strong>，这些框架帮助我们封装了底层对于 dom 的操作等，使我们能够专注于业务代码的编写。现如今国内 Vue 和 React 大行其道，但是作为 JS 革命性的框架之一，jQuery 我们自然不能忘记，该框架非常适合前端入门者进行学习。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjp0fxpij31950u0k21.jpg"></p><p>对于框架的学习大致可以分为以下 3 个步骤 👇：</p><p>第一步，学会<strong>招式的使用，</strong>你要学会怎么用它，知道这个框架究竟解决了哪些问题，这些资料最好的获取方式便是官网，例如 React 官网，便清楚的说明了 React 的用途，在开发中大多数遇到的问题也能在 React 官网上找到解决方法。</p><p>第二步便是用框架做一个项目，在编写项目的过程中，你会遇到很多”稀奇古怪”的问题，通过解决这些问题，可以加深你对框架的理解。</p><p>第三步要做到知其然知其所以然，在熟练掌握框架的使用后，去学习它的源码，去看一些源码解析或者大佬的直播课，最好是自己手动实现一个类似于 React 的 diff 算法。</p><h3 id="Q：在学习的过程中，有什么需要注意的呢？"><a href="#Q：在学习的过程中，有什么需要注意的呢？" class="headerlink" title="Q：在学习的过程中，有什么需要注意的呢？"></a>Q：在学习的过程中，有什么需要注意的呢？</h3><p>在学习过程中你会接触到非常多的知识点，难免会产生焦虑，这时候要做的就是定义一个边界，做到对另一个知识点的探索<strong>适可而止</strong>。</p><p>例如，在利用 React 脚手架的开发过程当中，我们会接触到 Webpack，我们可以先用脚手架中 Webpack 默认配置来进行项目开发，去了解 Webpack 的功能和大致打包流程，来做到对 Webpack 的整体认识，在后续进行项目优化时，可以尝试对默认配置进行修改，通过熟读 Webpack 官网，了解针对 Webpack，我们有哪些优化手段，并且付诸于实践，在工程当中加深自己对于框架和工具的理解。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjr8hph8j31900u0gqf.jpg"></p><p>上述是如何学习一个前端框架的简单例子。我们有时候会感叹，这么多的知识点，我们如何来进行学习，这也是国内技术面试的现状：<strong>面试造火箭，工作拧螺丝</strong>。在准备面试的过程当中，我们可以通过一个面试宝典或知识点的总结来系统的学习前端，随后其余教程和专业书籍加深你对知识点的理解，根据人类的遗忘周期，大概会在第二至第三天会忘掉大部分第一天学习的知识，因此，通过反复学习，反复理解，<strong>达到内功和招式的相互影响，最终修炼成功！</strong></p><h3 id="Q：作为一个-Offer-收割机，关于前端面试你有什么想说的呢？"><a href="#Q：作为一个-Offer-收割机，关于前端面试你有什么想说的呢？" class="headerlink" title="Q：作为一个 Offer 收割机，关于前端面试你有什么想说的呢？"></a>Q：作为一个 Offer 收割机，关于前端面试你有什么想说的呢？</h3><p>正如上文提到的，国内现在的技术面试基本是“面试造火箭，工作拧螺丝“，在准备面试过程当中，要求我们既有较广的知识面，又需要在一个领域有比较深入地研究。比如面试官会非常感兴趣问 React 源码相关的一些问题，这可能在我们的工作过程当中基本接触不到，因为一般的大厂都有自己的组件库和针对自己的业务，会对市面上较流行的脚手架工具都做一层封装，大部分的开发人员都属于”搬砖“的角色，也就是完成特定的任务即可。所以，这时候就会用人问了，明明是工作中不常用的知识点，为什么面试官就喜欢问呢？</p><p>个人看来，问源码能考察一位同学对该项技术是否有思考和热情，因为框架的使用基本每一个人都会，然而对于源码的阅读和理解，有助于更深层次的去理解框架，在开发中遇到一些问题时，也能够更加快速的去定位问题，有相应的方法去解决。将来在做业务的技术选型时，因为你知道各个框架的利弊，所以能够更加快速的做出决策和进行开发。这也就是面试官喜欢考察源码的原因，在原有的广度基础上，来查看我们的知识点深度究竟在哪里。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjrjl8ayj318z0u0td2.jpg"></p><h3 id="Q：简单分享一下你的面经吧"><a href="#Q：简单分享一下你的面经吧" class="headerlink" title="Q：简单分享一下你的面经吧"></a>Q：简单分享一下你的面经吧</h3><p>面试一般分为三个部分，自我介绍，面试官提问，和同学提问。其中第一部分和第三部分我们需要进行详细的准备，自我介绍准备一分钟左右时长即可，对于应届生来说，可能没有太多的项目经验，我们可以介绍下自己学习前端的过程和相对比较擅长的技术栈，有目的性的来引导面试官问对应的问题。面试官基本也会挑你简历上写的知识点来问，这时候就要求我们对简历上的每一个知识点都要做到胸有成竹，在写该知识点的时候，可以模拟下面试官可能会问些什么问题，对知识点进行总结和有逻辑性的表达，在回答过程当中也可以合理的“埋坑”，引导面试官往自己擅长的知识点上问。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjtwg27vj31960u0gu5.jpg"></p><p>举一个较简单的例子，浏览器中输入 URL 究竟发生了什么，你回答了相关步骤中有一步为浏览器根据返回的状态码进行判断再进行后续操作。那么接下来面试官可能会问你你了解到的状态码有哪些。你经过准备也知道这个知识点，便能自信的回答。在最后一个环节反向提问的过程中，可以针对职位相对应的技术栈和相关的业务，或者此次面试过程中有什么不足点，有什么建议进行提问，有时高质量的提问也能提升面试官的印象分。在面试后我们要进行及时的复盘和总结，例如每一个提问知识点的及时记录，对于在此次面试过程中发挥不好的地方，及时想出对应的方法总结，有利于在下次面试中更充分的发挥自己的实力。</p><h3 id="Q：要不推荐一些资料呗？"><a href="#Q：要不推荐一些资料呗？" class="headerlink" title="Q：要不推荐一些资料呗？"></a>Q：要不推荐一些资料呗？</h3><p>下面是我个人推荐的较好的学习资料，既有书籍也有博客等。</p><ul><li>HTML：基本概念和常用标签的掌握，h5 新标签和新特性。html 语义化等。</li><li>CSS：《CSS 世界》(从流的概念来讲解) ,flex 布局(阮一峰教程)。</li><li>JS:《JavaScript 高级程序设计第 4 版》(红宝书反复看) 《你不知道的 JS》《javascript 语言精髓与编程实践》</li><li>ES6:菜鸟教程 ES6(大致浏览新特性) 《阮一峰 ES6 标准入门》(api 细节查看)</li><li>Typescript:ts 官网，<a href="https://www.cnblogs.com/sexintercourse/p/11961086.html">一文学会 TypeScript 的 82% 常用知识点（上）</a></li><li>Vuejs:vue 官网(建议花 2-3 天完完整整的看下来)，  《剖析 vuejs 运行机制》(染陌大佬编写)     <a href="https://www.bbsmax.com/A/lk5aPaE4J1/">逐行分析 vue 源码</a></li><li>React:react 官网，《深入浅出 react 技术栈》，<a href="https://react.iamkasong.com/#%E7%AB%A0%E8%8A%82%E8%AF%B4%E6%98%8E">React 技术揭秘</a></li><li>Webpack:webpack 官网，《深入浅出 webpack》</li><li>Node:nodejs 菜鸟教程(快速上手),《深入浅出 nodejs》(掌握 node 的事件循环和垃圾回收算法，有精力可以研究 v8 源码)。</li><li>计算机网络：《图解 HTTP》(反复看)，《计算机网络》(谢希仁著)</li><li>数据结构：《算法》(书名就叫算法，虽然是 java 写的，但也能看得懂)。</li><li>设计模式：《javascript 设计模式与开发实践》</li><li>知识点总结和面试宝典：<a href="https://www.nowcoder.com/discuss/258810?type=post&order=time&pos=&page=3">个人秋招经验总结(前端方向)</a>  <a href="https://www.cxymsg.com/guide/">前端面试与进阶指南</a></li></ul><p>子弈大佬的面经: <a href="https://juejin.im/post/6844904116590739469">个人前端资源汇集（持续更新）</a> <a href="https://juejin.im/post/6844903928442667015">面试分享：两年工作经验成功面试阿里 P6 总结</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjujbf2mj30d10hddrx.jpg"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这便是简单的一些前端学习和面试经验的分享，希望对你的前端学习和面试都有一定的帮助。欢迎各位读者留言讨论，也欢迎添加我的微信，进一步的交流和分享前端经验，预祝小伙伴们都有自己满意的 offer！</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmjuweypyj309t0d4418.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好久不见</title>
      <link href="p/f449.html"/>
      <url>p/f449.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.ytools.xyz/uPic/9hWcfiKWcVEhPeHcGvXUKjSpMEs7MQno7tFAwez2WYYAtgRQXcTp9hKZXKSbWopRoBLPcxbucwCFumXUWAAXFY3g.jpeg"></p><p>今天登录公众号后台看了一下，上一篇文章已经是 2 个月前写的了。</p><p><img src="https://cdn.ytools.xyz/uPic/Y0GcKJimage.png"></p><p>其他平台也基本属于停更状态，这段时间一直在忙毕业设计和论文的事情，属实有些耽搁了，不过今天刚好把毕业论文提交了，毕业的倒计时也开始了。想着从下周开始，我就准备恢复更新了。今天就先水一篇，讲讲最近停更期间发生的一些事情吧。</p><h2 id="毕业设计和论文"><a href="#毕业设计和论文" class="headerlink" title="毕业设计和论文"></a>毕业设计和论文</h2><p>熟悉我的读者应该知道我现在还没毕业，今年 6 月份才能拿到我的硕士毕业证。总体上来看，我读研的这两年还是比较快乐的，科研的压力虽然有一些，但因为是推免的进实验室比较早所以也就提前适应了。研一的课程虽然比较多但是难度适中，再加上去年碰到了疫情，很多时间都是在家中度过，之后暑期去实习了几个月就回学校了，研二因为实验室已经来新人了相对就轻松了些，等之后找个时间写一篇文章专门聊聊这几年读研的生活。</p><p>其实读研期间我没有做出什么成果，主要还是因为自己的想法就是找工作，不想花那么多时间浪费在一些无关紧要的事情上，所以这个毕设可以算是我读研期间为数不多的成果之一了。大体框架如下：</p><p><img src="https://cdn.ytools.xyz/uPic/LvKPKjimage%20(1).png"></p><p>和大多数软件系学生类似，我的毕设也是一个 XXX App，用的技术也是很常见的一些技术，Flutter、Spring Cloud、Docker、MQ 这些，但是涉及的领域是我比较喜欢也比较看好的智能家居领域。</p><p>我自己是一个智能家居的爱好者，也爱好捣鼓，所以在家里也购买了一些小米智能家居和苹果智能家居的设备，读研的时候恰好学长就给我安排了一些和智能家居有关的活，虽然活不是很多，难度也还好，但因为自己喜欢也就坚持着做了，所以毕设也就恰好选择了这个方向。做下来这段时间，总体感受还是很不错的，如果有学弟学妹读研之后不知道选什么方向的，这个领域可以涉及下，还是挺好玩的。</p><h2 id="多平台短视频发布工具-MediaPub"><a href="#多平台短视频发布工具-MediaPub" class="headerlink" title="多平台短视频发布工具 MediaPub"></a>多平台短视频发布工具 MediaPub</h2><p>其实这两个月里，除了在忙活毕业设计和毕业论文，我还在捣鼓另一个东西，也就是一个多平台短视频发布工具 MeidaPub，做这个工具的初衷就是实现一个可以一键将短视频发布到多个平台的工具，提高一些视频制作者的发布效率，其实已经开始内测了，之前也贴出了<a href="https://mp.ytools.xyz/">官网地址</a>和<a href="https://www.yuque.com/docs/share/40d36f90-db5d-4816-8cbe-8f3d35356eef">使用说明</a>，目前看来用户不是很多，可能是跟宣传有关吧，不过好在还是收集到了一些测试反馈，之后我也将会持续更新这个软件。</p><p><img src="https://cdn.ytools.xyz/uPic/Niptecimage%20(2).png"></p><p>其实最近也在忙活着给他来一个大版本的更新，未来可能也会把图文多平台发布也加进去，有兴趣的小伙伴也可以联系我一起搞点事情。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>简单聊了聊最近停更期间做的一些事，接下来要忙活的应该就是准备毕业答辩和旅行了，公众号文章我也会持续更新下去，还有就是之前一直说的要写的 Spring Boot 入门教程，虽然中途写到了第二章就停更了，不过近期也会慢慢拾起的，最后希望接下来这段时间可以顺利的从科研狗 🐶 过渡到打工人 👨‍🔧。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学生该不该接私活？</title>
      <link href="p/98b8.html"/>
      <url>p/98b8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2gh7ye24sj30go09k0to.jpg"></p><p>之前有说过要开一个新的系列的，那个系列最新的一篇已经是快一周前了，可能会有人奇怪我干嘛去了，为啥一直没有更新（也有可能是我想的太多）。其实我这周的主要就做了两件事，做毕设和复联4。不过这毕设不是我的毕设，而是我接的其他人的毕设，这也是我写这篇文章的原因。我想从我个人的经历看看我们大学生究竟该不该接私活（临时加需求真是太痛苦了）？</p><h3 id="这是一个纠结的话题"><a href="#这是一个纠结的话题" class="headerlink" title="这是一个纠结的话题"></a>这是一个纠结的话题</h3><p>其实这个话题特别的纠结，为啥呢？原因有二，其一是因为现在还是大学生，学业仍然是第一要素，如果把心思过多的放在这些和学习无关的事情上，对之后的升学可能会有影响。其二就是因为穷，尤其是作为一个大学萌新，从高中的牢笼解脱，女生有那么好看的衣服想穿，男生有那么多游戏装备想买，但是每个月生活费就那么点，你说着不着急？</p><p><img src="https://ws2.sinaimg.cn/bmiddle/006tNc79ly1g2ghjkgb29j30j60ej3yz.jpg"></p><p>但是急能怎么办？急就有钱了？肯定不会啊，所以也就有了校园兼职这一说。就我个人而言，我从大一开始就接触了一些兼职，我去过物流中心搬过快递一晚上100、做过家教一小时30、送过外卖一单5块，卖过电话卡（记不得一单多少了，但是那一天赚了600，现在大三软工的学弟只要是移动卡的多半是我当初帮他们办的），当然还有些临时的，零零散散的做了好多，但是单论价钱的话都没有接一个私活来的多。</p><h3 id="从实例出发"><a href="#从实例出发" class="headerlink" title="从实例出发"></a>从实例出发</h3><p>举个我自己的例子，我之前接过一个私活，是一家材料厂，为了应付上面检查，要有一个出入库的管理软件（app+后台），让我两天内做完，最后那老板给了我3000，其实这玩意大家也都知道，无非就是增删改查，而且目的也就是为了应付检查，所以不需要考虑太多，能跑就行。我当时也就加了一晚上班就做出来了。而且难度不大，会安卓+随便一种后台就足以应付了，你说这钱赚的是不是很舒服？</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2gij7nv44j305i05i74e.jpg"></p><p>但现实真的这么美好吗？我再举个例子，我大三的时候，手头正缺钱（因为当时准备保研发期刊是需要money的），一个<strong>认识的人</strong>找到我问我能不能做毕业设计，我当时看了下他的开题报告觉得没什么问题就接了，顺便包论文，东西在他中期答辩前就弄完给他了，当时还觉得这两千块钱赚的真舒服。结果后来那个人找到了我，说他老师觉得他完成的工作太简单了，任务量不够，要加些内容（都是些乱七八糟的想法），否则不给我尾款（先给了500定金的），那个时候论文我已经写了一半了，碍着那钱我心想忍忍就算了，结果后来论文又说不合格，得改，那大半个月真的是前前后后几乎啥事没做全去忙他那个傻X玩意了。</p><h3 id="从经济学入手"><a href="#从经济学入手" class="headerlink" title="从经济学入手"></a>从经济学入手</h3><p>有了上面两个例子，你觉得我们大学生要不要接私活呢？在回答之前我先说一个经济学的知识，叫做<strong>比较优势理论</strong>，是我之前看薛兆丰的经济学看到的，他的核心是：自己跟自己比，总有效率比较高、成本比较低的生产项目，专注这种生产项目然后跟别人进行交换，整个社会的财富就能够增加，而个人的财富也能够增加。假设盖茨家有块草坪，他自己打理需要2小时，请隔壁王大爷打理需要3小时，那你觉得盖茨是会自己打理草坪还是请王大爷打理呢？那肯定是请人打理了（除非他自己想体验生活），因为这两小时他都不知道可以赚多少钱了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2gj4j40p0j30d00gojsx.jpg"></p><h3 id="该不该接私活？"><a href="#该不该接私活？" class="headerlink" title="该不该接私活？"></a>该不该接私活？</h3><p>这么看来，你翘课去做外包，接私活好像也没什么不对，毕竟上一节课就要花23块钱。但真的是这样吗？对我们大学生来说财富二字难道可以狭义的理解为money吗？当然不是，你的财富除了你能掌握的金钱，还有就是你的精力和时间（我这几天没怎么更新公众号也是因为最近接了一个毕设）。我的好朋友🐔哥前两天也写了一篇关于接外包的文章：<a href="https://mp.weixin.qq.com/s/zogbbE9ku3Oh6wT4cY6Yhw">《怎么接外包？该不该接外包？几次踩坑后的思考》</a>，他提到了收入分为两种形式：<strong>主动收入和被动收入</strong>。主动收入可以理解为，我给老板打工，老板给我发工资，<strong>我追着钱跑</strong>。被动收入可以理解为我花一些时间后，钱就会追着我跑，因此也就被形象的称为”睡后收入”。最简单的，我写完了这篇文章，开了赞赏，就去睡觉了，你早晨起来看到觉得写得还不错，给我赞赏了2块钱，等我起床发现自己余额多了两块，这就是”睡后收入”了。</p><p>所以作为一个即将毕业的且踩了些坑的大四老狗，我对大学生要不要接私活这个问题的看法是<strong>NO</strong>，除非自己真的是非常缺钱并且时间相对充裕的情况，否则不如好好培养自己”睡后收入”的能力。</p><h3 id="其他赚钱的方式？"><a href="#其他赚钱的方式？" class="headerlink" title="其他赚钱的方式？"></a>其他赚钱的方式？</h3><p>如果你觉得你的编程能力足够优秀，而且也不想浪费这个优势，我建议你可以试试去参加各类学科竞赛，中国最不缺的就是各种比赛，如果你觉得你足够优秀那么水几个比赛，拿几个奖金自然也是不在话下了，再加上有的学校老师会报销一些研究经费以及竞赛奖励（这些钱估摸着得有大几千，虽然也不多，但是对于一个普通的大学生来说也是一笔不小的财富）。</p><p>如果你想到了好玩的点子，做成app，万一火了，其实大学的学费都能供给了，大学里面很多有钱的学生，他们很多都是自己在大学之前写app赚钱的，现在时下流行，代码经验同样可以为日后生活积累。</p><p>当然如果想赚钱其实还有更好的办法，那就是好好学习，然后收割各种奖学金，比如国家奖学金、励志奖学金、学校的人民奖学金、一些企业的奖学金。我周围就有一个同学，年年奖学金拿到手软（拿到的钱都是以w为单位），好生羡慕😂。</p><h3 id="一点建议"><a href="#一点建议" class="headerlink" title="一点建议"></a>一点建议</h3><p>虽然上面说了那么多 ，但是你仍然有可能会手痒想接外包（毕竟贫穷使人接活），那么作为一个负责任的博主，我就结合自己的经历提点建议吧。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2gjy4o3xyj3069069gme.jpg"></p><ol><li>不接熟人的私活</li><li>不接没有详细需求的活</li><li>不接屁事多的甲方的活</li><li>不接没有现成解决方案的活</li><li>不接要写论文的毕设</li><li>会后台的前提下去学着做app</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>身为未来码农的你在上学的时候还不找女朋友？难不成等着工作之后国家分配吗？</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又要春招了？</title>
      <link href="p/bc8a.html"/>
      <url>p/bc8a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ytools.xyz/uPic/recruitment-3709595_1920.jpg"></p><p>去年四月的时候，我在公众号「01 二进制」发了几篇和春招面试有关的文章，眼瞅着现在已经 2 月底了，马上又到了一年一度的春招黄金时期，即将找工作的你做好准备了么？</p><p>作为一个经历过春招的老狗，我决定在今年的金三银四到来前梳理下对大家春招可能有帮助的文章，也算是回馈我为数不多的公众号粉丝了，如果你觉得对你有所帮助，还请大家点赞关注支持一下 🌹</p><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p><img src="https://ytools.xyz/uPic/question-mark-2492009_1920.jpg"></p><p>作为一个计算机专业的学生，想要找到一份好的工作，知识的储备是毋庸置疑的。去年，我在公众号开了一个「技术科普」专题系列，主要是做一些知识的分享，争取用通俗易懂的方式介绍一些计算机知识，其目的就是要扩展读者们的知识面。</p><p>技术科普系列的链接在这 👉<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2ODAyNTgyMQ==&action=getalbum&album_id=1418449495750311936">技术科普系列</a>，其中有一些我觉得对你们的面试可能会有些帮助。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/p_Dg5CHUeyS80J7OEvJeRQ">如何向女朋友解释在地址栏中输入网址后发生了什么？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/J15PdJ5fgZW2g8oa0HVPHw">科普系列——如何解释什么是 AJAX？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247484125&idx=1&sn=0fd9a6d7ef5949226227f64153eff21a&chksm=ceb3d66ff9c45f79970111144c9f23c79537795b37c5e9b617c7523a730bd6117b9205be71d5&scene=178&cur_album_id=1418449495750311936#rd">科普系列——从网购/直播入手理解什么是 CDN</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247484290&idx=1&sn=fea14e612baf388e97695dd77f39873b&chksm=ceb3d730f9c45e2633d21739ebeabc6b6e9ab530e0eced6773bea3fb21116d8dc801ecc9cf44&scene=178&cur_album_id=1418449495750311936#rd">聊一聊 RPC</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247484302&idx=1&sn=42f10b35ec595195697ce5b6aa3870b4&chksm=ceb3d73cf9c45e2a9f56ea820db3ee99c8f55c58aebde1d3d287489d032b46dbb20fb568a8d6&scene=178&cur_album_id=1418449495750311936#rd">浅入浅出消息队列</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247484452&idx=1&sn=1e5c69796e14d98e807ad6e9f413f7a1&chksm=ceb3d096f9c45980915c35641bb6524ccdf1c7418b356deebfb6478ee8a6b11bb077ac851be2&scene=178&cur_album_id=1418449495750311936#rd">接口调度者——API 网关</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247484517&idx=1&sn=3f2d1ed9f388057bfa2ede3eb510f642&chksm=ceb3d0d7f9c459c11fd24dd96d6e99158589c81fe5ecb52d353f642cc527872744a24d853c06&scene=178&cur_album_id=1418449495750311936#rd">想追女神？先学 Synchronized 吧</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247484553&idx=1&sn=132a24db34dc55a11be68cbb738a5631&chksm=ceb3d03bf9c4592dcc8c64419cafbb2461128a8f11767fe66592dc96ed69f7b520ca0d6356c9&scene=178&cur_album_id=1418449495750311936#rd">互联网是如何工作的？</a></p></li></ul><h2 id="面试时的刁难问题"><a href="#面试时的刁难问题" class="headerlink" title="面试时的刁难问题"></a>面试时的刁难问题</h2><p>对于校招生而言，面试官除了会检验一些基础知识，还会额外的对面试者的思考能力做一个评判，方式就是通过提出一些“八股文”之外的问题，所谓面试中的“八股文”也即各种面试宝典、面试题库里的题目。GitHub 上有很多这样的仓库，我就不一一举例了。</p><p><img src="https://ytools.xyz/uPic/head-1965671_1920.jpg"></p><p>在掌握“八股文”外，如果可以对场景有更深层次的思考，是可以在面试中加分的。去年我同样在公众号中开了一个新的系列「每周一问」，目的就是解决一些在编程中遇到的一些可以让人产生疑惑的小问题，如果面试中问道了，而你刚好又看过了，岂不是赚了？</p><p>比如说<a href="https://mp.weixin.qq.com/s/nkU1kBTzfG8C_EJhj53a3A">为什么我们需要批量操作？</a>就是我在淘宝转正面试时遇到的一个小问题，其实答案稍加思考就可以得出，只是平常我们很少对自己问出这样的问题，如果突然被问到可能会慌。虽然这个系列目前的文章数量比较少，但是我一直在更新，还请大家多多关注。</p><p>每周一问系列 👉<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2ODAyNTgyMQ==&action=getalbum&album_id=1456084819246809089&scene=0&from_msgid=2247484629&from_itemidx=1&count=10%23wechat_redirect&subscene=91&sessionid=1606920527&enterid=1606920640">每周一问</a></p><p>推荐文章 👇</p><ul><li><a href="https://mp.weixin.qq.com/s/gnKt-jwGRJFqmBq4zFUSfQ">为什么不建议在 for 循环里捕捉异常？</a></li><li><a href="https://mp.weixin.qq.com/s/iIghGgzZ43ssCs-_Pn3_Gw">API 与 SDK：有什么区别？</a></li><li><a href="https://mp.weixin.qq.com/s/nkU1kBTzfG8C_EJhj53a3A">为什么我们需要批量操作？</a></li></ul><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>「<em>Talk is cheap</em>. _Show me the code_」作为一个计算机专业的学生，编程能力无疑是最重要的，而想要在短短一小时的面试时间里判断出你的编程能力，最好的办法就是做题了，这个题目可能是算法题、也可能是面向对象的设计题，当然也有可能是写脚本的题目。因此平时的做题训练是必不可少的，我之前也曾在公众号中发过力扣的题解系列，可后来由于阅读量惨淡也就没有坚持下去了，这里我就不推荐了，建议大家自己去力扣上多刷题，上面有很多大神的题解。</p><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p><img src="https://ytools.xyz/uPic/application-1756282_1280.jpg"></p><p>想要面试，第一步一定是投简历，因此简历的编写是一个极其重要的环节，我曾见到过很多人把无关紧要的信息填充在简历的正中央，这样显然是不好的。之前我在<a href="https://mp.weixin.qq.com/s/A3HiLWg3i36LCRJaVUSqdA">计算机相关专业实习指北</a>一文中曾简单聊过如何去写简历，但也没有系统整理过，不过我的好友寒食君曾有一篇关于写简历的文章，我觉得还不错，这里分享给大家 👉<a href="https://mp.weixin.qq.com/s/GdHE6q1e7SrmnNOX2rofpg">收到上百份简历，其中一半被秒拒，原因出在这三个地方</a></p><h2 id="面试心得"><a href="#面试心得" class="headerlink" title="面试心得"></a>面试心得</h2><p><img src="https://ytools.xyz/uPic/sparkler-677774_1920.jpg"></p><p>每一次面试都是一次重要的经历，而在面试完有没有好好整理总结面试中出现的一些情况更是衡量是否是一个好的面试者的因素。吾日三省吾身，面试完后回顾之前面试过程中可能犯的错、总结自己回答的好与回答的不好的地方相信对下一次的面试会有正面的帮助。之前我就在我的公众号中发过一些我以及我的好友们面试的一些分享和经验总结，不只是面经，这里列出来，希望能有所帮助。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/A3HiLWg3i36LCRJaVUSqdA">计算机相关专业实习指北</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/yAah1_flUDt6D4dCulh-3A">从三本到 985 再到微软，他做了这些！</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/i9d0AT2pnjetfQOfh2ltYA">一个科班小前端的大厂面经</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/siqmHsHyEYxNIwj26R6tNA">搏一搏，单车变摩托，记录一下我的淘宝实习面试</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/mv4OSgo28Y1-PVxbQpt9Eg">刚完一波蚂蚁金服的面试后，他说他累了</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9ssXDvG3AAWxCpZl2WqiYQ">未雨绸缪，小米前端实习面经</a></p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是我整理的我的公众号中可能会对大家面试有帮助的一些文章了，今天推荐的文章基本上都是我的原创文章，如果你觉得对你有所帮助，还请大家点赞关注支持一下 🌹</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刚上大学？过来人给你提些建议</title>
      <link href="p/a1a7.html"/>
      <url>p/a1a7.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g47n0jkemgj30zk0j9djs.jpg"></p><blockquote><p>本文是我大四保研之后学校老师让我去给当时的新生做的分享的内容，偏口语化，现在过去也有将近一年时间了，有些学弟学妹给我发消息说很感谢当时的分享，如今正好又到了新生入学的时候，我也开启了新的征程，就当是过来人给的建议了。以下是当时的分享内容。</p></blockquote><p>很高兴收到王老师的邀请来到这和学弟学妹做一个有关自己这几年大学经历的分享。首先我先自我介绍下，我叫XXX，来自15级软件工程。</p><p>不知不觉你们都已经在大学度过3个多月了，不知道你们现在对大学都有一个什么样的认识，我当时来的时候特别的迷茫，因为刚从高三那个紧绷的环境过来，宛如一匹脱缰的野马，自由但是没有方向，说实话我很羡慕你们在这个阶段可以有学长和学姐引导，我刚来的时候只有一个告诉我上大学只要不挂科就ok的学长，而且当时我还奉为人生信条。</p><p>今天我来不是跟你们说要你们好好学习之类的，因为那没什么用，自助者天助，我今天来是想把我从入学到现在所遇到的一些困扰来和你们分享，相信对你们应该会有所帮助。</p><h3 id="第一，大学的目的是什么？"><a href="#第一，大学的目的是什么？" class="headerlink" title="第一，大学的目的是什么？"></a>第一，大学的目的是什么？</h3><p>我问问你们，你们觉得大学的目的是什么？我以一个同龄人且是过来人的身份告诉你们，在我眼里，大学4年，如果你能明白自己就行想要怎么活，你的人生想怎么过，你最想要得到的是什么，就足够了。</p><p>有的人大学不学习只玩游戏，有的人大学不玩游戏只学习，有的人大学什么不做只恋爱，有的人大学就要找个白金男。</p><p>很正常，你可以说玩游戏是浪费生命怎么的，也可以觉得天天逃课的都是傻逼，也可以觉得去学生会做事的就是浪费时间。如果你就是喜欢玩游戏，并且认为自己能够为止奋斗一生那么就去做吧，其他人怎么评论又如何，难道只有拿奖学金是牛逼的？</p><p>如果你认为人生就应该平平淡淡娶妻生子 ，乖乖念书然后去找工作一步一步过有什么不好？比起那些会为玩游戏而抛弃一切的我更鄙视那些什么都想做什么都要做，结果机会给他了又开始说这个不会那个不会的人。找到那个最美的自己，然后为之不断奋斗，这是我在大学的最大体会。</p><h3 id="第二，你对学校失望吗？"><a href="#第二，你对学校失望吗？" class="headerlink" title="第二，你对学校失望吗？"></a>第二，你对学校失望吗？</h3><p>扪心自问下，你们来到这也有3个月了，你们对这个学校失望吗？我刚来的时候对这个学校真的是非常非常失望，论面积不如我的高中；论地理位置，夹在南京和扬州中间，尴尬；那图书馆，随便找个别人家的大学都比我们气派，就更别说学校的食堂、宿舍了。你问我失不失望，失望呀，可是我不能对我自己失望啊。一只站在树上的鸟儿，从来不会害怕树枝断裂，因为它相信的不是树枝，而是它自己的翅膀。与其每天担心未来，不如努力现在。自己努力做到最好，那么人与环境均为一流。</p><h3 id="第三，我需要合群吗？"><a href="#第三，我需要合群吗？" class="headerlink" title="第三，我需要合群吗？"></a>第三，我需要合群吗？</h3><p>我需要合群吗？这个问题我在大一的时候反复的问我自己，我需要合群吗？那个时候的我为了合群，我积极参加了社团活动，去不断的认识新的人，这种状态我一直持续到了大二下，当然我并不是说参加活动，广泛交友是坏事，只是后来我在想，这是我想要的吗？人们往往把合群看作一种能力，却忽略了独处也是一种能力，并且在一定意义上是比合群更为重要的一种能力。低质量的社交不如高质量的独处。为何会有芸芸众生这个词，说到底就是因为群体的智商往往都是低下的。现在回头看看我独来独往的大三一年，真的觉得没必要为了随大流在不重要的人身上浪费时间。君子之交淡如水，用陪伴、时间和玩乐次数磨出来的朋友大多是酒肉朋友，配得上知音二字的朋友不会拖着你浪费时间。如果不是本身性格孤僻封闭，而是对生活有明确目标、计划和安排的话，不要因为旁人或集体打乱自己的节奏，想想是理想重要还是所谓的“合群”重要。朝夕相处共同生活不等于真正的朋友，真正的朋友就算远在天边，很久没有联系，他们也永远在那里。想要学会与别人相处，就要先学会和自己相处。</p><h3 id="第四，为了不让我的大学荒废，我应该做什么？"><a href="#第四，为了不让我的大学荒废，我应该做什么？" class="headerlink" title="第四，为了不让我的大学荒废，我应该做什么？"></a>第四，为了不让我的大学荒废，我应该做什么？</h3><p>其实这个问题你们去知乎上搜索是会有很多回答的，你们可以自己结束之后去搜搜，我来这并不是来教育你们的，更不是来教你如何成为一个优秀的大学生，因为我自认我并不优秀，我只想以一个同龄人以及过来人的经验告诉你们，大学期间，需要做些什么。</p><ol><li>明确自己想要的是什么？</li></ol><p>刚进大学，你们很多人都才从紧张繁重的高中学习跳出来，带着一些稚嫩的孩子气，那种初生牛犊的韧劲儿，无论对什么都充满着无限的好奇和憧憬，你们这个时候就像一张白纸一样，可以任意的去涂鸦出属于你自己的那抹斑斓，我认为大一就应该是一个不断尝试的时候，这个时期我建议你们尽可能多的尝试，不要有任何的顾忌与犹豫，敢于犯错，因为什么都才刚刚拉开序幕。我为什么说让你们多去试试呢，因为你们在尝试的时候是对自己的一个重新探索的过程，以前的你们，只有一个目标，那就是高考。但是现在正值青春年少，为何不多去尝试一些之前没有接触的新鲜事物，只有你积极的探索了之后你才知道你自己想要的是什么，而且越早行动，就越早知道自己的目标，就可以更好的去为了那个目标去奋斗了。</p><ol start="2"><li>为了自己的追求，全力以赴</li></ol><p>当然每个人想要的可能都不太一样，比如说我想在大学谈个恋爱，我想认识一帮好基友，我想成为一个更好的人，等等等等。想要的东西不分大小，不分主次，更重要的是你愿不愿意为了你想要的去全力以赴，这就是我想说的第二点。假如说，你喜欢一个女孩子，但是自己不敢去追求，那你只能眼看着她被别的男生追走，又或者你想认识一帮好基友，但是自己整天在宿舍打游戏，如果是这样的话，想要的再多又有什么用呢？重要的是，你愿不愿意为了你想要的全力以赴。也许你付出了不一定会有结果，但是你不付出，就一定没结果。</p><ol start="3"><li>永远不要在学习上懈怠</li></ol><p>我相信在座的很多人都听别人说过到了大学就轻松了，只要考试不挂科就可以了，但是真的是这样的吗？拿我自己举例吧，我大一大二两年就是以60分万岁为信条的，这样的后果就是我大一大二的成绩一般，大三一年为了保研花在争取加分项上的精力要比其他保研的人多很多。你们可以想象下我大三一年，我要忙学生会的工作，社联和本创都是我负责，还要学技术，做项目，参加比赛，写论文，复习考试，后期还要准备简历，准备复试，联系学校和导师。大三那一年我几乎没有早于凌晨一点半睡觉的。现在看来，我的努力都有了回报，但是回头看看，如果我大一和大二的时候不那么放纵自己，多花点时间在学习上，我的大三就可以稍微轻松点不是吗？所以如果在座的各位和我当时一样有60分万岁的想法，我劝你们趁早结束这种想法，因为出来混迟早是要还的，你今天欠下的东西，未来必然会以某种你不喜欢的形式出现。</p><ol start="4"><li>结识一些志同道合的朋友</li></ol><p>刚才我在合群的问题上提到了享受一个人的乐趣，但并不代表优秀的社交圈就没有用处。见贤思齐焉，见不贤而内自省也。一个好的交际圈真的很重要，我很庆幸我在大学期间认识了很多优秀的人。举个例子，我有一个学长叫XXX，保研浙大的，楼下的海报上还有他的名字，我大一的时候经常跟在他后面写代码的，关系还算不错。大二快结束的时候，他拜托我帮他打印一份文件给老师签字，因为那个时候他已经在东区了，我收到文件打开之后发现是他申请浙江大学夏令营的导师推荐信和他的个人简历，真的，我当时很震惊，我们学校的学生竟然可以申请浙江大学的研究生，而且他和我说他已经和浙大那边的教授联系好了对面也愿意接收了。我相信在座的各位每个人都跟我一样，心中都有一个名校梦，这件事情对我触动最大的地方就是他让我的名校梦死灰复燃了，那一瞬间我觉得我这辈子还是有机会去我想去的大学，也是从那时候开始，我才意识到接下来的一年我该做什么了。现在看来如果不是他让我帮的那个忙，我可能后来也不会有去南大的想法了。当然还有和我一起开发果核的那两个人，我很庆幸可以和他们一起把我们的想法付诸实践。</p><ol start="5"><li>不要害怕展示自己</li></ol><p>如果你对自己的实力表示自信，那就不要错过展示自己的机会。举个例子，今年7、8月是保研的夏令营期间，那段时间全国各个想保研的学生都会给名校投递简历，我也不例外。但是南大、复旦这样的名校的计算机类的专业基本上是不会在夏令营期间收我们这样学校的学生的，所以在我被刷了之后心里很不平衡，因为我自认我的能力并不比那些211/985的人差，于是我就在7月底，南大的夏令营已经结束之后，自己联系了导师并且私下去和导师面谈，也正是那次的面谈，导师决定给我一个机会参加南大9月的复试，后来复试通过我也就被录取了。试想一下，如果7月底我没有主动和老师联系然后去面谈，那我仍然会因为本科学校的原因被拒绝，然后再一次让我的名校梦化为泡影。</p><ol start="6"><li>谈一场单纯并且完整的恋爱</li></ol><p>大学里的爱情，相比高中更加成熟，相比工作以后更加单纯。你们的爱情可以不用担心每个月的房租、不用去管未来会是什么样子。通过大学这个平台，相识、相知、相爱，从第一次见面，第一次约会吃饭、第一次一起上自习、第一次一起翘课去看电影、为了爱情而疯狂，尽管很多人批判现在大学的恋情已经变了味，但我仍然相信，大部分情况下，大学生的爱情是澄澈而纯洁的。</p><p>在恋爱中，两个人相互交换彼此的思想，学会为对方考虑，学会担当和责任感，两个人之间的交流、争吵、矛盾、谅解，也是一个重新认识自己并让自己获得成长的过程。更何况，大家以后基本都是做IT的，工作之后就很难有机会接触异性了不是吗？</p><ol start="7"><li>世界那么大，多出去看看</li></ol><p>上大学的时候，你有大把大把的课外时间，还有着学生证这样一件神器，在很多旅游景点，可以享受半价的优惠。这样一件利器不用简直太可惜了，况且工作以后你需要考虑生活、家庭、工作，很难像大学那样有一次纯粹的旅游。</p><p>多出去看看世界，去自己喜欢的的地方，感受每个地方不同的历史和文化，不仅把它当作是旅游，同时也是提升自己见识的好机会。俗话说得好，“读万卷书，不如行万里路”，这个道理是没毛病的。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后，希望各位学弟学妹们在不影响自身学业的情况下，可以为了自己想做的事全力以赴，让自己的大学不留下遗憾。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些实用的免费在线网站</title>
      <link href="p/f833.html"/>
      <url>p/f833.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4zh75g9bej30zk0hs74z.jpg"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/coffeebeanworks-558718/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2017978">Coffee Bean</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2017978">Pixabay</a>上发布</p></blockquote><p>受到公众号「曾少贤」的启发，自己也整理了一些我在生活中经常使用到的在线网站，涉及的领域有<strong>图片、设计、文档、编程、学习等</strong>方面，这里分享出来，希望可以对大家所有帮助。话不多说，我们开始吧 😄</p><h2 id="免费图片库-Pixabay"><a href="#免费图片库-Pixabay" class="headerlink" title="免费图片库 Pixabay"></a>免费图片库 Pixabay</h2><p><strong>地址：</strong> <a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a></p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g50ypj0magj32l80sik5h.jpg"></p><p>首当其冲的自然是 Pixabay 了，我几乎每篇文章的题图都是在这个网站发现的。这是一个免费的图片网站，图片质量高，数量多，种类繁杂，最最关键的是它免费。</p><h2 id="在线抠图-换背景"><a href="#在线抠图-换背景" class="headerlink" title="在线抠图/换背景"></a>在线抠图/换背景</h2><p><strong>地址：</strong> <a href="https://www.gaoding.com/koutu">https://www.gaoding.com/koutu</a></p><p>有时候我们需要将图片的设置成透明的，虽然使用 PS 等工具可以实现，但是操作起来总是有些难度，无意中发现这个网站，只需画几笔，3 秒就能稿定透明背景。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g50ypn2yuxj31ye0lgwik.jpg"></p><h2 id="在线图片压缩网站"><a href="#在线图片压缩网站" class="headerlink" title="在线图片压缩网站"></a>在线图片压缩网站</h2><p><strong>地址：</strong> <a href="https://zhitu.isux.us/">https://zhitu.isux.us/</a></p><p>很多人都会推荐 TinyPNG，但是 TinyPNG 的限制太多了，使用起来很 XX，直到我发现了「智图」，可以选择图片格式和压缩品质。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g50ypqaq2sj31900u0ted.jpg"></p><hr><h2 id="在线文件转换网站"><a href="#在线文件转换网站" class="headerlink" title="在线文件转换网站"></a>在线文件转换网站</h2><p><strong>地址：</strong> <a href="https://www.aconvert.com/cn/">https://www.aconvert.com/cn/</a></p><p>我们经常会碰到转换文件的需求，很多人会在电脑上下载一个格式工厂之类的软件，然而一个网站就可以了。Aconvert.com 可以在线转换各类<a href="https://www.aconvert.com/cn/pdf/">PDF</a>，<a href="https://www.aconvert.com/cn/document/">文档</a>，<a href="https://www.aconvert.com/cn/ebook/">电子书</a>，<a href="https://www.aconvert.com/cn/image/">图像</a>，<a href="https://www.aconvert.com/cn/icon/">图标</a>，<a href="https://www.aconvert.com/cn/video/">视频</a>，<a href="https://www.aconvert.com/cn/audio/">音频</a>和<a href="https://www.aconvert.com/cn/archive/">压缩</a>文件，非常方便。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g50ypuck2fj328l0u0wj5.jpg"></p><h2 id="微信公众号格式化工具"><a href="#微信公众号格式化工具" class="headerlink" title="微信公众号格式化工具"></a>微信公众号格式化工具</h2><p><strong>地址：</strong> <a href="http://blog.didispace.com/tools/online-markdown/">http://blog.didispace.com/tools/online-markdown/</a></p><p>公众号排版是一个很头疼的事情，尤其对我这样一个直男来说，排一次版的时间可能跟写一篇文章的时间差不多，好在我发现了这个工具，可以轻松的将 Markdown 文件转换成微信公众号可用的 HTML 格式。对于比较懒的公众号主来说是不可或缺的神器。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g50ypxrabrj32l80qktel.jpg"></p><hr><h2 id="绿豆堂中文字体免费下载"><a href="#绿豆堂中文字体免费下载" class="headerlink" title="绿豆堂中文字体免费下载"></a>绿豆堂中文字体免费下载</h2><p><strong>地址：</strong> <a href="http://www.lvdoutang.com/zh/0/0/1/1.html">http://www.lvdoutang.com/zh/0/0/1/1.html</a></p><p>在开发过程中，我们可能会使用到多种字体，仅靠系统自带的一些字体无法满足我们的需求，这时候就需要寻找一些字体了，这个网站有很多好看的免费字体，足够日常使用了。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g50yq1zebfj31ia0u079i.jpg"></p><h2 id="草料二维码"><a href="#草料二维码" class="headerlink" title="草料二维码"></a>草料二维码</h2><p><strong>地址：</strong> <a href="https://cli.im/url">https://cli.im/url</a></p><p>这个就不多说了，生成二维码用的。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g50yq5ir3cj31ns0oc0uv.jpg"></p><h2 id="二维码梦工厂"><a href="#二维码梦工厂" class="headerlink" title="二维码梦工厂"></a>二维码梦工厂</h2><p><strong>地址：</strong> <a href="http://qrdream.com/">http://qrdream.com/</a></p><p>单说二维码肯定是不够的，现在的年轻人都追求二维码的美观，仅靠草料二维码内置的美化器是不够的，这里推荐一个「二维码梦工厂」，里面有很多非常好看的二维码模版可供选择。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g50yq9beh5j31ns0u0gyq.jpg"></p><h2 id="在线-Logo-制作器"><a href="#在线-Logo-制作器" class="headerlink" title="在线 Logo 制作器"></a>在线 Logo 制作器</h2><p><strong>地址：</strong> <a href="https://www.designevo.com/">https://www.designevo.com/</a></p><p>对于没有学过设计的程序员来说，如何给自己的个人网站（博客）上添加一个好看的 Logo 是一件很困难的事情，然而有了这个网站后我们就可以自己作出一个好看的 Logo 了。我相信很多人都用过那些所谓的”免费“Logo 生成器，在花了很长时间制作好 Logo 准备下载的时候网站却提示你要付费，让你顿时有一种受到欺骗的感觉。好在这个网站在做好 Logo 后会给你几个选择，如果你想要高质量的 Logo，需要付费购买。如果你对 Logo 的质量要求不高，这个网站还是个很不错的选择。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g50yqg5wsoj31sq0tswi0.jpg"></p><h2 id="Iconfont-图标库"><a href="#Iconfont-图标库" class="headerlink" title="Iconfont 图标库"></a>Iconfont 图标库</h2><p><strong>地址：</strong> <a href="https://www.iconfont.cn/plus">https://www.iconfont.cn/plus</a></p><p>阿里巴巴出品的图表库，种类全、数量多，用过的都说好。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g50yqndhhmj31lk0iit9g.jpg"></p><h2 id="设计模板-Canva"><a href="#设计模板-Canva" class="headerlink" title="设计模板 Canva"></a>设计模板 Canva</h2><p><strong>地址：</strong> <a href="https://www.canva.cn/">https://www.canva.cn/</a></p><p>同样是一个设计工具，对于不会 PS 但是又有一些作图需求的人来说就是一大神器，最重要的是免费！</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g50yqq93rmj31ox0u044h.jpg"></p><hr><h2 id="在线工具——程序员的工具箱"><a href="#在线工具——程序员的工具箱" class="headerlink" title="在线工具——程序员的工具箱"></a>在线工具——程序员的工具箱</h2><p><strong>地址：</strong> <a href="https://tool.lu/">https://tool.lu/</a></p><p>这个网站收录了很多很多和程序员有关的工具，截个图自己感受下。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g50yquhh6ij31870u0q9g.jpg"></p><h2 id="代码图片生成器-Carbon"><a href="#代码图片生成器-Carbon" class="headerlink" title="代码图片生成器 Carbon"></a>代码图片生成器 Carbon</h2><p><strong>地址：</strong> <a href="https://carbon.now.sh/">https://carbon.now.sh</a></p><p>这个网站可以生成类似 mac 风格的代码图片，主要用于分享，现在也有客户端了。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g50yqyqvjwj314r0u0adp.jpg"></p><h2 id="Download-Git"><a href="#Download-Git" class="headerlink" title="Download Git"></a>Download Git</h2><p>我们在浏览 GitHub 的时候，发现很多对自己有用的项目就会下载下来，但是大多数时候我们只需要其中某些文件夹（虽然可以全部下载下来然后选择自己想要的部分，但是国内的网速你们懂的），但是官方提供的下载途径只允许下载全部的文件，所以这时候就需要一个工具下载 GitHub 仓库里的部分文件了。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g50yr1rgktj31cw0eu754.jpg"></p><hr><h2 id="精品-Mac-应用分享"><a href="#精品-Mac-应用分享" class="headerlink" title="精品 Mac 应用分享"></a>精品 Mac 应用分享</h2><p><strong>地址：</strong> <a href="https://xclient.info/">https://xclient.info/</a></p><p>因为笔者自己用的是 Mac，由于限制很多应用都只能在 App Store 下载，这个网站提供了很多 Mac 端有用的软件（当然也包括一些破解软件），Mac 用户值得收藏一下。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g50yr4evp8j31fn0u0grt.jpg"></p><hr><h2 id="SCI-HUB"><a href="#SCI-HUB" class="headerlink" title="SCI-HUB"></a>SCI-HUB</h2><p><strong>地址：</strong> <a href="http://sci-hub.tw/">http://sci-hub.tw/</a></p><p>写科研论文时经常发现，有些论文网上只公布了论文题目和摘要，想要读全文的时候，却被告知不能免费下载（有的学校图书馆没有购买），只能到处求人下载或者放弃。SCI-HUB 网址则完美的解决了这个烦扰，只需要知道论文的 URL、PMID/DOI 就可以直接搜到并免费下载全文，堪称科研狗必备利器。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g50yr7z24dj31y60u07el.jpg"></p><h2 id="在线-LaTex-公式编辑器"><a href="#在线-LaTex-公式编辑器" class="headerlink" title="在线 LaTex 公式编辑器"></a>在线 LaTex 公式编辑器</h2><p><strong>地址：</strong> <a href="https://www.codecogs.com/latex/eqneditor.php?lang=zh-cn">https://www.codecogs.com/latex/eqneditor.php?lang=zh-cn</a></p><p>其实鄙视链无处不在，就比如用 LaTex 的看不起用 Word 的，虽然 LaTex 的语法确实有些难受，尤其是公式编辑的时候，好在我发现了这个网址。（其实还有个非常好的桌面工具叫做 Mathpix，但是有时候会识别不准，建议搭配使用这个网站）</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g50yraz412j31s80k2wh3.jpg"></p><h2 id="百度脑图"><a href="#百度脑图" class="headerlink" title="百度脑图"></a>百度脑图</h2><p><strong>地址：</strong> <a href="http://naotu.baidu.com/">http://naotu.baidu.com/</a></p><p>在学习的过程中，我个人比较喜欢做一些笔记，然后以思维导图的形式保存，虽然该领域有很多非常优秀的 APP，但是在使用了百度的这款良心应用后，我觉得他就是我的菜，操作简单，功能简洁明了，没有其他百度系产品的毛病，良心推荐。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g50yrz2hr2j31ox0u0jut.jpg"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你觉得文中提到的网站对你有所帮助，不如扫描下方二维码关注我，您的支持是我前进的最大动力！</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g50yss7j0vj31970oxmyz.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准备开一个新系列</title>
      <link href="p/a973.html"/>
      <url>p/a973.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g3zjri4refj31940u0k7h.jpg"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/Free-Photos-242387/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1030779">Free-Photos</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1030779">Pixabay</a>上发布</p></blockquote><p>我从今年年初正式运营我的公众号到现在也有小半年了，说来也惭愧，一个运营了将近半年的公众号到现在连1000人也没有，虽然我在去年年底给自己定的目标就是今年公众号人数达到1000人，但是这个数字和其他的公众号对比多少还是显得寒碜，期间我也考虑过怎么吸引读者，但是实在也没想出什么有效的方法。近期也发了一些不温不火的文章，但总是没办法保持持续更新，现在更是能做到一周一更就很不错了。一方面是因为自己最近这段时间毕业季确实太忙了，另一方面也是因为自己技术确实不强，很多时候也不知道可以写什么。我之前想过写系列文章，也做了尝试👉<a href="http://mp.weixin.qq.com/mp/homepage?__biz=Mzg2ODAyNTgyMQ==&hid=4&sn=f69a637fac6b21c980f20fdd9af6753a&scene=18#wechat_redirect">《AI 绘画系列》</a>，虽然阅读量没有多少，但毕竟是自己写的，觉得只要自己努力去做了，收获多少会有一些的。</p><p>于是我又心血来潮，想开（挖）一个新的系列（坑）了。我决定在公众号上发布Leetcode的题解（虽然我知道有很多人的博客里面都有）。我在今年年初立了一个flag，就是在Leetcode上刷满400题，前段时间因为要做毕业设计和写毕业论文耽搁了一阵，前天重新登录网站发现自己才做了200多道。</p><p><img src="http://ww4.sinaimg.cn/bmiddle/006tNc79ly1g3zt71ee2xj30ga0laab3.jpg"></p><p>做题期间我也整理了一些题解，想着这些题解既然搁着也是搁着，倒不如拿出来放进公众号里，当然我更希望大家也可以把你们题解分享出来，说不定哪天有兴趣了，或者业务代码写的太累了，花个十来分钟做做算法题也未尝不可。</p><p>不知道是不是因为我的公众号没有文章留言功能，总觉得和读者之间的互动性几乎为0，越来越觉得自己的公众号变成了”自嗨号”。我起初做这个公众号的目的就是希望和大家一起交流进步，然而现在却事与愿违，所以在这篇文章末尾我会发起一个关于是否建读者群的投票，希望大家可以多多支持🙏</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在掘金的第100篇文章</title>
      <link href="p/7d13.html"/>
      <url>p/7d13.html</url>
      
        <content type="html"><![CDATA[<p>2018 年 6 月 21 日，我在掘金发布了我的第一篇博客 👇<br><img src="https://user-gold-cdn.xitu.io/2020/7/28/17394c7a4db41c46?w=1288&h=298&f=png&s=40366"><br>到今天这第 100 篇的时候，已经过去 2 年多了。这 2 年发生了好多好多事，毕业、保研、暴瘦、恋爱、分手、实习。如果说有什么事是没变的，那应该就是我一直在做技术分享。我知道我的阅历尚浅，所写文章的深度有限，我的文笔也不是很好，也写不出富有文藻的文章。所以我非常感谢这些关注我的，读我文章，给我点赞的好人们。如今我也算是半只脚迈入社会的人了，感触良多。正好借着这次掘金年中总结的征文好好总结下这半年来的所学所思所想（估计活动都要结束了吧）。<br><img src="https://user-gold-cdn.xitu.io/2020/7/28/17394c7a4ea24de0?w=524&h=570&f=png&s=31826"><br>上图是我这两年在掘金的成绩，2 年时间才这么点东西我心里也是很惭愧的，今年上半年总共发过 20 篇文章（部分没有在掘金更新），平均一个月 3 篇左右。其中很大一部分还是收集的身边好友的实习经历，外加一些翻译的文章，这么一看真实产出就更少了。其实我的计划列表里堆积了很多要写的文章，但每每准备写点什么的时候又停下了手里的键盘，原因我自己心里也很清楚，这半年我的状态很差（好像从去年开始我的状态就不怎么好），经常性的失眠，新年伊始和女朋友分手，随即迎来新冠疫情，学校不开学了，还要忙着找实习。因为疫情的原因，各行各业都有所缩水，互联网行业也不例外，所幸我的运气还算可以，拿到了淘宝和字节的实习 offer。我找实习的经历之前有写过 👉<a href="https://mp.weixin.qq.com/s/siqmHsHyEYxNIwj26R6tNA">搏一搏，单车变摩托，记录一下我的淘宝实习面试</a><br>之所以最后选择了来淘宝实习，一方面是因为阿里巴巴是我一直很想去的公司，另外一方面就是字节跳动的加班太严重了（虽然在国内 996 已成常态了）。<br>其实在找实习前，我是很迷茫的，我也不清楚自己应该要找什么样的岗位，当时的我做过深度学习的项目，会写一些网页，也会用 Python 的 Flask 和 Java 的 SpringBoot 做些后端项目，顺便也会写写 App 什么的。总的来说，我的技术栈是很混乱的，不过也可以理解，毕竟是学生，乱七八糟的什么都学了一些。所以这两家公司里，字节投的是客户端，淘宝投的是服务端。当时的想法也很简单，谁要我我就去哪搬砖。对于我们计算机专业的同学找实习，我之前写过一篇指北文章，有兴趣的朋友可以阅读参考下 👉<a href="https://juejin.im/post/6844904122039156744">计算机相关专业实习指北</a></p><h2 id="选择合适的路"><a href="#选择合适的路" class="headerlink" title="选择合适的路"></a>选择合适的路</h2><p>之前有人问过我，都读研了为什么还要做开发，这样一来，和本科生有什么区别？<br>真的是，我要是能从那些大佬手里抢过算法岗的 offer，我也去抢啊。<br><img src="https://user-gold-cdn.xitu.io/2020/7/28/17394c7a4f5e5e2e?w=446&h=433&f=png&s=97758"><br>年年都说算法岗爆炸，今年更甚，有些大厂的算法岗投录比甚至已经 40:1 了，和你竞争的不光是优秀的硕士，更会有一些博士对你降维打击，人家拿出一两篇 A 类论文，怎么打？<br>再加上，我对自己的能力也很清楚，天赋不够，也不想用努力去凑，读博什么的对我来说可能更多是赌博，与其这样，不如早点找个开发的工作，拿个像样的薪资苟一波。<br>算法岗，相对普通开发来说，薪资高，加班少，给人的感觉就是每天看看论文，跑跑数据，掉的头发也不比普通程序员多，再加上某些“鄙视链”的存在，自然会更吸引人。可好的并不一定是适合你的，就像你喜欢的菇凉，不管再怎么优秀，三观不合，也是不合适的。所以选择一条适合自己职业发展的方向才是最重要的。</p><h2 id="谈谈实习感受"><a href="#谈谈实习感受" class="headerlink" title="谈谈实习感受"></a>谈谈实习感受</h2><p>2020 的开局非常魔幻，庆幸我的上半年还算平稳。前半部分在找实习、后半部分在实习。怎么找实习之前谈过了，这里就简单聊聊自己实习期间的感受。</p><h3 id="对自己的代码负责"><a href="#对自己的代码负责" class="headerlink" title="对自己的代码负责"></a>对自己的代码负责</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17394c7a4fa8c47f?w=638&h=293&f=png&s=349509"><br>来阿里也已经 2 个多月了，需求没做几个，倒是体重增了几斤。实习前，听的最多的一句话就是“面试造航母，工作拧螺丝”，这话并不假，大多数人进来后都不可能让你从 0 开始做一个项目，更多的还是在已有项目的基础上加些功能，但并不能因为是拧螺丝的工作就可以掉以轻心。因为一颗马蹄钉输掉一场战争的例子比比皆是，入职培训的第一天就看到的非常非常多资损的例子，其实都是因为一些小失误导致的。更何况，拧螺丝也是一个积累的过程，如果连一颗小小的螺丝都拧不好，等真的有造航母的机会你也参与不了。<br>不想造航母的工程师不是好码农，不管是在哪工作，不求把代码写的像诗一样，但求不要把代码写的像 💩 一样。心中要牢记，对自己的代码负责。</p><h3 id="持续学习的观念"><a href="#持续学习的观念" class="headerlink" title="持续学习的观念"></a>持续学习的观念</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17394c7a4f6c857b?w=558&h=432&f=png&s=286592"><br>活到老，学到老。考上了一个好大学，找到了一份好的工作，并不是结束，而是开始。<br>大家都知道，好的公司都更愿意收一些名校的学生，不单单是因为名校的学生能力更强一些，更多的是因为公司对于展示出高水平**”学习力”<strong>的员工有着巨大的需求，”学习力”是指</strong>快速成长和调整自身技能<strong>的渴望和能力，以保持在工作生涯中的称职状态。这是一种抽象的能力，所以如果想要快速的筛选出拥有这种抽象能力的人，最方便的就是看出身。这话说的很残忍，但也很现实。<br>那怎么样才能保持持续学习的状态呢？我的建议是</strong>持续接触新的事物**，只有当你不断接触新鲜事物，真正觉得自己无知的时候，才会永远保持一颗学习的心。这也是我为什么一直坚持做分享的原因。</p><h3 id="工作与生活的协调"><a href="#工作与生活的协调" class="headerlink" title="工作与生活的协调"></a>工作与生活的协调</h3><p>上面提到的持续学习的观点并不只是适用于工作中，生活中同样如此。除去技术，这个世界上有趣的东西还有很多。我们同样需要去学习、去探索。<br>只是，我们处在这个行业，有太多太多不得已，996 的口号喊了没多久，007 就已经开始流行。一天就 24 小时，工作的时间是有限的，压榨你的欲望是无限的。之前我写过一篇吐槽，算是小小的抗争吧 👉<a href="https://mp.weixin.qq.com/s/jsZa3hBhFlqJFgIR3LGT_Q">我不想加班，您看我还有机会吗？</a><br>阿里的加班是出了名的，哪怕实习生也不例外，所以为了避免在通勤上花费我太多时间，我租的房子离公司只有 10 分钟路程。幸运的是，公司给实习生提供了租房补贴。但即使是这样，等回到家收拾好也已经差不多快 11 点了。如果中途想跑跑步、看看书可能就更晚了。<br><img src="https://user-gold-cdn.xitu.io/2020/7/28/17394c7a52539d69?w=225&h=225&f=png&s=36900"><br>其实我自己也没办法完全做好工作与生活的协调，毕竟下班都已经很晚了。周五不加班，周末双休已经是我最后的倔强。空闲时间我会出去吃点好吃的，健健身，发工资的那个周末还会出去旅旅游、拍拍照片。我觉得工作不只是为了工作，而是为了更好的生活，如果本末倒置是得不偿失的。当然，可能很多人会觉得我的这番言论还太过幼稚，我也知道很多人到中年会有不得已的“中年危机”，可对于我来说，这些到底还是太过遥远。我还不想未雨绸缪到让自己在本该快乐的年纪疲惫不堪。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>还有一年我就硕士毕业了，这么多年的学生生涯到底是要结束了。我很庆幸自己是一个有野心的人，不会轻易满足已有的成绩，但也因为如此，才有很多事不能如我所愿。我有很多事想做，想带着爸妈去旅行，想吃遍所有美食，也想有一个懂我的女孩。过去的这两年，是我摆脱颓废的两年，有成绩，有遗憾，才算成长，如今，我再一次站在了通往未来的岔路口，只是这次，我想做一个快乐生活的人。<br><img src="https://user-gold-cdn.xitu.io/2020/7/28/17394c7a700f988f?w=600&h=600&f=png&s=94561"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码情书——谁说程序员不懂爱</title>
      <link href="p/d74b.html"/>
      <url>p/d74b.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3y5w29es3j319b0u0gx6.jpg"></p><blockquote><p>七夕佳节， 送你们一份来自直男的代码情书</p></blockquote><h3 id="代码情书——谁说程序员不懂爱"><a href="#代码情书——谁说程序员不懂爱" class="headerlink" title="代码情书——谁说程序员不懂爱"></a>代码情书——谁说程序员不懂爱</h3><p>曾经有一份真挚的爱情摆在我眼前， 我没有珍惜， 等我失去的时候我才后悔莫及， 如果上天能给我一个再来一次的机会， 我会对那个女孩子说三个字我爱你， 如果非要在这份爱上加一个期限， 我希望是一万年。<br>来源： 电影《大话西游之大圣娶亲》</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> love = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (love) &#123;</span><br><span class="line">            love = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        me.regret();</span><br><span class="line">        <span class="keyword">if</span> (god.getChance()) &#123;</span><br><span class="line">            me.sayToHer(<span class="string">&quot;我爱你&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (me.getLoveTime() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                me.setLoveTime(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>你的一句明天见， 偷走了我整个夜晚的睡眠。<br>来源： <a href="https://www.zhihu.com/question/28314613">https://www.zhihu.com/question/28314613</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (you.say(<span class="string">&quot;see you tomorrow&quot;</span>)) &#123;</span><br><span class="line">            i.sleep = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我愿化身石桥， 受五百年风吹， 五百年日晒， 五百年雨打， 但求此少女从桥上走过。<br>来源： 电影《剑雨》</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> years = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">while</span> (years != <span class="number">0</span>) &#123;</span><br><span class="line">            stoneBridge.tilt();</span><br><span class="line">            stoneBridge.dry();</span><br><span class="line">            stoneBridge.wet();</span><br><span class="line">            years--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如果记忆也是一个罐头的话， 我希望这罐罐头不会过期。<br>来源： 电影《重庆森林》</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memory == can) &#123;</span><br><span class="line">            can.validity = <span class="number">1</span> f / <span class="number">0</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我连一秒都不曾拥有过你， 却感觉已失去你千万次。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">            me.has(you);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            me.lost(you);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>I love you three thousand.<br>来源： 电影《复仇者联盟4： 终局之战》</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i.love(you);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>爱你一万年（简单的循环， 表达的是经典）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(“i love you”);</span><br><span class="line">            year += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (year &lt; = <span class="number">10000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>情不知所起，一往而深。<br>来源：《牡丹亭》题记</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = ONEDAY; day &lt; FOREVER; day++) &#123;</span><br><span class="line">            love++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>你爱或者不爱我， 爱就在那里， 不增不减<br>来源： 仓央嘉措《见与不见》</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (you.Love(me) || !you.love(me)) &#123;</span><br><span class="line">            me.emotion.love.value++;</span><br><span class="line">            me.emotion.love.value--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>尽管我捕捉到了这个bug， 但是你却catch了我的爱， 最后的最后， 依旧无法忘记你</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Mylove(U);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotLoveMe e) &#123;</span><br><span class="line">            Mylove(U);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Mylove(U);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>自从遇见了你，我就习惯上了等待</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Love</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isYou = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isYou) &#123;</span><br><span class="line">            waitFor(you);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果你的女朋友不是程序员，请不要写这样的情书给她。</p><p>如果写了，你可能会觉得她配不上你这么聪明的男人。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g45qe0gey7j30a30f7qdb.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最后一天，写给 2019</title>
      <link href="p/440f.html"/>
      <url>p/440f.html</url>
      
        <content type="html"><![CDATA[<p>相较于 2018 年的我，虽然每天仍然忙忙碌碌，始终觉得在为自己的未来未雨绸缪着，但静下心来仔细回顾这一年，却发现和自己期待的 2019 大相径庭。</p><p>这一年，我做了挺多事，毕业、读研、减肥、写作、编程、摄影、购物、恋爱，相对只有保研这一件事的 2018 年，2019 年我过的丰富的多，可这一年却也是我最近这几年最迷茫的一年。</p><p>如果要用一句话总结我的 2019，我想应该会是「想法太多，行动太少」。</p><p>2019 年，我本科毕业了，也顺利读研了。导师之前说过，对于大多数不想就业或者难就业的应届生来说，读研是最好的选择。说实话，即使到现在我也仍在困惑自己是否是因为恐惧就业才读研的。可能和大多数人在考研前期待的不太一样，并不是所有读研的人都会整天泡在实验室研究些高大上的东西，由于时间限制，大多数专硕是接触不到多少科研工作的。当然，专硕本就是以就业为导向的，多出一两年的就业缓冲期对于一些人来说也未尝不是一件好事。</p><p>2019 年，我给自己定了很多的目标，掘金要有多少关注、公众号要有多少粉丝、要看多少本书等等等等。总的来说，这些目标算是基本完成了。</p><p>这一年的写作，满打满算加起来有 90 篇，看起来很多，但是注水的文章也不少，</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaerfpre3wj312m0qqadz.jpg"></p><p>占大比重的是翻译和算法题解，这两个部分的内容往往干货很少，其次就是和机器学习有关的内容了。我在去年的总结中写到，今年是准备进入机器学习领域的，因此前期我输出了一些和机器学习有关的内容。开篇提到的「想法太多」说的也是如此，因为后来在意识到了自己的能力上限以及各种生活压力后我还是决定放弃走机器学习的道路。</p><p>这一年是我开始做自媒体的第一年，说是做自媒体，其实也就是写写公众号、发发博客。可一年过去了也没多少起色，虽然早已达到年初制定的目标（掘金 4000+，公众号 1000+），但我并没有多少喜悦。不知为何，总觉得现在产出好文章的公众号越来越少了，取而代之的是各种广告。说实话我很讨厌这些，我做公众号的初心是分享我自己的所学所想，因此我也尽力在做原创，但可能是因为我在写作上有很多问题，这些原创文章反响平平，阅读量寥寥无几，而且缺少和读者交流的过程，这些一度让我没有更新的动力，最近的发布一篇文章还是 2 个月前（当然拖更还有一部分原因是因为读研的压力）。不过 2020 年就要来了，我会步入正轨的。</p><p>至于阅读，相比去年还是有些进步的，虽然还有些书没有读完，但数量比去年多了一些，也开始做些书摘、写些读书笔记了。涉及的知识领域也广了一些。除去技术书籍，也开始阅读一些名著、历史、心理相关的书籍了。不过一些书籍的搁置率也挺高的，年初的时候给自己列了个书单，但直到年底都还停留在“买了就是看过了”这个阶段，所幸 2020 年还可以接着看，这里推荐几本书，有兴趣的可以了解下：</p><ul><li><p>《小狗钱钱》，篇幅不长，许多大 V 推荐过的理财入门书</p></li><li><p>《人类简史》，对人类的深刻思考，今年第二次阅读，只读一遍的话太可惜了</p></li><li><p>《高性能 MySQL》，看过才知道自己以前对 MySQL 性能优化的理解有多么浅显</p></li><li><p>《Head First 设计模式》，写代码容易，写好代码难，写让人看懂的代码难上加难</p></li><li><p>《程序员代码面试指南》，用 Java 刷题的时候看的，虽然还没有看完，但是内容真的非常好</p></li></ul><p>2019 年，最值得高兴的应该是我减肥成功了。去年的总结中还说到自己对减肥一事很佛系的，毕竟不抱太大希望，但终于还是瘦下来了。简单分享下心得就是“管住嘴，迈开腿”，减肥期间，我基本保持每天跑步三公里，这可以说是今年做的最成功的一件事了。如果有兴趣，后期我也可以分享下我的减肥历程。</p><p>2019 年，对自己最不满意的部分应该就是技术这一块了。不满意的原因就如标题所言，想法太多，行动太少。想学的东西很多，从今年写的博客就能看出来，数据分析、机器学习、Flutter、Spring、Flask 这些都有涉猎，但偏偏每个方面做的又太少，做的也都不怎么样。</p><p>毕设选了和深度学习有关的题目，又自学一些和机器学习相关的内容，可读研之后才发现根本没什么用。自己的天赋有限，又不想读博深造，未来若是想走算法岗，没论文的硕士又怎么可能被应聘。</p><p>刷题上，年初预定自己在 LeetCode 上做满 400 道题，可截至今日，也不过完成了 346 题，题解记录的数量也远远低于预期。</p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaey3dzhrpj30ew0lst9u.jpg" style="zoom:50%;" /><p>GitHub 的贡献量更是少的可怜，相比去年 318 的 contributions，今年直接缩减了一半。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaey5aejx2j31600n20wq.jpg"></p><p>作品上，本期待今年可以做一款 3000+ 用户的产品，可直到现在也没出现。对移动端有兴趣的我，今年也只是简单看了看 Flutter 的一些更新内容，没有亲自使用跟进。</p><p>总的来说，这一年在技术上的投入实在是太少太少了，阅读的技术书籍不够、做的东西太少、对外技术分享的频率也过低，2020 年应该好好吸取教训，静下心来沉淀自己才是最重要的。</p><p>眼瞅着 2020 年就要来了，在颓废了将近 2 个月之后，我才明白，今年对自己的期待过高了。制定详细的计划固然是好事，但被这些计划拖着走，只会让自己更累。与其按部就班的做着每一件事，倒不如顺其自然。就像《阿甘正传》里说的，生活就像巧克力，你永远不知道下一颗会是什么味道，我能做的就是珍惜现在生活中的每一分钟，尽量做好每一件事。</p><p>2019，我憧憬过，也迷茫过。2020，我相信我会步入正轨，继续前行。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我建议你去写博客？</title>
      <link href="p/3e02.html"/>
      <url>p/3e02.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkburs4eqbj31900u0ql3.jpg"></p><p>每次有学弟学妹问我如何学编程的时候，我都会在最后告诉他们最好写篇博客记录下。现在是 2020 年的 11 月，我自己写博客也已经有 3 年多了，零零散散也写了有 200 多篇了，虽然不如一些大佬写的多且快，但自己佛系更新倒也开心。刚开始写的时候，也没想着能坚持到现在，现在写了几年，渐渐也成了一种习惯，今后应该还会继续写下去。</p><p>维基百科对于博客的解释是：</p><blockquote><p>博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或影片来记录生活、抒发情感或分享信息。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。</p></blockquote><p>说白了就是记录自己的一些想法、学习心得、总结之类的，主要还是看自己<strong>想写</strong>什么。</p><p>我是一个文笔很差的人，高考语文也是勉强及格，所以如果一开始你告诉我，我的文字将会对我产生很大的影响，我肯定是不相信的。直到后来本科学了软件工程之后，想着要整理一些自己的学习笔记，但是代码也不方便用纸记下来，这便开始有了用电脑做笔记的想法。当时的做法也很土，就是新建一个 word 文档记笔记，然后用一个文件夹收录，后来经学长提点，索性就把笔记整理到 csdn 上，这样就不用每次记笔记还要新建一个 word 文档了。</p><p>再之后，看到了阮一峰、池建强的博客网站，也学到了很多有用的知识，也萌生出弄一个自己的博客的想法。期间也尝试了很多，有在掘金、简书等第三方平台上发布博客，也自己玩了玩 wordpress、hexo 这样的自建博客，现在也算是确定了写作的位置，最终选择了自建博客（hexo）+掘金/简书/公众号的搭配。掘金和简书主要是发布一些技术性的文章，例如实战教程这些，公众号吹水的比较多，科普一些我学到的技术、聊一聊我的想法之类的，然后所有的这些都存放到我的自建博客中去。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc1a56gk5j314a0kwwi9.jpg"></p><p>之所以会选择 hexo 这种自建博客，一方面是因为他的颜值比较高（虽然 wordpress 也可以安装各种主题），只要下载别人的主题简单的配置下就可以弄出一个好看的博客了。另一个原因就是部署、同步相较于 wordpress 更加方便，hexo 是用 markdown 的形式进行写作，这样的好处就是我可以无缝迁移到简书、掘金、公众号等平台，而且和 wordpress 这种需要自己购买服务器的自建博客相比，hexo 可以依赖 GitHubPages 免费使用，这对于我这种白嫖党来说无疑是最好的选择。</p><p>其实写博客的这几年也有人问过我，你又不接广告，也没什么人打赏，还要花那么多时间来写博客，不觉得累吗？为什么还坚持写了几年？</p><p>说实话，写博客确实是很花时间的，但是我认为和单纯的学习笔记相比，博客是对笔记的又一种成<strong>体系的整理</strong>，一方面可以加深记忆，另一方面也方便日后的查找翻阅。</p><p>不仅如此，如果你的博客内容质量很高，在一定程度上是可以提高自己的影响力。在如今这个浮躁的社会，很多人的文章都是东拼西凑，如果你的内容有足够的深度，那么物以稀为贵，你会更加容易、持久的建立起自己的影响力。</p><p>而且就算你的文笔不够好，也可以在写博客的过程中锻炼自己的思维能力、知识储备能力，以及思维的严谨程度。我相信，在写作过程中得到的锻炼，对于你在其他领域的工作，依然会有所帮助。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc1dalo9jj3069069jrh.jpg"></p><p>功利点说，如果你的内容质量非常高，也是可以通过写作赚钱的。我们正处在一个“知识付费”的年代，写达人课、写书、写推广文、写公众号，这些赚钱方式不一而足。而且不同于工作，你在写作上所花费时间可以被多次售卖，你可以通过你的写作，构建出属于自己的<strong>「睡后收入」</strong>。</p><p>当然了，博客也不单单可以用来整理学习笔记，我时常会通过博客来帮助我探索、梳理和记录生活。写一篇博客所花费的时间，比整理笔记要多得多，但另一方面，我们又会浪费很多时间。坚持抽一些时间写一篇博客，一定程度上可以让自己学会管理时间，毕竟谁不希望可以成为一个“时间管理大师”呢？</p><p>以上就是我对于写博客这件事的一些简单想法，就个人而言，写博客的这几年，我的知识储备得到了提升，也获得了一些收入，还通过博客认识到了一些有趣的人。当然，如果你觉得你想说的东西不适宜让他人知道，其实也可以在自己的电脑里写，不用放到网上。但我还是强烈建议，每一个朋友（尤其是计算机专业），都应该有一个属于自己的 Blog，尝试将自己的生活和想法记录下来，留下一些印记，说不定未来的某一天你的博客就让你的人生有了一些变化，毕竟，我女朋友就是写博客认识的（逃）。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不是总结的年终总结</title>
      <link href="p/4c8f.html"/>
      <url>p/4c8f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3sifas75j30dt0a2gm4.jpg"></p><p>年底照例要写一篇总结，从 12 月初我就说要写，如今都要元旦了，我还没想好写什么。往前翻了翻，前两年的总结更像是陈列了自己一年所做的事，等开始回顾今年，才发现整个人仿佛停滞了，竟没有什么值得总结的事情。既然这样，就趁着这个机会好好吐槽一下自己吧。</p><p>我是 2018 年开始写的总结，那是我人生重要转变的一年，那年我 20 岁。也是那一年，我开始变的上进，开始不断尝试自己的上限。如今 3 年过去了，我的各项能力确实有了提升，现在的我控制得了自己的体重，能静下心看几个小时的书，可以一个人悠闲的听歌、扫街拍照，也不会和以前一样羞于和女生交谈。最重要的是，我变强了，头还没秃。</p><p>而今年是我三年计划的最后一年，对我来说是既平凡又不平凡的一年。疫情对这个国家有很大的冲击不假，但对我而言，受到的冲击可能并没有那么大。年初在家不让出门，刚好给我了安心学习、健身的机会；美股熔断对我这个不炒股、偶尔玩玩基金的人来说鲜有影响；年初火起来的网课刚好给了我安心准备春招的机会，毕竟只要登入会议系统就不会算你翘课。这么一看这一年太过平淡，1 月过年、2、3 月准备春招实习、4、5 月在家躺着，6、7、8、9 在外实习提前体验社畜生活，10、11、12 月忙活毕设、论文。一眨眼，一年就到头了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3shb9l1rj30sg0lcju5.jpg"></p><p>可真有这么好吗？</p><p>今天我翻了翻我 2018 年的总结，虽然这两年我的文笔依旧没什么变化，但可以真切的感受到那一年的自己是一个多么积极乐观的人。然后到了 2019 年，我给自己的评价是<strong>「想法太多，行动太少」</strong>，但总归是积极向上的一年。2020 这一年，我给自己的评价是<strong>「被自己安排的明明白白」。</strong>这一年我依旧按照给自己设置的条条框框去做事，去阿里实习、定时更文、写代码做东西，仿佛一切都井然有序，不曾变化。</p><p>yoga 之前问过我，你这样像 todo list 一样一件一件去安排自己，就像完成任务一样，做事情是，谈恋爱也是，不会很累吗？我当时的回答是不会，因为这几年我认为井然有序的生活会避免自己犯错的可能。可最近发生的一些事情让我有些崩溃，我想变得更优秀，这没什么错，只是我忘了，在追求的过程中，有期待就会有遗憾，有的遗憾可以坦然面对，有的遗憾却会让你花一辈子时间去后悔。听起来很可惜，却也无能无力。</p><p>害，写了这么多字都不知道自己在写什么，现在看看，这篇文章可能就和我这一年一样真的没什么好看的吧。</p><p>GitHub 提交 282 次，上半年准备春招、中间忙着实习，码代码的时间都集中在今年的后半段了，不多不少。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3sgv9xawj315g0soguj.jpg"></p><p>公众号涨粉 1500 左右，和去年基本一致，对于公众号我没什么想说的，目下高质量的公众号越来越少，虽然感觉什么公众号粉丝都比我多，但我还是想按照自己的思路走下去，争取每篇都是高质量的原创文章。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3sguxyprj315g0jbwke.jpg"></p><p>目前掘金的年度报告还没出，自己也懒得统计了，就用简书的代替一下。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm3sh0yxofj30gw10k40g.jpg"></p><p>在浏览了几个 APP 的年度报告后，我终于明白了，原来我的 2020 只是 2019 的延续罢了。这一年在我身上并没有发生任何新鲜事，反倒被前几年犯下的错误反噬，我想我这一年的不快乐也是源于此吧。</p><p>朋友们都说我是凡尔赛本赛，毕竟我有很多别人羡慕不来的东西，只是于我而言，现下我所得到的并不能减少遗憾给我带来的痛苦。很快我就要开始新的人生旅程了，2021，希望可以收起自己的凡尔赛，正视心中所想，回到三年前快乐的自己，也希望老天眷顾，让我不再留有遗憾。</p><hr><p>这篇文章与其说是总结倒不如说是对自己的一个反思，因此也没有发在首页，如果你看到这里，非常感谢，我用我的好运气祝你在新的一年里可以牛气冲天 🐂。</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年，我在编程时遇见的几个好物</title>
      <link href="p/b2bf.html"/>
      <url>p/b2bf.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6abr47u6j30p00andg8.jpg"></p><p>年年都写年终总结，确实没什么新意，虽然今年也做了总结，但写完之后总觉得过于悲观，只是到了年底应该要有些什么表示，想着今年是该换个花样了，于是便有了这篇《2020 年，我在编程时遇到的几个好物》。</p><p>这篇文章介绍的，有框架，有工具，有软件，都是自己在编程时遇到的有用的，而且自己比较喜欢的，这里分享给大家。正所谓相遇即是缘，若是你有幸读到这篇文章并且觉得还不错，不妨点赞关注支持一波。</p><h2 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6aeqvm9mj315g0nb4qq.jpg"></p><p>第一个要介绍的便是 Hutool，Hutool 是一个 Java 工具包，对文件、流、加密解密、转码、正则、线程、XML 等 JDK 方法进行封装，组成各种 Util 工具类。他的作用就是帮助我们简化代码，让程序员将更多的经历放在业务上而非一些无关紧要的工作上。</p><p>举个例子，近期我有一个很小的需求，一个大文件夹里有很多小文件夹，每个小文件夹里有一些我需要整理出来的 word 文档，如果通过界面点击的话，我可能需要点击 100 多个文件夹，所以很自然的就会想到用程序去实现这个需求，第一想法肯定是 shell 脚本或者 python 脚本，但其实借助 hutool 和 Java8 里的 lambda 表达式，同样可以很方便的实现这么一个小需求，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;File&gt; files = FileUtil.loopFiles(<span class="string">&quot;xxxPath&quot;</span>, file -&gt;</span><br><span class="line">                FileUtil.extName(file).equalsIgnoreCase(<span class="string">&quot;docx&quot;</span>) || FileUtil.extName(file).equalsIgnoreCase(<span class="string">&quot;doc&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        files.forEach(file -&gt; FileUtil.copyFile(file.getAbsolutePath(), <span class="string">&quot;xxxxxPath&quot;</span>, StandardCopyOption.REPLACE_EXISTING));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>FileUtil.loopFiles</code>就可以直接获取该路径下的所有文件，如要筛选，只需要在后面追加参数即可。<br>这样的工具类还有很多，例如发邮件，直接使用 MailUtil.send 即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MailUtil.send(<span class="string">&quot;yueyong1030@outlook.com&quot;</span>, <span class="string">&quot;新年快乐&quot;</span>, <span class="string">&quot;赶紧关注「01二进制」，现在关注以后就是老粉了&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>安装方法也非常简单，Maven 安装</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你使用的是 Gradle，进行以下配置即可</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;cn.hutool:hutool-all:5.5.6&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6acl1ufkj30xc0indgr.jpg"></p><p>第二个要介绍的是一个跨平台应用开发框架——Flutter。说到 Flutter，还真是有些缘分。2018 年我开始写公众号，我的第一篇破 10w 阅读的便是发表在简书上的<a href="https://www.jianshu.com/p/8baa8ed2414d">《你好，Flutter》</a>。那一年，Flutter 横空出世，颇有一番要改变移动端开发的势头。因为自己本科时做过一段时间的移动端开发，在阅读其官方文档后便被其深深吸引了，期间也写过一些入门文章，只是不成体系罢了。如今虽然不做移动端开发了，但总还是在关注着 Flutter 社区的发展，今年因为要忙活毕业设计，于是便又将其重新拾起了。</p><p>官网说 Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。简单而言就是，Flutter 是 Google 一个新的用于构建跨平台的手机 App 的 SDK。写一份代码，在 Android 和 iOS 平台上都可以运行，当然了，现在也可以运行在 web 端和桌面端，只是效果还不如移动端好。</p><p>虽然在 Flutter 之前，已经出现过一些跨平台方案了，比如 ReactNative、Weex 等，但仍然有很多人喜欢 Flutter，我也曾在知乎回答过<a href="https://www.zhihu.com/question/427198090/answer/1571423635">为何有人会喜欢 Flutter？ - LYYYYY 的回答 - 知乎 </a>。个人认为原因有以下几点：</p><ol><li>大厂背书，谷歌一直在推广</li><li>学习成本低，只要会 Java，就可以快速上手 Dart 语言</li><li>跨平台，这是最重要的一点，目前 Flutter 已经可以运行在 Android、iOS、MacOS、Windows、Linux 等平台上，编写一次到处运行对于一个想要快速做出成品的团队来说无疑是一个好的选择</li><li>组件丰富，Flutter 内置了许多非常好看的组件，pub.dev 上也有很多优秀的第三方组件，使用起来也很方便</li><li>开发出的 App 性能足够强大。</li></ol><p>总的来说，对于一个想要<strong>快速</strong>做出<strong>跨平台 App</strong>的<strong>人/小团队</strong>来说（比如做毕业设计、初创公司等），Flutter 确实是一个很好的选择。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6acwriblj30ic096q30.jpg"></p><p>第三个要说的是一个运维工具——Docker。说起 Docker 想必很多人都不陌生了，Docker 是近几年非常火的一个工具，虽然前几年就有所耳闻，但直到今年我才算是日常使用。</p><p>其实 Docker 的出现就是为了解决软件开发的一大难题——环境配置。每个用户的设备不一致，环境自然也是千差万别。如何保证你的代码在其他地方也可以运行？</p><p>用户必须保证两件事：<strong>操作系统的设置</strong>以及<strong>各种库和组件的安装</strong>。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>那有没有一种办法，从根本上解决问题，让软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><p>虚拟机就是一种解决方案，只是这种解决方案<strong>占用资源多、荣誉步骤繁杂且启动慢</strong>，于是 Linux 发展出了另一种虚拟化技术：Linux 容器。<strong>Linux 容器不是一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。简单而言就是容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><p>Docker 就属于<strong>Linux 容器的一种封装</strong>，提供简单易用的容器使用接口<strong>。它是目前最流行的 Linux 容器解决方案。</strong></p><p>今年我使用 Docker 主要是为了<strong>提供一次性的环境</strong>以及<strong>组建微服务架构</strong>。我通过 docker-compose 整合项目中所需要的中间件，例如 MySQL、Redis、MQ 等。</p><p>我也曾在掘金上翻译过相关的文章，如<a href="https://juejin.cn/post/6899674625325105159">《【译】在几秒钟内为你的开发环境创建一个私有 PostgreSQL 数据库》</a>以及<a href="https://juejin.cn/post/6900884077226917901">《【译】5 分钟内从单体架构迁移到微服务架构》</a>等，有兴趣的小伙伴不妨点击阅读。</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6adgkgk9j30hs0a0glr.jpg"></p><p>第四个要介绍的既不是框架也不是工具，而是 Java8 新引入的一种特性——Lambda。说起 Lambda 表达式，就不得不说函数式编程。</p><p>和面向对象（OOP）一样，函数式编程也是一种<strong>思想</strong>，一种<strong>理念</strong>。如果说面向对象编程是对<strong>数据</strong>的抽象，那么函数式编程就是对<strong>行为</strong>的抽象。</p><p>而 Lambda 正是函数式编程这种思想的实际体现。Lambda 表达式，也可称为闭包，它允许把函数作为一个方法的参数（函数作为参数传递进方法中），可以使代码变的更加简洁紧凑。</p><p>说了这么多，太过空洞，举一个简单的例子。</p><p>下面的代码所做的事情是：为一个按钮增加一个监听事件，当点击这个按钮时，将会触发打印“button clicked”行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;button clicked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码很好理解，但也侧面说明了一个问题，在 Java 支持函数式编程以前，我们如果需要传递一个行为常用的方式就是传递一个<strong>对象</strong>，而匿名内部类正是为了方便将代码作为数据进行传递。</p><p>只是在 Java8 引入函数式编程后，我们可以将点击事件抽象出来，作为参数传递，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">&quot;button clicked&quot;</span>));</span><br></pre></td></tr></table></figure><p>这种方式，就被称为 Lambda 表达式。Lambda 表达式语法规则主体分为两个部分，中间用“-&gt;”右箭头连接，左边代表参数，右边代表函数主体。</p><p>函数式编程出现已经很久了，但是我之前也只是简单的学习过，真正开始日常使用还是暑期在淘宝实习的时候，项目代码里有很多 Lambda 的身影（不排除师兄们炫技的可能），虽然一开始看起来有点烦人，不太好理解，但熟悉之后，对项目代码的精简也是有目共睹的。</p><p>关于 Lambda 的资料网上有很多，这里只是推荐，有兴趣的小伙伴可以搜索学习，相信了解之后你一定会对他爱不释手的。</p><h2 id="Proxyman"><a href="#Proxyman" class="headerlink" title="Proxyman"></a>Proxyman</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6adnmx7tj31gc0mlwyh.jpg"></p><p>接下来要说的就都是一个软件了。第一个软件便是 Proxyman。无论是前端开发还是后端开发，尤其是爬虫工程师，抓包都是一个非常重要的技能，而一个好的抓包工具至关重要。Proxyman 是我今年无意中发现的一款抓包工具，只用了一次我就喜欢上他了。</p><p>选它的理由很简单，使用简单。相比 Charles，可以随意布局，可以多设备分别管理，一屏可以预览所需的关键信息。而且做移动端的抓包时，配置相较于 Charles 简单许多。最最重要的是，颜值足够高。正所谓颜值即正义，对于一个软件来说，同样如此，如果一个软件长得不好看，那也一定不是一个好软件。</p><p>不过这款软件只在 Mac 上有，这倒是一个遗憾。</p><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6ad3s4igj30pd0i2q69.jpg"></p><p>和 Proxyman 一样，iTerm2 也是 Mac 独占的软件。可以说 iTerm2 是 MacOS 上首选的终端工具，毕竟作为一个 Coder，总是用图形化界面可不是什么好事情。虽然 MacOS 默认给我们提供了一个终端软件，但是 iTerm2 的比之强大太多，各种花里胡哨的配置网上已有很多，这里也不多说什么了。</p><p>这一年，我用它连接远程服务器，查看日志等信息，iTerm2 帮了我不少忙，如果你想尝试使用命令处理操作，iTerm2 会是一个很好的选择的。</p><h2 id="PPRows-或cloc"><a href="#PPRows-或cloc" class="headerlink" title="PPRows 或cloc"></a>PPRows 或<strong>cloc</strong></h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6ae2g3opj30sg0avt8j.jpg" alt="image.png"></p><p>其实这两个东西的功能都是一样的，就是用来统计代码行数的，只不过一个是图形化界面，一个是终端命令，就看你更喜欢的是哪一个了，只不过 PPRows 只能在 Mac 上使用，这点可能会影响你们的选择。</p><p>我个人倾向使用 cloc，毕竟能用命令解决的事情为什么要用鼠标去完成呢？</p><p>不说了，这就去统计我的毕设有多少代码了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6adagr95j30j80d475n.jpg"></p><h2 id="uTools"><a href="#uTools" class="headerlink" title="uTools"></a>uTools</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6adxxdtuj312f0u0q9g.jpg"><br>只一张图，我想你一定立刻就能知道 uTools 是一个怎样的软件。</p><blockquote><p>uTools  是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。<br>当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。</p></blockquote><p>这是来自  uTools 官方网站的一段话，它其实是几个程序员为自己开发的一个工具，当然也适用于大部分的人。</p><p>阅读英文文档时，如果有些单词不太清楚，直接快捷键呼出翻译；突然要计算时，直接快捷键呼出计算器；想要查看颜色代码？想要 OCR？uTools 都可以实现。</p><p>相比较 Alfred，uTools 更加本土化，操作逻辑更加直观简单，最重要的是，对于非 macOS 用户来说，没有一款可以媲美 Alfred 的 Spotlight 应用，一直是一个遗憾。而 uTools 同时支持 MacOS、Linux 和 Windows。不管你换到了什么操作系统，都可以无缝体验到 uTools 给予你强大的功能支持。</p><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm6acqdb48j30xc0gdwfl.jpg"></p><p>既然文章说的是在编程时遇见的好物，那一定离不开 IDE。我之所以没有介绍诸如 IDEA、WebStorm 这些主流 IDE，就是觉得太过普遍，吃饭的家伙没什么好说的。</p><p>但是 VSCode，今年确实给了我很大的惊喜。之前使用 VSCode，我更多是将其作为一个文本编辑器的。不过今年在任务加重的情况下，同时开了 IDEA、AndroidStudio 和 WebStorm 时，我的 16g 内存的 MacBook pro 明显感觉吃力很多，于是我便将目光转向了之前这个“文本编辑器”了。</p><p>他的优势很明显，插件丰富，语言支持完善，不管是前端的 Vue、React 还是 Flutter，都完美支持。配合着 LeetCode 插件，还可以直接在编辑器中做题提交。安装配置了 Java 的插件后，写 Java 代码的体验也接近 IDEA。不仅占用内存小，打开文件的速度还极快。最最关键的是，好看。想当初，众多开发者还在其与 sublime text 和 atom 中纠结，现如今，后两者不知还有多少分量了。</p><p>就像我之前说的，VSCode 更多是做“文本编辑器”用，这一年我用 Markdown 写博客、公众号，内容几乎都是 Typora 和 VSCode 搭配使用。不仅如此，最近我又用 VSCode 解锁了编写 Latex 的新姿势。写论文的体验又上升了。</p><p>不说了，这就用 VSCode 肝论文去。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我在 2020 年编程时遇见的几个好物，写着写着都感觉自己成恰饭的了。2020 已到年尾，不知道你们对于新的一年又有什么新的计划呢？不妨拿个小本本记录下今年要做的事情哦，最后祝看到这里的读者们可以在牛年牛气冲天！</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2018</title>
      <link href="p/f04a.html"/>
      <url>p/f04a.html</url>
      
        <content type="html"><![CDATA[<p>最近在逛掘金社区的时候，发现了一个写年终总结的专题，觉得自己也有必要写一篇记录下我的 2018，虽然自己文笔很烂，但生活总要有些仪式感，主要介绍下自己这一年的收获以及年初制定的计划的完成情况，包括求学路，社区，读书等。</p><p>当然这一年对我来说最大的收获的莫过于我被保送到南京大学读研，对于一个本科双非大学的学生，我觉得已经很满足了。相信也都知道今年的冬天格外的冷，很多人刚找到工作就被辞退了，所以还是十分庆幸自己可以去高校躲两年。虽然我还没有去实验室做事情，但是已经感受到了来自导师以及其他保研同学的压力，他们都非常的优秀，从他们身上可以学到很多东西，我相信接下来的几年依托南大这个平台的资源，我可以成长的更多，想到这，觉得自己更要加把劲了。</p><h2 id="今年达成的小目标"><a href="#今年达成的小目标" class="headerlink" title="今年达成的小目标"></a>今年达成的小目标</h2><p><img src="http://upload-images.jianshu.io/upload_images/5666077-5f49df3faa52dd02?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>先说下今年已经达到的目标：</p><ol><li>保研到南京大学</li><li>果核 app 和小程序的用户已经 5000+</li><li>拿到了 8 个省级和国家级奖项</li><li>翻译了 10+篇文章；简书、掘金等社区的累计阅读量 10w+（在此感谢掘金翻译计划 🙏）</li><li>看了 15+本书</li></ol><p>接下来分别说一下这几个目标的详细完成情况吧。</p><h3 id="我的保研"><a href="#我的保研" class="headerlink" title="我的保研"></a>我的保研</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-7d92dfa71c995c3e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其实这个部分我已经在简书里面比较详细的介绍过了，之所以没发到掘金上主要还是觉得掘金是个纯技术类的社区。但这毕竟是我今年最重要的事情之一，还是简单的写点什么吧。我从 5 月份开始搜集各种保研的资讯，到 9 月 28 日完成志愿录取，经历了 4 个月左右。这期间的过程对我来说有些煎熬，经常对自己产生质疑，6 月份确定了自己非名校不去的想法后开始各种碰壁，了解我的人都知道其实我是一个自信甚至有点小自负的人。我认为自己并不比那些 985、211 的学生差，可是又一次次的被那些学校“委婉”拒绝。尤其是在学院的一个朋友提前拿到复旦大学的 offer 之后，我整个人接近原地爆炸的状态。那段时间我从早晨起来的第一件事就是刷题，一直持续到晚上睡觉。现在想想那段时间给自己的压力有点大了，一点就着差不多就是我当时的状态，以至于这成为后来和我女朋友分手的导火索，当然这是另外一个话题了。</p><p>总的来说我还是很庆幸自己当时给房老师发了封邮件并且主动提出去南京和老师面谈，如果没有那次面谈，可能我现在就是另一种状态了吧。虽然现在还没有正式的去实验室做事情，但是就像开头说的，我已经感受到了来自导师和其他同学的压力了，不过有压力才有动力，我相信自己接下来的两年可以好好的利用南大的资源，成长的更多。</p><blockquote><p>说句题外话：如果有学弟学妹想了解保研的一些信息的话，可以看一下我的<a href="https://www.jianshu.com/p/c2db7f31db24">这篇文章</a></p></blockquote><h3 id="我的第一款作品果核"><a href="#我的第一款作品果核" class="headerlink" title="我的第一款作品果核"></a>我的第一款作品果核</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-17fd83b282213be1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这个小东西是我做的第一个有一定用户群体的应用，到现在发展也已经有一年了，因为面向的群体是我们江科大的学生，数量有限，到现在也只有 5k+的用户，看样子是到用户瓶颈了。其实做这个东西的时候是 17 年 12 月的时候，但是发布第一个正式版的时候是在今年的 1 月 17 日。开发过程中遇到了很多很多的坑，但更多的问题是在之后的运营。起初我以为只要产品好，自然会有人用，说果核不如江科大的某某圈这点我是不认同的，可是直到现在我们的用户也只有 5k 多，近期我才发现问题究竟出在哪里。吸引用户的不是一个 APP，而是习惯。用户已经习惯了使用一款软件，在需求只有查课表的情况下，为啥要给自己的手机多装一个 APP 呢？</p><p>现在我们团队的都已经大四了，临近毕业，期间因为一系列事情，这个东西几乎快要停止运营了。前几天还和胖子说过对这个东西已经逐渐失去热情了，老季也早已不管这个项目了，眼看到年底了，干脆重写下之前的代码，精简些暂时不必要的功能，稳定好后台后就给学弟们吧。毕竟是自己一手写出来的东西，多少有些感情，如果真的消失了，还是会觉得有些可惜的。</p><p>之前有学弟学妹问我为啥喜欢写代码，现在想想我可能不是喜欢写代码本身，而是喜欢在写代码的过程中那种创造的感觉。当我在写代码的时候，其实就是我在用自己的双手去构建一个或宏大或微小的世界，它可能是一个及其复杂的系统也可能就是个 hello world，但是不管大小，在这个世界里我说了算，我可以任性、可以肆意妄为。举个不恰当的例子，即使我想毁灭这个世界那也只是一行代码的事情。写代码对我来说是件愉快的事儿，写果核的那段时间经常熬夜到凌晨 2、3 点，直到现在熬夜的情况才有所收敛。但是当程序正常运行的那一刻，那种成就感，我想真的就只有体验过的人才会懂的吧。你问我熬夜困吗？当然困，但是相信当你沉浸其中的时候你是完全不会感觉到累的。经常都是做完一阶段工作回过神来一看时间，“原来都已经这个点了吗？”。我相信那些即使对不喜欢编程只是把它当成工作的人来说，这种大段安静时间的沉浸式编程也会给他的身心带来一些愉悦的感觉。果核给我带来的最大的收获莫过于让我找到了写代码的乐趣所在。</p><h3 id="这一年的学科竞赛"><a href="#这一年的学科竞赛" class="headerlink" title="这一年的学科竞赛"></a>这一年的学科竞赛</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a491c95fef8ca7ca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>图片很模糊，也记不清是啥时候拍的了，这张还是从学院公众号上面扒下来的，其实这些奖项就我个人而言有含金量的不多，毕竟我是一个连 acm 都没打过的渣渣 😂。其实当时想要做比赛的原因也很简单，就是为了保研加分，但是后来在做项目参加比赛的过程中，渐渐的认识到了很多事情。简单来说就是一个东西想要成功并不只是单单把产品做出来就 OK 了，<strong>除了作品本身力求完整，演示视频和 PPT 应高度融合作品特性和艺术美感，无论哪一环节，都应该以极度认真和细致的“工匠精神”，努力追求完美。</strong>其实这一段是我当时写保研自荐信的时候吹逼用的，但是后来想想也的确是这样，哪怕比赛很水没有含金量，我不能也跟着水。我很喜欢<strong>“工匠精神”</strong>这四个字，这是一种内心笃定、精益求精、追求突破的精神。作为一个 coder，如果对自己的东西没有一种“工匠精神”，想必东西也不会好到哪里去。</p><p>今年的比赛简单的说，就是帮我成功保研。长期来看，准备比赛的那段期间，学习到很多平时在学习生活中接触不到的部分，使我的沟通能力、团队合作能力都大为提升。说到底我毕竟还是个学生，眼界自然高不到哪里去，多拿些比赛获奖证书自然没啥坏处，顺便还能满足下自己那小小的虚荣心，当然学校每年的竞赛奖励也还是真香的。🐸</p><h3 id="在社区的活动"><a href="#在社区的活动" class="headerlink" title="在社区的活动"></a>在社区的活动</h3><p>之前说的那么多其实都还是因为自己是一个学生，眼界有限，沉醉于校园内的荣誉感，接下来说的才是我认为自己今年做的有意义的一些事情。</p><h4 id="博客数据"><a href="#博客数据" class="headerlink" title="博客数据"></a>博客数据</h4><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a04c4ca542f8280b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>今年才算是我真正开始写博客的一年，虽然去年也在简书上写过一些，但总感觉是写着玩玩的，今年这一年我在简书和掘金上共发表了 93 篇文章，其中将近 10 来篇是翻译的文章，阅读总量应该是 10w+（但其中<a href="https://www.jianshu.com/p/8baa8ed2414d">《你好，Flutter》</a>一文就有接近 9w 的阅读量）。看起来数量挺多的，其实质量如何我自己心里都清楚，很多都是很水的，比如说刷算法的时候，记录下过程就是一篇博客了。其实这种感觉都不能算是博客，说他是笔记都有些过分了。但就算是笔记也算是记录下了自己这一年的成长历程。</p><p>我今年的文章的类别大多都是<strong>笔记型</strong>：记录一些平常学习中遇到的通用型知识，比如一道算法题的解法，某某工具的用法之类的。希望明年可以转变下风格，分享一些较为专业的内容。</p><h4 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h4><p>不过对于我今年的博客也不算是没啥贡献，我开始尝试着写系列文章了：</p><p><strong>《利用 Flutter 编写跨平台果核系列》</strong></p><ul><li><a href="https://juejin.im/post/5b9a6d10f265da0ac9628c10">利用 Flutter 写一个跨平台的果核 APP（0）——介绍</a></li><li><a href="https://www.jianshu.com/p/19502981607e">利用 Flutter 写一个跨平台的果核 APP（1）——界面篇 1</a></li></ul><p><strong>《TensorFlow 笔记系列》</strong></p><ul><li><a href="https://juejin.im/post/5c00b8cbf265da6165014cbc">TensorFlow 笔记（1）——TensorFlow 中的相关基本概念</a></li><li><a href="https://juejin.im/post/5c014ff6f265da6149335fe9">TensorFlow 笔记（2）——利用 TensorFlow 训练一个最简单的一元线性模型</a></li></ul><p>很遗憾<code>《利用Flutter编写跨平台果核》</code>这个系列没有继续更细下去，之前想写 Flutter 这个系列的原因也很简单，早在今年 2 月份的时候我就已经听说并尝试使用了 flutter，真心觉得这会是一个改变移动端开发的框架，心想着等 9 月份保研结束之后慢慢学习然后重构下果核的，可人算不如天算，导师的方向是机器学习，而且本身也开始对机器学习产生了兴趣，再加上之前提到的，我对果核这个东西的开发热情越来越低，以至于到了 10 月中旬的时候我就已经不想再用 flutter 重构果核了，转而转向学习机器学习方面的知识了。</p><p>除了在简书和掘金上发文章，为了提高阅读量，我还解封了去年被封印的个人网站。说起来有些惭愧，很早就利用 HEXO 搭了一个个人网站，可是刚做好就被我无情的打入冷宫了，可能是当初觉得有些麻烦吧，总之直到近期才重新上线。希望接下来的一年可以好好利用吧。</p><blockquote><p>在这贴下我的个人网站：<a href="https://yueyong.info/">https://yueyong.info</a></p></blockquote><h4 id="翻译文章"><a href="#翻译文章" class="headerlink" title="翻译文章"></a>翻译文章</h4><p>相比去年，我今年开始尝试翻译英文文章了。这是一个全新的起点，在这我强烈安利掘金社区的<a href="https://juejin.im/tag/%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92">掘金翻译计划</a>，里面的文章大多都是国外的一些博客或者文档之类的，篇幅不长，而且在翻译的过程中会巩固自己的英语知识和翻译知识，况且还有礼品呢。我是今年 5 月份的时候开始接触到这个翻译计划的，当时想到要翻译文章的原因很简单，无非就是为了给自己保研的简历上加点东西，后来保研结束之后，发现自己也没什么事情，就坚持做了下去直到现在了。翻译这些文章最大的感受就是我掘金上的关注者变多了。之前在朋友圈发微信说希望元旦前掘金的关注者能到 600，可是早在这篇文章发出去之前我就已经有超过 600 的关注者了。</p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-8b6a46c93062f317?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>说起阅读，往年我是很少看书的，今年之所以开始阅读还是有段小插曲的。年初和丁小姐在南京逛先锋书店的时候说到大学这几年最遗憾的事情就是没有好好读书，结果当时的图书管理员听见了我们的对话就说了句，现在开始读书也不晚啊。惨遭打脸，心想果然还是图书管理员有觉悟啊。</p><p>其实也没细细的数过自己今年看了多少书，大多都还是技术书，不过相较往年，今年的阅读涉及到了一些非技术类的书籍，当然学院本创经费可以报销一部分书籍的费用这点还是让我很欣慰的。下面挑出一些我已经看完的书籍链接和简介：</p><h4 id="技术类书籍"><a href="#技术类书籍" class="headerlink" title="技术类书籍"></a>技术类书籍</h4><ul><li><a href="https://book.douban.com/subject/10750155/">《数学之美》</a>：之前也在考虑这本书到底是属于技术类还是非技术类，虽然本书的简介上说的是让非专业读者也能领略数学的魅力，但是在看书的过程中，如果没点专业基础可能真的还看不太明白。虽然这里我把他归类到技术类书籍里，但是还是希望大学生可以好好的去阅读下这本书。</li><li><a href="https://book.douban.com/subject/26351021/">《你不知道的 Javascript(上卷)》</a>：“你不知道的 JavaScript”系列就是要让不求甚解的 JavaScript 开发者迎难而上，深入语言内部，弄清楚 JavaScript 每一个零部件的用途。第一次听说这本书还是去年陆学长推荐的，然而很惭愧的是今年年初看完了上卷之后我就没再看中卷和下卷了。其实这本书对于初学者并不是很友好，但是对于那些想要深入学习 Javascript 的人来说还是值得阅读的。</li><li><a href="https://book.douban.com/subject/25894685/">《哈啊算法》</a>：这是一本充满智慧和趣味的算法入门书。没有枯燥的描述，没有难懂的公式，一切以实际应用为出发点，通过幽默的语言配以可爱的插图来讲解算法。你更像是在阅读一个个轻松的小故事或是在玩一把趣味解谜游戏，在轻松愉悦中便掌握算法精髓，感受算法之美。这本书其实都不能算是今年看的了，大一刚入学的时候我就被安利了，期间一直是零零散散的这看点，那看点的。到今年才算是完完整整的把这本书看完了，对于刚入学的大一新生想学算法的强烈推荐。</li><li><a href="https://book.douban.com/subject/26979890/">《算法图解》</a>：一本非常有趣的算法入门书，代码使用 Python 语言实现。最大的特点就是图多，充分体现了书名 算法“图”解，而不是算法“字”解，而且在每一章节之前会设定一个场景问题，从而引入合适的算法去求解。这本书很快就可以看完，有兴趣的小伙伴也可以入手一本。</li><li><a href="https://book.douban.com/subject/19952400/">《算法(第四版)》</a>：算法领域的经典好书，我记得逼乎上有人评价过《算 4》和《算导》，觉得自己智商够的看《算导》，觉得智商不够的看《算 4》。总之没啥好说的，啃就对了。</li><li><a href="https://book.douban.com/subject/27135841/">《Kotlin 极简教程》</a>：名为极简，实则高大全，阿里的一个大牛编写的，我买它的原因是因为学院有经费报销正好有想法看下 Kotlin 所以就买了这本。</li></ul><blockquote><p>总的来说今年看的技术书籍主要是以算法为主的，毕竟是为了准备今年各个学校的保研机试，当然还有些书到现在还没看完的，看来是只能等到 2019 年继续了 😭。</p></blockquote><h4 id="非技术类书籍"><a href="#非技术类书籍" class="headerlink" title="非技术类书籍"></a>非技术类书籍</h4><ul><li><a href="https://book.douban.com/subject/30231515/">《码农翻身》</a>：其实这本书是讲技术的，但是之所以把它放在非技术类书籍里是因为我在阅读这本书的时候简直就在和看小说一样，很多计算机领域的常见概念被作者讲解的通俗易懂，可以说是我今年看过的最畅快的一本书了。</li><li><a href="https://book.douban.com/subject/26929955/">《腾讯传》</a>：本书全景式地记录了腾讯崛起的经历，并以互联网的视角重新诠释了中国在融入全球化进程中的曲折与独特性。与其说这本书是讲腾讯的发家史，倒不如说是以腾讯的角度讲中国互联网的发展史。读懂了腾讯，你就读懂了中国互联网。</li><li><a href="https://book.douban.com/subject/1001885/">《带一本书去巴黎》</a>：这本书是我加入 K 哥的星球之后收到的第一本书。这本书的作者在浓厚的法国历史文化氛围中，用大量的历史细节和场景，丰富了对艺术、文化，对历史、社会，以及对“革命”的理解。虽然是一本游记，但却是一本有深度的游记。如果你对法国感兴趣，建议可以阅读下这本书。</li><li><a href="https://book.douban.com/subject/6537385/">《浮生六记》</a>：读完这本书我就一个感受，得一妻如芸娘，此生无悔矣。推荐闲的没事做的时候，可以拿出来看看。</li><li><a href="https://book.douban.com/subject/27661940/">《好看的皮囊千篇一律有趣的灵魂万里挑一》</a>：典型的鸡汤文，写在这的原因是告诫自己，对于即将到来的 2019，这种鸡汤还是少喝为妙。</li><li><a href="https://book.douban.com/subject/6798611/">《史蒂夫·乔布斯传》</a>：这本书是乔布斯唯一授权的官方传记，人家把他一辈子的经验都写下来，也就只买 40 多，还要怎么划算！如果说《腾讯传》是以一家公司的视角来看中国互联网，那这本《乔布斯传》应该就是从一个人的视角来看硅谷的发展了。</li><li><a href="https://book.douban.com/subject/1041482/">《万历十五年》</a>：这本书介绍的是一部立体的历史，是黄仁宇“大历史”的观点的印证。历史上的每一件小事，看似平常，但前后必有连结，大的变革一定是弱小变动的累积，这本书用年代断点、追溯上下因果的方式去研究明朝万历年间的人与事。非常好看，强烈推荐！</li></ul><blockquote><p>非技术类的书籍的阅读量其实还是不够的，而且涉及的领域也比较少，在那些大佬面前还是显得相形见绌。希望 2019 的时候可以多读读交叉类的文章，比如职场、理财、学习效率类的的书籍。如果大家有好书推荐的话希望可以在评论区留言。</p></blockquote><h2 id="今年未完成的目标"><a href="#今年未完成的目标" class="headerlink" title="今年未完成的目标"></a>今年未完成的目标</h2><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a2516e860461d412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>既然有完成的目标，那肯定就有未完成的目标啊，大多都是自己还没完成的或者快要放弃的了：</p><ul><li>减肥，说多了都是泪</li><li>GitHub 的 contributions 太少了</li><li>年初给自己定的读书计划其实是 30 本，虽然今年的数量比去年多了很多，但还是远远不够</li><li>年底给自己屯 1w 元的小目标，现在看来还差个 2、3k</li><li>开始尝试做自己的头条号和公众号，但是粉丝数太少。</li></ul><p>下面来简单说说：</p><h3 id="减肥"><a href="#减肥" class="headerlink" title="减肥"></a>减肥</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-05976717ecedbd3c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>有我 QQ 的人应该都知道，我的头像是不减三十斤不改网名，现在看来今年是换不了了，可能这也就是为什么我改用微信的原因了吧。希望来年的自己可以像上图一样，吃东西前都考虑下他的卡路里。</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-475c905db77061b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>今年其实都没做啥东西，所以 GitHub 上的记录也是少得可怜，先前写过几个非常简单的安卓开源库，但是也算迈出了开源的第一步。</p><ul><li><a href="https://github.com/YueYongDev/CourseTableView">CourseTableView</a>：我做的一个让你快速方便的创建课程表视图的库</li><li><a href="https://github.com/YueYongDev/QuickSPLibrary">QuickSPLibrary</a>：一个快速执行 SharePreferences 存储的库</li></ul><blockquote><p>希望明年的 GitHub 的提交记录上可以出现一些有趣的新玩意吧。</p></blockquote><h3 id="阅读（未完成）"><a href="#阅读（未完成）" class="headerlink" title="阅读（未完成）"></a>阅读（未完成）</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-3b6917abf553bcb1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之前也说了，原本今年的计划是看完 30 本书，但是因为许多乱七八糟的事情，有些没看完，还有的压根就没开始看。</p><h4 id="没看完的书"><a href="#没看完的书" class="headerlink" title="没看完的书"></a>没看完的书</h4><ul><li><a href="https://book.douban.com/subject/26363531/">图解机器学习</a>：这本书说是入门书，但是当我对机器学习还很懵懂的时候看这本书就成了懵逼，后来放下的原因就是去看周老师的西瓜书了，等着我对机器学习有一定了解的时候会再重新拿起来看的。</li><li><a href="https://book.douban.com/subject/26708119/">机器学习</a>：机器学习入门必备教科书，注意是教科书。书是很不错的，但是能不能啃下这本教材就因人而异了。</li><li><a href="https://book.douban.com/subject/11542972/">数据挖掘</a>：这本书反正我是没有看下去，估计 19 年也不会再看了，书很厚实，但是总感觉和我有些格格不入。</li><li><a href="https://book.douban.com/subject/4889838/">鸟哥的 Linux 私房菜</a>：Linux 入门必备，没看完的原因是我看的比较晚，现在还在阅读中。19 年应该是可以看完的。</li><li><a href="https://book.douban.com/subject/30205343/">深入理解 TensorFlow：架构设计与实现原理</a>：这本书是 k 哥送的，在这再次感谢 k 哥，这本书我是结合着其他 tensorflow 的课程和文章一起看的，收获还是很多的。</li></ul><h4 id="还没开始看的书"><a href="#还没开始看的书" class="headerlink" title="还没开始看的书"></a>还没开始看的书</h4><ul><li><a href="https://book.douban.com/subject/2334288/">大话设计模式</a>：买这本书的原因是因为学院报销书籍，就抽中了这本书，今年一直没时间打开，等 2019 再看吧。</li><li><a href="https://book.douban.com/subject/25779298/">利用 Python 进行数据分析</a>：也是学院报销的书籍，因为是 python2 的语法，所以就搁着在，但网上对他的评价还是比较高的，有机会会好好阅读下的。</li><li><a href="https://book.douban.com/subject/26599538/">Android 开发艺术探索</a>：没看的原因很简单，因为我已经不做安卓了 😂。</li><li><a href="https://book.douban.com/subject/4199741/">代码整洁之道</a>：被多次推荐，实在是没时间看，已经列入明年的阅读计划了。</li></ul><blockquote><p>上述是已经买过的没看完的活着还没看的，还有好多没买的，因为已经没有学院经费的支持了，所以明年买书的时候一定会注意书的质量的。</p></blockquote><h3 id="年底囤钱"><a href="#年底囤钱" class="headerlink" title="年底囤钱"></a>年底囤钱</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-b6ab967d65c56d79?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我本身是个学生，囤钱的途径无非是：兼职、外包、奖学金。现在粗略的估计下，到年底应该能有 7k+，今年还尝试着学了点理财，因为胆子小所以就投了 2k 在支付宝里面的基金和债券，我也不指望能涨多少钱，纯粹是克制自己别乱花钱，毕竟还想着明年毕业的时候可以有钱出去毕业旅行。就当试试水，等以后有钱了就可以少走冤枉路了。</p><h3 id="头条号和公众号"><a href="#头条号和公众号" class="headerlink" title="头条号和公众号"></a>头条号和公众号</h3><p>说起头条号是因为实验室今年开通了头条号，老师让我负责，因而了解到了今日头条的流量有多恐怖，虽然头条的编辑器是坨 💩，但是不得不说，他的流量是真香，明年我还是会继续做下去的。</p><p>至于公众号说起来就有些泪了，原先和老季一起弄的公众号，但是奈何自己的文笔和老季相差太大，难登大雅之堂，把我的文章发到“字节流”上都觉得有些对不起老季。所以下半年才把重心放到了博客上，但是并不代表我自己就不想做公众号了，其实上个月我就已经注册好了一个公众号，主要目的是想分享自己想写的东西，而且我也打算把弄好这个公众号作为我 2019 的年度目标，今天就算是第一次公开推荐这个公众号吧，虽然我的文笔不怎么样，但还是希望在我的努力下未来可以成为一个拥有较多读者的公众号。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-d25b384cce39fce9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号&quot;01二进制&quot;"></p><p>我博客的关注量不够，但还是在这推荐一下这一年对我帮助很大的两个公众号，老季的“字节流”和 k 哥的“NoBug”。真的很感谢他们。</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a006b6ab5ac32936?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字节流"><img src="http://upload-images.jianshu.io/upload_images/5666077-06395c0a6c98b4db?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NoBug"></p></blockquote><h2 id="展望-2019"><a href="#展望-2019" class="headerlink" title="展望 2019"></a>展望 2019</h2><p><img src="http://upload-images.jianshu.io/upload_images/5666077-38ee813bfa7c51b7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>为了让文章看起来有内容，我特地放了很多图片，就在这规划下 2019 年吧（立 flag 中）。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>我要开始重新刷 Leetcode 了。据说南大那算法是必修课，而且必须要刷满一定量的题目，以我目前的算法水平肯定是远远不够的，已经和胖子约好了元旦就开始刷题，希望来年能坚持下去。</p><p>因为读研的方向我打算是做机器学习，所以明年的主旋律应该还是围绕着机器学习方面的学习吧，希望自己可以早日入门。</p><h3 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h3><p>说到阅读，肯定是会把今年还没读完的书尽可能看完的，毕竟人丑还是要多读书的。技术书应该还会是我阅读的首选，争取技术上更上一层楼，同时除了技术书，还希望可以多看一些沟通，批判性思维，职场以及心理学方面的书籍，增强自己的学术能力和做事能力。</p><p>而且，有一个计划是今年一直想做的但是没有勇气去做的，今天就把 flag 立在这了，等到明年写总结的时候，我要读完全英文的<strong>《Harry Potter》</strong>！（坐等打脸）</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-e568f2f370757a4d?imageMogr2/auto-orient/strip"></p><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p>在未来读研阶段学习的同时，我的社区活动也会继续进行：</p><ul><li>希望等 2019 年底，我的掘金粉丝能到 4000+。而且文章大多数应该会以机器学习为主，然后再增加些个人感悟啥的。笔记类的文章日常更新，但是希望每个月都能出一篇高质量的文章。</li><li>公众号将会是我下一年的主战场，希望能通过接下来一年的努力，让我的公众号文章质量上去，然后拥有 1000+忠实读者。当然头条号也会同步更新。</li></ul><h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><p>今年还有两个奖金应该过段时间会发下来，已经有买微单的打算了。之前在 b 站上关注过一个叫”正月点灯笼“的 up 主，新南威尔士的 cs 博士，之前是因为他的数据结构和算法的视频关注的，没想到前段时间他的动态更新了他吹笛子的音频，果然现在没点才艺都不好意思说自己是学计算机的了。想想自己这么些年都没花时间培养下兴趣爱好，多少感觉有些遗憾。作为一个 coder，光会写代码可不行，希望明年在写文章的时候，配图可以是自己拍的图片了。</p><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><p>说理财范围有点广了，毕竟自己也没啥收入来源，目前的想法还是定期存点钱在支付宝里面，每个月定投个几十块钱，就当是给支付宝充个月卡吧，一方面克制自己乱花钱，另一方面也是希望年末自己清算资产的时候会有“原来这里还有点钱啊“的惊讶吧。</p><p>然后就是囤钱，去年立的今年年底囤 1w 的小目标还没实现，今天继续把这个 flag 立着吧，坐等明年升值加薪，一夜暴富。😁</p><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>健身减肥这个话题对我来说一直都是泪，几近放弃，减多少斤的 flag 我也不敢立了，只求明年可以把 QQ 的头像和网名换掉就心满意足了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>2018 年是我人生的一个岔路口，这一年过的漫长且充实，回首这一年的经历，惊异于自己的变化，也算基本完成年初的期许。希望接下来的 2019 可以像下图一样善待我！</p>]]></content>
      
      
      <categories>
          
          <category> 来都来了 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>身份认证之双因素认证 2FA</title>
      <link href="p/0.html"/>
      <url>p/0.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ytools.xyz/uPic/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%811.png"></p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>这里所说的身份认证，指的是狭义上的在计算机及其网络系统中确认操作者身份的过程，从而确定用户是否具有访问或操作某种资源的权限。</p><p><img src="https://ytools.xyz/uPic/image-20210219200828785.png"></p><p>之所以要在互联网中进行身份认证，是为了防止攻击者假冒你的身份在系统中进行不利于你的操作。试想一下，万一哪天早晨起来你发现你的支付宝账号被盗了，你余额宝里的钱全没了，那岂不是亏大了。</p><p>只不过，和现实世界不同的是，网络世界中一切信息都是用一组特定的数据来表示的，计算机只能识别用户的数字身份，所以<strong>对用户的授权本质上就是针对用户数字身份的授权</strong>。</p><p>因此，如何保证操作者的物理身份和数字身份相对应，就成了一个至关重要的议题了，身份认证也因此在互联网世界中起着举足轻重的作用了。本文将会介绍目前很多网站常用的一种方式——双因素认证（也叫两步验证，英语：Two-factor authentication，缩写为 2FA）。</p><h2 id="双因素认证-2FA"><a href="#双因素认证-2FA" class="headerlink" title="双因素认证 2FA"></a>双因素认证 2FA</h2><p>虽然网络世界和真实世界对于身份的表示不尽相同，但是对于身份认证的手段与经验是可以相互借鉴的。在真实世界，对用户的身份认证基本依据可以分为这三种：</p><p><img src="https://ytools.xyz/uPic/image-20210219202611087.png"></p><p>上述三种认证依据被称为三种「因素」（factor）。因素越多，证明力就越强，身份就越可靠。</p><p>因此，在网络世界中，为了达到更高的身份认证安全性，某些场景会将上面 3 种挑选 2 种混合使用，即双因素认证。</p><p>在支付宝还没有在中华大地普及的时候，去银行通常需要准备一个叫「U 盾」的东西，在使用网上银行时，用户需要先插上 U 盾，然后再输入密码才能登录网上银行。在这一操作中，U 盾（you have）+密码（you know）这两种因素组合在一起就构成了一个双因素认证。</p><p>只是后来，随着移动互联网的普及，手机渐渐成为最离不开人身边的物品了，于是传统的「U 盾+密码」的组合方案就被「手机+密码」的组合替代了。</p><p>现如今，短信验证码在国内已经成为使用最广泛的两步验证方法之一了，虽然操作方便，不需要安装额外的 APP，但是验证码的下发<strong>依赖网络和运营商信号</strong>，有被窃听的风险。试想一下，如果这种验证码的获取不需要依赖运营商和网络，哪怕手机处于飞行模式也可以获取验证码，那么安全性是不是就得到提升了？</p><p>而这也就是下面将要说的 TOTP，即<strong>“基于时间的一次性密码（Time-based One-time Password）”</strong>。这是目前公认的可靠解决方案，已被纳入国际标准。</p><h2 id="TOTP"><a href="#TOTP" class="headerlink" title="TOTP"></a>TOTP</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>TOTP 的流程如下：</p><ol><li>服务器随机生成一个的密钥，并且把这个密钥保存在数据库中。</li><li>服务端将该密钥下发，通常是在页面上显示一个二维码，内容中包含密钥。</li><li>客户端扫描二维码，把密钥保存在客户端。</li><li>客户端每 30 秒使用密钥和时间戳通过 TOTP 算法生成一个 6 位数字的一次性密码</li></ol><p>其实利用 TOTP 验证的流程很简单，这里也只是介绍，如果想深入了解 TOTP 算法的具体实现过程，可以参考 👉<a href="https://tools.ietf.org/html/rfc6238"> TOTP: Time-Based One-Time Password Algorithm</a></p><p>通过这种方式生成一次性验证码，除去第一次获取服务器下发的密钥外，对网络并无其他要求了，这样即使是在离线情况下也可以使用，而且由于由于这种动态生成的密码通常只会存在 30s，安全性也得到了较大的提升。</p><p>只是在实际过程中，肯定要额外考虑一些情况，比如如果有人想要暴力破解验证码时，我们可以对验证的错误次数进行限制；抑或是手机端时间和服务器时间不同步，我们需要通过算法的方式兼容服务器时间的前后 30s，从而有效的避免细微时间上差异而导致的验证失败。</p><h3 id="使用现状"><a href="#使用现状" class="headerlink" title="使用现状"></a>使用现状</h3><p><img src="https://ytools.xyz/uPic/image-20210219214209075.png"></p><p>目前 TOTP 验证 App 主要分为两类：“独占类”和“开放类”。所谓独占类指的是只支持自家账户登录的两步验证，比如 QQ 安全中心、Steam 验证令牌等。开放类则是一个纯粹的两步验证 App，通过一个 App 去作为多个网站的验证器，例如 <code>Google authenticator</code> 就是一个开源的基于 TOTP 原理实现的一个生成一次性密码的工具。</p><p>Google Play Store 上就有许多第三方的基于 TOTP 原理实现的一次性验证码工具，只是由于国内用户使用习惯的问题，除非在一些特殊场合，例如找回密码时会用到 TOTP 验证外，其他大多数情况还是会使用短信验证码的方式，这也算国内外使用习惯的差异了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://ytools.xyz/uPic/image-20210219200548466.png"></p><p>总的来说，基于 TOTP 机制的两步验证 APP 有着比短信验证码高得多的安全性和相媲美的便利性，是一种能保障用户财产安全的工具。只是在登录时会多一步，费时且麻烦，可能会引起用户的不适。只是在重要数据面前，还是尽量使用两步验证吧，不然和 AntDesign 一样丢了代码库可就不好了。</p><p>以上就是本文的全部内容了，新年已到，想必大家也都已经复工了，在这里祝大家新年快乐，牛年大吉 🐂。如果你觉得我的文章对你有所帮助，还希望在新的一年里可以继续支持「01 二进制」，你们的支持是我更新原创的最大动力！</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费米推理——理科生的脑筋急转弯</title>
      <link href="p/373c.html"/>
      <url>p/373c.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4q43lvr1aj31910u0jzi.jpg"></p><blockquote><p>文：「边缘琐事丶」 | 图：Pixabay </p></blockquote><p>##前言</p><p>先问大家几个问题：</p><ul><li>下午两点半有多少人在刷朋友圈？</li><li>北京有多少加油站？</li><li>芝加哥有多少调音师？</li><li>胡同口的煎饼摊子一年能卖多少个煎饼？</li></ul><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lu3nhawqj307g06ugni.jpg"></p><p>产品或市场方向的面试中，时不时会出现这些匪夷所思的问题，而面试官只给你几分钟的时间进行思考，让你做出合理的分析，并且给出答案。</p><p>作为一个产品小白，初次面对这样的问题真是无从下手。之后搜罗了不少文章，也留下了一些思考，写了点东西就迫不及待地想大家分享一下。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>这类问题被称为“费米问题”，英文名“Fermi Problem”，维基百科的词条是这么描述的：</p><blockquote><p>In physics or engineering education, a Fermi problem, Fermi quiz, Fermi question, Fermi estimate, or order estimation is an estimation problem designed to teach dimensional analysis, approximation, and such a problem is usually a back-of-the-envelope calculation.</p></blockquote><p>它往往被设计用于考察一个人多维度思考的逻辑思维能力，而回答它时，因为题述给出的已知条件几乎不存在，所以又可以看出一个人的知识面是否广泛，把它放在面试中可以说是再合适不过了。</p><p>这个问题真的有标准答案嘛？</p><p>估算问题，怎么可能有标准答案嘛！</p><p>这个问题答案显然是开放的，因为题述几乎不存在什么已知条件，所以我们并不需要去纠结给出的那个数字正确与否，而应该把更多的目光放在推理过程。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>在解决现在我们面试中碰到的费米问题之前，我们不妨先看看古人是怎么思考的。</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4luzex88tj30dw09574v.jpg"></p><p>众所周知，学术界存在的那些XX问题，基本上就是XX提出的。费米问题起源于<strong>“费米悖论”</strong>，那是1951年的一天……一个叫费米的人，仰望星空，问了一句：“外星人都在哪呢？”</p><p>银河系中有数十亿和太阳类似的恒星，其中很多比太阳系古老10亿年以上。其中一些恒星可能会有类似地球的行星，它们很可能也会孕育智慧生命。其中部分智慧生命可能会发展出星际飞行的科技。即使以我们现在能够想象的科技飞行，它们也能够在一百万年内飞遍整个星系。</p><p>但是，为什么我们在太空中没有看见一个智慧生命的影子呢？</p><p>一拍脑子想出来的问题，众说纷纭。一直到1961年，<strong>弗兰克·德雷克</strong>成名之作诞生——“宇宙文明方程式”。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4luzj3ivvj308c07gjsy.jpg"></p><p>其中：</p><p>**$N$**：银河系内可能与我们通讯的文明数量</p><p>*<em>$R^</em>$**：银河系形成恒星的平均速率</p><p>**$F_p$**：恒星有行星的比例</p><p>**$n_e$**：每个行星系中类地行星数目</p><p>**$f_l$**：有生命进化可居住行星比例</p><p>**$f_i$**：演化出高智生物的概率</p><p>**$f_c$**：高智生命能够进行通讯的概率</p><p>**$L$**：科技文明寿命</p><p>通过参数相乘，我们便可以推算出银河系及可观测宇宙能与我们进行无线电通信的高智能文明数目。</p><p>看到这里，费米问题的思路就有了。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>我们可以将那些看似完全无法预测的问题拆解成一个个可以估算的小问题。就像N成为费米问题的答案，它不再代表的“外星人”的数量时，我们也应该把解决问题的思考聚焦在那一个个参数上面。</p><p>但我们怎么才能想到这些参数呢，是逻辑；这些参数如何取值呢，是知识储备。后者往往看个人积累，而前者我们却可以通过不断的训练而得出。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>笔者认为，常见费米问题的解答通常可以分为以下两类：</p><ol><li>由点及面，由面及点的参数相乘</li><li>供需关系的参数相除</li></ol><p>下面我们举例展开。</p><h3 id="1-由点及面，由面及点的参数相乘"><a href="#1-由点及面，由面及点的参数相乘" class="headerlink" title="1.由点及面，由面及点的参数相乘"></a>1.由点及面，由面及点的参数相乘</h3><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lv14r3ghj30b80b475c.jpg" alt="·1"></p><p>牛客网上有一个笔试题：如何预测周五下午两点半刷朋友圈的人数。</p><p>因为笔者还是在校学生，所以附加一个条件——学生党。</p><p>这个问题求的是一个很小的点，我们不妨先考虑一个面——整个用户群体，估测微信活跃用户量约为<strong>100，000万</strong>，出于计算简便和误差的综合考虑，我们将其分为两个用户群体：学生党、上班族，大致比例<strong>3：7</strong>吧，那么我们就可以得到微信活跃用户中学生党的数量。</p><p>再回到一个点，举一个典型的例子。从我自身出发，工作日的一天我一般会刷6次左右的朋友圈，其中3次会在饭后发生，下午一般是2次，自我判断我应该是属于朋友圈刷的比较少的那一类人，女生可能会更多，如6次。我们取平均数4次，每次时间一般为1分钟（假设一分钟后会刷到上次的内容），也就是在下午的四个小时240分钟内，估算学生党会有4分钟刷朋友圈的时间。那么在2：30（假设下午的时间每个点都一样）的概率就是<strong>1/60</strong>。</p><p>所以，周五下午两点半刷朋友圈的人数（学生党）</p><p>= 微信用户量100，000万 × 学生党比例3/10 × 下午2:30刷朋友圈的概率1/60</p><p>=500万</p><h3 id="2-供需关系的参数相除"><a href="#2-供需关系的参数相除" class="headerlink" title="2.供需关系的参数相除"></a>2.供需关系的参数相除</h3><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lv0wpkfrj30b805ugmb.jpg"></p><p>大部分的问题，都可以从供需关系展开。</p><p>有些是<strong>真实</strong>的供需问题，比如北京加油站问题：</p><ul><li>需求：北京机动车数量*每辆机动车多久加一次油，按天计算，即每天北京的机动车要加<strong>A</strong>次油</li><li>供应：每个加油站每天可以给<strong>B</strong>辆车加油</li></ul><p>再比如芝加哥钢琴师问题:</p><ul><li><p>需求：芝加哥每年有<strong>A</strong>架钢琴需要调</p></li><li><p>供应：一位钢琴师一年可以调<strong>B</strong>架钢琴</p></li></ul><p>需求和供应都是一个个参数堆叠出来的小问题，解决了<strong>A</strong>和<strong>B</strong>，最后的答案两者相除就可以得到，即<strong>N=A/B</strong>。</p><p>有些供需问题很简单，甚至不需要考虑需求，比如煎饼摊问题，煎饼是属于现做现卖的产品，所以几乎是没有库存的，也就是做多少卖多少。</p><p>这样的问题，我们只需要考虑供应就行了。在一个大佬的回答中，他取早上一个时段饱和状态下卖出的数量，能卖出360个煎饼作为上限；若赚取的毛利润刚好维持生计，则每天至少卖出67个，作为下限。取几何平均，再乘上一年的天数，得出56.7K这个数字。</p><p>其实题目做多了，会发现很多问题都是供需问题，只是供需很抽象罢了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在回答完问题后，还有个比较重要的事情——误差分析，我们应该去指出自己的估算中，有哪些采样是容易产生较大的误差的，产生误差的因素是什么。这样做可以体现思考问题的全面，也许会成为面试中一个很大的加分点。</p><p>懂了那么些“套路”后，发现回答费米问题还是一件很有意思的事情。碰到一眼看不出来的问题，就换个角度，或许就产出了一个思路清奇的答案。</p><p>所以<strong>孙悟空到底有几个女朋友呀～</strong></p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4q3zdlcgeg306204ggzx.gif" alt="006APoFYly1g2hkl4zu4ug306204ggzx"></p><hr><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4q476zqw0j30x80jwast.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊 2038 年问题</title>
      <link href="p/ee77.html"/>
      <url>p/ee77.html</url>
      
        <content type="html"><![CDATA[<p>庚子年是中国传统的 60 甲子纪年法。擅长观测的古人很早就发现，每当年份执行到庚子这一年，自然灾害变多，突发事件频频，一些震动世界、影响安定的大事件也容易发生在这一年。而我们现在所处的 2020 年就是新一轮的庚子年，现在都 4 月了，很多网友都调侃说新的一年什么事情都没做，光在见证历史了。</p><p>当然了，作为一个技术博主，我并不是来给大家科普庚子年的，今天我们要说的是计算机中的一个比较危险的年份——2038 年。</p><iframe src="//player.bilibili.com/player.html?aid=285254446&bvid=BV1Qf4y1U7sR&cid=178767205&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="2038-年问题"><a href="#2038-年问题" class="headerlink" title="2038 年问题"></a>2038 年问题</h2><p>在说 2038 年问题前，我们需要先明白计算机是如何存储系统时间的。</p><p>在 Unix 或类 Unix 系统中，都是以 1970 年 1 月 1 日 0 点 0 分 0 秒作为时间的基准点，用<strong>秒数</strong>来表示系统时间，也即<strong>当前系统时间</strong>是从基准时间（1970 年 1 月 1 日 0 点 0 分 0 秒）走过<strong>多少秒</strong>之后的时间。</p><p>用公式简单表示就是这样：<strong>系统时间 = 基准时间 + 秒数</strong></p><p>因为基准时间是确定的，所以我们唯一需要考虑的就是<strong>秒数</strong>应该如何保存。在当时那个年代，计算机硬件资源非常紧缺，用 16 位表示数据就已经是一个非常奢侈的选择了。因此当时的设计者都认为用 32 位存储秒数已经<strong>“足够大”</strong>了。所以从那个时候开始使用 32 位来表示秒数。</p><p>我们知道在二进制中，32 位数能表示的最大的数是$2^{32}-1$，不过为了能够让时间可以往前往后数，会用第一位作为正负的判断位，第一位如果为 0，则说明为正；若第一位是 1，则说明为负。因此，在 Unix 或类 Unix 系统中，这$2^{32}-1$个数被分成了 2 部分，分别是$+2^{31}-1$和$-2^{31}$。这样我们就可以以 1970 年 1 月 1 日 0 点 0 分 0 秒作为时间的基准点，往前往后每过一秒就加一个数字，依此来计算时间。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdtcwxgmw6j31r00js0zp.jpg">这个时间的最后结束点是 2038 年 1 月 19 日 03:14:07，一旦越过这个瞬间，时间将会“绕回”（wrap around）且在内部被表示为一个负数，并造成程序无法工作，因为它们无法将此时间识别为 2038 年，而可能会依个别实现而跳回 1970 年或 1901 年。因此可能产生错误的计算及动作。就像下面这样。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdtd16mk3ag30b403mdh7.gif" alt="img"></p><p>所以如果时间将近 2038 年时，还存在 32 位机器在世界中运行，那将会受到 2038 年问题的影响。</p><blockquote><p>从这也可以看出为什么很多厂商都不再提供 32 位支持了。</p></blockquote><h2 id="危害性"><a href="#危害性" class="headerlink" title="危害性"></a>危害性</h2><p>可能很多人都疑惑，这不就是个时间问题吗？有你说的那么严重吗？</p><p>当然，简单来看这就是个时间问题，而且换成 64 位的机器 2038 年问题就会自动消失了。但这只是一厢情愿，对于嵌入式设备来说，现在还有大量 32 位系统在全球各地运行，谁也无法保证这些系统在 2038 年之前就能光荣退役。</p><p>而且很多程序都会依托时间进行计算，最简单的就是银行的贷款利息等金融服务的计算，如果不解决，就一定会出现各种混乱。</p><p>而且，由于这个特殊时间点的存在，并不是说只有到 2038 年的时候才会出现问题，比如前两年就出现过，将 iPhone/iPad 等设备日期设置成 1970 年 1 月 1 日，设备就会变砖，并且无法通过寻常的备份还原等手段进行恢复。就是因为，iOS 是基于 Unix 操作系统构建的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdtdi6gzdjj318k0k47ak.jpg"></p><p>而且事实上 2038 年问题的范围远不止于此。前面谈到的问题都还是操作系统运行时表示数据的溢出，但还有一些数据是静静在躺在某个磁盘上，当时间走到 2038 之后再把它它们翻读出来，一样会出现问题。</p><p>我们知道文件都有几种时间属性，比如创建时间，最后一次访问时间，最后一次修改时间。如果该时间类型也是 32 位有符号数，那在 2038 之后的某个早晨，试想一下你和朋友喝着咖啡，回忆起 2038 年以前的某次旅游，你兴高采烈说着之前见闻，并拿出手提电脑打开之前拍下的照片，这时扫兴的事情将会发生，文件打不出或者出错。</p><p>所以说，如果这个问题不解决，夸张点说，未来真的可能会出现，全世界大部分的电子设备全部瘫痪的场景。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>2038 年问题的根源就是使用了 32 位有符号整数来表示时间，看起来它的解决方案非常的简单，直接粗暴地将<strong>32 位有符号整数</strong> 修改成 <strong>64 位有符号整数</strong>。</p><p>如果真的这样做，那对这个世界会产生什么影响呢？ 在修复 2038 年问题那一天，估计全世界人已都在做同一件事情：</p><ol><li>所有应用程序统统重新编写代码，至少得重新编译才能在新系统上运行</li><li>所有受影 2038 年影响的文件系统对应的分区，得统统格式化掉</li><li>在那天有的互联网服务都统统下线了，整个应用网络处于瘫痪状态</li><li>更离奇的是，你在银行的存款被清零了；对于那个贷款的家伙来说是个好事情，因为他们不用向银行还钱了</li></ol><p>因此这样的做法无异于格式化整个世界，创建一个新的世界。我们当然不能这样。</p><p>不过，遗憾的是，当前并没有针对现有的 CPU／操作系统搭配的简单解决方案。直接将时间更改为 64 位模式将会破坏对于软件、数据存储以及所有与二进制表示时间相关的部分的二进位兼容性。更改成无符号的 32 位整数则会影响许多与两时间之差相关的程序。</p><p>那我们就真的无能为力了吗？并不是，我们还可以：</p><ol><li>推广 64 位机器/软件的使用，争取当那一天来临的时候波及的设备尽可能少</li><li>做好对 32 位软件的兼容</li></ol><p>不过大家也没必要恐慌，毕竟离 2038 年还有 18 年的时间，Linux 社区也开始着手处理这个问题了，离目标不远了，胜利在望。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你真的有兴趣的话，可以到<a href="https://time.is/Unix">time.is/Unix</a>这个网站，他会告诉你从 1970 年 1 月 1 日 0 点 0 分 0 秒开始到现在一共过了多少秒。</p><p>以上就是这次介绍的 2038 问题了，相信很多工程师都知道这个问题，也许到时候世界上就没有 32 位的机器了，或者是说已经有大佬解决了这个问题。毕竟已经有过<strong>千年虫问题</strong>的前车之鉴了，很多人已经知道要提前做准备了。</p><p>最后，如果你觉得我的文章对你有帮助的话，不妨给个关注支持一波，</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdteuu7pdxj30go0goabc.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊 RPC</title>
      <link href="p/4a31.html"/>
      <url>p/4a31.html</url>
      
        <content type="html"><![CDATA[<p>随着近几年分布式、微服务架构的火热，RPC 在开发工作中使用的越来越多，也变的越来越重要。 作为一个学生，在学校接触到的大多都是 SSM 这类单体应用，但实习后发现，基本是接触不到从 0 到 1 的项目的，更多的是在为整个大系统的某个小模块添砖加瓦。因此，模块与模块之间的通信就变得异常重要。</p><h2 id="集群、微服务、分布式"><a href="#集群、微服务、分布式" class="headerlink" title="集群、微服务、分布式"></a>集群、微服务、分布式</h2><p>《道德经》是老子的宇宙生成论，其中“一生二，二生三”广为流传，对于一个软件系统来说，笔者认为这句话也同样适用。所谓一，便是系统的业务需求，无论何人，其编写的每行代码最后都是为了服务业务，或是实现业务功能，或是提升业务性能，最终目的均无法逃离业务。一般意义上，一个公司的业务系统发展脉络基本都是类似的：从单个应用到多个应用，从本地调用到远程调用，随着业务规模的发展，需要对远程服务进行高效的资源管理。于是分布式、集群、微服务等<strong><em>“银弹”</em></strong>便应运而生。</p><blockquote><p>在欧洲民间传说的影响下，银弹往往被描绘成具有驱魔功效的武器。 后来也被比喻为具有极端有效性的解决方法。不过佛瑞德·布鲁克斯所发表一篇关于软件工程的论文中提到在软件工程领域是<strong>没有银弹</strong>的，复杂的软件工程问题无法靠简单的答案来解决</p></blockquote><p>为了分散业务能力，出现了“微服务”；为了分散机器压力，出现了“集群”和“分布式”。那这三者有何关联？我们以一张图来说明：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpb1mkqvaj30tk0hcgms.jpg"></p><p>某大型系统下有众多功能，如订单、视频、物流等，项目初期可能是写在一个大的工程里，部署在一台机子上，后来业务发展了，每个子功能都变得相当复杂，用 IDE 打开这个项目都要花好久，为了方便开发，开发团队将每个功能分开，并起名为“服务”。每个服务可以操作自己的数据库、缓存等，也可以在本机与其他服务通信（这时项目仍然部署在一台机子上）。再后来，一个 DB、Redis 已经没办法满足这个服务的需求，所以又将单个 DB 扩展成 DB <strong>集群</strong>，单个 Redis 扩展成 Redis 集群以此来分担机器的压力。再后来，这些服务所在服务器的性能被压榨的一滴也没有了，没办法，只能将这些服务一个个的分在不同的机器上，这就是<strong>“分布式”</strong>。</p><p>由此可见，集群，是在多台机器上部署<strong>相同</strong>的程序，对于集群内部而言，每台机器是一个不同的节点。但对于集群外部（调用方）而言，集群就是一个<strong>整体</strong>，操作起来就和操作单个数据库、单个 Redis 没有任何区别。对于整个项目来说，如果集群中某个节点挂了，整个集群仍然可以正常工作，这是一种<strong>纵向的扩展</strong>。</p><p>而分布式，是指在多台机器上部署<strong>不同</strong>的模块。这些模块<strong>原本</strong>可以放在一台机器上，这叫<strong>中心化</strong>，一旦这台机器崩溃，上面所有的服务就会崩溃，整个项目也就崩溃了。因此我们可以将系统<strong>横向拆分</strong>成多个服务后部署到不同的服务器上，如果一台机器崩溃，虽然这台机器上的服务也会崩溃，但不至于导致整个系统发生崩溃，这叫<strong>去中心化</strong>。</p><p>所以随着业务的发展，微服务、集群、分布式这些名词的出现是很有必要的。</p><h2 id="RPC-的三个问题"><a href="#RPC-的三个问题" class="headerlink" title="RPC 的三个问题"></a>RPC 的三个问题</h2><p>上面我们用了一定篇幅解释了<em>微服务、集群、分布式</em>这些比较火的名词，接下来我们回到本文的主角——RPC。</p><p><strong>RPC（Remote Procedure Call）</strong>，即远程过程调用。不同于本地调用，函数与函数之间同属于同一块内存空间，如需调用某个函数，只需要找到所在内存地址即可。远程调用，通俗地说，便是有两台服务器 A，B，一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数/方法，需要通过网络来表达调用的语义和传达调用的数据。</p><p>知道了 RPC 是什么，以及为什么需要 RPC 后，接下来我们就要看看如何实现 RPC 了。文末我会给出一个简单的用 Java 实现 RPC 的 demo，这里先从一个有趣例子出发给出需要解决的三个问题：<strong>Call ID 映射、序列化和反序列化、网络传输</strong>。</p><h3 id="从一个有趣的例子出发"><a href="#从一个有趣的例子出发" class="headerlink" title="从一个有趣的例子出发"></a>从一个有趣的例子出发</h3><p>笔者之前写过一篇<a href="https://zhuanlan.zhihu.com/p/82712132">《从找对象到多线程》</a>，文中以找对象这个例子出发，介绍了线程，这次就让我们开一个线程来看一下远程调用 RPC 吧。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfqhsza5jxj307m054wec.jpg"></p><p>笔者的好友在一个男生如云的工科学校，机缘巧合下，喜欢上一个隔壁学校的妹子，终于有一天他决定告白。所以，第一步就是要知道那个女生所在的学校、年级、班级、姓名等相关信息，<strong><em>确定</em></strong>到那个人，这个过程就是<strong>Call ID 映射</strong>。由于疫情的原因，虽然各自都开学了，但都被学校强制封闭性管理，<strong><em>无法直接见面</em></strong>，因此，男生就想着用<strong><em>情书</em></strong>的方式表达自己的爱慕之意，这个过程就是<strong>序列化</strong>。男生想着，只要女生收到情书后便能<strong><em>理解</em></strong>自己的爱慕之情，就会和自己在一起了，这就是<strong>反序列化</strong>。剩下的就是如何将情书<strong><em>送过去</em></strong>了。可选的方式有很多，比如找快递小哥送、发微信、发邮件之类的，只要能将信息传送过去就可以。这个过程就是<strong>网络传输</strong>。</p><h3 id="Call-ID-映射"><a href="#Call-ID-映射" class="headerlink" title="Call ID 映射"></a>Call ID 映射</h3><p>不知道上面的例子有没有很好的解释<strong>Call ID 映射、序列化和反序列化、网络传输</strong>是什么东西。将上述例子类比到项目中，我们就能很好的理解为什么需要解决这些问题了。</p><p>类比本地调用函数，我们需要知道函数名，Call ID 就类似于这样的标志，只有这样才知道你需要的调用的是什么。如果没有 Call ID，我们就无法得知需要调用的方法是什么。</p><p>所以，在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个 {函数 - &gt;Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的 Call ID 必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfqhxabadqj31e60nwjtc.jpg"></p><p>序列化可以简单理解为<strong>对象 –&gt; 字节</strong>的过程，同理，反序列化则是相反的过程。这一过程的目的可以理解为转义，然后方便传输，就和上文例子中的把爱慕之情-&gt;文字（情书）也是为了方便传输。因为网络传输只认字节，所以互信的过程依赖于序列化与反序列化。</p><p>我们知道，在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用 C++，客户端用 Java 或者 Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。</p><p>常见的序列化方式有 JDK 自带序列化（Serializable 接口），HESSIAN 序列化，Kryo 序列化等。后面我们可以详细聊一聊这些序列化方式。</p><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><p>不管采取什么样的序列化方式，最终目的都是为了方便传输，所有的数据都需要通过网络传输，因此 RPC 的实现就需要有一个网络传输层。</p><p>网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。因此，它所使用的协议其实是不限的，能完成传输就行。</p><p>常见的有 HTTP、TCP、当然 UDP 也是可以用于 RPC 的。至于为什么已经有了 HTTP 传输协议，为什么许多 RPC 框架还是会使用 TCP，之后我会单独写一篇文章谈谈我自己的看法。</p><h2 id="一个简单的-RPC-实现"><a href="#一个简单的-RPC-实现" class="headerlink" title="一个简单的 RPC 实现"></a>一个简单的 RPC 实现</h2><p>为了直观的感受 RPC 通信，笔者实现了一个简易的 RPC 通信的 demo，开两个 terminal 分别执行 <code>java -jar server-0.0.1-SNAPSHOT.jar</code> 和 <code>java -jar client-0.0.1-SNAPSHOT.jar</code> 便可以在控制台看到相应的输出。</p><p><strong>server</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfplwoxcjmj31v20t6woi.jpg"></p><p><strong>client</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfplwcr86bj31v20t6qdi.jpg"></p><p>这时，我们再开另一个 terminal 执行 <code>curl http://127.0.0.1:4321/getUserInfo</code> 来模拟请求，我们可以得到如下的响应 body：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ curl http://127.0.0.1:4321/getUserInfo</span><br><span class="line">&#123;&quot;sex&quot;:0,&quot;name&quot;:&quot;name&quot;,&quot;id&quot;:1,&quot;schoolName&quot;:&quot;Sunny School&quot;,&quot;email&quot;:&quot;name@sample.com&quot;,&quot;age&quot;:19&#125;</span><br></pre></td></tr></table></figure><p>这时我们再来看 server 和 client 的输出有什么变化</p><p><strong>server</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpm456v30j31qg09676m.jpg"></p><p><strong>client</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpm4k7hj6j31rm0agwhr.jpg"></p><p>由此我们看见，我们请求 client 的接口，进而转发到 server 上，如果以后想要扩展需要的服务，只需要多加一个服务的 jar 包就可以了（当然这是最简单的实现）。</p><p>如果想要了解具体实现的，可以点击下面链接获取代码 👇</p><p><a href="https://github.com/YueYongDev/rpcdemo/tree/master">https://github.com/YueYongDev/rpcdemo/tree/master</a></p><p>该项目简化了 RPC 中的一些操作，例如 Call ID 映射直接通过指定字符串来实现，实际项目中是通常会有一个配置中心负责持久化调用的 ip、端口、函数名、参数等信息。为了简化通信，使用了 HTTP 作为网络传输协议，通信框架采用 OkHttp。另外，本项目涉及到一些前置知识，例如动态代理、自定义注解等，有兴趣的小伙伴也可以学习了解下。</p><p>以上就是本篇文章的全部内容了，如果觉得文章对你有所帮助，不妨给个赞支持一下。</p><hr><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfqi2ryuklj30go0goabc.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊一聊MQTT</title>
      <link href="p/80ee.html"/>
      <url>p/80ee.html</url>
      
        <content type="html"><![CDATA[<p>3 月 30 日，小米在其新品发布会上公布了他们要造车的消息，那场发布会我看完了，其实这个消息在意料之中，如今的手机市场已经趋向饱和，手机厂商竞争加剧，疯狂内卷，手机业务再进行大的扩张也非易事。</p><p><img src="https://cdn.ytools.xyz/uPic/cJxa8Eimage.png"></p><p>就在这两天，极狐阿尔法 S 也面世了，这辆车上搭载的是华为最新的无人驾驶系统，由此可见，围绕着汽车形成的车联网在未来也会逐渐普及。而我也就是一个写代码的，对于企业的战略布局我不关心，这一篇文章也只是想来聊聊新领域背后的一项老技术——MQTT。</p><h2 id="何为-MQTT"><a href="#何为-MQTT" class="headerlink" title="何为 MQTT"></a>何为 MQTT</h2><p>MQTT 即 Message Queuing Telemetry Transport，中文名为消息队列遥测传输协议，是一种基于发布/订阅模式的”轻量级”通讯协议。其本质上也是构建于 TCP/IP 协议上的一种通信协议，其地位在 OSI 七层网络协议中和 HTTP 协议并列，同属应用层的网络通信协议。</p><p><img src="https://cdn.ytools.xyz/uPic/dDN2wm1_2s8uUdqTWUm_liI7m54y2g.jpeg"></p><p>HTTP 协议全称<strong>「超文本传输协议」</strong>，这里的超文本包括 HTML 文件、图片等。因此在设计之初，HTTP 就已经包含了复杂的报文，但我们知道并不是所有的环境都有较好的网络环境，MQTT 的出现正是为了解决这种问题。</p><p>MQTT 协议的最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。也正是因为 MQTT 协议是一种低开销、低带宽占用的即时通讯协议，使其在<strong>物联网、小型设备、移动应用</strong>等方面有较广泛的应用。</p><h2 id="探究-MQTT-的原理"><a href="#探究-MQTT-的原理" class="headerlink" title="探究 MQTT 的原理"></a>探究 MQTT 的原理</h2><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p><img src="https://cdn.ytools.xyz/uPic/HHipChimage%20(1).png"><br>MQTT 协议是基于客户端-服务器的消息发布/订阅传输协议，在整个通信过程中，有三个重要的角色，分别是<strong>发布者</strong>（Publish）、<strong>代理</strong>（Broker）（服务器）、<strong>订阅者</strong>（Subscribe）。其中，消息的发布者和订阅者都是<strong>客户端</strong>，消息代理是<strong>服务端</strong>，<strong>消息发布者可以同时是订阅者</strong>。</p><h3 id="代理（Broker）"><a href="#代理（Broker）" class="headerlink" title="代理（Broker）"></a>代理（Broker）</h3><p>MQTT 中的 Broker 类似于一个中转站，位于消息发布者和订阅者之间。在 Broker 中，可以<strong>接受客户发布的应用信息，处理来自客户端的订阅和退订请求以及向订阅的客户转发应用程序消息</strong>。Broker 通常由一个应用程序或一台设备充当。</p><h3 id="消息组成"><a href="#消息组成" class="headerlink" title="消息组成"></a>消息组成</h3><p>在 MQTT 中，传输的消息分为：主题（topic）和负载（payload）两部分：</p><ol><li>Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容。</li><li>Payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本篇文章篇幅较短，主要是为了向大家介绍一下 MQTT 这一协议的基本信息，下一节将会介绍如何搭建一个可用的 MQTT 环境并用实际代码演示如何使用 MQTT 协议。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅入浅出消息队列</title>
      <link href="p/1acc.html"/>
      <url>p/1acc.html</url>
      
        <content type="html"><![CDATA[<p>高中的时候，每节自习课都会有人零零散散的找老师问问题，一开始就一两人还好，后来渐渐的人多了，老师也烦了，你说我这上了一天的课难得晚上可以看自习休息会，这帮小崽子还一个个这么折腾人。</p><p>于是老师决定让同学们把需要提的问题写在纸上，下自习后交给课代表，然后老师再从课代表那取出要问的问题，然后再一个个解决。</p><p>相信在学生时代大家都遇到过上面的这种情况，如果我们将在学校上课抽象成一个系统，那这种情况就是一个很常见的消息队列的使用场景。</p><p>在上述实例中，要提的问题就是<strong>「消息」</strong>，提问题的学生是<strong>「生产者」</strong>，回答问题的老师是<strong>「消费者」</strong>，收集问题的课代表是<strong>「消息队列」</strong>。</p><p>看到「生产者」和「消费者」，不知道有没有想起来在 RPC 的中同样也有生产者和消费者，那么这两者之间有关联吗？</p><blockquote><p>如果对 RPC 还不了解的读者可以阅读我之前写过的一篇文章</p></blockquote><p>我们先来回顾一下，在 RPC 的调用关系里，我们把提供具体的调用方法的系统叫服务提供者（Provider），调用服务的系统称为服务消费者（Consumer）。</p><p>如果有 N 个不同系统相互之间都有 RPC 调用，这时候整个系统环境就是一个很大的网状结构，如下图所示，依赖关系有 N*(N-1)/2 个。任何一个系统出问题，都会影响剩下 N-1 个系统，这种强耦合肯定不是我们想要的，那应该怎么降低这种耦合呢？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9eznbw0bj30o30j0dht.jpg"></p><p>基于这些问题，消息队列（Message Queue，简称 MQ）技术横空出世，所有的处理请求先作为一个消息发送到 MQ（一般我们叫做 broker），接着处理消息的系统从 MQ 拿到消息并进行处理。这样就实现了各个系统间的<strong>解耦</strong>，同时可以把失败策略、重试等作为一个机制，对各个应用透明，直接在 MQ 与各调用方的应用接口层面实现即可，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9f8cofaij30sx0i30ut.jpg"></p><p>一般来说，我们把发送消息的系统称为消息生产者（message producer），接受处理消息的系统称为消息消费者（message consumer）。</p><p>一般来说，我们把发送消息的系统称为消息生产者（message producer），接受处理消息的系统称为消息消费者（message consumer）。</p><p>根据消息处理的特点，我们又可以总结两种消息模式：</p><ul><li>点对点模式（Point to Point，PTP），一个生产者发送的每一个消息，都只能有一个消费者能消费，看起来消息就像从一个点传递到了另外一个点。</li><li>发布订阅模式（Publish-Subscribe，PubSub），一个生产者发送的每一个消息，都会发送到所有订阅了此队列的消费者，这样对这个消息感兴趣的系统都可以拿到这个消息。</li></ul><h2 id="使用-MQ-的好处"><a href="#使用-MQ-的好处" class="headerlink" title="使用 MQ 的好处"></a>使用 MQ 的好处</h2><p>从上面的介绍中我们可以看出 MQ 的出现在一定程度上是可以将复杂的服务<strong>解耦</strong>。</p><p>那么回到一开始的例子，我们发现，课代表的出现也确实在一定程度上解决了老师和学生之间的强耦合关系。类似的例子还有快递柜，快递员将快递放到快递柜，不方便拿快递的人可以在下班之后再去拿快递。这样快递员和收快递的人就可以更加自主，只通过一个简单的“容器”——快递柜来联系。你甚至可以不知道你的快递员长什么样子，快递员也可以不知道你是谁，在他们眼里，都只有快递柜，没有对方。</p><p>毫无疑问，与一个简单的容器打交道，比与复杂的人打交道容易一万倍，他们也可以更加专注的去完成自己的事情。</p><p>那么除<strong>解耦</strong>外还有其他的优势吗？自然是有的。</p><p>再回到一开始学生提问的例子，我们设想另一个场景：如果提问的问题特别难，而且是每个人都要问这个问题，老师给每个人讲解要花很多时间，学生有压力，老师也会觉得麻烦，所以老师决定第二天上课的时候把这个问题单独拿出来说。</p><p>在上面这个事例中，就体现了 MQ 的另外两个作用——<strong>广播</strong>和<strong>削峰</strong>。</p><p>广播：老师只需要讲解一次，所有需要听这道题的同学就都可以听了。</p><p>削峰：将当晚那么多同学讲题的需求延迟到第二天上课。</p><p>当然，在实际的使用过程中，MQ 的用处也不只是这么些，这里推荐阅读阿里巴巴中间件团队的十分钟入门 RocketMQ 中的第一章 👉<a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/">消息中间件需要解决哪些问题？</a></p><h2 id="MQ-的使用成本"><a href="#MQ-的使用成本" class="headerlink" title="MQ 的使用成本"></a>MQ 的使用成本</h2><p>如此一看，消息队列确实有很多好处，不过凡事皆有利弊，消息队列的使用也是有一定的使用成本的。</p><p><strong>引入了一定的复杂度</strong></p><p>虽然引入了消息队列可以让各个系统解耦，但同时也增加了维护存放消息的容器的成本。</p><p>就和例子中的快递柜一样，维护快递柜也是需要成本的，不然前段时间也不会出现丰巢收费的事情了。当过课代表的人也知道自己有多辛苦。</p><p><strong>暂时的不一致性</strong></p><p>同学问问题，老师没办法立即给出解答。快递到了，你不能及时感受拆快递的快感，这些在一个复杂系统中体现出来的就是暂时的不一致性。</p><p>不过，就像老话说的，正义可能会迟到，但永远不会缺席。老师最终还是会给你解决问题，你最终还是可以感受到拆快递的快感，这就是所谓的<strong>「最终一致性」</strong>。</p><h2 id="什么情况下适合使用-MQ？"><a href="#什么情况下适合使用-MQ？" class="headerlink" title="什么情况下适合使用 MQ？"></a>什么情况下适合使用 MQ？</h2><p><strong>容忍暂时的不一致性</strong></p><p>如果不是对消息的处理非常及时，比如电商系统中的付款和下订单以及物流配送，只要用户最终满意于「尽快收到货」，这种情况就可以使用 MQ。</p><p>当然，如果用户对这种情况无法容忍，那就再想想其他办法吧。</p><p><strong>收益&gt;成本</strong></p><p>这点也很好理解，如果使用维护一个消息队列的成本，比消息队列对项目的实际效益要大，那使用他作甚？</p><hr><p>以上就是本篇文章的全部内容了，其实本来想在最后写一点关于利用 docker 部署 RocketMQ 的，但因为最近实习+实验室的工作真的是太多了，精力实在有限，所以这一部分只能留到以后来说了。 如果你觉得我的文章对你有帮助，不妨关注一下，我会尽可能分享更多优质内容。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggivizlglhj30go0goabc.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找对象的过程中，我竟然理解了什么是机器学习！</title>
      <link href="p/18ed.html"/>
      <url>p/18ed.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近开始了有关机器学习方面知识的学习，自己啃书本的时候一些概念枯燥无味，所以借着做笔记的机会来简单理解其中的一些概念，如有谬误，还望指出。😊</p></blockquote><h2 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h2><p>我看过很多博客解释什么是人工智能，我觉得还不如一句话一张图解释的简洁明了。<strong>让机器实现原来只有人类才能完成的任务</strong>，这个操作就是人工智能。</p><p>下图所示就是让机器模拟人各种能力的人工智能领域示意图：（图片我是在逛知乎的时候发现的，地址贴在文末）</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-368f5f0a8ba66e93?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><a id="more"></a><h2 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h2><p>在解释什么是机器学习之前，我们先来举一个让每个程序员都头疼的问题：</p><h3 id="找对象"><a href="#找对象" class="headerlink" title="找对象"></a>找对象</h3><p>作为一个程序员，找对象自然是个非常紧迫的问题，那找对象总要有个要求吧 🤔</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-b62ea9fc2026f3ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>啥？活的？能动？骨骼轻奇的我怎么可能只有这两点要求啊 🙊 显然我是希望找一个好的女朋友啊（毕竟要带出去撑场面的啊），所以应该怎么找呢？</p><p>爱美之心，人皆有之。长得好看的妹子肯定比长得丑的妹子更优秀啊，所以这时我就有了一个简单的规则了：只挑选长得好看的女生的当女朋友。所以还等什么？快去朋友圈看看哪些漂亮的女生还是单身啊。是不是 So easy？</p><p><strong>当！然！不！是！</strong></p><h3 id="生活总是充满了艰辛"><a href="#生活总是充满了艰辛" class="headerlink" title="生活总是充满了艰辛"></a>生活总是充满了艰辛</h3><p>张无忌的麻麻说过：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-482ba7066caeca54?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当你网恋奔现的时候你会发现，那些朋友圈里的都是照骗，你懵逼了。。。很显然，只看女生照片找对象这个方法是很片面的，找到一个好的女朋友的因素有很多而并不只是根据女生的颜值。</p><p>在经过了大量思考（并且参考了众多好友的女朋友）之后，你又得出了一个结论：身材好同时颜值高的女生更容易吸引你。同时身材一般但颜值高的好友中只有一半左右能让你感兴趣。</p><p>这时你再带着你得出的结论去找女生的时候，才知道原来妹子已经脱单好久，只是把你当朋友。。。但是心好的妹子为了安慰你便把她的闺蜜推给了你。然后你发现你之前的结论不适用了，所以只能重新开始约朋友圈的妹子。</p><p>假设过了好久好久之后，你成功的总结了一个找妹子的经验，找到了一个优秀的另你满意的妹子了，你很开心的和她在一起了。丑媳妇也要见公婆的，终于到了你把女朋友带回家给家长见面的时候了，你爸妈说，这女生太漂亮了，你管不住，坚决反对。</p><p>在你爸妈的反对下，你只能选择无奈的和妹子 say goodbye👋。最后的最后你和你爸妈摊牌，然后将你的择偶规则告诉你的家人，在他们的筛选下，你终于找到了符合<strong>“所有”</strong>预期标准属性的女朋友了。</p><h3 id="是不是觉得很-dan-疼？"><a href="#是不是觉得很-dan-疼？" class="headerlink" title="是不是觉得很 dan 疼？"></a>是不是觉得很 dan 疼？</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-bc2be257362748d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>回想一下上述的场景，是不是觉得十分 dan 疼，虽然最终结果是你找到了一个满意的女朋友，但是在找对象的过程中，你需要不断的更换标准（属性），而且每当你需要用一个新的标准（属性）去衡量一个妹子的时候，你只能手动更改你自己的规则。并且你需要了解所有繁杂的影响女朋友质量的因素（比如颜值、身材、贴心程度、可爱程度等等）。如果这些因素足够复杂，你很难手动分类所有类型的女生而做出精确的规则。</p><p>并且，不断的和不同的女生谈恋爱、试错不仅浪费时间，名声也不好。说不定还会被扣上一定渣男的帽子。</p><h3 id="来类比下？"><a href="#来类比下？" class="headerlink" title="来类比下？"></a>来类比下？</h3><p>其实上述就是一个非常不典型的机器学习的例子，我们来类比下：</p><p><strong>机器学习（ML）</strong></p><p>你可以从朋友圈随机挑选一些女生（假设你的异性缘足够的好）作为样本(<strong>training data</strong>)，然后列出所有女生的属性，比如身高、颜值、身材、学历、工作，等等(<strong>features</strong>)，以及是否贴心、黏人度、孝心，等等(<strong>output variables</strong>)。将这些抽象化的数据在机器学习算法里运行(<strong>classification/regression</strong>)，则 ML 算法构建一个模型：女生的属性——女生的质量。</p><p>然后等到下次你又遇见了一个女生了，你就可以用眼睛扫一下检查女生的属性（身材、颜值等）了(<strong>test data</strong>)，然后提供给 ML 算法，他就会根据之前生成的模型（<strong>model</strong>）预测这个妹子最终和你走到一起的可能有多大。</p><p>其实在机器学习构建模型过程中，内部使用的规则也许和上述例子中类似，但是也有可能是更复杂的规则，不过这些你并不需要关心。</p><p>你现在再去找对象就有很大信心了，而且更重要的时候，随着时间你的 ML 算法会自我提升(<strong>reinforcement learning</strong>)，当预测错误的时候（恋爱谈不下去就分手）矫正自身，随着读取更多的 training data 预测也会越来越精准。但是，最流弊的一点在于，你可以利用相同的算法而训练出不同的模型(model)，找女朋友可以用这个模型，那找秘书呢？（仿佛发现了什么不得了的事情 🤓，随便你想要训练出什么模型只要你高兴就好 )</p><p>所以说对机器学习的最简单的理解，便是：</p><p><strong>使用某种算法来对已有数据进行解析、学习，然后对真实世界中的数据/事件作出决策/预测。</strong></p><h2 id="那深度学习又是啥？"><a href="#那深度学习又是啥？" class="headerlink" title="那深度学习又是啥？"></a>那深度学习又是啥？</h2><p><strong>深度学习</strong>，是<em>实现机器学习的技术</em>。对机器学习来说，特征提取并不简单。特征工程往往需要大量的时间去优化，而此时，深度学习便可以自动学习特征和任务之间的关联，还能从简单特征中提取复杂的特征。</p><p>深度学习是机器学习的许多方法之一，其他方法包括决策树学习、归纳逻辑程序设计、聚类、强化学习和贝叶斯网络等。</p><p>那深度学习是如何寻找那些复杂特征的呢？</p><p>他是通过<strong>建立、模拟人脑进行分析学习的神经网络</strong>，它模仿人脑的机制来解释数据，如图象、声音、文本。其产生的灵感来自于大脑的结构和功能，即许多神经元的互联。</p><p>下图是我在知乎上看见的一个非常有趣的回答：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-1aba9b8b43846e3e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>推荐大家去阅读下这个回答：👇</p><p>人工智能、机器学习和深度学习的区别? - 图普科技的回答 - 知乎<a href="https://www.zhihu.com/question/57770020/answer/418117913">https://www.zhihu.com/question/57770020/answer/418117913</a></p><h2 id="那他们三个有什么关系呢？"><a href="#那他们三个有什么关系呢？" class="headerlink" title="那他们三个有什么关系呢？"></a>那他们三个有什么关系呢？</h2><p><img src="http://upload-images.jianshu.io/upload_images/5666077-eec46350cf0d93d2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>人工智能是为机器赋予人的智慧</strong>，而<strong>机器学习</strong>是实现人工智能的手段之一，而<strong>深度学习则是机器学习的分支</strong>，所以三者之间的关系就如上图所示。</p><h2 id="教你一招快速分辨-AI-和-ML"><a href="#教你一招快速分辨-AI-和-ML" class="headerlink" title="教你一招快速分辨 AI 和 ML"></a>教你一招快速分辨 AI 和 ML</h2><p>最后再教你一招如何快速分辨 AI 和 ML：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-898ddb92ecaaefe6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/20229908/answer/73521529">人工智能是什么？ - 林仁翔的回答</a></li><li><a href="https://www.zhihu.com/question/33892253/answer/124327784">什么是机器学习？ - 你不知道我是谁的回答</a></li><li><a href="https://www.zhihu.com/question/57770020/answer/418117913">人工智能、机器学习和深度学习的区别? - 图普科技的回答</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想追女神？先学 Synchronized 吧</title>
      <link href="p/7819.html"/>
      <url>p/7819.html</url>
      
        <content type="html"><![CDATA[<p>在之前的<a href="https://mp.weixin.qq.com/s/WFPTzzJex5R0IFqf2cCQ7Q">《从找对象到多线程》</a>一文中我曾介绍了一些和多线程有关的知识，而谈到多线程，就一定离不开「锁」这个名词。在 Java 中，锁的使用主要有两种：Synchronized 关键字和 Lock 接口，本文将会换个角度来聊一聊 synchronized 中的锁。</p><p>Synchronized 用的锁是存在<strong>对象头</strong>里的，用来表明当前对象所持有的锁。在 Java SE1.6 之前，Synchronized 是作为重量锁出现的，一旦使用了 synchronized，就一定会阻塞到其他线程。而在 Java SE1.6 后，为了减少获得锁和释放锁带来的<strong>性能</strong>问题，引入了”偏向锁”和”轻量锁”的概念。由此可以得知，在新的 Java 中，锁一共有 4 种状态：<strong>无锁状态、偏向锁状态、轻量锁状态和重量锁状态</strong>。这几个状态会随着竞争不断升级且<strong>只能升级不能降级</strong>，即轻量锁只会升级到重量锁而不会降级到偏向锁。</p><p>以上的解释未免太过官方了，我们从一个小例子入手。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gitqf3b5s9j30p00bo3zi.jpg"></p><p>我们用女神来表示同步代码块，就好比女神有很多追求者，同步代码块也会被很多线程执行。有一天女神的微博状态变成了「单身」，此时她就处于<strong>无锁</strong>状态，于是这些追求者纷纷创建了一个名为<strong>「找对象」的线程</strong>，此时对于女神（对象）来说，还没有任何线程来访问她，所以当第一个男生小 A 试图邀请她看电影的时候<strong>（获取锁）</strong>，她会偏向小 A 的邀请，此时她就是处于「<strong>偏向锁」状态</strong>的。有了这次经历之后，小 A 就知道该怎么邀请女神而不用反复试探了，这就是「<strong>可重入锁」，</strong>即同一个线程可以<strong>多次</strong>访问同一代码块。</p><p>再后来女神发了一条微博，说今天和这个男生看电影很开心。这条微博被其他男生看见了，大家也都知道了女神这个对象的偏向状态了。可还是有男生小 B 想追女神，此时这两个男生各自「找对象」的线程就在女神这个对象上产生了<strong>竞争</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gitqfbnj2yj307w05wt8o.jpg"></p><p>小 B 一直关注女神的微博动态，他心想着，只要小 A 被女神拒绝了，女神就会变成「无锁」状态，自己也就有机会被女神偏向了。女神也知道小 B 在追自己，为了找到最合适的另一半，女神也在暗中观察小 B，有<strong>两个竞争者</strong>同时竞争，这时候她就处于<strong>「轻量锁」</strong>的状态。虽然女神明显更喜欢小 A，但在小 B 心里觉得小 A 除了比自己早点出现外根本不具有和自己竞争的能力，于是不断给女神献殷勤，保持关系，这就叫<strong>自旋，</strong>不断的将自己的时间花费在获取锁上，逐渐成为一条舔 🐶。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gitqfexhohj30k00k0mxx.jpg"></p><p>虽然一开始女神也会偶尔答应小 B 的邀请，但当竞争者越来越多后，小 B 变得疯狂起来，追求逐渐变成了骚扰，女神也逐渐不耐烦起来。最终在小 A 的努力下，女神和小 A 确定了关系，并发了微博告知众人，此时她的状态就升级成为<strong>「重量锁」状态</strong>。这时，除了小 A，其他所有竞争者的「找对象」线程都没有办法再追求女神了。这样做的好处就是赶紧断了那些追求者的念头，让他们可以早日觅得其他良人，<strong>不要在一棵树上吊死</strong>。</p><p>从线程的角度来看，重量锁使除了拥有锁的线程外的其他所有线程都阻塞，这样可以有效<strong>防止 CPU 空转</strong>，避免造成资源的浪费。</p><p>在偏向锁和轻量锁阶段，女神还没有和任何人确定关系，只要给点甜头小 B 等其他追求者都会很开心，这是一种「乐观锁」。而一旦女神和小 A 确定了关系，自身状态升级为重量锁后，小 B 就很不开心了，对他来说这就是一种「悲观锁」。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gitqficbb9j3069069jrb.jpg"></p><p>当然，上面所说的乐观锁和悲观锁只是为了方便大家的记忆，实际的定义并不是这样。</p><p>所谓悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。悲观锁假定会发生并发冲突，因此屏蔽一切可能违反数据完整性的操作。就跟上面的例子中，女神已有男朋友之后就不会再答应其他男生的邀约类似。</p><p>而乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gitqfllvhnj307307374c.jpg"></p><p>想到这，我不禁开始怀疑 Synchronized 的设计者是不是经历过类似的事情，不然为什么会这么熟练。只是不知道他究竟是那个线程还是被锁起来的对象。</p><p>以上就是本文的全部内容了，如果你觉得本文对你有所帮助，不妨点个关注支持一波，也欢迎大家在下方评论区留言 👇。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何向女朋友解释在地址栏中输入网址后发生了什么？</title>
      <link href="p/f473.html"/>
      <url>p/f473.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>前几天有个学妹问我为什么在浏览器里面输了网址就会显示出来页面，虽然这个现象很常见，但是要想解释清楚确实有些小困难，当时也只是简单的回答了她，现在想趁着这个机会好好整理下相关知识。整理完才觉得其实就和我们去一个地方找人是一个道理。所以说艺术源于生活却又高于生活，技术同样如此。</p></blockquote><p>在回答这个问题前， 我们先来了解下我们平常说的那个网址到底是啥？</p><p>网址的学名叫做统一资源定位符（<strong>Uniform Resource Locator</strong>， 常缩写为<strong>URL</strong>）， 我们知道现在的互联网其实就是由众多<strong>资源</strong>所构成的一张巨大的网， 如何定位那些资源就是靠的 URL， 因此我们也可以把 URL 理解为是网络上资源的“门牌号“， 我们在浏览器中输入网址， 就相当于开一辆车（浏览器）去找一个地址（URL）</p><h2 id="1-缓存查找"><a href="#1-缓存查找" class="headerlink" title="1. 缓存查找"></a>1. 缓存查找</h2><p>如果你要出门找一个地方， 第一想法肯定是先想这个地方你有没有去过， 你要是去过的话那就不需要问人直接过去就好了。 我们的系统也是这么想的。 当你在浏览器中输入了 URL 之后， 浏览器会先查看 <strong>浏览器缓存</strong> 中有没有这个地址， 如果没有那就再去 <strong>系统缓存</strong>， 如果系统缓存还没有， 那就去路由器缓存找， 总之只要缓存中有， 就说明有这个资源， 那浏览器直接显示出来就好了。</p><blockquote><p><strong>Tips：</strong> 这里说下 <strong>hosts 文件</strong> ， <strong>hosts</strong> 是一个没有扩展名的系统文件， 可以用记事本等工具打开， 其作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联“数据库”， 当用户在浏览器中输入一个需要登录的网址时， 系统会首先自动从 hosts 文件中寻找对应的 IP 地址，一旦找到， 系统会立即打开对应网页， 如果没有找到， 则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。 需要注意的是， hosts 文件配置的映射是静态的， 如果网络上的计算机更改了请及时更新 IP 地址， 否则将不能访问。</p></blockquote><h2 id="2-DNS-解析"><a href="#2-DNS-解析" class="headerlink" title="2. DNS 解析"></a>2. DNS 解析</h2><p>如果你认得去那个地址的路自然是最好， 那如果你根本就没去过那咋办？ 肯定会有人说导航， 但并不是所有的地方都是导航能搜到的， 这个时候我们自然而然就会想着去问路人了。 浏览器也是这样的， 如果在本地缓存中没有找到想要的资源， 那就只能去其他网络上的机器中寻找我想要的资源了。 那你怎么知道你要的资源在那台机器上？ 这时， DNS 就横空出世了。</p><p>DNS（Domain Name System， 域名系统），<strong>DNS 解析的过程就是寻找哪台机器上有你需要资源的过程</strong>。当你在浏览器中输入一个地址时， 例如 <a href="http://www.baidu.com,/">www.baidu.com，</a> 其实这段 URL 并不是真正意义上的地址。 互联网上每一台计算机的唯一标识是它的 IP 地址（比如 127.0.0.1 就是我们本机的 IP 地址）， 但是 IP 地址并不方便记忆（毕竟都是很长的数字串）， 所以也就出现了网址（URL）这个玩意了， 目的就是为了方便普通用户去寻找网络上的其他计算机。 所以 DNS 实际上充当了一个翻译的角色， 将网址翻译成 IP 地址（就跟我想去南京大学， 问路的那个人告诉我南京大学在广州路上是一个道理）。</p><h3 id="2-1-DNS-解析过程"><a href="#2-1-DNS-解析过程" class="headerlink" title="2.1 DNS 解析过程"></a>2.1 DNS 解析过程</h3><p>DNS 解析其实是一个递归查询的过程： <img src="http://upload-images.jianshu.io/upload_images/5666077-7b43dca82cab0c56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未命名图片"></p><p>在上述过程中， 首先在本地域名服务器中查询 IP 地址， 如果没有找到， 本地域名服务器会向根域名服务器发送一个请求， 如果根域名服务器也不存在该域名时， 本地域名会向 com 顶级域名服务器发送一个请求， 依次类推下去。 直到最后找到目标网址所对应的 IP， 并将其缓存到本地， 以供下次使用。</p><h3 id="2-2-DNS-负载均衡"><a href="#2-2-DNS-负载均衡" class="headerlink" title="2.2 DNS 负载均衡"></a>2.2 DNS 负载均衡</h3><p>在讲 DNS 负载均衡前先来看张图片： <img src="http://upload-images.jianshu.io/upload_images/5666077-669a0f99a745cbca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image20190325123632567"></p><p>看到这可能就会有人犯嘀咕了， 我们不是 ping 的同一个网址吗， 为啥两次 IP 都不一样啊？ 其实原因很简单， 如果每次都一样是否说明你请求的资源都位于同一台机器上面， 那么这台机器需要多高的性能和储存才能满足亿万请求呢？ 其实真实的互联网世界背后存在成千上百台服务器， 大型的网站甚至更多。 但是在用户的眼中， 它需要的只是处理他的请求， 哪台机器处理请求并不重要。 DNS 可以返回一个合适的机器的 IP 给用户， 例如可以根据每台机器的负载量， 该机器离用户地理位置的距离等等， 这种过程就是 DNS 负载均衡， 又叫做 DNS 重定向。</p><p>再来举个例子， 如果你在新街口用地图搜南京大学， 返回给你的第一条数据可能就是南京大学鼓楼校区（因为距离最近）， 但如果你是在仙林用地图搜南京大学， 返回给你的第一条数据就有可能是南京大学仙林校区了。 DNS 负载均衡简单来说也是这个道理。</p><h3 id="2-3-DNS-污染"><a href="#2-3-DNS-污染" class="headerlink" title="2.3 DNS 污染"></a>2.3 DNS 污染</h3><p>DNS 污染（DNS cache pollution）， 又称域名服务器缓存投毒（DNS cache poisoning）， 是指一些刻意制造或无意中制造出来的域名服务器数据包， 把域名指往<strong>不正确的 IP 地址</strong>。</p><p>某些网络运营商为了某些目的， 对 DNS 进行了某些操作， 导致上网的用户无法通过域名取得正确的 IP 地址。 某些国家或地区出于某些目的为了防止某网站被访问， 而且其又掌握部分国际 DNS 根目录服务器或镜像， 也会利用此方法进行屏蔽。 （Google、 Facebook 等）</p><p>至于如果防止 DNS 污染， 这里只说一个方法就是修改 hosts 文件， 其他的自行搜索吧。</p><h2 id="3-TCP-连接"><a href="#3-TCP-连接" class="headerlink" title="3. TCP 连接"></a>3. TCP 连接</h2><p>其实在上面 DNS 解析的图中就已经有了 TCP 连接的过程了： <img src="http://upload-images.jianshu.io/upload_images/5666077-d6b7b5665130d54c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们通过 DNS 解析获取到了网址所对应的 IP 地址后， 便需要发起 TCP 连接请求， 这里总共需要三次握手， 具体的过程就不赘述了， 可以查阅相关资料， 这里推荐刘欣老师的<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513094&idx=1&sn=a2accfc41107ac08d74ec3317995955e&scene=21#wechat_redirect">《TCP/IP 之 大明王朝邮差》</a>， 以及大学计算机网络课本里面的 TCP 相关章节。</p><h2 id="4-HTTP-请求"><a href="#4-HTTP-请求" class="headerlink" title="4. HTTP 请求"></a>4. HTTP 请求</h2><p>握手成功后， 浏览器就可以向服务器发送<strong>http</strong>请求了， 请求数据包。 **发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议中发送到服务器指定端口(HTTP 协议 80/8080, HTTPS 协议 443)**。HTTP 请求报文是由三部分组成: 请求行,请求报头和请求正文。</p><h3 id="4-1-请求行"><a href="#4-1-请求行" class="headerlink" title="4.1 请求行"></a>4.1 请求行</h3><p>格式如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Method  RequestURL  HTTPVersion CRLF</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET index.html HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>常用的方法有: <code>GET, POST, PUT, DELETE, OPTIONS, HEAD</code>。</p><h3 id="4-2-请求报头"><a href="#4-2-请求报头" class="headerlink" title="4.2 请求报头"></a>4.2 请求报头</h3><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。</p><blockquote><p>Tips：客户端不一定特指浏览器， 有时候也可使用 Linux 下的 CURL 命令以及 HTTP 客户端测试工具等。</p></blockquote><p>常见的请求报头有: <code>Accept, AcceptCharset, AcceptEncoding, AcceptLanguage, ContentType, Authorization, Cookie, UserAgent</code>等。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-215654ace2ed5bf0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上图是使用 Chrome 开发者工具截取的对百度的 HTTP 请求以及响应报文， 从图中可以看出， 请求报头中使用了<strong>Accept, AcceptEncoding, AcceptLanguage, CacheControl, Connection, Cookie</strong>等字段。 Accept 用于指定客户端用于接受哪些类型的信息， AcceptEncoding 与 Accept 类似， 它用于指定接受的编码方式。Connection 设置为 Keepalive 用于告诉客户端本次 HTTP 请求结束之后并不需要关闭 TCP 连接， 这样可以使下次 HTTP 请求使用相同的 TCP 通道， 节省 TCP 连接建立的时间。</p><h2 id="5-服务器响应"><a href="#5-服务器响应" class="headerlink" title="5. 服务器响应"></a>5. 服务器响应</h2><p>这部分对应的就是后端工程师眼中的 HTTP。 后端从在固定的端口接收到 TCP 报文开始， 这一部分对应于编程语言中的 socket。 它会对 TCP 连接进行处理， 对 HTTP 协议进行解析， 并按照报文格式进一步封装成 HTTP Request 对象， 供上层使用。 这一部分工作一般是由 Web 服务器去进行， 常用的 Web 服务器有 Tomcat, IIS 和 Netty 等等。</p><p>HTTP 响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。 篇幅原因这里就不详细展开了。</p><h2 id="6-浏览器解析网页信息"><a href="#6-浏览器解析网页信息" class="headerlink" title="6. 浏览器解析网页信息"></a>6. 浏览器解析网页信息</h2><p>服务器返回给浏览器的文本信息， 通常是 HTML, CSS, JS, 图片等文件， 那么浏览器是如何对泽泻内容进行渲染呢？ 通常是下面五个步骤：</p><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局， 以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><p>不过这五个步骤在不同内核的浏览器中执行细节是不同的， 想深入了解的可以查阅相关资料， 这里推荐一篇文章：<a href="https://segmentfault.com/a/1190000010298038">《浏览器渲染页面过程与页面优化》</a></p><p>浏览器是一个边解析边渲染的过程。 首先浏览器解析 HTML 文件构建 DOM 树， 然后解析 CSS 文件构建渲染树， 等到渲染树构建完成后， 浏览器开始布局渲染树并将其绘制到屏幕上。</p><p>JS 的解析是由浏览器中的 JS 解析引擎完成的。 JS 是单线程运行， 也就是说， 在同一个时间内只能做一件事， 所有的任务都需要排队， 前一个任务结束， 后一个任务才能开始。 但是又存在某些任务比较耗时， 如 IO 读写等， 所以需要一种机制可以先执行排在后面的任务， 这就是： 同步任务(synchronous)和异步任务(asynchronous)。 JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。 同步任务就是放在主线程上执行的任务， 异步任务是放在任务队列中的任务。 所有的同步任务在主线程上执行， 形成一个执行栈; 异步任务有了运行结果就会在任务队列中放置一个事件； 脚本运行时先依次运行执行栈， 然后会从任务队列里提取事件， 运行任务队列中的任务， 这个过程是不断重复的， 所以又叫做事件循环(Event loop)。 如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-e063a1efbea16636.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>当上述步骤执行完成后我们便可在浏览器中看到一个完整的页面了， 总结下其实就只有几步：</p><ol><li>浏览器地址栏输入 url</li><li>浏览器会先查看浏览器缓存系统缓存路由缓存， 如有存在缓存， 就直接显示。 如果没有， 接着第 3 步</li><li>域名解析（DNS）获取相应的 IP</li><li>浏览器向服务器发起 tcp 连接， 与浏览器建立 tcp 三次握手</li><li>握手成功， 浏览器向服务器发送 http 请求， 请求数据包</li><li>服务器请求数据， 将数据返回到浏览器</li><li>浏览器接收响应， 读取页面内容， 解析 html 源码， 生成 Dom 树</li><li>解析 css 样式、 浏览器渲染， js 交互</li></ol><p>其实简单来看这几个过程并不是很复杂， 但是每个步骤都可以深挖出一大堆的知识， 比如 DNS 的优化、页面渲染的优化、 HTTPS 等等非常多的东西， 这里考虑到篇幅以及科普效果很多东西都一笔带过了，想深入了解的可以在微信公众号 <strong>「01 二进制」</strong> 后台回复 <strong>“计算机网络书籍”</strong> 获取相关专业书籍进行阅读。</p><hr><p>下面是我的微信公众号，感兴趣的可以扫描二维码给个关注哦 😊<br><img src="https://upload-images.jianshu.io/upload_images/5666077-897e724c7b596a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你看那个区块链，像不像我借你的二百元？</title>
      <link href="p/9bcc.html"/>
      <url>p/9bcc.html</url>
      
        <content type="html"><![CDATA[<p>最近这几天区块链又粉墨登场了，新闻媒体也一直在大量报道，宣称可能要在金融界掀起一番浪潮。甚至有人说很久之前中国就出现了区块链的产物——麻将。那么区块链到底是什么，麻将和区块链又有什么关系呢？</p><p>笔者这两天也阅读了相关文献和资料，下图是我学习的一个路径，本文也是按照自己了解区块链的路径做的一些总结，篇幅较长，写这篇文章的目的也是希望能简单地向对区块链技术不了解但是想知道区块链是什么的人介绍区块链技术，因为自己在区块链方面也是一个小白，如果有错误的地方，还望各位留言指正。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8fi138dmij30u012e44a.jpg"></p><h2 id="区块链-gt-比特币"><a href="#区块链-gt-比特币" class="headerlink" title="区块链 -&gt; 比特币"></a>区块链 -&gt; 比特币</h2><p>首先我们得先知道，区块链和比特币之间并不等同，如果要论辈分，区块链应该是比特币的爸爸，为什么这么说呢？我们先来了解下区块链是什么，以及区块链是用来干嘛的。</p><h3 id="什么是区块链？区块链是做什么的？"><a href="#什么是区块链？区块链是做什么的？" class="headerlink" title="什么是区块链？区块链是做什么的？"></a>什么是区块链？区块链是做什么的？</h3><p>一提到区块链，相信很多人都会想到什么去中心化、分布式、不可篡改之类的名词。说实话我刚开始由于姿势水平不够看到这些名词的时候也是一头雾水，《区块链技术发展现状与展望》一文给出如下定义：</p><blockquote><p>狭义来讲，区块链是一种按照时间顺序将数据区块以链条的方式组合成特定数据结构， 并以密码学方式保证的不可篡改和不可伪造的去中心化共享总账(Decentralized shared ledger)，能够安全存储简单的、有先后关系的、能在系统内验证的数据。 </p><p>广义的区块链技术则是利用加密链式区块结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用自动化脚本代码(智能合约)来编程和操作数据的一种全新的去中心化基础架构与分布式计算范式。 </p></blockquote><p>上面的文字毕竟太过学院派了，如果用一句话来概括，区块链其实就是一种<strong>数据结构</strong>（栈和队列也是一种数据结构），既然他是一种数据结构，那区块链的作用自然也就不言而喻了：<strong>组织并存储数据</strong>。剩下的一些定语如「去中心化」、「分布式」这些无非就是对这种数据结构的修饰罢了。**<em>比特币就是应用这种技术制作的数字货币。**</em></p><h3 id="区块-链-区块链？"><a href="#区块-链-区块链？" class="headerlink" title="区块+链=区块链？"></a>区块+链=区块链？</h3><p>既然他和栈一样是一种数据结构，那我们总得知道这个数据结构长什么样子吧。我们把区块链拆分成<strong>「区块」</strong>和<strong>「链」</strong>就会明白区块链长什么样子了。</p><h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f37ejsj8j30nc0fgn05.jpg"></p><p>上图是一个<strong>区块（Block）</strong>示意图，每个区块包含两个部分：</p><ul><li><p><strong>区块头（Block Header）</strong>：记录当前区块的特征值（里面存放的内容我们稍后再说）</p></li><li><p><strong>区块体（Block Body）</strong>：存放的数据</p></li></ul><p>所以，区块就是一种存放数据的东西，可以近似的理解为链表中的节点。</p><h4 id="链"><a href="#链" class="headerlink" title="链"></a>链</h4><p>把许多上图那样的区块连接在一起就形成了区块链，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3hhty51j311207yq97.jpg"></p><p>想要形成一个链，那总得有头吧，链头的区块学名叫做<strong>创世区块（Genesis Block）</strong>。前一个区块称为后一个区块的父区块，反之则称为子区块。 所以，其实区块链就长上面那样，没什么神秘的。</p><p>这时我想肯定会有人问了，你说把区块连接在一起他们就能连接在一起了吗？他们之间是怎么连接的呢？</p><h4 id="如何链接"><a href="#如何链接" class="headerlink" title="如何链接"></a>如何链接</h4><p>这里我也不卖关子了，子区块与父区块是通过父区块的 <strong>哈希（Hash）</strong> 值建立链接的。这里又引入一个新的概念，什么是哈希呢？</p><p>所谓「哈希」就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的哈希长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，<strong>只要原始内容不同，对应的哈希一定是不同的。</strong>因此我们可以得到两个推论：</p><ul><li>推论1：每个区块的哈希都是不一样的，可以通过哈希<strong>唯一标识</strong>区块。</li><li>推论2：如果区块的内容变了，它的哈希<strong>一定</strong>会改变。</li></ul><p>所以我们只需要在每个区块的区块头存放上个区块的哈希值即可。就是下图红线标注的地方。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f49s6gqtj30l60fgwhj.jpg" alt="WX20191029-154534@2x"></p><p>至于如何计算出这个哈希值，不同的区块链有不同的计算方法，这里不多说。</p><blockquote><p>下面这篇文章介绍了比特币是如何计算Block Hash的，有兴趣的可以阅读了解下。👇</p><p><a href="https://www.jianshu.com/p/4187a7352769">https://www.jianshu.com/p/4187a7352769</a></p></blockquote><h2 id="为什么需要区块链？"><a href="#为什么需要区块链？" class="headerlink" title="为什么需要区块链？"></a>为什么需要区块链？</h2><p>看了上面的内容后相信你应该就明白什么是区块链了。但是肯定就会有人说，说到底这不就是链表吗，为什么国家还要大力发展区块链产业，甚至上升到了到战略层面呢？</p><p>的确，区块链的技术原理并不复杂，但是他的『<strong>社会意义</strong>』却是巨大的。</p><p>区块链<strong>本质</strong>上是一种<strong>解决信任问题、降低信任成本</strong>的技术方案，其目的就是为了<strong>去中心化</strong>。</p><p>好了，这里又出现了一个新的概念，<strong>去中心化</strong>？这个名词只要一提到区块链就一定会被提到，所以你一定想知道去中心化到底是什么。不急，在谈去中心化之前，我们先谈一下另一个词——<strong>信任</strong>。</p><h3 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h3><p>对于信任一词，维基百科给出的定义如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f57knxvpj31fs08e408.jpg"></p><p>可能你还是不太能理解，我们再来举个很常见的例子：</p><p>近视的人想要摘下眼镜一般都需要做手术，但是你不清楚这个手术做了之后是否真的可以恢复视力，所以你去找<strong>专家</strong>，这个专家是全国非常有名的眼科医生，他告诉你这个手术做完是可以恢复视力的，所以你就去做手术了。</p><p>还有一种情况是，你在做手术之前问了之前做过这个手术的<strong>亲戚朋友</strong>，他们都说这个手术做完之后可以恢复到正常视力，你觉得他们都成功了，所以你就去做手术了。</p><p>但如果一个<strong>小诊所的医生</strong>告诉你，我们诊所也可以帮你做这个手术，做完也能帮你恢复视力，你会信吗？我想你可能就要好好考虑下了。</p><p>这就是所谓的信任的力量。你不会信任一个没有足够信用度的单独个体，但你会信任<strong>一堆个体</strong>或者有<strong>足够信用度的单独个体</strong>。</p><p>在金融领域，我们平常能接触到的<strong>银行就是这个有足够信用度的个体（中心）</strong>。</p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>仔细想一下上面那个例子，为什么我们会相信眼科专家而不相信小诊所的医生，因为相较于小诊所的医生，眼科专家有更多的信用成本，所以我们往往要为眼科专家付更多的费用。</p><p>对于银行来说，作为信用中介也是需要成本的，而我们普通大众就要为这庞大的信用成本买单。所以才会造就金融业是最赚钱的行业。</p><p>所以如果想要去除银行类等中心机构的信用背书？ 那就可以用我们上面提到过的<strong>「一堆个体」</strong>，这也是区块链技术的核心——<strong>去中心化</strong>。 </p><p>用一句非常洗脑的广告语来描述去中心化就是：<strong>没有中间商赚差价</strong>。</p><h4 id="如何实现去中心化——分布式账本"><a href="#如何实现去中心化——分布式账本" class="headerlink" title="如何实现去中心化——分布式账本"></a>如何实现去中心化——分布式账本</h4><p>我们先来建立一个去中心化的系统，为了方便理解，我们来看一个简单的去中心化借贷模型：如果A借了B 100块钱，这个时候，A在人群中大喊“我是A，我借给了B 100块钱！”，B也在人群中大喊“我是B，A借给了我100块钱！”，此时路人甲乙丙丁都听到了这些消息，因此所有人都在心中默默记下了“A借给了B100块钱”。你看，这个时候一个去中心化的系统就建立起来了，这个系统中不需要银行，也不需要借贷协议和收据，严格来说，甚至不需要人与人长久的信任关系（比如B突然又改口说“我不欠A钱！”，这个时候人民群众就会站出来说“不对，我的小本本上记录了你某天借了A100块钱！”）。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f64svxpmj30k00d8wf0.jpg"></p><p>上述例子中A君、B君和路人甲乙丙丁每个人的小本本上都有 A 借给 B 100块钱这条记录了，那些小本本就是这个去中心化系统中的<strong>分布式账本</strong>。</p><p>那如果发生了很多次交易呢？很简单，那就在小本本上面再添加一条记录就可以了啊。</p><p>久而久之，这个小本本上面就会有很多交易记录了，有没有让你想到什么东西？不错，就是区块链，一条<strong>记录</strong>就是一个<strong>区块</strong>，这个小本本就是一个<strong>区块链</strong>。看到这里你应该就可以理解为什么提到区块链就会提到分布式账本了吧。</p><h2 id="如何操作区块链？"><a href="#如何操作区块链？" class="headerlink" title="如何操作区块链？"></a>如何操作区块链？</h2><p>上文说过比特币就是应用区块链技术制作的数字货币，这里的话我们就以比特币交易为例来看看区块链具体是如何操作的。再介绍流程前，我们先来了解一个概念：<strong>节点/矿工</strong>。</p><blockquote><p>什么是节点？在上个例子中，路人甲乙丙丁都有一个小账本用于记账，每个记账的都是一个<strong>节点</strong>，外号<strong>矿工</strong>。</p></blockquote><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><h4 id="1-挖矿"><a href="#1-挖矿" class="headerlink" title="1. 挖矿"></a>1. 挖矿</h4><p>什么是挖矿？每增加一笔交易，即形成一个区块的过程，就是所谓的<strong>挖矿</strong>。</p><h4 id="2-广播"><a href="#2-广播" class="headerlink" title="2. 广播"></a>2. 广播</h4><p>如果我们想要新增一笔交易（也就是在区块链中新增一个区块），我们需要广播到整个区块链网络中，让所有的节点都承认这条记录 。那么应该如何实现广播的呢？</p><p><strong>区块链的广播机制</strong></p><p>下图画出了区块链广播机制的一个流程：</p><blockquote><ol><li>节点A收到一个区块，对其进行验证并将其广播给其附近的区块；</li><li>节点B收到<em>inv</em>消息后，如果他之前没有接收过这个区块，则向节点A发送一个<em>getdata</em>消息；</li><li>节点A收到<em>getdata</em>消息后，就会把区块和交际记录的具体信息发送给节点B。</li><li>此时节点B也就收到了一个区块，重复1、2、3操作给其附近的区块的。</li></ol></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f8tcghvfj30g2095dgc.jpg"></p><h4 id="3-记录"><a href="#3-记录" class="headerlink" title="3. 记录"></a>3. 记录</h4><p>一旦A节点新增一条记录并广播到网络中，网络中的其他节点如B、C、D等都会在自己的小本本上新增这条记录。一旦记录，之后就不可撤销，且不能随意销毁。为什么不可修改呢？</p><p><strong>区块链的不可修改</strong></p><p>这里就引出了一个区块链的特性——<strong>不可修改</strong>。之所以没有在前面介绍区块链的时候介绍这个特性就是想结合上面的例子来说。试想一下如果有人想修改的其中一条记录，就得先修改自己的这个账本上的这条记录以及这条记录后的所有记录，然后还得按照同样的方式修改别人的账本。这个难度是可想而知的。</p><h2 id="区块链的激励机制"><a href="#区块链的激励机制" class="headerlink" title="区块链的激励机制"></a>区块链的激励机制</h2><p>这一节会介绍下区块链的激励机制，因为比特币已经十分成熟，这里会以比特币作为例子讲解。</p><h3 id="为什么要挖矿？"><a href="#为什么要挖矿？" class="headerlink" title="为什么要挖矿？"></a>为什么要挖矿？</h3><p>整个系统看似很和谐，但是有一个问题不可避免，“凭啥你让我记账我就记账？我的小本本不要钱么？”</p><p>以比特币举例，矿工会把每十分钟（这是比特币系统规定的）产生的交易打包到一个区块之中，一旦生成区块成功，矿工就会收到<strong>两种形式</strong>的奖励，也就是<strong>出块奖励</strong>和<strong>手续费</strong>，奖励过程是程序自动完成的。</p><p><strong>出块奖励</strong></p><p>为了鼓励矿工的服务，对于其所记录和确认的交易，系统为矿工提供25个比特币作为奖励。（这个奖励数量，系统设定每4年减半）</p><p><strong>手续费</strong></p><p>交易双方为了交易被区块链尽早记录会提供给矿工一笔交易费用作为激励。</p><h3 id="谁来发行货币？"><a href="#谁来发行货币？" class="headerlink" title="谁来发行货币？"></a>谁来发行货币？</h3><p>既然我可以收到比特币奖励，那货币究竟是怎么发行出来的？出块奖励是系统生成新币的唯一方式。比特币是通过挖矿来生成并进入流通的，这个过程要消耗很多电力和硬件资源，跟采金矿很类似。生产货币的过程伴随着记账和出块的过程，这就是为何比特币的记账过程被叫做挖矿了。大家都会争着去生成区块，因为只有最快的人才最有可能获得生产这个区块的权力，也才能得到经济激励。</p><h3 id="谁可以收到奖励？"><a href="#谁可以收到奖励？" class="headerlink" title="谁可以收到奖励？"></a>谁可以收到奖励？</h3><p>既然我们知道了挖矿是为了获取奖励、也知道了奖励是从哪来的，这时候就会有新的问题了，奖励到哪去？</p><p>因为没有中心分配奖励，而且每个矿工都会新增一个区块，那奖励该怎么给？难不成每人一份？答案当然是<strong>no！</strong></p><p>奖励只有一份，想要确定奖励对象（即记账权归属的问题），这就要涉及区块链中另一个概念了——<strong>共识机制</strong>。</p><h4 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h4><p>共识机制是区块链网络最核心的秘密。简单来说，共识机制是区块链节点就区块信息达成全网一致共识的机制，可以保证最新区块被准确添加至区块链、节点存储的区块链信息一致不分叉甚至可以抵御恶意攻击。实践中要达到这样的效果需要满足两方面条件：一是选择一个独特的节点来产生一个区块，二是使分布式数据记录不可逆。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8fhkp8m1mj30t70huacm.jpg"></p><p>上图为当前主流的共识机制，主要包括：工作量证明/POW(Proof of Work)、权益证明/POS(Proof of Stake)、工作量证明与权益证明混合(POS+POW)、股份授权证明/DPOS(Delegated Proof-of-Stake)、实用拜占庭容错(PBFT)、瑞波共识协议等。其中比特币使用的是<strong>工作量证明机制</strong>。</p><h4 id="POW机制"><a href="#POW机制" class="headerlink" title="POW机制"></a>POW机制</h4><p>这里简单说下POW机制的工作流程：</p><ol><li><p>节点监听全网数据记录，通过基本合法性验证的数据记录将进行暂存;</p></li><li><p>节点消耗自身算力尝试不同的随机数(nonce)，进行指定的哈希计算，并不断重复该过程直到找到合理的随机数，这一过程也被称为“挖矿”;</p></li><li><p>找到合理的随机数后，生成区块信息(块头+块身);</p></li><li><p>节点对外部广播出新产生的区块，其他节点验证通过后，连接至区块链中，主链高度加一，然后所有节点切换至新区块后继续进行下一轮挖矿。</p></li></ol><p>尽管工作量证明机制解决了记账权归属问题，但是上面的描述实在是太复杂了，我们可以简单的理解为<strong>谁记录的快谁就可以获得奖励</strong>。</p><h3 id="记录的速度一样快怎么办？"><a href="#记录的速度一样快怎么办？" class="headerlink" title="记录的速度一样快怎么办？"></a>记录的速度一样快怎么办？</h3><p>因为整个系统是分布式的，所以有很多机率会出现一样快的情况，所以为了保证节点之间的同步，新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。</p><p>因此，区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。</p><p>这种产出速度不是通过命令达成的，而是<strong>故意设置</strong>了海量的计算。也就是说，只有通过<strong>极其大量的计算</strong>，才能得到当前区块的有效哈希，从而把新区块添加到区块链。由于计算量太大，所以快不起来。</p><p>若两个人同时上传，虽然这个概率很小，但是若发生，我们就看最后的区块链哪条更长，短的那条就失效。这就是区块链中的<strong>“双花问题”</strong>（同一笔钱花两次）。</p><h3 id="如果想造假怎么办？"><a href="#如果想造假怎么办？" class="headerlink" title="如果想造假怎么办？"></a>如果想造假怎么办？</h3><p>如何判断交易是否真实？我们遵循的是<strong>少数服从多数</strong>原则，对于要制作虚假交易，除非你说服了整个网络中超过51%的矿工都更改某一笔账目，否则你的篡改都是无效的。 网络中参与人数越多，实现造假可能性越低。</p><p>这也是集体维护和监督的优越性，伪造成本最大化。说服51%的人造假还是灰常灰常难的。这就是经常提到的<strong>51%攻击</strong>。</p><blockquote><p>脑洞突然大开，我们每个人的记忆不就是个区块链，分布记账法的模式吗。 如果有件事情发生了，有51%以上的人记住了写在自己的脑子里，那这件事情就真的发生了，成为了记忆。相反，如果只有少数的人看到了这件事情的发生，就算发生了也可能会被当成没发生吧。</p></blockquote><h3 id="为什么比特币成功了？其他山寨币失败了？"><a href="#为什么比特币成功了？其他山寨币失败了？" class="headerlink" title="为什么比特币成功了？其他山寨币失败了？"></a>为什么比特币成功了？其他山寨币失败了？</h3><p>过去几年比特币网络的算力悄无声息的增长到了无比之大，这大大增加了比特币成功的可能性。反之也可以解释为什么山寨币不靠谱，太容易被51%攻击。在依赖密码学的数字货币领域，先发优秀是非常明显的。所以51%攻击对于比特币来说并不是一个什么大问题（早在2013年7月，比特币全网算力已经达到世界前500强超级计算机算力之和的20倍），即使有政府集全国之力秘密造出一台超级计算机，用来击溃比特币来挽救自己的货币发行体系，它会发现使用该能力进行挖矿便可垄断比特币的发行权，其收益远大于击溃比特币，动机也就不复存在了。</p><h3 id="比特币是有限的吗？发行结束了怎么办？"><a href="#比特币是有限的吗？发行结束了怎么办？" class="headerlink" title="比特币是有限的吗？发行结束了怎么办？"></a>比特币是有限的吗？发行结束了怎么办？</h3><p>比特币是一个<strong>无通胀</strong>的货币，发行是<strong>有上限的</strong>。系统规定，比特币的出块奖励每四年会减半，到2140年，比特币发行总量到达2100万之后，就不会有出块奖励了，手续费会成为唯一的奖励形式。很多人担心比特币完成了2100万的发行量之后，单纯靠手续费不足以弥补矿工的挖矿支出，这会给比特币带来危机。实际中真的会这样的吗？</p><p>首先，出块奖励消失的过程是非常缓慢的。每四年减半一次，2020年会减半到6.75个，到一百多年后的2140年才会真的消失。社区有几十年的时间去逐步适应这个问题，不会一下子造成巨大的网络震荡。其次比特币的持有者也会因为期待比特币升值，会非常有动力的去推广比特币，然后不断产生手续费，不断产生收益。</p><h3 id="一个有趣的例子"><a href="#一个有趣的例子" class="headerlink" title="一个有趣的例子"></a>一个有趣的例子</h3><p>其实上面就是<strong>挖矿</strong>的流程和一些问题整理了，我之前在网上看到一个有关比特币挖矿的非常有趣的例子，在这里分享出来：</p><blockquote><p>单身汪们要找女票，国民岳母说我有好多女儿，这样吧我给你们出点题目，解出一个就给其中一个姑娘的微信号。</p><p>单身汪们疯狂竞争，想破脑袋去解题。只要其中一只汪解出一道题，就立马得意洋洋地昭告天下，示威全部单身汪，这个姑娘是我的啦，你们放弃吧。其他单身汪们即使不服也没有办法，惆怅懊恼也不是个事儿啊，还是麻溜地立马去解下一道题目吧。这只喜赢姑娘的幸运小汪被岳母认可后还能得到25个货币单位的彩礼，简直人生赢家。</p></blockquote><h2 id="麻将和区块链"><a href="#麻将和区块链" class="headerlink" title="麻将和区块链"></a>麻将和区块链</h2><p>看了这么多，想必你也已经有些累了，不妨让我们回到文章开头的问题，麻将到底和区块链又有什么关系呢？</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8fc6876c0j30ia0ixt9u.jpg" style="zoom:50%;" /><p>麻将是中国传统的区块链项目。他拥有以下几个特征：</p><ol><li><p>去中心化。不像斗牛闲家只能赢庄家的钱，麻将谁的牌都能胡。</p></li><li><p>比赛挖矿。四个矿工一桌，最先正确组合出13张牌的矿工将获得奖励。</p></li><li><p>不可篡改。打错了牌绝不能反悔，其他人指定不同意。</p></li><li><p>公开透明。都是桌上现金交易，没有暗箱操作。</p></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后我们总结下，区块链主要有以下核心内容：</p><h3 id="1-去中心化"><a href="#1-去中心化" class="headerlink" title="1. 去中心化"></a>1. 去中心化</h3><p>这是区块链颠覆性特点，不存在任何中心机构和中心服务器，所有交易都发生在每个人电脑或手机上安装的客户端应用程序中。</p><p>实现点对点直接交互，既节约资源，使交易自主化、简易化，又排除被中心化代理控制的风险。</p><h3 id="2-开放性"><a href="#2-开放性" class="headerlink" title="2. 开放性"></a>2. 开放性</h3><p>区块链可以理解为一种公共记账的技术方案，系统是完全开放透明的，</p><p>账簿对所有人公开，实现数据共享，任何人都可以查账。</p><h3 id="3-不可撤销、不可篡改和加密安全性"><a href="#3-不可撤销、不可篡改和加密安全性" class="headerlink" title="3. 不可撤销、不可篡改和加密安全性"></a>3. 不可撤销、不可篡改和加密安全性</h3><p>区块链采取单向哈希算法，每个新产生的区块严格按照时间线形顺序推进，时间的不可逆性、不可撤销导致任何试图入侵篡改区块链内数据信息的行为易被追溯，</p><p>导致被其他节点的排斥，造假成本极高，从而可以限制相关不法行为。</p><hr><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8fd2jaat2j31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的系统可用性 5 个 9 了吗？</title>
      <link href="p/431c.html"/>
      <url>p/431c.html</url>
      
        <content type="html"><![CDATA[<p>又是一年放榜日，众多考生满怀期待的点开招生网，结果输了信息才发现根本没办法查询——查询人数太多了，直接把系统打挂了！</p><p>这个时候，还没翻身的码农闰土被问到一个直击心灵的问题：这个系统可用性达到了多少个 9？</p><p>想要回答这个问题，我们得先有些前置知识。</p><h2 id="可用性-amp-可靠性"><a href="#可用性-amp-可靠性" class="headerlink" title="可用性&amp;可靠性"></a>可用性&amp;可靠性</h2><p>这两个词很相似，我也一直找不到一个很好的定义区分这两个词，直到后来在看分布式系统的时候，看到了一个解释：</p><blockquote><p>可用性被定义为系统的一个<strong>属性</strong>，它说明系统已准备好，马上就可以使用。换句话说，高度可用的系统在任何给定的时刻都能及时地工作。<br>可靠性是指系统可以无故障地持续运行，是一个<strong>持续的状态</strong>。与可用性相反，可靠性是根据时间段而不是任何时刻来进行定义的。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/5666077-8c5c18ff0153414b.png&originHeight=226&originWidth=226&size=34806&status=done&style=none&width=226?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>举个例子，想要评估一个舔 🐶，可用性就是你找他的时候能不能找到，而可靠性就是你需要花钱的时候他出手大不大方。一个舔 🐶 如果随叫随到，但是花钱太抠，就是高可用、低可靠；而如果他经常找不到人，但出手很大方，就是低可用、高可靠。</p><p>类比到系统时，如果系统在每小时崩溃 1ms，那么它的可用性就超过 99.9999%，但是它还是高度不可靠。与之类似，如果一个系统从来不崩溃，但是每年要停机两星期，那么它是高度可靠的，但是可用性只有 96%。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-0e6fc48e557d9a64.png&originHeight=461&originWidth=640&size=60750&status=done&style=none&width=411?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>百度百科对于系统可靠性的解释是：系统可靠性一般是指在规定的时间内和规定的工况下，系统完成规定功能的能力/概率。也就是系统的无故障运行概率。而在我们在评估一个系统的可用性和可靠性时，一般都会说三个 9，四个 9 之类的。这些一般都是说系统的**SLA(Service Level Agreement)**具体是几个「9」，以此，来表示该系统一年中具体宕机的时间。对于这几个 9 的解释，我会放到第三节来详细解释。</p><p>不过，在实际交流过程中，大多数人对这两个词的理解还是差不多的。况且咬文嚼字也并非本文的主题，接下来我们来看看可用性的计算方式。</p><h2 id="可用性计算"><a href="#可用性计算" class="headerlink" title="可用性计算"></a>可用性计算</h2><p>通常我们用 A 表示一个系统的可用性，用以下几个指标来辅助计算：</p><h3 id="相关指标"><a href="#相关指标" class="headerlink" title="相关指标"></a>相关指标</h3><h4 id="MTBF"><a href="#MTBF" class="headerlink" title="MTBF"></a>MTBF</h4><p>MTBF,即平均故障间隔时间，英文全称是“Mean Time Between Failure”。是衡量一个产品（尤其是电器产品）的可靠性指标。单位为“小时”。具体来说，是指相邻两次故障之间的平均工作时间，也称为平均故障间隔。</p><h4 id="MTTR"><a href="#MTTR" class="headerlink" title="MTTR"></a>MTTR</h4><p>MTTR，全称是 Mean Time To Repair，即平均修复时间。是指可修复产品的平均修复时间，就是从出现故障到修复中间的这段时间。MTTR 越短表示易恢复性越好。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-fd931ef75d19cb18.png&originHeight=457&originWidth=1097&size=214887&status=done&style=none&width=1097?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过上述公式计算出单个组件的可用性后，我们便可以以此计算出整个系统的可用性，而系统可用性是通过将系统建模为串联和并联的组件来计算的。以下规则用于确定系统是串联的还是并联的：</p><ul><li>如果组件的失效导致组合变得不可操作，则认为这两个部件是串联操作的</li><li>如果组件的故障导致另一部件接管故障部件的操作，则认为这两部件并行操作</li></ul><h3 id="串行可用性"><a href="#串行可用性" class="headerlink" title="串行可用性"></a>串行可用性</h3><p><img src="https://upload-images.jianshu.io/upload_images/5666077-582e2fa107864bec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如上图所示，两个组件 X 和 Y，如果有一个出问题导致整个组合都不可用，就认为 X 和 Y 这两个组件是串联的。只有组件 X 和组件 Y 同时可用时，整个组合才可用。由此可见，组合的可用性是这两部分的乘积，公式如下：</p><p>A = Ax Ay</p><p>从上面的等式我们看出，串联系统中，整体组合的可用性，总是低于单个组件的可用性。</p><p>对于上面 X 和 Y 两个串联组件，可用性如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-ca7542edaaad8340.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>从上面的表中，我们看到，即使使用了非常高可用性的组件 Y，但组合系统仍然受组件 X 的影响，会降低好多，和「木桶原理」一致，都受最短板的影响。</p><h3 id="并行可用性"><a href="#并行可用性" class="headerlink" title="并行可用性"></a>并行可用性</h3><p><img src="https://upload-images.jianshu.io/upload_images/5666077-6ab5009c312ae817.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如上图所示，如果两个组件都失败时，整个系统会失败的话，这两个组件会被认为是并行的。任一组件可用时，整个系统都是可用的。整体可用性是 1- (两个组件都不可用)，公式如下：</p><p>A = 1-(1-Ax )2</p><p>从上面我们能看出，两个组件并行的系统，整体可用性要任一单独的组件可用性高。如上图假设是组件 X 的两个部分，可用性如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-df4db79df86f5702.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们看到，即使一个可用性低的组件 X，组合后的系统可用性也很高。</p><h2 id="X-个-9"><a href="#X-个-9" class="headerlink" title="X 个 9"></a>X 个 9</h2><p>说完了可用性的计算后，总算是回到本文的重点了，有个衡量其可靠性的标准——X 个 9，X 个 9 表示在系统 1 年时间的使用过程中，系统可以正常使用时间与总时间（1 年）之比，我们通过下面的计算来感受下 X 个 9 在不同级别的可靠性差异。</p><ul><li>3 个 9：(1-99.9%) × 365 × 24=8.76 小时，表示该系统在连续运行 1 年时间里最多可能的业务中断时间是 8.76 小时。</li><li>4 个 9：(1-99.99%) × 365 × 24=0.876 小时=52.6 分钟，表示该系统在连续运行 1 年时间里最多可能的业务中断时间是 52.6 分钟。</li><li>5 个 9：(1-99.999%) × 365 × 24 × 60=5.26 分钟，表示该系统在连续运行 1 年时间里最多可能的业务中断时间是 5.26 分钟。</li></ul><p>那么 X 个 9 里的 X 只代表数字 3<del>5，为什么没有 1</del>2，也没有大于 6 的呢？我们接着往下计算：</p><ul><li>1 个 9：(1-90%) × 365=36.5 天</li><li>2 个 9：(1-99%) × 365=3.65 天</li><li>6 个 9：(1-99.9999%) × 365 × 24 × 60 × 60=31 秒</li></ul><p>可以看到 1 个 9 和、2 个 9 分别表示一年时间内业务可能中断的时间是 36.5 天、3.65 天，这种级别的可靠性或许还不配使用“可靠性”这个词；而 6 个 9 则表示一年内业务中断时间最多是 31 秒，那么这个级别的可靠性并非实现不了，而是要做到从“5 个 9” 到“6 个 9”的可靠性提升的话，后者需要付出比前者几倍的成本。</p><table><thead><tr><th>可用性 A</th><th>X 个 9</th><th>停机时间（分钟）</th><th>适用产品</th></tr></thead><tbody><tr><td>0.999</td><td>3 个 9</td><td>500</td><td>电脑或服务器</td></tr><tr><td>0.9999</td><td>4 个 9</td><td>50</td><td>企业级设备</td></tr><tr><td>0.99999</td><td>5 个 9</td><td>5</td><td>一般电信级设备</td></tr><tr><td>0.999999</td><td>6 个 9</td><td>0.5</td><td>更高要求电信级设备</td></tr></tbody></table><h2 id="怎么做到更多的-9？"><a href="#怎么做到更多的-9？" class="headerlink" title="怎么做到更多的 9？"></a>怎么做到更多的 9？</h2><p>每个公司对几个 9 的定义都不一样，好多的互联网公司要求都是 99.99。像一些事业单位网站，办事网站等，经常故障服务不可用，估计最高也就到 99.9。</p><p>而我们经常用到所谓 4 个 9 或者 5 个 9，也就是 99.99%与 99.999%。虽然这两者的差距是 0.009%，还不到 0.01%。但对于系统而言，恰恰是这不到 0.01%的差距，决定了系统完全不在一个档次上。</p><p>我们知道一个系统的可靠性并不完全取决于硬件，而由软件和硬件共同来决定，如果是软件问题，就需要监控自己的服务，在服务出现异常或者宕机的时候，能及时恢复。增加冗余，防止出现问题。</p><p>但是要提高系统的可靠性，除软件外，还有硬件的部分，包括网络、服务器以及存储设备等。其中，网络可以借助多运营商接入来解决，存储有 RAID、快照等应对技术，通过备份来提高数据安全性。对于服务器来说，我们可以选择集群的方式保证高可用。</p><hr><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghzqtz801ij30go0go40v.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从网易云日推浅谈个性化推荐系统--基于用户的协同过滤算法</title>
      <link href="p/f93c.html"/>
      <url>p/f93c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>这是 2019 年的第一篇文章，因为最近导师给了一个新的任务，有关某 app 的个性化推荐的，正好自己也是第一次学习这方面的知识，便想着汇总整理下。前人栽树，后人乘凉，因为篇幅原因，这一部分准备分开来叙述，本篇主要和大家介绍基于用户的协同过滤算法，希望可以对大家有所帮助，如有谬误，还望指正！</strong></p></blockquote><h3 id="什么是个性化推荐系统？"><a href="#什么是个性化推荐系统？" class="headerlink" title="什么是个性化推荐系统？"></a>什么是个性化推荐系统？</h3><p>其实个性化推荐系统早已渗透进我们的生活了，网易云音乐的“每日推荐”，淘宝的”猜你喜欢“，这些都是生活中非常常见的个性化推荐的案例。如今，随着大数据的发展，个性化推荐早已涉及诸多领域，比如电子商务（京东淘宝）、电影和电视网站（youtube）、个性化音乐网络电台（网易云音乐）、社交网络（QQ）、个性化阅读（微信读书）、基于位置的个性化服务（美团）等。推荐算法的本质是通过一定的方式将用户和物品联系起来，而不同的推荐系统也会根据实际情况采取不同的推荐方式。</p><p>一般来说<strong>一个完整的推荐系统一般包括以下三个参与方：</strong></p><ol><li>被推荐对象</li><li>推荐物品的提供者</li><li>提供推荐系统的网站</li></ol><a id="more"></a><p>以网易云音乐的日推为例：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-e78c1919c4706cf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300"></p><p>首先，推荐系统需要满足用户的需求，给用户推荐那些令他们感兴趣的音乐。其次，推荐系统要尽量让各个歌手的歌都能够被推荐给对其感兴趣的用户，而不是只推荐几个大流量歌手的歌。最后， 好的推荐系统设计，能够让推荐系统本身收集到高质量的用户反馈，不断完善推荐的质量，增加用户和网站的交互，提高网站的收入。如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-e92cd2701bd35062?imageMogr2/auto-orient/strip%7CimageView2/2/w/300"></p><h3 id="什么是好的推荐系统？"><a href="#什么是好的推荐系统？" class="headerlink" title="什么是好的推荐系统？"></a>什么是好的推荐系统？</h3><p>想要评判一个东西好不好，一定要有个标准。那么推荐系统好坏的标准是什么呢？试想一下为什么大家都喜欢网易云音乐的每日推荐而不喜欢今日头条的每日推送呢？最直观的感受就是网易云的日推歌曲你爱听，而头条的推送你很讨厌。所以说<strong>预测准确度是推荐系统领域的重要指标（没有之一）</strong>。</p><blockquote><p>好的推荐系统不仅仅能够准确预测用户的行为，而且能够<strong>扩展用户的视野</strong>，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西（比如网易云音乐经常给你推送那些非常好听但是比较冷门的歌曲）。同时，推荐系统还要能够帮助商家将那些被埋没在长尾中的好商品介绍给可能会对它们感兴趣的用户。</p></blockquote><h3 id="协同过滤（Collaborative-Filtering）"><a href="#协同过滤（Collaborative-Filtering）" class="headerlink" title="协同过滤（Collaborative Filtering）"></a>协同过滤（Collaborative Filtering）</h3><p>为了让推荐结果符合用户口味，我们需要深入了解用户。如何才能了解一个人呢?《论语·公冶长》中说“听其言，观其行”，也就是说可以通过用户留下的文字和行为了解用户兴趣和需求。</p><p>实现个性化推荐的最理想情况是用户能主动告诉系统他喜欢什么，比如很久之前注册网易云音乐的时候会让用户选择喜欢什么类型的歌曲，但这种方法有 3 个缺点:首先，现在的自然语言理解技术很难理解用户用来描述兴趣的自然语言；其次，用户的兴趣是不断变化的，但用户不会不停地更新兴趣描述；最后，很多时候用户并不知道自己喜欢什么，或者很难用语言描述自己喜欢什么。</p><blockquote><p>因此，我们需要通过算法自动发掘用户行为数据，从用户的行为中推测出用户的兴趣，从而给用户推荐满足他们兴趣的物品。</p></blockquote><p>基于<strong>用户行为分析</strong>的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为<strong>协同过滤算法（Collaborative Filtering Algorithm）</strong>。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。</p><p>既然是基于用户的行为分析，就必须要将用户的行为表示出来，下表给出了一种用户行为的表示方式（当然，在不同的系统中，每个用户所产生的行为也是不一样的），它将个用户行为表示为 6 部分，即<strong>产生行为的用户和行为的对象、行为的种类、产生行为的上下文、行为的内容和权重</strong>。</p><table><thead><tr><th>表示</th><th>备注</th></tr></thead><tbody><tr><td>user id</td><td>产生行为的用户的唯一标识</td></tr><tr><td>item id</td><td>产生行为的对象的唯一标识</td></tr><tr><td>behavior type</td><td>行为的种类（比如说是点赞还是收藏）</td></tr><tr><td>context</td><td>产生行为的上下文，包括时间和地点等信息</td></tr><tr><td>behavior weight</td><td>行为的权重（如果是听歌的行为，那么权重可以是听歌时常）</td></tr><tr><td>behavior content</td><td>行为的内容（如果是评论行为，那么就是评论的文本）</td></tr></tbody></table><p>随着学术界的大佬们对协同过滤算法的深入研究，他们提出了很多方法，比如<strong>基于邻域的方法（neighborhood-based）</strong>、隐语义模型（latent factor model）、基于图的随机游走算法（random walk on graph） 等。在这些方法中，最著名的、在业界得到最广泛应用的算法是<strong>基于邻域的方法</strong>，而基于邻域的方法主要包含下面两种算法：</p><ul><li>基于用户的协同过滤算法（User-based Collaborative Filtering），简称 UserCF 或 UCF，这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。</li><li>基于物品的协同过滤算法（Item-based Collaborative Filtering），简称 ItemCF 或 ICF，这种算法给用户推荐和他之前喜欢的物品相似的物品。</li></ul><h4 id="基于用户的协同过滤算法"><a href="#基于用户的协同过滤算法" class="headerlink" title="基于用户的协同过滤算法"></a>基于用户的协同过滤算法</h4><p>在一个在线个性化推荐系统中，当一个用户 A 需要个性化推荐时，可以先找到和他有相似兴趣的其他用户，然后把那些用户喜欢的、而用户 A 没有听说过的物品推荐给 A。这种方法称为基于用户的协同过滤算法。</p><p>基于用户的协同过滤算法主要包括两个步骤：</p><ol><li>找到和目标用户 A 兴趣相似的用户集合。</li><li>找到这个集合中的用户喜欢的，且目标用户 A 没有听说过的物品推荐给目标用户。</li></ol><p>步骤 1 的关键就是<strong>计算两个用户的兴趣相似度</strong>。这里，协同过滤算法主要利用<strong>行为的相似度</strong>计算兴趣的相似度。</p><blockquote><p>举个栗子 🌰：假设现在有三个用户 A、B、C，已经知道 A 连续 5 天都在听周杰伦和林俊杰的歌，B 连续 5 天在听刘德华和张学友的歌，C 连续听了 5 天林俊杰和张杰的歌，那么你说 A 和谁的兴趣相似度更高，自然是 C。</p></blockquote><p>刚才是你在脑海中思考这个问题的，那如果让机器思考 A 和谁的兴趣相似度更高呢？</p><p>其实也很简单，不过在进行下一步的讲解之前，先让我们回顾下基本的数学知识：</p><blockquote><p>在数学中，我们通过测量两个<a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F/1396519">向量</a>的夹角的<a href="https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6/73670">余弦</a>值来度量它们之间的相似性，两个向量有相同的指向时，余弦相似度的值为 1；两个向量夹角为 90° 时，余弦相似度的值为 0；两个向量指向完全相反的方向时，余弦相似度的值为-1。名曰：“<strong>余弦相似性</strong>”。最重要的是这一定律不仅仅适用在二维空间，对任何维度的<a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4">向量空间</a>中都适用，因此余弦相似性常用于高维正空间。例如在<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/831904">信息检索</a>中，每个词项被赋予不同的维度，而一个文档由一个向量表示，其各个维度上的值对应于该词项在文档中出现的频率。余弦相似度因此可以给出两篇文档在其主题方面的相似度。</p></blockquote><p>考虑到大多数人可能已经忘了怎么计算余弦相似度了，在这再给大家开个小灶，简单的回顾下计算方法，想要深入了解的，请自行 Google。</p><p>假设有二维向量 a,b 如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-688610890876cd23?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>则他们的余弦相似度为：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-911ac3a249714eb2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>推广到多维向量$a(a1,a2,a3,a4……)$，$b(b1,b2,b3,b4……)$：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-6fdb5e0a95b9cbcc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>理解了上述数学知识，接下来的就是基本操作了，首先我们先给定两个用户$i$和$j$，令$N(i)$表示$i$ 听过的歌的集合，$N(j)$表示$j$听过的歌的集合，那么$\left | N(i)\bigcap N(j) \right |$就表示$i$、$j$ 都听过的歌的集合，$\left | N(i)\left |  \right |N(j) \right |$就表示$i$或 $j$ 听过的歌的集合总数，$W_{ij}$表示用户$i$和用户$j$的相似度。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-372e1b7b7e1833a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们来尝试计算下 A 和 D 之间的兴趣相似度：</p><p>从<strong>“用户打开过的网页”</strong>可以看出，A 和 D 都听过的歌只有 d，也就是 1 个。用户 A 打开过的网页数=3，用户 D 打开过的网页数=3。所以 A 和 D 的相似度$W_{AD}=\frac{1}{\sqrt{3*3}}=\frac{1}{3}$。其他的计算也是类似的。</p><p>在得到用户之间的相似度之后，我们要做的就是解决<strong>步骤 2</strong>的问题了，假设 e 是刚刚发布的新歌，用户 C 和用户 D 都已经听过了，那么如何计算 A 对新歌 e 的感兴趣程度呢？</p><blockquote><p>得到用户之间的兴趣相似度后，UserCF 算法会给用户推荐和他兴趣最相似的 K 个用户喜欢的物品。如下的公式度量了 UserCF 算法中用户 u 对物品的感兴趣程度：</p><p>$$p(u,i)=\sum_{v\in S(u,K)\cap N(i)}^{ }W_{uv}r_{vi}$$</p><p>其中，$S （u, K）$包含和用户$ u $兴趣最接近的$ K $个用户，$N (i）$是对物品$ i $有过行为的用户集合，$W_{uv}$是用户$ u$ 和用户$v$ 的兴趣相似度，$r_{vi}$代表用户 $v$ 对物品的兴趣，因为使用的是单一行为的隐反馈数据，所以所有的 $r_{vi}$ =1。</p></blockquote><p>上面一大段截取自<a href="https://book.douban.com/subject/10769749/">《推荐系统实践》</a>，可能很多人看到这公式和这解析有些云里雾里，简单来说就是：</p><p>$$p(A,e)=W_{AB}*R_{Be}+W_{AC}*R_{Ce}+W_{AD}*R_{De}$$</p><p>其中$P(A,e)$表示 A 对 e 的兴趣度，$W_{AB}$表示 A 与 B 的相似度，$R_{Be}$表示 B 对 e 的兴趣度 ，以此类推。因为我们这里用的不是评分制，而是考虑是否听过这首歌，那么 C 听了 e，C 对 e 的兴趣度就是 1，B 没听过这首歌，所以 B 对 e 的兴趣度为 0。</p><p>所以我们可以预测 A 对 e 的相似度为：</p><p>$$p(A,e)=\frac{1}{\sqrt{3*2}}<em>1+\frac{1}{\sqrt{3</em>3}}*1=\frac{1}{\sqrt{6}}+\frac{1}{3}=0.74158$$</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章从网易云音乐的每日推荐这个生活中很常见的例子，引出了什么是推荐系统，一个好的推荐系统是什么样子的，进而引出协同过滤的概念，并且介绍了什么是基于用户的协同过滤，同时还回顾了余弦相似性等数学知识。然而真正在实际的企业产品中，基于用户的协同过滤并不会这么简单，判断两个用户的相似程度也不是简简单单的使用余弦相似性就可以了，考虑到本文旨在让更多的人对个性化推荐有个简单的概念，本文就不详细展开了，推荐阅读相关的论文，下一篇文章将会介绍基于内容的协同过滤算法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个性化推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从网易云日推浅谈个性化推荐系统--基于内容的协同过滤算法</title>
      <link href="p/e01e.html"/>
      <url>p/e01e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>上篇文章介绍了基于用户的协同过滤算法，该算法在一些网站（如 Facebook）中得到了应用，但该算法有一些缺点。首先，随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系。其次，基于用户的协同过滤很难对推荐结果作出解释。因此，著名的电子商务公司亚马逊提出了另一个算法一基于内容的协同过滤算法。</p></blockquote><h2 id="什么是基于内容的协同过滤算法"><a href="#什么是基于内容的协同过滤算法" class="headerlink" title="什么是基于内容的协同过滤算法"></a>什么是基于内容的协同过滤算法</h2><p>在进入本文的正题之前，先打开网易云音乐看下今天的日推：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-41752e0493926127?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>看了上述的标记，是不是瞬间理解了为啥用网易云听音乐的时候会有上瘾的感觉，因为他给你听的都是你爱听的啊。就跟小时候我妈给我做菜是一样的，今天知道我喜欢吃红烧肉，明天为了照顾我的喜好又为了保证不重样，第二天就给我做了糖醋排骨，久而久之产生了依赖性，体重也开始飙升了。</p><p>上述就是 <strong>基于内容的协同过滤算法（Item-based collaborative filtering，简称 ItemCF）</strong> 在生活中常见的案例，该算法给用户推荐那些和他们之前喜欢的内容相似的内容。比如，该算法会因为你购买过《数据挖掘导论》而给你推荐《机器学习》。不过，ItemCF 算法并不利用内容的内容属性计算内容之间的相似度，它主要通过分析用户的行为记录计算内容之间的相似度。该算法认为，内容 A 和内容 B 具有很大的相似度是因为喜欢内容 A 的用户大都也喜欢内容 B。</p><p>事实上，由于人和人之间的差异性远大于内容和内容之间的差异（不然怎么会说你女朋友翻脸比翻书还快呢 🙈），<strong>ItemCF 算法</strong>算是目前业界应用最多的算法。无论是淘宝首页猜你喜欢，还是网易云音乐、哔哩哔哩、YouTube，其推荐算法的基础都是该算法。</p><blockquote><p>Tips：基于内容的协同过滤算法可以利用用户的历史行为给推荐结果提供推荐解释，比如上图中网易云日推的标签，会告诉你是根据你收藏的某某单曲推荐的。</p></blockquote><h2 id="基于内容的协同过滤算法"><a href="#基于内容的协同过滤算法" class="headerlink" title="基于内容的协同过滤算法"></a>基于内容的协同过滤算法</h2><p>如果你理解了我的上一篇文章<a href="https://juejin.im/post/5c2e1e0ce51d45690a254d98">《从网易云日推浅谈个性化推荐系统（1）–基于用户的协同过滤算法》</a>，那你也很容易就可以联想到想要实现一个基于内容的协同过滤需要有以下两步：</p><ol><li><p>计算内容之间的相似度。</p></li><li><p>根据内容的相似度和用户的历史行为给用户生成推荐列表。</p></li></ol><h3 id="计算内容之间的相似度"><a href="#计算内容之间的相似度" class="headerlink" title="计算内容之间的相似度"></a>计算内容之间的相似度</h3><h4 id="1-确定计算相似度的公式"><a href="#1-确定计算相似度的公式" class="headerlink" title="1.确定计算相似度的公式"></a>1.确定计算相似度的公式</h4><p>很显然，步骤（1）的关键就是计算两个内容之间的相似度，亚马逊显示相关内容推荐时的标题是 <strong>“Customers Who Bought This Item Also Bought” (购买了该商品的用户也经常购买的其他商品)</strong> ，相当于就下了一个定义，根据这个定义，我们可以用下面的公式定义内容的相似度：</p><p>$$W_{ij}=\frac{\left | N(i)\cap N(j) \right |}{\left | N(i) \right |}$$</p><p>这里，分母$\left | N(i) \right |$是喜欢物品$i$的用户数，而分子$\left | N(i)\cap N(j) \right |$是同时喜欢物品$i$和物品$j$的用户数。因此，上述公式可以理解为喜欢物品$i$的用户中有多少比例的用户也喜欢物品$j$。</p><p>上述公式虽然看起来很有道理，但是却存在一个问题。如果物品$j$很热门，很多人都喜欢， 那么$W_{ij}$就会很大，接近 1。因此，该公式会造成任何物品都会和热门的物品有很大的相似度，这对于致力于挖掘长尾信息的推荐系统来说显然不是一个好的特性。为了避免推荐出热门的物品， 可以用下面的公式:</p><p>$$W_{ij}=\frac{\left | N(i)\cap N(j) \right |}{\sqrt{\left | N(i)\left |  \right |N(j) \right |}}$$</p><p>是不是似曾相识？没错，我们又碰到了熟悉的余弦相似性，为什么说这个公式相对公平呢？因为在该公式中，$N(j)$对于整个式子的影响会比上一个式子小，即该公式<strong>公式惩罚了物品$j$的权重</strong>，因此减轻了热门物品会和很多物品相似的可能性。</p><p>从上面的定义可以看到，在协同过滤中两个物品产生相似度是因为它们共同被很多用户喜欢，也就是说每个用户都可以通过他们的历史兴趣列表给物品“贡献”相似度。这里面蕴涵着一个假设，就是每个用户的兴趣都局限在某几个方面，因此如果两个物品属于一个用户的兴趣列表，那么这两个物品可能就属于有限的几个领域，而如果两个物品属于很多用户的兴趣列表，那么它们就可能属于同一个领域，因而有很大的相似度。</p><h4 id="2-建立相似度矩阵并计算相似度"><a href="#2-建立相似度矩阵并计算相似度" class="headerlink" title="2.建立相似度矩阵并计算相似度"></a>2.建立相似度矩阵并计算相似度</h4><p>和 UserCF 算法类似，用 ItemCF 算法计算物品相似度时也可以首先建立用户-物品倒排表（即对每个用户建立一个包含他喜欢的物品的列表），然后对于每个用户，将他物品列表中的物品两两在共现矩阵 C 中加 1。</p><div align=center><img src="https://user-gold-cdn.xitu.io/2019/1/4/1681934978aec521?w=1336&h=1080&f=jpeg&s=107755" style="zoom:60%" /></div><p>上图是一个根据上面的程序计算物品相似度的简单例子。图中最左边是输入的用户行为记录，每一行代表一个用户感兴趣的物品集合。然后，对于每个物品集合，我们将里面的物品两两加一，得到一个矩阵。最终将这些矩阵相加得到上面的$C$矩阵。其中$C[i][j]$记录了同时喜欢物品$i$和物品$j$的用户数。最后，将$C$矩阵归一化可以得到物品之间的余弦相似度矩阵$W$。然后再根据上一篇的余弦相似性的计算方法即可计算出不同物品之间的相似度了。</p><h4 id="3-推荐物品"><a href="#3-推荐物品" class="headerlink" title="3.推荐物品"></a>3.推荐物品</h4><p>在得到物品之间的相似度后，ItemCF 通过如下公式计算用户$u$对一个物品$j$的兴趣:</p><p>$$P_{uj}=\sum_{i\in N(u)\cap S(j,K)}^{ }W_{ji}r_{ui}$$</p><p>这里$N(u)$是用户喜欢的物品的集合，$S(j,K)$是和物品$j$最相似的$K$个物品的集合，$W_{ji}$是物品$j$和$i$<br>的相似度，$r_{ui}$是用户$u$对物品$i$的兴趣。</p><p>该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。</p><h2 id="举个栗子-🌰"><a href="#举个栗子-🌰" class="headerlink" title="举个栗子 🌰"></a>举个栗子 🌰</h2><p>上面一大段可能有点枯燥，不过没关系，相信举了下面的栗子之后，你们可能就会对该算法有个基本的了解了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-6c6c18c2d51e2388?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个基于内容推荐的简单例子"></p><p>上图是一个基于内容推荐的简单例子。该例子中，用户喜欢《晴天》和《江南》两首歌。然后 ItemCF 会为这两首歌分别找出和它们最相似的 3 首歌，然后根据公式的定义计算用户对每首歌的感兴趣程度。比如，ItemCF 给用户推荐《不能说的秘密》，是因为这首歌和《晴天》相似，相似度为 0.4，而且这首歌也和《江南》相似，相似度是 0.5。考虑到用户对《晴天》的兴趣度是 1.3，对《江南》的兴趣度是 0.9，那么用户对《不能说的秘密》的兴趣度就是 1.3 × 0.4 + 0.9×0.5 = 0.97。</p><blockquote><p>从这个例子可以看到，ItemCF 的一个优势就是可以提供推荐解释，即利用用户历史上喜欢的</p><p>物品为现在的推荐结果进行解释。</p></blockquote><h2 id="UserCF-V-S-ItemCFU"><a href="#UserCF-V-S-ItemCFU" class="headerlink" title="UserCF V.S. ItemCFU"></a>UserCF V.S. ItemCFU</h2><p>网上在比较这两个推荐算法的时候，往往都是先放上各种曲线比较图，例如召回率、覆盖率的比较等等，然而作为小白那样的图可能看的并不是十分的明白。倒不如直接进行这两个算法在实际使用中的对比情况：</p><h4 id="UserCF-和-ItemCF-算法在现实中的应用"><a href="#UserCF-和-ItemCF-算法在现实中的应用" class="headerlink" title="UserCF 和 ItemCF 算法在现实中的应用"></a>UserCF 和 ItemCF 算法在现实中的应用</h4><table><thead><tr><th>公司</th><th>算法</th><th>用途</th></tr></thead><tbody><tr><td>腾讯</td><td>UserCF</td><td>微信 7.0 的看一看功能</td></tr><tr><td>GroupLens</td><td>UserCF</td><td>个性化的新闻推荐</td></tr><tr><td>网易</td><td>ItemCF</td><td>网易云音乐的歌曲推荐</td></tr><tr><td>阿里巴巴</td><td>ItemCF</td><td>淘宝的首页猜你喜欢</td></tr></tbody></table><p><strong>那为什么新闻推荐使用 UserCF 算法，而购物网站使用 ItemCF 算法？</strong></p><p>UserCF 算法的推荐结果着重于反映那些与目标用户兴趣相似的小群体的热点，而 ItemCF 算法的推荐结果着重于维护目标用户的历史兴趣。换句话说，UserCF 的推荐更加社会化，而 ItemCF 的推荐更加个性化。</p><h3 id="UserCF-与-ItemCF-算法的比较"><a href="#UserCF-与-ItemCF-算法的比较" class="headerlink" title="UserCF 与 ItemCF 算法的比较"></a>UserCF 与 ItemCF 算法的比较</h3><table><thead><tr><th></th><th>UseCF</th><th>ItemCF</th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>适合于用户数量较小的场景，如果用户很多，则计算用户之间相似度矩阵的代价很大</td><td>适用于物品数量明显小于用户数量的场景，如果物品很多，则计算物品之间相似度矩阵的代价很大</td></tr><tr><td><strong>领域</strong></td><td>时效性较强，用户个性化兴趣不太明显的领域</td><td>长尾物品丰富，用户个性化需求强烈的领域</td></tr><tr><td><strong>实时性</strong></td><td>用户的新行为不一定导致推荐结果的立即变化</td><td>用户的新行为一定会导致推荐结果的实时变化</td></tr><tr><td><strong>冷启动</strong></td><td>当新用户对很少量的物品产生行为后，不能立即对他进行推荐，因为用户相似度表一般是每隔一段时间离线计算的。 当新物品上线后，一旦有某个用户对该物品产生行为，就可以将该物品推荐给与该用户相似的其他用户</td><td>新用户只要对一个物品产生行为，就可以向他推荐与该物品相似的其他物品 必须在更新了物品相似度表（离线）之后，才能将新的物品推荐给其他用户</td></tr><tr><td><strong>推荐理由</strong></td><td>很难提供令用户信服的推荐解释</td><td>利用用户的历史行为来作为推荐理由，容易令用户信服</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章紧接上文，介绍了什么是基于内容的协同过滤，当然，真正用到企业级产品时，其相似度也不可能只用简单的余弦相似性就能描述了，考虑到各种特殊情况，可能还需要将内容的相似度进行归一化，当然这就需要你深入了解了，本文就不详细展开了，推荐阅读相关的论文。文章最后比较了下 UCF 和 ICF，大家只需要知道在什么情况下哪种推荐算法更加实用即可，毕竟适合自己的才是最好的。下一篇我将会用 python 代码结合 tensorflow 来训练一个最简单的电影个性化推荐模型。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个性化推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天我们来种一棵树</title>
      <link href="p/e64d.html"/>
      <url>p/e64d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>Image by pangziai on Pixabay</em></p></blockquote><p>今天是一年一度的植树节，说到树，我就想到了《西游记》中的古树精，今年下半年。。。好了好了，不皮了，我们直接开花。今天就趁着植树节来种一棵我们程序员的“树”吧。</p><h2 id="什么是“树”？"><a href="#什么是“树”？" class="headerlink" title="什么是“树”？"></a>什么是“树”？</h2><p>在种树之前，我们先来了解下什么是树？看个例子：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a91038bb9108937b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>不对不对，放错了，应该是下面这个：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-990a44a75b83d719?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>维基百科对于树的定义是：</p><blockquote><p>在计算机科学中，<strong>树</strong>（英语：tree）是一种<strong>抽象数据类型</strong>（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&gt;0）个有限结点组成一个具有层次关系的<strong>集合</strong>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p></blockquote><p>说白了，只要是形如上图的数据结构就叫树。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>自然界中有“迎客松”、“轩辕柏”这样出名的树，我们今天要种的树也是我们 IT 圈里面的扛把子——“二叉树”。</p><p>二叉树是数据结构中一种重要的数据结构，也是树表家族<strong>最为基础</strong>的结构之一。</p><p>二叉树的特点是每个结点最多有两个子树，左边的叫做左子树，右边的叫做右子树，二叉树要么为空，要么由根结点、左子树和右子树组成，而左子树和右子树分别是一棵二叉树。 下面这棵树就是一棵二叉树。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9e42ed87bec359ba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h3><ul><li><strong>结点（node）</strong>：上图中的 A、B、C。。。就是一个结点</li><li><strong>结点的度</strong>：一个结点含有的子树的个数称为该结点的度</li><li><strong>树的度</strong>：一棵树中，最大的结点的度称为树的度</li><li><strong>深度</strong>：对于任意节点 n , n 的深度为从根到 n 的唯一路径长，根的深度为 0；</li><li><strong>高度</strong>：对于任意节点 n , n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0；</li></ul><h3 id="种树"><a href="#种树" class="headerlink" title="种树"></a>种树</h3><blockquote><p>接下来的代码均用 Java 展现，完整代码可在公众号「01 二进制」后台回复“二叉树”查看。</p></blockquote><p>现在我们就开始种一棵如上图的树吧。根据定义，我们了解到，结点是一棵二叉树<strong>最重要</strong>的元素，而作为一个结点，必须满足以下条件：</p><ol><li>根结点</li><li>左子树和右子树</li></ol><p>因此我们可以创建一个结点类（TreeNode）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    String data;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(String data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个结点类之后我们就可以创建出一个如上图的树了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">createTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    root.left = <span class="keyword">new</span> TreeNode(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    root.right = <span class="keyword">new</span> TreeNode(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    root.left.left = <span class="keyword">new</span> TreeNode(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    root.left.right = <span class="keyword">new</span> TreeNode(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    root.right.left = <span class="keyword">new</span> TreeNode(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">    root.right.right = <span class="keyword">new</span> TreeNode(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，一棵树不就种好了吗？</p><h3 id="树的特征"><a href="#树的特征" class="headerlink" title="树的特征"></a>树的特征</h3><p>作为一个新时代的好青年，我们不能把树种好了就不管不顾了，得负起责任啊。最起码你要知道自己的树长啥样吧。所以接下来我们就来看看如何获取<strong>树的特征</strong>。</p><p>我们描述一个人的特征往往都是从他的外形、长相、身材入手的，描述一颗树也是如此，我们接下来将会从下面几个角度去获取树的特征：</p><ul><li>判断是否为空</li><li>获取树的高度</li><li>获取树中的结点个数</li></ul><h4 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取树的高度"><a href="#获取树的高度" class="headerlink" title="获取树的高度"></a>获取树的高度</h4><p>这里我们采用递归的方式，因为树的高度是由其子树决定的，所以我们只需要比较左、右子树的高度然后取最大值即可，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归结束：空树高度为0</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> j = height(root.right);</span><br><span class="line">        <span class="keyword">return</span> (i &lt; j) ? (j + <span class="number">1</span>) : (i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取树的结点大小（个数）"><a href="#获取树的结点大小（个数）" class="headerlink" title="获取树的结点大小（个数）"></a>获取树的结点大小（个数）</h4><p>一个树的结点个数必定为其左子树的结点个数 + 右子树的结点个数 +1，因此我们同样可以用递归非常简单的将其表示出来：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取结点大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + size(root.left) + size(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>上一节中我们获取到了树的特征，但这远远不够，特征只能粗略的描述一个二叉树，想要详细的了解一个二叉树，我们必须对其进行“遍历”。</p><p><strong>遍历二叉树</strong>是指以一定的次序访问二叉树中的每个结点。所谓<strong>访问结点</strong>是指对结点进行各种操作的简称（最简单的就是访问该结点的值）。</p><p>而访问结点无非就 3 个操作：</p><ul><li>访问结点本身（N）</li><li>访问左结点（L）</li><li>访问右结点（R）</li></ul><p>我们以根结点为核心，如果先访问根节点在访问左右结点成为<strong>前序遍历</strong>；如果先访问左结点然后根结点最后右结点则为<strong>中序遍历</strong>；若最后访问根节点则为<strong>后序遍历</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-6d74c29e621687ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>因此上图的遍历结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序：A B D E C F G</span><br><span class="line">中序：D B E A F C G</span><br><span class="line">后序：D E B F G C A</span><br></pre></td></tr></table></figure><p>当然这只是我们自己根据定义手写出来的，该如何用代码表示出来呢？</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>根据定义我们知道，前序遍历就是先访问根结点，然后是左结点和右结点，因此用递归可以很简单的展现这一过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(root.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>同理我们也可以很快的知道中序和后序遍历了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        System.out.print(root.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里遍历二叉树的代码均是以<strong>递归</strong>方法完成的，非递归遍历二叉树的过程较为麻烦，由于篇幅限制，这里就不放出来了。若想查看<strong>非递归</strong>版本的代码可在公众号「01 二进制」后台回复“二叉树”查看。</p></blockquote><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>事实上，以人来看一个树的话大多都是一层一层的看，这种遍历方式称为<strong>层序遍历</strong>。具体思路：用队列实现，先将根节点入队列，只要队列不为空，然后出队列，并访问，接着讲访问节点的左右子树依次入队列。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelTravel</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode temp = q.poll();</span><br><span class="line">        System.out.print(temp.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) q.add(temp.left);</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) q.add(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="二叉树的作用"><a href="#二叉树的作用" class="headerlink" title="二叉树的作用"></a>二叉树的作用</h3><p>二叉树是种非常强大的数据结构，那她到底强大在哪里呢？我们来看下面这个简单的例子：</p><blockquote><p>该例来自于 Aditya Bhargava 的《算法图解》</p></blockquote><p>假如说，你想从微博中找到一个人，最快的方法一般是二分查找。但当有新用户增加时，都得将新用户插入组别内再排序，因为二分查找法只会有序的组别才有用。</p><p>所以就有人想了，如果可以将新增的用户插入到数组的正确位置就好了，这样就不需要在插入后在排序了。</p><p>于是就有人设计了一种二叉树：对于每个结点,左子节点的值都比它小，右子节点值都比它大。如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-e74f3044585bf8bf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><code>Maggie</code>排在<code>David</code>后面，因此向右找<code>Maggie</code>，排在<code>Manning</code>前面，因此向左找。</p><p>这个<strong>运行时间,用大 O 表示法,平均运行时间是 O(log2 N),最差运行时间是 O(N)</strong></p><p>在有序数组查找时，与二分查找法运行时间相同。</p><p>二叉树对比二分查找法优势在于&lt;如下图&gt;：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-0ae21d4e7efd3e72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>可以看出<strong>插入和删除速度都快。</strong>二叉树的缺点也很明显，就是<strong>不能随机访问。</strong></p><h3 id="二叉树的扩展"><a href="#二叉树的扩展" class="headerlink" title="二叉树的扩展"></a>二叉树的扩展</h3><p>上述例子其实就是一个二叉查找树的简易使用，那么除此之外二叉树还有什么常见的应用呢？下面列出四个，有兴趣的小伙伴可以自己搜索相关的文档阅读学习。</p><ul><li>B- 树，是一种特殊的二叉树，数据库常用它来存储数据。</li><li>B+ 树，B+树是 B-树的一种变体，主要用于磁盘文件组织、数据索引和数据库索引等场景。</li><li>红黑树，二叉平衡树的一种，Java 中的 TreeSet ,TreeMap，HashMap 就是这种数据结构。</li><li>堆，是一种完全二叉树，可以实现优先队列。</li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>种一棵树最好的时间是十年前，而后是现在。我们常常去后悔过去的事情。遗憾自己犯的错误，遗憾自己错过的机会。虽然现实很让人感到可惜，但其实很多事情早就该做了，再懊恼又有什么用呢？与其无端抱怨还不如行动起来。当你感到遗憾时，才是行动的最好时机！</p><hr><p>“关注我最好的时间是 3 分钟前，而后是现在 👇”</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-69426c28dc62a653?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从找对象到多线程</title>
      <link href="p/e0a1.html"/>
      <url>p/e0a1.html</url>
      
        <content type="html"><![CDATA[<p>最近遇到了一个和多线程有关的事，顺便简单复习了下相关概念，稍后举个栗子🌰来解释下。</p><h3 id="进程-and-线程"><a href="#进程-and-线程" class="headerlink" title="进程 and 线程"></a>进程 and 线程</h3><p>进程我们都知道，就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p><p>而线程从属于进程，是程序的<strong>实际</strong>执行者。一个进程至少包含一个主线程，也可以有更多的子线程。</p><p>我们可以简单的理解：为了做一件事，我开了一个进程，为了让这件事更有效率的完成，我开了多个线程。</p><h3 id="从找对象入手加深理解"><a href="#从找对象入手加深理解" class="headerlink" title="从找对象入手加深理解"></a>从找对象入手加深理解</h3><p>如果这么说还是不清楚的话，我们以一个<strong>找对象</strong>的例子来加深理解：</p><p>​    读研了，望着身边的小伙伴一个个都是成双成对，笔者有一个万年单身的好基友就跟一条酸菜鱼似的（又酸又菜又多余），想着要不也找个女朋友吧？于是就创建了一个名为<strong>「找对象」的进程</strong>。但是学校女生太多了，如果一个一个试的话不知道啥时候才能脱单。这时候，万能的度娘给出了建议，为什么不同时下手呢？</p><p>于是，他就创建了<strong>两个「撩妹」的线程</strong>，每个线程负责撩一个妹子。但这时就有问题出来了。</p><p>​    虽然他可以同时撩两个妹子，但是有些事情就是没办法<strong>同时</strong>和两个妹子做，比如上课、吃饭、散步。这个时候就需要<strong>「数据保护」</strong>。做这些事情的时候，他一次只能跟一个妹子做，这就叫做<strong>「临界区」</strong>。他撩的两个妹子，一个是红玫瑰，一个是白玫瑰，各有各的特点，这是她们的<strong>「私有属性」</strong>。这两个妹子都可以跟他约会，此时他就是一个<strong>「共享内存」</strong>。如果某一天他跟其中一个妹子在外面约会，那另一个撩妹线程就只能<strong>「阻塞」</strong>了。但是为了防止后院起火，不让另一个妹子不爽，他就只能发条朋友圈说自己在学习，不想被打扰，这就叫<strong>「互斥锁」</strong>。同时为了不让她们影响对方的存在，他用QQ叫着其中一个的小名，微信却是另一个的情侣头像，这就是<strong>「消息传递」</strong>。</p><p>​    上述两个线程在某种意义上就构成了<strong>「竞态条件」</strong>（个人认为叫做「竞争状态」会更好）。如果他只有这两个线程的话，想要完成「找对象」这个进程，就只能看这两个线程谁的<strong>执行效率更高（其实就是看谁先运行完）</strong>了。这么一看，我的好基友貌似很快就可以完成「找对象」这一进程了，因为无论是哪个线程，只要有一个「撩妹」线程结束了，整个进程也就结束了。</p><p>​    但是在结束前*<strong>可能*<strong>会出现一些问题（注意这里是可能），如果他在排约会档期时一旦没有进行良好的调度，就很有可能会出现两个妹子约在同一天约会，基友却没办法到达的情况，这种情况就叫</strong>「死锁」*<em>，即较长时间的等待或资源竞争。亦或是如果不幸被两个妹子都发觉了对方的存在，却又为表大度，</em></strong>你让我我让你*<strong>，最终导致「找对象」进程无法进行下去，这就叫做</strong>「活锁」<strong>。 如果此时出现了一个**<em>「工具人」</em></strong>妹子，主动倒追我基友，这样的话即使被加入了「找对象」的进程，也可能会因为一系列问题始终没法和他单独约会（毕竟还有两个「撩妹」线程在进行着），这种情况就叫做<strong>「饥饿」</strong>。 这三种情况总结一下就是：</p><ol><li>死锁：争来争去 谁也得不到</li><li>活锁：让来让去 谁都不拥有</li><li>饥饿：排多久 都轮不到自己</li></ol><p>倘若我基友最后撩成功的女朋友并不是他最喜欢的那个人，即最终的运行结果和预期不同，这就叫<strong>「线程不安全」</strong>。反之，如果最后撩成功的妹子是他最喜欢的，即最终的结果和预期相同，那这个就叫<strong>「线程安全」</strong>。</p><p>这么一看，真是人生如戏。只是可悲的是，我本以为现在执行的是一个单进程，却没想到也只是别人的一个线程罢了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70kyzo7w9j30c80960t6.jpg"></p><hr><p>如果你觉得我的文章还不错，不妨扫描下方二维码关注我，你的支持是我前进的最大动力💪</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g71248v19yj31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科普系列——从网购/直播入手理解什么是CDN</title>
      <link href="p/88b6.html"/>
      <url>p/88b6.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信很多人在制作自己的第一个网站的时是很激动的。我们知道，在一个网站项目中，页面里经常会有许多 JavaScript 以及 CSS 的引用，如果是直接引用项目内文件的话，他们可能是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-40676dd79ad48aba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这种方式的优点是开发省力，发布省力，对服务器要求小，省钱，没有具体公网接入需求。</p><p>然而如果你的网站里面有很多图片或者视频并且需要部署到公网上时，网站的访问速度一定会让你倍感崩溃。就像下面这张图 👇</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-9351bc271a65b652.gif?imageMogr2/auto-orient/strip"></p><p>这时候肯定会有推荐你使用 CDN 来加速网站里的一些 JavaScript 和 CSS 文件，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-a3ecb4874d32bd72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其实上面的图片就已经使用到 CDN 了。那到底什么是 CDN 呢？</p><p>在解释什么是 CDN 之前，我们先来看一个身边非常常见的案例—— <strong>网购</strong>。</p><h2 id="京东自营与淘宝的购物体验"><a href="#京东自营与淘宝的购物体验" class="headerlink" title="京东自营与淘宝的购物体验"></a>京东自营与淘宝的购物体验</h2><p>相信现在应该没有人没用过淘宝和京东的，在说 CDN 之前我们先来说下我在淘宝和京东的购物体验。下面是我在使用这两个电商平台时的情况：</p><ul><li>在淘宝买第三方店家商品</li><li>在京东购买自营商品</li></ul><p>之前我在淘宝买了一个雷电 3 的扩展坞，发货地是深圳，花了三天才到南京，如果收货地是河南呢？新疆呢？我想时间就更长了。可是我在河南的同学在京东（自营）买了一个手机下午购买的第二天早晨就收到货了（并不是给京东打广告）。这是为什么呢？</p><p>我们在用京东购物的时候，如果仔细观察的话可以发现，京东自营会根据我们的收货地点，在全国范围内找离我们最近、送达最快的仓库，比如我在南京下的订单，他可能就会从上海甚至直接从南京发货；如果是在洛阳下单可能就会从郑州发货。这样做的好处就是不管我们在南京，还是乌鲁木齐，我们的收货时间会大大减少。<strong>CDN</strong> 就类似于京东建立的这种仓储系统。</p><h2 id="从网购到-CDN"><a href="#从网购到-CDN" class="headerlink" title="从网购到 CDN"></a>从网购到 CDN</h2><p>不知道上面的描述是否清楚，这里为了加深理解，我制作了下面的流程对比图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-567c3c10ed200f26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>为了让货物更快的送到买家手中，京东建立了这种仓储系统；类比到网络中，为了让用户更快地加载网页（可以理解为服务器给浏览器送页面），CDN 横空出世了。</p><p>CDN 的全称是 <strong>Content Delivery Network</strong>，即<strong>内容分发网络</strong>。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据<strong>网络流量和各节点的连接、负载状况以及到用户的距离和响应时间</strong>等综合信息将用户的请求<strong>重新导向</strong>离用户<strong>最近</strong>的服务节点上（如下图所示）。其目的是使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-2a633684ff154114.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="从“直播”理解一些和-CDN-有关的名词"><a href="#从“直播”理解一些和-CDN-有关的名词" class="headerlink" title="从“直播”理解一些和 CDN 有关的名词"></a>从“直播”理解一些和 CDN 有关的名词</h2><p>从上面的描述中我们得知了 CDN 的作用以及大概原理，但是其中的细节并没有展开来说。其实 CDN 的一些细节通常会和一些名词联系上，例如<strong>负载均衡</strong>、<strong>源站</strong>之类的。同样的，我们以一个身边的例子——<strong>“直播”</strong>——来讲解这些和 CDN 有关的名词。</p><p>我们知道，视频其实是由一帧一帧的图片组成的，所以直播的时候我们收到的视频画面的流程可以近似理解为下面这样 👇</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-11974ee8d8a58bd5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然而事实是这样的吗？当然不是！一个主播怎么可能只有一个观众，所以应该是下面这样 👇</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-6a4b4f8fdff3fac4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上图的方式是主播把相同的数据同时传给多个不同的观众，这当然是非常愚蠢的方式，<strong>同样的数据</strong>被传了多次，主播端的瓶颈非常明显，比如有 1000 个观众同时观看的时候，主播端根本无法承担这么多的数据传输。</p><p>所以很容易想到的一个方式就是在主播和用户之间增加一个性能<strong>非常强悍</strong>的服务器充当<strong>中间人</strong>的角色，从服务器把数据发给不同用户，也就是下面这样 👇</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-e09155d61f855383.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里的服务器主要有两个作用：1. 接收来自主播的数据（推流）；2. 将收到的数据分发给用户（分发）。</p><blockquote><p>当然，如果这里的服务器性能过于强悍，那么它除了可以执行推流和分发的作用外，还可以实现美颜、特效、鉴黄等功能。这时，这台服务器就又多了一个身份——<strong>流媒体处理中心</strong>。</p></blockquote><p>可是一台服务器的性能也是有上限的，假设一台服务器最多可以支持 1000 个用户同时观看的话，如果用户数远远大于 1000 的话又该怎么办呢？相信读到这里的小伙伴一定都知道可以怎么做了，没错，那就是再添加一层服务器（集群），如下图所示 👇</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-de579ffc8c35d56b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上图中，服务器 0 负责接收主播的视频数据，然后传递给服务器 1、2、3……，然后再由这些服务器分发给用户。考虑到用户之后有可能还会访问这些数据，所以他们就干脆把数据在服务器 1、2、3……上都存储了一份。</p><h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h3><p>接下来我们从上面的描述中来理解一些概念。</p><p><strong>负载均衡</strong></p><p>当观众人数不太多的时候，例如总共只有 1000 人，那么是选择让某一台服务器服务这 1000 人，还是 3 台服务器分担 1000 人，还是 2 台？机器也会有新旧之分，老机器只能抗 800 数量，那要怎么来分配呢？等等问题。这里就需要有一个策略来做资源的分配。这个策略叫做：负载均衡。负载均衡通常可以利用<strong>重定向、反向代理等</strong>方式实现，常用的负载均衡算法有<strong>轮询法、随机法、最小连接数法等</strong>（篇幅问题，这里不再阐述）。</p><p><strong>CDN 缓存</strong></p><p>考虑到用户之后有可能还会访问这些数据，所以他们就干脆把数据在服务器 1、2、3……上都存储了一份（最简单的例子就是多个用户可能会在不同的时间段访问同一张图片）。这个概念叫做：CDN 缓存。</p><p><strong>回源、源站、边缘节点</strong></p><p>当分配到服务器 1 的第一个观众进入时，服务器 1 是没有存储数据的，它会向服务器-0 获取数据，这个过程叫做：回源；相应的，服务器-0 被称为：源站；服务器 1、2、3……这些负责内容分发的被称为边缘节点。</p><p><strong>缓存命中/缓存命中率</strong></p><p>观众请求的数据如果由 CDN 缓存提供，叫做缓存命中，所有用户请求的缓存命中比例叫做缓存命中率，它是衡量 CDN 质量的关键指标。</p><p><strong>就近原则</strong></p><p>一名新进入的观众会被分配到哪一台服务器上呢？理论上，这台服务器距离用户的网络链路越短、不跨网，数据的传输的稳定性就越好，这个叫做：就近原则。</p><h2 id="CDN？对象存储？"><a href="#CDN？对象存储？" class="headerlink" title="CDN？对象存储？"></a>CDN？对象存储？</h2><p>通过上面的介绍，我们知道 CDN 的主要目的就是为了加速访问，服务对象主要是<strong><em>直播、点播、网页静态文件、小文件等</em></strong>。这时候可能就会有人问了，为了加速一些小文件的访问，我也会使用一些厂家的对象存储服务，例如阿里的 OOS，百度的 BOS 等。那对象存储和 CDN 又有什么区别呢？</p><p>的确，这两者的目的其实都是加速用户的访问，但是侧重点完全不同。CDN 的重点在于<strong>分发</strong>，对象存储的重点在于<strong>存储</strong>。可以把对象存储简单理解为网盘，CDN 是高速公路。</p><p>以图片存储为例，<strong>对象存储是存图片的，CDN 是加速下载图片的。</strong>所以在很多情况下，二者是配合使用的，目前这一套组合也已经成为互联网应用的一个必不可少的组成部分。</p><h2 id="使用-CDN-的好处"><a href="#使用-CDN-的好处" class="headerlink" title="使用 CDN 的好处"></a>使用 CDN 的好处</h2><p>说了这么多，如果只是为了加速网站的访问速度，完全可以选择其他方式，为什么一定要用 CDN 呢？或者说，除了可以加速，CDN 还有什么好处？</p><ol><li>有利于搜索排名。谷歌等搜索引擎已经把网站访问速度作为一个结果排名的重要指标了。</li><li>网站不容易宕机。其实这就和把鸡蛋放在很多篮子里是一个道理，多个服务器分流之后，源站的压力就会小很多。</li><li>减少托管成本。大多数服务器的带宽都是有限制的，分流之后不同的文件被存放在不同的服务器上，可以减少带宽产生的费用。</li></ol><h2 id="怎么使用-CDN"><a href="#怎么使用-CDN" class="headerlink" title="怎么使用 CDN"></a>怎么使用 CDN</h2><p>怎么使用 CDN 是个比较难回答的问题，因为如果要自己搭建一套 CDN 服务难度非常大，但如果只是想要使用的话，有很多大厂都有自己的 CDN 服务，不同厂家都有不同的收费标准和特性，这个就因人而异了，具体使用看各家的文档即可。一般在 html 中使用的时候我会直接去 BootCDN 上复制粘贴下需要使用的库。</p><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p>虽然有句话叫做“凡是能通过怼硬件来实现的都别浪费时间做软件优化”，但是从上面的解释中我们也能得知，CDN 的能力和那些边缘节点有很大关系，假设硬件投入已经饱和了，还有什么方式可以加速整个访问流程呢？</p><p>压缩传输数据！如果可以实现将传输过程中的数据更进一步的压缩同时保持信息不变，那传输过程中各个节点所需要承担的压力就会小很多了，自然而然就可以加速访问了。</p><p>我最喜欢的美剧之一《硅谷》讲述的就是主人公 Richard 开发出的一种开创性的“通用压缩算法”，并以此创业的故事。按照剧里的描述，该算法可以改变已有的互联网世界。遗憾的是该剧中的算法现实中并不存在，但这并不影响这是一部十分优秀的美剧，推荐每一个从事 IT 领域的人观看。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>鉴于笔者能力有限，如果有什么疑问或建议可以在评论区留言。新来的小伙伴不妨给个关注，你们的支持我前进的最大动力 💪</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-a02396dfd4b73744.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><p><strong>参考文章</strong></p><ol><li><a href="https://www.jianshu.com/p/57433bc34659">CDN 是什么鬼</a></li><li><a href="https://zhuanlan.zhihu.com/p/52362950">到底什么是 CDN？</a></li><li><a href="https://www.zhihu.com/question/36514327">CDN 是什么？使用 CDN 有什么优势？ - 知乎</a></li><li><a href="%5Bhttps://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF%5D(https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF)">内容分发网络</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科普系列——如何解释什么是 AJAX？</title>
      <link href="p/aaa8.html"/>
      <url>p/aaa8.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学妹这学期新开了一门课《Script 及 AJAX 开发技术》，然而临近学期末，她突然跑来问我：到底什么是 AJAX ？相信很多人（尤其是前端）在写代码的时候经常会用到 AJAX 技术，但是如果真要说出个所以然，可能还会有些困难。其实简单概括下，AJAX 就是一种利用 JavaScript 向服务端发起请求，并获得服务端响应的<strong>技术</strong>。它的特点是<strong>异步请求，局部刷新。</strong></p><blockquote><p><strong>Tips：</strong>这里我将<strong>技术</strong>二字加粗了，是因为很多初学者会以为 AJAX 是一个库/框架，类似于<em>JQuery/Vue</em>之类的，因而有很多初学者会提出该怎么安装 AJAX 的问题。事实上 AJAX 是一种技术。</p></blockquote><p>虽然概括起来很简单，但是 AJAX 技术的一些细节仍然值得我们思考，接下来我会详细的介绍。</p><h2 id="AJAX-解决的问题"><a href="#AJAX-解决的问题" class="headerlink" title="AJAX 解决的问题"></a>AJAX 解决的问题</h2><p>我们刚才说过了，AJAX 是一种发送<strong>请求</strong>的技术，那在 AJAX 被发明前，浏览器是如何请求的呢？</p><ol><li>地址栏。用户在地址栏输入 <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> ，按回车，就向 <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 发起了一个请求。（同时页面刷新）</li><li>a 标签。用户点击页面中的 a 链接，也会发起一个请求。（同时页面刷新）</li><li>img 标签。页面中如果有 img 标签，那么就会发起一个对此图片的请求（页面没有刷新，但是只能请求图片）类似的还有 link 标签、script 标签，都可以对一类文件的请求。</li></ol><p>在这三种方式中，除了第三种，其他两种方式想要发送一个请求，就必须要刷新页面，如果页面只有展示内容的话刷新一下自然无所谓，但倘若一个页面有很多的表单内容需要填写，而你在最后填写完成提交的时候才告诉你，其中某一个地方不符合要求，要你回去重填，然后刷新一下页面，内容都消失了，怕是当时就可能会气的暴走了吧。</p><p>也正是这种极端的用户体验让微软创新地开发了一个接口 ActiveXObject(“Microsoft.XMLHTTP”)，并在 IE 5.0 中开放给开发者用。通过该接口，浏览器可以向服务器发送请求并取回所需的数据，并在客户端采用 JavaScript 处理来自服务器的回应。这就是 AJAX 的前身。随后这种技术被谷歌的开发人员发现并运用在 Gmail 中，再然后就是 W3C 制定了一个标准用来规范 AJAX，至此 AJAX 算是正式成为每一个前端开发者的必备技能了。</p><p>通过 AJAX 技术，服务器和浏览器之间交换的数据大量减少，服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此服务端的负荷也减少了许多。</p><h2 id="AJAX-的原理"><a href="#AJAX-的原理" class="headerlink" title="AJAX 的原理"></a>AJAX 的原理</h2><p>那 AJAX 的实现原理又是什么呢？我们先来看一下 AJAX 的定义，以下内容摘自维基百科：</p><blockquote><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（异步的<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>与<a href="https://zh.wikipedia.org/wiki/XML">XML</a>技术），指的是一套综合了多项技术的<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>开发技术。</p></blockquote><p>这里又出现了一个新的名词：<strong>异步</strong>。这个名词在计算机领域可以说是一个很重要的名词了，很多技术都离不开异步二字，比如 Nodejs 的<strong>异步</strong>非阻塞 I/O 模型，当然这就是题外话了。我们应该怎么理解这里的异步呢？</p><p>不急不急，我们先来看一个生活中非常常见的例子 🌰：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-abeef41042891d22.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这种场景在上学的时候很常见，其实 AJAX 的原理和上述流程很相似，不信你看下面：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-269d112e62ac5a37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上述例子中，核心是班长（也就是 HXR 对象），班主任可以通过他传递消息（客户端构建 XHR 对象发送请求）然后收到响应。在班长去通知小明的过程中，班主任仍然可以继续手头的工作，这就是一个异步的过程。（果然生活处处皆学问）</p><p>那么我们又该如何在代码中使用这个 XHR 对象呢？</p><h2 id="AJAX-的使用"><a href="#AJAX-的使用" class="headerlink" title="AJAX 的使用"></a>AJAX 的使用</h2><p>XHR 的全称是 XMLHttpRequest，这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。这跟以前的技术最大的不同点在于<strong>「页面无需刷新」</strong>，仅此而已。</p><p>想要使用 AJAX 发起一个请求很简单，一共 4 步。</p><ol><li>创建一个 XHR 对象（需要考虑浏览器差异）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">  <span class="comment">// 兼容 IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">  xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 兼容 IE6, IE5</span></span><br><span class="line">  xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>监听请求成功后的状态变化</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState == <span class="number">4</span> &amp;&amp; <span class="built_in">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三行的 request.responseText 就是服务器返回的内容了（默认是字符串）</p><ol start="3"><li>设置请求参数</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.open(method, url, <span class="keyword">async</span>);</span><br></pre></td></tr></table></figure><p>请求的三个参数分别是：请求的方法、请求的地址、和是否采用异步请求。</p><ol start="4"><li>发送请求</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.send();</span><br></pre></td></tr></table></figure><p>说实话，虽然只有 4 步，但是通过这种原生的方法发送请求还是觉得有些复杂，那有没有什么简单的方法呢？</p><h2 id="AJAX-的其他使用方式"><a href="#AJAX-的其他使用方式" class="headerlink" title="AJAX 的其他使用方式"></a>AJAX 的其他使用方式</h2><h3 id="JQuery-使用-AJAX"><a href="#JQuery-使用-AJAX" class="headerlink" title="JQuery 使用 AJAX"></a>JQuery 使用 AJAX</h3><p>JQuery 将上述过程封装的很好，使用起来也非常简单（只举出最简单的例子，详细还请移步官方文档）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&quot;url&quot;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 response 就是返回的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Vue-使用-AJAX"><a href="#Vue-使用-AJAX" class="headerlink" title="Vue 使用 AJAX"></a>Vue 使用 AJAX</h3><p>vue 官方推荐使用 axios 来进行请求，这里同样举出一个最简单的例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getApiData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//设置请求路径</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;XXXXXX&quot;</span>;</span><br><span class="line"><span class="comment">// 发送请求:将数据返回到一个回到函数中</span></span><br><span class="line"><span class="comment">// 并且响应成功以后会执行then方法中的回调函数</span></span><br><span class="line">axios.get(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="comment">// result是所有的返回回来的数据</span></span><br><span class="line"><span class="comment">// 包括了响应报文行</span></span><br><span class="line"><span class="comment">// 响应报文头</span></span><br><span class="line"><span class="comment">// 响应报文体</span></span><br><span class="line"><span class="built_in">console</span>.log(result.data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="微信小程序使用-AJAX"><a href="#微信小程序使用-AJAX" class="headerlink" title="微信小程序使用 AJAX"></a>微信小程序使用 AJAX</h3><p>微信小程序的请求就是 wx.request 这个 api，wx.request(一些对象参数)，微信小程序不同于浏览器的 ajax 请求，可以直接跨域请求不用考虑跨域问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: <span class="string">&quot;test.php&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    x: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    y: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>看到这其实我们就可以发送数据了，那怎么接收返回的数据呢？事实上，这已经不是在 AJAX 的讨论范围了，但是作为一个拓展知识点，我还是想介绍下<strong>状态码</strong>这个东西。状态码的作用是服务器返回给客户端的用来描述 HTTP 请求的状态的。用来描述 HTTP 请求的状态码太多了，这里介绍一些常见的状态码。</p><ul><li>200 表示从请求成功</li><li>301 表示永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li><li>302 表示临时性重定向。</li><li>404 表示服务器上找不到请求的资源。</li><li>500 表示服务器端在执行请求时发生了错误。多半是因为 Web 应用存在的 bug 或某些临时的故障。</li><li>503 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h3 id="获取网页中的-XHR-请求"><a href="#获取网页中的-XHR-请求" class="headerlink" title="获取网页中的 XHR 请求"></a>获取网页中的 XHR 请求</h3><p>这时就有人可能会问了，有没有什么办法可以获取一个网页中的 XHR 请求呢？当然是有的，这一过程其实说的宽泛点其实就是抓包，这里我以掘金为例，介绍下获取网页中的 XHR 请求。</p><p>首先我们打开 Chrome 浏览器，然后进入开发者工具（按 F12 或者网页右击选择“检查”），选择<strong>Network</strong>选项卡，我们可以发现下面有很多东西，比如 Filter、All、HXR、JS 等等，通过这个工具这里我们可以看见一个网页渲染过程中的所有请求（不只是 XHR，还有 JS、CSS 等）。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-f24f921a3097d63b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>随后我们选择 XHR，就会出现请求这个网页过程中的所有的 XHR 请求了。包括 name、status、size 等信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-4e94aa9a30590069.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之前提到过了，我们通过 XHR 携带的数据返回给浏览器渲染页面，到底是怎么实现的呢？不急，我们先来看一下现在的页面是什么样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-0897c3b047592149.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其实这些东西都在其中一个 XHR 中，于是我们随便点击一个名为<em>query</em>的 XHR 对象（其实并不是随便点击的 😜），然后移到<strong>Response</strong>选项卡：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-a23ae5f4a574780c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们看到了很长的一段 JSON 数据，格式化后（这里我们可以直接切换到<strong>Preview</strong>选项卡）筛选出一部分可以看到：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-20648c5ef9c37eb7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>是不是刚才那个页面里面的东西都在这里面呢？</p><h3 id="简单分析下"><a href="#简单分析下" class="headerlink" title="简单分析下"></a>简单分析下</h3><p>既然都获取到请求数据了，再不分析下都感觉对不起这么多的数据了，让我们把选项卡从<strong>Response</strong>移到<strong>Headers</strong>上，我们惊讶的发现竟然出现了好多东西：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-f13ba2a0b85a0801.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里我们简单说明下各个参数：</p><h4 id="General-部分"><a href="#General-部分" class="headerlink" title="General 部分"></a>General 部分</h4><p>首先是 General 部分：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-959b767f97475b12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们可以看出，请求地址是<code>https://web-api.juejin.im/query</code>，请求方法为 POST 方法，请求状态是 200，也就是请求成功了，同时还可以知道这次请求的 IP 地址是<code>119.254.97.159:443</code>。</p><h4 id="Referrer-Policy"><a href="#Referrer-Policy" class="headerlink" title="Referrer Policy"></a>Referrer Policy</h4><p>这里说下<strong>Referrer Policy</strong>这个字段，这个字段解释起来有点小麻烦，我们知道当用户在浏览器上点击一个链接时，会产生一个 HTTP 请求，用于获取新的页面内容，而在该请求的报头中，会包含一个 Referrer，用以指定该请求是从哪个页面跳转页来的，常被用于分析用户来源等信息。但是也有成为用户的一个不安全因素，比如有些网站直接将 sessionid 或是 token 放在地址栏里传递的，会原样不动地当作 Referrer 报头的内容传递给第三方网站。所以就有了 Referrer Policy，用于过滤 Referrer 报头内容，目前是一个候选标准，不过已经有部分浏览器支持该标准。这里为 <em>no-referrer-when-downgrade</em> 的意思是指当发生降级（比如从 https:// 跳转到 http:// ）时，不传递 Referrer 报头。但是反过来的话不受影响。通常也会当作浏览器的默认安全策略。</p><h4 id="Headers-部分"><a href="#Headers-部分" class="headerlink" title="Headers 部分"></a>Headers 部分</h4><p><img src="https://upload-images.jianshu.io/upload_images/5666077-76f391a98c9b1297.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-d5149867577d3b8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来是 Response Headers 和 Request Headers，这里说实话我觉得没什么好说的，稍微有些重要的就是请求体<strong>Content-Type</strong>，为什么说他重要呢？我们往下看。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-7575e5856ab16c69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来一段是<strong>Request Payload</strong>，<strong>Form Data</strong>我们比较熟悉，那这个<strong>Request Payload</strong>又是个什么东西呢？我们知道前端开发中经常会用到 AJAX 发送异步请求，对于 POST 类型的请求会附带请求数据。而常用的传参方式有两种，其一是 Form Data，另一个就是 Request Payload 了。</p><p>那这两者有何区别呢？其实区别主要就是在<strong>Content-Type</strong>上，这也就是为啥我说他重要的原因。</p><h4 id="Form-Data-和-Request-Payload-区别"><a href="#Form-Data-和-Request-Payload-区别" class="headerlink" title="Form Data 和 Request Payload 区别"></a>Form Data 和 Request Payload 区别</h4><ol><li>如果请求头里设置<code>Content-Type: application/x-www-form-urlencoded</code>，那么这个请求被认为是表单请求，参数出现在 Form Data 里，格式为 key=value&amp;key=value&amp;key=value…</li><li>原生的 AJAX 请求头里设置<code>Content-Type:application/json</code>，或者使用默认的请求头<code>Content-Type:text/plain</code>参，数会显示在 Request payload 块里提交，参数格式为 JSON 格式：<code>&#123;&quot;key&quot;:&quot;value&quot;,&quot;key&quot;:&quot;value&quot;…&#125;</code>，可读性会更好。</li></ol><h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>既然 XHR 这么方便，是不是就没有不足之处呢？当然不是。XHR 很实用，但并不是一个设计优良的 API，在设计上并不符合职责分离原则，输入、输出以及状态都杂糅在同一对象中，并用事件机制来跟踪状态变化。并且，基于事件的模型与最近流行的 Promise 和 generator 异步编程模型不太友好。因此 Fetch API 横空出世，它旨在修正上述缺陷，它提供了与 HTTP 语义相同的 JS 语法，简单来说，它引入了 <code>fetch()</code> 这个实用的方法来获取网络资源。</p><p>当然由于文章篇幅有限，这里仅仅只是引出 Fetch API，推荐阅读 <a href="http://bubkoo.com/2015/05/08/introduction-to-fetch/">http://bubkoo.com/2015/05/08/introduction-to-fetch/</a>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实刚开始只是想简单介绍下 AJAX 的原理，但是后来发现用了班主任让班长找小明这例子之后，AJAX 的原理似乎也就明白了，便想着要不就扩展点吧，以至于整篇文章有将近一半的篇幅在写扩展的知识了。不过也不算喧宾夺主，毕竟也是 AJAX 衍生出的知识点。</p><p>如果你对本篇文章的内容有所疑问，可以在评论区写下你的观点；如果你觉得本篇文章对你有所帮助，希望可以扫描下方二维码关注公众号「01 二进制」。您的支持是我前进的最大动力！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/22564745">「每日一题」AJAX 是什么？</a></p></li><li><p><a href="https://juejin.im/post/5b1cebece51d4506ae71addf">Ajax 原理一篇就够了</a></p></li><li><p><a href="https://www.cnblogs.com/btgyoyo/p/6141480.html">HTTP 请求中的 form data 和 request payload 的区别</a></p></li><li><p><a href="http://xiaobaoqiu.github.io/blog/2014/09/04/form-data-vs-request-payload/">Form Data vs Request Payload</a></p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html">微信开放文档</a></p></li><li><p><a href="http://bubkoo.com/2015/05/08/introduction-to-fetch/">fetch API 简介</a></p></li><li><p><a href="https://imququ.com/post/referrer-policy.html">Referrer Policy 介绍</a></p></li></ol><hr><p><img src="https://upload-images.jianshu.io/upload_images/5666077-e3a4d5b87f8ef4d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人人都是 LSP？—— 种子与文件下载的相爱相杀</title>
      <link href="p/a28d.html"/>
      <url>p/a28d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj1jm2yvtj30r3094wgy.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>世界上根本没有 LSP，又或者，人人都是 LSP。</p><p>说起种子，你会想到什么？</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj10n84fuj306d064q4g.jpg"></p><p>是农民伯伯春天播下，秋天就会收获果实的东西？还是以<code>.torrent</code>结尾的文件？</p><p>如果是前者，那你一定是一个热爱大自然的人。如果是后者，你一定是一个“热爱生活”的人。</p><p>不过今天我们要聊的不是大自然的那个种子，而是 LSP 们喜闻乐见的这个种子。</p><h2 id="P2P-与-BitTorrent-协议"><a href="#P2P-与-BitTorrent-协议" class="headerlink" title="P2P 与 BitTorrent 协议"></a>P2P 与 BitTorrent 协议</h2><p>所谓“种子”（或者叫种子文件），其实就是以<code>.torrent</code>结尾的文件，而他之所以叫种子，是因为这个文件里包含了你需要获取的文件的相关信息。就和自然界中的种子一样，包含了日后形成一颗果实所需要的最基本的成分。</p><p>而这个<code>.torrent</code>后缀其实指的是支持 BitTorrent 协议的文件。BitTorrent 简称 BT，俗称比特流。看到这，想必你已经有些印象了吧，我们常说的 BT 种子和种子其实是一种东西。</p><p>那么这个 BitTorrent 协议是什么？</p><p>不急，在介绍 BitTorrent 之前，先让我们梦回高中课堂，回想一下以前抄作业的时光。</p><h3 id="抄作业的例子"><a href="#抄作业的例子" class="headerlink" title="抄作业的例子"></a>抄作业的例子</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj10tciimj31060rqac8.jpg"></p><p>如上图所示，学霸在写完作业后，要把作业借给同学抄，但是一次只能借给一个人，且其他人只能抄学霸的作业，那么如果想要让学霸在内的 7 个人都写完作业，取决与学霸写作业的速度和每个同学抄作业的速度。我们知道，这样的效率一定是很低下的，所以聪明的学霸想出了第二个办法。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj119zpjkj31140q6q6x.jpg"></p><p>学霸的办法就是，把作业分成几块，让每个人抄不同的部分，比如 A 抄单选题、B 抄多选题、C 抄填空题……然后每个人再把自己抄到的作业和其他人抄到的作业互换，这样，所有人都可以在规定时间内把所有的作业都抄完了，以此实现效率的提升。</p><h3 id="P2P-与文件下载"><a href="#P2P-与文件下载" class="headerlink" title="P2P 与文件下载"></a>P2P 与文件下载</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj11grv82j31140b9wga.jpg"></p><p>之所以要先提抄作业这个事情，是因为这两种方案和下载文件颇为相似。</p><p>传统的文件下载就和上面的第一种方案类似，如上图所示，客户端向服务器发送“我要下文件”，服务器便将文件再发给客户端，这是一个很常见的场景，在这个场景中，客户端下载文件的速率取决于两个因素：服务器的<strong>上传带宽</strong>和客户端的<strong>下载带宽</strong>。带宽是指在单位时间（一般指的是 1 秒钟）内能传输的数据量。</p><p>而一旦需要下载的文件数量是多个时，下载的总时间便受到下载数量 N 的限制，即越多的人下载某一个文件时，理论上所需要的下载时间就越长，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj12hrcrtj31140e6ado.jpg"></p><p>这种用户体验显然是很糟糕的，那么有没有什么好的方法解决这个问题呢？这就要请出我们本期的“天降猛男”——P2P<strong>（peer-to-peer）</strong>。</p><blockquote><p>这里的 P2P，和点对点（point-to-point）的协议程序不同，它是<strong>用户群对用户群（peer-to-peer）</strong>，当然也不是我们前几年经常听见的暴雷的 P2P（互联网金融点对点借贷平台）。</p></blockquote><p>本文所说的 P2P 是一种架构模式，就和我们之前说过的 C/S（客户端/服务端）架构类似。</p><p>在 P2P 模式中，服务和资源<strong>分布化</strong>，资源不集中存储在某些设备上，而是<strong>分散存储</strong>在运行 P2P 程序的设备上，每一个对等方都可以为其他对等方提供服务。</p><p>还是拿抄作业这个例子来说，学霸的第二个方案就是一个很典型的 P2P 模式。他将自己的作业分成填空、选择、单选、多选等部分，然后分别送给 6 个人，这样当每个人都有自己的一部分副本后，就可以不用再找学霸本人要作业了，直接找其他拥有和自己副本不同的人索取然后互换资源即可。</p><p>在互联网，P2P 模式也有一个非常重要的，乃至影响了所有 LSP 的应用，即 BitTorrent，也就是本文开篇所说的种子。</p><h2 id="BitTorrent-协议"><a href="#BitTorrent-协议" class="headerlink" title="BitTorrent 协议"></a>BitTorrent 协议</h2><p>维基百科对 BitTorrent 的解释是：</p><blockquote><p>BitTorrent 协议（简称 BT，俗称比特洪流、BT 下载）是用在对等网络中文件分享的网络协议程序。和点对点（point-to-point）的协议程序不同，它是<strong>用户群对用户群（peer-to-peer）。</strong></p></blockquote><p>BitTorrent 协议是架构于 TCP/IP 协议之上的一个 P2P<strong>文件传输通信协议</strong>，处于 TCP/IP 结构的应用层。</p><p>简而言之就是 BitTorrent 是一个用来传输文件的协议，和第二个抄作业案例的特性类似，该协议的特点是，用户越多，即下载同一文件的人越多，下载该文件的速度越快。且下载后，继续维持上传的状态，就可以“分享”，成为其用户端节点下载的种子文件（.torrent），同时上传及下载。</p><p>在大多数人感觉中 BitTorrent 与 P2P 成了对等的一组概念，而它也的确将 P2P 技术发展到了近乎完美的地步。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>介绍完 BitTorrent 协议后，我们来说说他的原理吧。</p><p>其实和学霸将作业分成选择题、填空题等给其他人抄的道理一样，BitTorrent 协议也是将需要下载的文件虚拟分成大小相等的块，这些块的大小被要求成 2k 的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和 Hash 验证码写入 .torrent 文件（即种子文件，也简称为“种子”）中，作为被下载文件的<strong>“索引”</strong>。  下载者要下载文件内容，需要先得到相应的 .torrent 文件，然后使用 BT 客户端软件进行下载。</p><p>而.torrent 文件其本质就是一张信息清单，存储了一些信息，如下图所示，其中就包括了文件大小、哈希值、tracker 地址等信息。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj12w04xmj30n5074jso.jpg"></p><p>下载时，BT 客户端首先解析 .torrent 文件得到 Tracker 地址，然后连接 Tracker 服务器。Tracker 服务器回应下载者的请求，<strong>提供下载者其他下载者（包括发布者）的 IP</strong>。或者，BT 客户端也可解析 .torrent 文件得到 nodes 路由表，然后连接路由表中的有效节点，由网络节点提供下载者其他下载者的 IP。</p><p>下载者再连接其他下载者，根据 .torrent 文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参或者其他网络节点的参与，分散了单个线路上的数据流量，因此减轻了服务器负担。</p><p>下载者每得到一个块，需要算出下载块的 Hash 验证码与 .torrent 文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。</p><p>因此，下载的人越多，提供的带宽也越多，种子也会越来越多，下载速度就越快。</p><p>如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj133uuapj30mx0fin1a.jpg"></p><p>从 BT 客户端角度考虑，下载原理分为以下几步：</p><ol><li>根据 BitTorrent 协议，文件发布者会根据要发布的文件生成提供一个 .torrent 文件。客户端可从 Web 服务器上下载种子文件，并从中得到 Tracker 服务器 URL。</li><li>根据 Tracker URL 与 Tracker 服务器建立连接，并从服务器上得到 Peers 信息。</li><li>根据 Peers 信息与一个 Peer 建立连接，依据 Peer wire 协议完成握手，并从 Peer 端下载数据文件。同时监听 Peer 的连接，并给 Peer 上传数据文件。</li></ol><h3 id="Tracker-没了怎么办？"><a href="#Tracker-没了怎么办？" class="headerlink" title="Tracker 没了怎么办？"></a>Tracker 没了怎么办？</h3><p>从上面的分析中我们得知，想要利用种子下载资源，第一步就是根据种子里的信息获取到 Tracker 地址，那么这时候问题就来了，如果运营商掐断了你和 Tracker 服务器间的连接了怎么办？</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj13w09hrj30h60h1wpc.jpg"></p><p>有两种解决方案：</p><h4 id="PT"><a href="#PT" class="headerlink" title="PT"></a>PT</h4><p>第一种是采用一种不会被运营商掐断的 Tracker 服务器，PT（英语：Private Tracker），即私有种子服务器。他与 BT 最大的不同点为：可进行私密范围下载。由于是私有的，所以一般的 PT 网站都是采用的邀请制，由已注册的用户向自己所信任的人发送邀请，以确保用户质量。例如紫荆站就是南大人专属的网络资源的 PT 站点（需要在连接到校园网的状态下登录）。</p><blockquote><p>说个题外话，紫荆花的花语是矢志不渝，而这个网站之所以叫紫荆，是因为开发者曾约定和他的女朋友一起在南大种一朵紫荆花，虽然最后因为学校的原因没有种成，但意外诞生了紫荆 PT 来纪念他们的爱情。就像紫荆的作者说的，紫荆是胡同写给他的领导“紫荆 MM”的一封情书，即“你的心里，刻着我的名字”。</p><p>不说了，这就去吃柠檬。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj15jurc8j30b40akweo.jpg"></p></blockquote><h4 id="DHT-网络"><a href="#DHT-网络" class="headerlink" title="DHT 网络"></a>DHT 网络</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj15oy9zyj30lx0dzdnq.jpg"></p><p>第二种解决方案便是 DHT 网络了，维基百科对他的解释是：</p><blockquote><p>DHT 全称为分布式哈希表（Distributed Hash Table），是一种分布式存储方法。在不需要服务器的情况下，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个 DHT 网络的寻址和存储。使用支持该技术的 BT 下载软件，用户无需连上 Tracker 就可以下载，因为软件会在 DHT 网络中寻找下载同一文件的其他用户并与之通讯，开始下载任务。</p></blockquote><p>不知道上面这种解释能否理解，我换个说法，大家可能就清楚了。</p><p>曾经有一个非常著名的理论：最多通过五个人你就能够认识世界上任何一个陌生人，即<strong>六度分离理论</strong>。在 DHT 网络中，每个节点就跟人一样，你可以通过你的朋友，或者你朋友的朋友，或者你朋友的朋友的朋友，只需要不断递归即可找到你想要的资源地址。这样的话，在一个网络中也就不需要 Tracker 服务器了，又或者说，在这个网络中，所有的机器都充当了 Tracker 服务器。再回顾开篇说的那句，世界上根本没有 LSP，又或者，人人都是 LSP。这么一想，是不是有那味了。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj15uioqyj306a06775r.jpg"></p><p>而这也是磁力链接的原理。所以其实磁力下载和种子下载的<strong>本质</strong>都是 P2P 下载，都是<em>让每个下载者分享资源片段，从而拼凑出一个完整的资源，下载者既是资源的消费者，又是资源的传播者。</em>他们之间的区别仅仅是<strong>寻找其他下载者的方式不同</strong>。由于篇幅的原因，本文便不详细介绍磁力链接查找下载者的方式了，有兴趣的小伙伴们可以搜索相关的资料学习下。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>看到这想必你对 BT 种子已经有了一定的了解了。其实 BT 技术早已涉及我们生活的方方面面了，以在线游戏为例，有些在线游戏的在线更新（如魔兽世界）就是采用 BT 的技术。所以当每次有改版时，动辄数百 MB 的更新档，透过游戏厂商所提供的更新程序，以 BT 的方式进行下载分流。这为以往的其他种在线游戏，每次重大改版就必须重新压制光盘，或是等待单一下载点的下载方式，带来另一种节省成本的经营模式。</p><p>技术是把双刃剑，利用 BT 传播非收费性内容的好处有目共睹，但利用 BT 免费发布著作权内容肯定损害著作权所有者的合法权益，因此是否应因此立法全面禁止 BT 仍然是一个焦点问题。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmj191uefvj30gh08u424.jpg"></p><p>对于大多数 85 后，90 后来说，第一次接触 BT 种子想必和一个名为“快播”的播放器是脱不了干系的，我至今仍然记得王欣的那句技术本无罪。其实 Facebook 创立之初就是为了找到好看的女生，BT 的也是靠着他的作者科亨收集了些免费的色情电影才吸引到更多的人来测试他的程序，不得不说，某种程度上，ghs 真的促进了互联网技术的发展。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本文的全部内容了，如果你觉得还不错的话，欢迎点赞关注转发支持一波，你们的支持是我肝文的最大动力。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网是如何工作的？</title>
      <link href="p/797f.html"/>
      <url>p/797f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk07dsf8fdj30p00andln.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们每天都在使用网络，面对这个看不见也摸不着的东西，你有没有思考过他的背后发生了什么吗？</p><p>相信很多人第一次接触网络是通过一个叫「网站」的东西，那网站又究竟是什么？</p><p>影视剧里经过出现的通过 IP 地址获取定位，是真的可以实现吗？</p><p>相信你在阅读本文后就会有一个清晰的认知了。</p><h2 id="网站？服务器？网络？"><a href="#网站？服务器？网络？" class="headerlink" title="网站？服务器？网络？"></a>网站？服务器？网络？</h2><p>首先我们要理解的是，一个网站只是一堆保存在硬盘上的<strong>文件</strong>， 就像你的电影、 音乐或图片一样。 然而，网站的唯一的不同之处是： 网站包含一种称为 HTML 的代码。也正是这个叫 HTML 的东西让网站有了好看的皮肤（界面）。</p><p>如果你对编程不熟悉，一开始你会很难理解 HTML，因为 HTML 其实是让你的浏览器（Chrome、Safrai、FireFox、IE 等）去<strong>“理解”</strong>的信息，浏览器读得懂这些代码，然后会按照代码的内容展示这些文件。</p><p>就和我们对待自己的电脑文件一样，我们会把 HTML 文件存储在硬盘的某个位置， 然后通过浏览器去访问这些 HTML 文件。对于互联网，我们使用特定而功能强大的电脑，我们称之为<strong>服务器</strong>，所以其实服务器本质上也是一台电脑，它们没有屏幕、鼠标或者键盘，因为它们的主要目的是存储数据，并用它来提供服务。 这就是为什么它们被称作<strong>服务器</strong>的原因——因为他们用数据<em>服务</em>你。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjx1g21fg0j30l40e2goh.jpg"></p><p>因此如果想要存储更多的信息，我们有两种解决方案：</p><ol><li>增加服务器的容量</li><li>增加服务器的数量</li></ol><p>显而易见的，一台服务器可以存储的信息是有限的，哪怕是不断增加一台机器的容量也肯定是有上限的。所以，我们可以通过第二种方式以达到<strong>「量变产生质变」</strong>的效果。</p><p>于是，一台又一台的服务器通过“网线”连接在了一起，形成了类似下面这样的结构</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjx1k05syuj31mf0twarm.jpg"></p><p>众多服务器组成的这种结构被称为“互联网”，而其中每台服务器都被称作“节点”，所以「顺着网线来打你」是有理论依据的。</p><h2 id="IP地址？域名？"><a href="#IP地址？域名？" class="headerlink" title="IP地址？域名？"></a>IP地址？域名？</h2><p>那么紧接着，问题就来了。</p><p>既然网络是用来存储文件的，对于我这个初次上网的人，我又如何找到我想要的内容呢？</p><p>不着急，我们先来设想一个场景。</p><p>闰土家里有几套房子，其中房子 A 被闰土爸妈当作仓库了，一天，妈妈让闰土去房子 A 拿一个家传的盒子 X，说是给未来儿媳妇准备的，房子 A 在 a 市 b 区 c 小区 d 号，并给了侧门钥匙，让他从侧门 C 进去拿，盒子 X 在房子 A 的 2 楼的房间 B 里的衣柜。</p><p>我们可以从上述场景中抽象出盒子 X 的位置：</p><blockquote><p>房子 A：侧门 C/二楼/房间 B/盒子 X</p></blockquote><p>但对于闰土来说，其实他在心里还做了一个位置转换，房子 A 等价于地址 a 市 b 区 c 小区 d 号</p><p>所以，这个盒子的位置还可以表示成：</p><blockquote><p>a 市 b 区 c 小区 d 号：侧门 C/二楼/房间 B/盒子 X</p></blockquote><p>这样的表示方法有没有让你想起什么？</p><p>没错，就是我们最常见的网址，就像这样 👉 <a href="https://mp.weixin.qq.com/s/jHbf-cFTu6rpVEySw-juGg">https://mp.weixin.qq.com/s/jHbf-cFTu6rpVEySw-juGg</a></p><p>不过，作为一个学计算机的，我们还是要专业点，这玩意叫 URL，全称是 Uniform Resoure Locator，翻译过来就是“统一资源定位符”。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjx1kimdhkj30e40e874y.jpg"></p><p>看翻译名称就知道这他的作用就是为了定位一个资源的，这里的资源其实就是我们之前说的存储在服务器上的各种各样的文件。</p><p>和找盒子一样，想要找到一个服务器上的资源，第一步就是要知道服务器的地址在哪，在网络中，我们使用的地址叫做 IP 地址，例如 192.168.0.1。使用 IP 地址后，我们就可以找到相应的服务器所在的位置。但即使我们找到了房子 A，我们也需要知道从哪个门进去，“端口”就起到了这样的作用。通过访问 IP 地址指定的端口，我们可以访问到不同的资源，当然了，考虑到安全，服务器也有可能会关闭一些端口，只开放几个常见的端口，就跟你家通常只会开一个门用作进出是一个道理。</p><p>再回到找盒子这个例子，我们记忆一个地址是很容易，可是久而久之，女朋友家的地址要记、丈母娘家的地址要记，还有各种乱七八糟要记的地址越来越多，没办法，闰土只能拿出小本本，写下了如下的内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">房子 A： a 市 b 区 c 小区 d 号</span><br><span class="line"></span><br><span class="line">女友家： a 市 b 区 e 小区 f 号</span><br><span class="line"></span><br><span class="line">丈母娘家： c 市 g 区 h 小区 i 号</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>这样每次他要去一个地址的时候都会先看一下小本本，通过代号然后找到具体的地址，在这里，这个小本本就起到了地址解析的作用。</p><p>在网络中也有类似的实现，例如在刚才的 URL<code> https://mp.weixin.qq.com/s/jHbf-cFTu6rpVEySw-juGg</code>中,</p><p><code>mp.weixin.qq.com</code> 这样的内容被称为<strong>“域名”</strong>，其真实的 IP 地址是 121.51.79.206（这个 IP 是会变化的），而从域名到 IP 的转换是通过一个叫 <strong>DNS 服务器</strong>的东西完成的，这个东西的功能就和我们刚刚提到的小本本是一样的，起到<strong>将域名解析成 IP 地址</strong>的作用。</p><p>那么影视剧里经常出现的通过 IP 地址获取定位，是真的可以实现吗？</p><p>结论是当然可以，但精度远没有描述的那么准确。至于原因，且听下回分解。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本文的全部内容了，如果你觉得对你有所帮助的话，欢迎关注点赞支持一波，你的支持就是我更新的最大动力。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算之 Anything As a Service</title>
      <link href="p/f82d.html"/>
      <url>p/f82d.html</url>
      
        <content type="html"><![CDATA[<p>这年头，不管什么应用，仿佛“上云“都成了标配，感觉拥抱了“云”，应用的逼格都上升了。那真的是这样的吗？</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-04b7eccd293d63d2.png&originHeight=483&originWidth=499&size=313508&status=done&style=none&width=263?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>是的，的确是这样。<br>云计算是一种按照需求通过 Internet 获取计算资源的形态。这些计算资源被包装成为服务，提供给用户。而提供这些服务的主体，我们称之为云服务供应商（Cloud Service Provider）。云服务最主要的有三类，就是本文的三个主角 IaaS、PaaS、SaaS。<br>那这三个 aaS 到底是个啥？</p><h2 id="XaaS"><a href="#XaaS" class="headerlink" title="XaaS"></a>XaaS</h2><p>看到这个标题，可能就有人产生疑惑了，那三个 aaS 都不知道是什么，怎么突然又多了一个 XaaS。不急，且听我娓娓道来。<br>XaaS，即<strong>一切皆服务</strong>，代表 “X as a service”、“anything as a service”或“everything as a service” 。这一缩写指越来越多地通过互联网提供的服务，而不仅仅指本地或现场服务。<strong>云计算的本质就是 XaaS</strong>。<br>XaaS 最常见的例子就是“软件即服务”（Software as a Service，SaaS）、“基础设施即服务”（Infrastructure as a Service，IaaS）和“平台即服务”(platform as a service，PaaS)。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-669713c8e5cb9b61.png&originHeight=280&originWidth=496&size=275113&status=done&style=none&width=447?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>根据所提供服务的不同，云服务可以被分为以下三类／三层：</p><table><thead><tr><th>缩写</th><th>全写</th><th>注释</th></tr></thead><tbody><tr><td>IaaS</td><td>Infrastructure as a Service</td><td>基础设施即服务</td></tr><tr><td>PaaS</td><td>Platform as a Service</td><td>平台即服务</td></tr><tr><td>SaaS</td><td>Software as a Service</td><td>软件即服务</td></tr></tbody></table><p>如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-395a43f09d7f156e.png&originHeight=330&originWidth=750&size=129865&status=done&style=none&width=750?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">SaaS</p><p>Software as a Service (SaaS) 又称云应用服务，通过网络为最终用户提供应用服务。绝大多数 SaaS 应用都是直接在浏览器中运行，不需要用户下载安装任何程序。对用户来说，软件的开发、管理、部署都交给了第三方，不需要关心技术问题，可以拿来即用。<br>比如：电商服务 淘宝</p><h4 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h4><p>Platfrom as a Service (PaaS) 的主要作用是将一个开发和运行平台作为服务提供给用户，能够提供定制化研发的中间件平台，以及数据库和应用服务器等。对开发者来说，只需要关注自己系统的业务逻辑，能够快速、方便的创建 Web 应用，无需担心底层软件。 比较典型的便是计算平台。<br>比如：微信开放平台</p><h4 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h4><p>Infrastructure as a Service (IaaS) 主要提供一些基础资源，包括服务器、网络、存储、安全等服务<strong>。</strong>由自动化的、可靠的、扩展性强的动态计算资源构成。用户可以按需购买服务满足业务需求。可以分为公共和私有两种基础资源服务，“公共云” 包含了共享资源 提供了部署在互联网上的基础设施，“私有云” 则是运行在专用网络上的基础设施，另外还有“混合云”，提供公共或私有云的混合组合方式。<br>比如：阿里云</p><hr><p>上面说的这些可能还是太过抽象，下面我会从一个实际例子出发，直观感受一下。</p><h3 id="从实例出发"><a href="#从实例出发" class="headerlink" title="从实例出发"></a>从实例出发</h3><p>我有一个朋友，他之前实习的时候，每天上班只能乘坐价值上千万的交通工具——地铁。对于当时的他来说，<strong>只要交钱坐上地铁等到站下车</strong>就可以了，这是 Saas。后来，“人性化”的公司考虑到这些“自愿”加班的员工下班后可能赶不上地铁了，于是规定 9 点以后报销打车费。终于，我的这个朋友，可以体验到公费打车的快乐了。这时候的他<strong>只需要提供目的地，剩下的（比如汽车、油费）交给司机就可以了</strong>，这是 PaaS。再后来，他喜欢上一个菇凉，想着每次约会都坐公交、地铁觉得不太合适，但是又买不起车，无奈，只好从租车公司租了一辆车，汽车的维修、安检都由租车公司承担。<strong>他需要做的是提供燃料、自己开车</strong>，这是 IaaS。再后来，他总算“码农翻身”，买得起车了，可各种事情接踵而来，<strong>自己开车，需要维护汽车，确保其安全行驶。同时需要为车上保险，提供燃料</strong>。这是 On-premise。</p><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>一路走来，这个朋友做的事情变得越来越多了，这是好事还是坏事？<br>不好说。我们需要辩证的看待问题，从维护成本上来看，自己买车开的成本肯定是要高于坐公交地铁的，毕竟要把车牌费、停车费、油费、保险等全部算上，这么看，确实不是一件好事。但是，如果从其他角度，例如出行更方便，买车更有身份等角度去考虑，这又是一件好事。<br>类比到系统设计中，这三种方式最大的区别就在于<strong>开发人员所参与的程度</strong>：<br>High Code：IaaS<br>Low Code：PaaS<br>No Code：SaaS<br>而这三种方式通常也反映了程序员的编码能力。一般来说，越接近底层的程序员，其能力更强。如果为了追求快速实现业务需求，直接使用 PaaS，甚至 SaaS，肯定会更好。但从技术的角度去思考，IaaS 对于开发人员技术的提升肯定是优于 PaaS 和 SaaS 的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云游戏在革谁的命？</title>
      <link href="p/332b.html"/>
      <url>p/332b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glirwn3tmwj311u0ns4qp.jpg"></p><p>我上大学时的第一台电脑是微星的一款游戏本，当时买它的原因很简单，性能足够强大，无论是编程等日常任务还是游戏它都可以胜任。现在回想起来，依稀记得它炫酷的灯光、强悍的性能以及用它驰骋虚拟世界的快感。后来年纪渐长，打游戏的热情也逐渐减少，虽然那台电脑仍在家中，但已经落后的性能让我鲜有机会“宠幸”它。再后来，读研之后换了 Mac 后更是没怎么碰过游戏了。</p><p>大家都说正经人谁用 Mac 打游戏，一开始我也是这么认为的，毕竟买来就是用来写代码的，可是最近发现的一个有趣玩意让我对这个问题有了新的想法，那就是——云游戏。</p><h2 id="云计算？云？"><a href="#云计算？云？" class="headerlink" title="云计算？云？"></a>云计算？云？</h2><p>以下内容摘自百度百科</p><blockquote><p>云游戏是以<strong>云计算</strong>为基础的游戏方式，在云游戏的运行模式下，所有游戏都在<strong>服务器端</strong>运行，并将渲染完毕后的游戏画面<strong>压缩</strong>后通过网络传送给用户。在客户端，用户的游戏设备<strong>不需要</strong>任何高端处理器和显卡，只需要基本的<strong>视频解压能力</strong>就可以了。</p></blockquote><p>我将上述内容中一些比较重要的点做了标注，百科在对于云游戏的描述时，第一句就直接阐明了云游戏的基础是云计算，那么「云计算」以及「云」指的是什么？</p><p>云计算（cloud computing），是一种基于互联网的计算方式，通过这种方式，<strong>共享的</strong>软硬件资源和信息可以按需提供给计算机和其他设备。提供资源的网络被称为“云”。</p><p>看完上面一句话有些小伙伴还会不太清楚，我们先来回顾下之前的知识。我在<a href="https://mp.weixin.qq.com/s/V1fLjznV_QoOozX1G6_VGA">《互联网是如何工作的》</a>这一篇文章中提到：一台又一台的服务器通过“网线”连接在了一起，形成了类似下面这样的结构 👇</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqqwvtpwj315g0l70wr.jpg" alt="网络结构"></p><p>众多服务器组成的这种结构被称为“互联网”，而其中每台服务器都被称作“节点”。</p><p>事实上这些节点都和你的本机无关但又何你的本机有关。</p><p>为什么这么说呢？</p><p>无关的原因是，这些节点所包含的计算能力（CPU、GPU）和存储文件都不是你的。有关的原因是，你可以通过某些方式运用这些能力和文件。</p><p>而上述所说的一个个节点便是云计算的核心，即「云」。</p><p>大量的水滴漂浮在空中，聚合成云。和我们所说的云很相似，只是这里的云是由<strong>大量的数据存储、计算资源和应用程序组成</strong>，这便是云计算服务。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqraemsyj31900u0wl5.jpg" alt="Cloud Computing"></p><p>「云」其实是一个抽象的概念，并不像服务器有一个具体的实物可以展示，我们可以把「云」理解为一个<strong>资源共享池</strong>。举个例子就是，我有很多东西，家里放不下了，放到一个特定的地方存着，随时提取。大家都可以访问的就是「公有云」，只有特定的人可以访问的就是「私有云」。</p><p>这个“东西”一般是指<strong>数据、软件、服务</strong>等，而“特定的地方”就是云。所以对于云计算我们也可以简单的理解为：将本地需要进行的计算任务迁移到云端进行。</p><p>如今云计算及其产物已经深入我们的生活，我们熟悉的百度网盘、iCloud 还有最近的阿里网盘就是「云存储」，以及本文要介绍的主角「云游戏」也是云计算的产物。</p><h2 id="云游戏"><a href="#云游戏" class="headerlink" title="云游戏"></a>云游戏</h2><h3 id="云游戏的原理"><a href="#云游戏的原理" class="headerlink" title="云游戏的原理"></a>云游戏的原理</h3><p>在现在这个游戏变得越来越流行的时代，人们却被低配设备所限制，比如我，虽然出了很多新游戏，却苦于手头没有一台合适的机器用于玩耍。以往玩游戏我需要配一台游戏主机或者高性能游戏本，少说也要五六千，因为游戏对于计算机性能的要求是非常高的，这些都必须依赖玩家自己的电脑。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqrvn8w7j31kg0u0u0y.jpg" alt="《赛博朋克》配置要求"></p><p>但是在云游戏模型中，所有的游戏逻辑和渲染都在<strong>服务器端</strong>运行，然后再从服务器把压缩的画面传给用户，这样玩家就不需要一台高性能的计算机了，对于设备的要求便也就是<strong>基本的视频渲染能力</strong>和<strong>可靠稳定的网络环境</strong>了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqs6jqelj31cg0iywh6.jpg" alt="云游戏模型"></p><p>云游戏摆脱了对硬件的依赖。对服务器来说，仅仅需要提高服务器性能而不需要研发新主机；对用户来说，可以得到更高的画质而不用购买高性能的计算机。也就是说，用户可以花一小笔钱租一个更好的计算机来玩各种游戏，就像用机顶盒看电视一样，这意味着玩家可以在计算机硬件，特别是 GPU 上省下一大笔钱。</p><h3 id="云游戏需要什么？"><a href="#云游戏需要什么？" class="headerlink" title="云游戏需要什么？"></a>云游戏需要什么？</h3><h4 id="低延时"><a href="#低延时" class="headerlink" title="低延时"></a>低延时</h4><p>在解释云游戏的原理时，我们提到了云游戏的游戏逻辑和渲染都是在服务器端进行，然后将画面传送给用户，所以说一台可以高速上网的设备极其重要。如果网速不够快，不够稳定就无法及时接收到高质量的画面。</p><p>说到这我们需要介绍一下网络延时，所谓网络延时指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。通俗的讲，就是数据从电脑这边传到那边往返所用的时间。</p><p>以我们现在还在普遍使用的 4G 网络而言，它的延时基本在 30ms ～ 70ms 波动，部分信号不好的地方延时还会更大。这还只是数据传输时的网络延时，如果算上画面编解码的时间，延时达到 100ms 是很容易的事情。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqthkswbj308b08cgm6.jpg"></p><p>我们知道视频的原理就是每秒播放多张静态画面，画面越多，对于人的观感来说就是视频越流畅。这是因为对于人眼来说，我们的视觉神经是有一个反应速度的，并且对于不同频率的光有不同的暂留时间。其时值约是 1/16 秒，也就是 62.5ms。也就是说，如果网络传输所消耗的延时大于 62.5ms，我们就会觉得画面很不流畅（62.5 是一个理论值，实际情况下这个数值会小于 62.5ms，对延时的要求更苛刻）。</p><h4 id="高带宽"><a href="#高带宽" class="headerlink" title="高带宽"></a>高带宽</h4><p>现在我们来做一个简单的数学题。</p><p>刚才我们说到视频的原理是每秒播放多张静态图像。我们知道图像都是由一个个像素点构成的，对于一张非黑即白的二值图像，不压缩的情况下一个像素只需要 1 个 bit。如果是 256 种状态的灰度图像，不压缩的情况下一个像素需要 8bit（1 字节，256 种状态）。如果用 256 种状态标识屏幕上某种颜色的灰度，而屏幕采用三基色红绿蓝（RGB），不压缩的情况下一个像素需要占用 24bit（3 字节），这个就是常说的 24 位真彩色。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqu5tkjej30e80byt9w.jpg"></p><p>那么对于一张 1920×1080 的图像，在不压缩的情况下，所需要的大小为 1920×1080×24 = 49766400bit，约等于 48Mb（注意这里是小写的 b，表示位），那么假设对于一个 1080P 30FPS 的视频，每秒就会播放 30 张 1920×1080 的图像，所以在不压缩的情况下如果为了传输这么多画面，网络的带宽必须要达到 48×30=1440Mb/s，当然在视频传输的过程中，肯定会有压缩的过程，假设可以压缩 50%的数据，那网络的带宽也需要 720Mb/s，看到这你想一下，你家的网络带宽又有多少呢？</p><blockquote><p>这里之所以用 Mb 作为单位是因为方便大家和自己家的宽带进行比较，因为通常我们所说的百兆带宽指的是 100Mb 而不是 100MB。</p></blockquote><h3 id="如何实现低延时-高带宽"><a href="#如何实现低延时-高带宽" class="headerlink" title="如何实现低延时+高带宽"></a>如何实现低延时+高带宽</h3><p>从开源节流的角度去考虑问题，如果网络传输的速度有上限，那么想要在单位时间内传输更多的视频数据，最好的方式便是对视频进行编解码。</p><h4 id="视频编解码"><a href="#视频编解码" class="headerlink" title="视频编解码"></a>视频编解码</h4><p>编码这一概念在通信与信息处理领域中广泛使用，其基本原理是将信息按照一定规则使用某种形式的码流表示与传输。常用的需要编码的信息主要有：文字、语音、视频和控制信息等。</p><p>刚才说了动态图像的像素形式表示数据量极为巨大，存储空间和传输带宽完全无法满足保存和传输的需求。所以要对视频进行编码，其最主要的目的就是为了对视频数据进行压缩。</p><p>而视频信息之所以存在大量可以被压缩的空间，是因为其中本身就存在大量的数据冗余。</p><p>举个简单的例子，下面这两张图片是一段视频的其中两个画面（寒食君友情出镜）</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqv8fflrj30sd0fuh0l.jpg" alt="视频中的冗余数据"><br>从这两张图片可以看出，其实变化的部分就是人物的动作，而不变的是后面的背景，所以后面的这块背景像素在对于视频来说就是一段冗余数据，可以被压缩。同样的，人物的脸部虽然有动作变化，但是人物的脸并没有变化，寒食君还是寒食君，因此不变的地方同样是冗余数据。</p><p>视频中的冗余数据的主要类型有：</p><ul><li>时间冗余：视频相邻的两帧之间内容相似，存在运动关系</li><li>空间冗余：视频的某一帧内部的相邻像素存在相似性</li><li>编码冗余：视频中不同数据出现的概率不同</li><li>视觉冗余：观众的视觉系统对视频中不同的部分敏感度不同</li></ul><p>针对这些不同类型的冗余信息，在各种视频编码的标准算法中都有不同的技术专门应对，以通过不同的角度提高压缩的比率。这里我们简单说一下目前较为流行的两种编码 <strong>H.264 与 H.265</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqvyupq0j30kg0e4jsq.jpg" alt="H.265 与 H.264"></p><p>这两个是 ITU-T VCEG 制定的视频编码标准。H.265 标准围绕着现有的视频编码标准 H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。</p><p>具体的编码算法太过复杂，这里就不再多说，我们只要知道 H264 由于算法优化，可以低于 1Mbps 的速度实现标清数字图像传送；H265 则可以实现利用 1~2Mbps 的传输速度传送 720P（分辨率 1280*720）普通高清音视频传送。H.265 旨在在有限带宽下传输更高质量的网络视频，仅需 H.264 的一半带宽即可播放相同质量的视频。</p><p>经过测试，在相同的图像质量下，相比于 H.264，通过 H.265 编码的视频大小将减少大约 39-44%。在码率减少 51-74%的情况下，H.265 编码视频的质量还能与 H.264 编码视频近似甚至更好。</p><h4 id="5G-和-Wi-Fi6"><a href="#5G-和-Wi-Fi6" class="headerlink" title="5G 和 Wi-Fi6"></a>5G 和 Wi-Fi6</h4><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqwquoq7j31di0r4tck.jpg"></p><p>有了视频解码可以在单位时间内传输更多的数据后，剩下要做的便是提高传输速率。这便引出了今年非常火的两个名词——5G 和 Wi-Fi6。</p><p>就目前公开的数据来看，5G 协议中的峰值速度已经达到 20Gbit/s，Wi-Fi 6 最高也可以达到 9.6Gbit/s，这也就意味着在网络传输中可以携带的数据包更大。而且由于技术的提升，这两者在网络延时上也做了非常多的优化，在同等条件下 5G 的延迟低于 1 毫秒，相较于 4G 的 30-70 毫秒可谓是质的飞升。而 WI-FI6 的网络延时虽然不及 5G 这么优秀，但也从 Wi-Fi5 的平均 30ms 降低至 20ms。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>云游戏的概念其实早在 2013 年就已提出，但一直不温不火，目前来看，得益于越来越先进的压缩算法和低延时高带宽的网络环境，云游戏真的有可能异军突起，那么目前已有的云游戏做到什么样了呢？恰好笔者最近收到消息，腾讯的 START 云游戏平台已经公测，接下来谈谈我的云游戏初体验。</p><h2 id="我的云游戏初体验"><a href="#我的云游戏初体验" class="headerlink" title="我的云游戏初体验"></a>我的云游戏初体验</h2><p>我的第一次云游戏初体验是在腾讯的 START 平台上进行的，点击官网<a href="https://start.qq.com/">https://start.qq.com</a>即可看到如下的页面。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqx3qjh4j31p20u07wi.jpg"></p><p>如果不是因为他的域名里有 qq.com，这简洁的页面真的让我怀疑这是腾讯做的吗？而且这句「从此 Mac 也有庞大的游戏库」这句话真的让我很难不怀疑腾讯会那么好心提供那么多游戏吗？</p><p>抱着怀疑的态度我下载安装了这款云游戏平台，Mac 安装软件的方法一如既往的简单，下载完后直接将 app 文件拖入 Application 文件夹中即可。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqxj2jgqj310o0m8afq.jpg"></p><p>打开之后我们可以看到腾讯提供的一些游戏，种类虽然不是很多，但是对于不能玩游戏的 Mac 来说已经很不错了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gliqxuadt0j30s20ifwtc.jpg"></p><p>我试玩了一下很久没玩的 QQ 飞车，体验一番后，我只能说：NB！！</p><p>我录了一段小视频，大家可以播放看一下（玩的比较菜，不要嫌弃）</p><iframe src="//player.bilibili.com/player.html?bvid=BV1SX4y1M7CA&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>之后我又玩了几把堡垒之夜和穿越火线，目前来看：</p><ol><li>腾讯 START 的整个流程已基本完备，使用门槛很低，下载一个客户端即可体验云游戏。</li><li>虽然游戏种类不是很多，但有总比没有好</li><li>赛车类键盘操作游戏体验很好，能还原 PC 体验的 90%以上。画面流畅，帧率稳定，分辨率高。(网速要求并不是很苛刻，只要连接了 5G Wi-Fi 即可)</li><li>目前来看 START 是免费的，不知道公开运行时候是不是会收费。</li></ol><p>总的来说，这次的体验真的让我惊到了，因为按照之前的计算，现在的 5G Wi-Fi 的速率和延时其实是不足以带动云游戏，但体验下来，效果真的非常棒，我的 Macbook pro 终于也可以愉快的打游戏了，手里有 Mac 的小伙伴也可以下载体验下。</p><h2 id="浅谈云游戏"><a href="#浅谈云游戏" class="headerlink" title="浅谈云游戏"></a>浅谈云游戏</h2><h3 id="云游戏的影响"><a href="#云游戏的影响" class="headerlink" title="云游戏的影响"></a>云游戏的影响</h3><p>对于玩家来说，云游戏并不需要高性能的显卡，连使用 MacBook Air 的小伙伴也可以畅玩，扩充了游戏品类，减少了高昂的硬件开支。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glir1h358gj30go0afabf.jpg"></p><p>而且由于游戏都在云端，可以有效的杜绝外挂（你总不能把外挂装到厂商的服务器里吧），同样的也可以防止盗版游戏的盛行（虽然并不知道这是好事还是坏事）。</p><p>同样的，对于游戏开发者来说，云游戏的出现可以是他们在开发游戏时可以减少对老设备、低性能设备的适配，提升了游戏呈现质量的同时降低了开发成本，提高了游戏开发的效率。</p><h3 id="云游戏会取代-PC-吗？"><a href="#云游戏会取代-PC-吗？" class="headerlink" title="云游戏会取代 PC 吗？"></a>云游戏会取代 PC 吗？</h3><p>说了那么多，一旦一项新技术兴起，就会面临一个老生常谈的问题：云游戏的出现会取代传统的游戏主机吗？<br>肯定的说，不会。</p><p>就算未来网速再快、延时再低，也不可能达到 0 延迟。没办法，这是物理法则。当你在玩电竞游戏的时候，你需要的一定是几毫秒的延时而不是几百毫秒。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glir1tsdwej30qo0h4abb.jpg"></p><p>但同样的，云游戏给游戏玩家提供了新的选择，对于一些非重度游戏玩家，玩一些对延时要求不高的游戏来说，云游戏确实是一个新的选择。</p><p>所以，回到一开始的问题，云游戏在革谁的命？是英伟达、AMD 这样的显卡厂商吗？还是 Steam、Uplay 这样的游戏平台？我看都不是，它革的是「游戏本」、是「盗版游戏」的命。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本篇文章的全部内容了，如果你觉得还不错的，欢迎点赞支持一波，你们的支持是我更新的最大动力！</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glirdzzkfqj30go0go40v.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1 暴打 Intel？——这次的芯片有何不同</title>
      <link href="p/62cf.html"/>
      <url>p/62cf.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>之前看到 M1 芯片出来之后，就想说些什么，结果光写 x86 和 ARM 就写了 4000 多字，考虑到文章篇幅，只得分为上下两篇，上一篇文章发出后有很多人表示非常喜欢，让我赶紧更新，在这里向支持我的读者们表示感谢 🙏。</p><p>那么话不多说，这篇我们来聊一聊，这次的芯片到底有何不同，以至于让那么多人说苹果不讲武德。</p><blockquote><p>在这之前我先说明，我只是一个计算机专业的学生，从来就没有自诩自己是什么专家学者，我写博客也只是为了做一些简单的科普，把自己知道的一些知识分享给大家。如果文章中有什么错误的地方，还请各位读者指正。</p></blockquote><h2 id="2-M1-芯片-≠-CPU"><a href="#2-M1-芯片-≠-CPU" class="headerlink" title="2. M1 芯片 ≠ CPU"></a>2. M1 芯片 ≠ CPU</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl622ukxxqj30r80himy1.jpg"></p><p>首先，我们要先摆脱一个认知误区，M1 芯片<strong>不是一块 CPU</strong>，而是一块专为 Mac 设计的 SoC 芯片。<strong>CPU 只是 M1 芯片的一个组成部分</strong>。</p><p>所谓 SoC 芯片，指的是系统级芯片（System on Chip），也称片上芯片，是一个将电脑或其他电子系统集成到单一芯片的<strong>集成电路</strong>。 SoC 集成的主要包括处理器(CPU，GPU 等)、基带、各种接口控制模块、各种互联总线等，其典型代表为手机芯片。举个例子，CPU 公司将自己的所生产的 CPU 设计卖给其他公司，而其他公司就根据该 CPU 自己添加上所需要的各种外设控制器，这就是 SoC。</p><p>所以简单来说：SoC 就是一块集成了 CPU、GPU 等多种结构的芯片。因此，千万不要简单的认为 M1 芯片就是 CPU。</p><p>官网有一张图，就很好地说明了 M1 芯片的组成成分。如下图所示，苹果称其为<strong>统一内存架构（Unified memory architechture）</strong>，即通过 Fabric 高速总线将中央处理器、图形处理器、神经网络引擎、缓存、DRAM 内存全部连接在一起。因此，M1 芯片的强大，绝不是靠一个强悍的 CPU 支撑的，而是众多性能强大的部件结合苹果优秀的设计共同努力的成果。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl623i52xvj311i0lgjz1.jpg"></p><h2 id="3-统一内存架构（UMA）"><a href="#3-统一内存架构（UMA）" class="headerlink" title="3. 统一内存架构（UMA）"></a>3. 统一内存架构（UMA）</h2><p>通过上一段内容，我们知道了 M1 芯片的强大光靠一颗强大的 CPU 是不够的，毕竟苹果也没办法突破物理定律，单纯通过设计让 CPU 的性能提升数倍。很明显苹果采用了其他的技巧来弯道超车，而<strong>「统一内存架构」</strong>就是其中之一。</p><p>我们知道，处理器在处理任务时，他要做的事情很简单就是<strong>取东西和算东西</strong>，也就是上一篇文章中提到的“接收指令+运算数据”。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl623wze7wj315k0g7gnl.jpg" alt="image-2"></p><p>和上篇文章一样，我们还是以打工人为例，取东西就是打工人搬砖，算东西就是打工人砌砖，你砌砖砌得再快再好，砖搬的慢，砌砖的速度也不会快。反过来也是，如果砌砖的慢，搬砖的块，就会有砖堆积。</p><p>因此<strong>理想状态</strong>下，搬砖的速度和砌砖的速度应该是一致的，这样就不用等对方。对于 CPU 来说也是同样的道理，如果双方的速度不一致，就会造成性能浪费。</p><p>因此，为了解决上述问题，苹果提供了一个解决方案，就是<strong>统一内存架构</strong>。</p><h3 id="3-1-UMA-做了什么？"><a href="#3-1-UMA-做了什么？" class="headerlink" title="3.1 UMA 做了什么？"></a>3.1 UMA 做了什么？</h3><p>那么 UMA 到底做了什么？</p><p>我们电脑里面有很多 PU（Processing Unit），即处理单元（处理器），我们常见的有 CPU（Central Processing Unit，即中央处理器）、GPU（Graphics Processing Unit，即图形处理器）和 NPU（Neural network Processing Unit，神经网络处理器）。他们都需要取东西、算东西，但是在 UMA 出现之前，他们只能通过 CPU 来分配东西，而 CPU 还要事先从内存中取数据。显然，这种工作方式的效率很低，况且，不同的处理器对于数据的运算速度也是不同的，为了做到时序同步，一定程度上不利于硬件性能的发挥。</p><p>而且，每个处理单元作为一个独立的个体，各自处理的数据包格式也不一样。不同 PU 之间通信的语言都是不一样的，统一数据格式时也需要消耗时间，如果这样通信效率还高那才有问题。就像来自不同国家的打工人一起打工时，都说各自的语言，通过翻译才能进行沟通，这听起来效率就很低。</p><p>当然了，以上只是简单的举一些例子，真实情况肯定是比这更加复杂的，但即使是这样，我们也能感受到有很多本来不应该存在的步骤耽误了很多时间。所以，为了解决上述这些问题，苹果给出了几个解决方案。</p><h4 id="3-1-1-PU-直接访问内存"><a href="#3-1-1-PU-直接访问内存" class="headerlink" title="3.1.1 PU 直接访问内存"></a>3.1.1 PU 直接访问内存</h4><p>没有 UMA 之前，需要先将数据从内存中取出，然后由 CPU 优先处理、分配，如下图所示 👇</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl625fb9ufj312m0r37am.jpg"></p><p>有了 UMA 之后，这些处理单元可以直接访问内存，再也不需要通过 CPU 去获取一些数据了，如下图所示 👇</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl625q6lprj312y0tjqad.jpg"></p><p>通过这样的设计方式，这个 PU 们不需要再和 CPU 同步语速，也不用什么乱七八糟的事情都先去找 CPU 过问一遍，这样就省下来一大笔时间了。</p><h4 id="3-1-2-Apple-designed-package"><a href="#3-1-2-Apple-designed-package" class="headerlink" title="3.1.2 Apple-designed package"></a>3.1.2 Apple-designed package</h4><p>虽然解决了取数据时的时序问题，但是各处理单元的通信问题仍然没有得到解决，这里就要提到苹果所做的另一个解决方案了——Apple-designed package。</p><p>通过 Apple-designed package，各单元处理数据时的数据包格式统一了，他们之间的沟通不再需要翻译了，哪怕都说的是“阿巴阿巴阿巴”也都能明白各自说的是什么了，这就又省下了一部分时间。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl6263nd9kj31b60u0ahu.jpg"></p><h4 id="3-1-3-高度集成"><a href="#3-1-3-高度集成" class="headerlink" title="3.1.3 高度集成"></a>3.1.3 高度集成</h4><p>无论是拆解图还是实例图，都说明苹果这次的高度集成，是直接将内存放到了处理器的旁边，这极大的缩小了内存和处理器之间的物理距离，取数据的速度自然就会更快了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl6273kb14j312a0oek94.jpg"></p><p>千万别小看了这点物理距离的减少，目前的计算机都属于<strong>冯诺依曼结构</strong>，而该结构最大的一个隐患就是：在内存容量指数级提升以后，CPU 和内存之间的数据传输带宽成为了瓶颈，原因之一就在于内存和 CPU 的物理距离过大。虽然现在 CPU 和内存的速度越做越快，但是他们之间的距离却无法改变，而传输数据的速率-光速也无法改变。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl627if3zwj312m0h1myk.jpg"></p><p>我们可以来做一个简单的数学题，i9-7980XE 是一颗 18 核 36 线程的民用 CPU，这颗 CPU 最大睿频 4.4GHz，假设该 CPU 在一个时钟周期内执行一条运算指令，那么该 CPU 执行一个指令需要的时间是 0.000000000227273 秒，即 0.22ns（纳秒），那么在这段时间内，光所跑的距离是 0.0681819 米，四舍五入就约等于 7 厘米。所以说如果 CPU 和内存之间的距离超过 7 厘米，CPU 岂不是要多等一会才能继续收到指令了。这还是一次只取一条指令的情况，如果数量多了呢？</p><p>所以物理距离的缩小，自然可以让 CPU 取数据的速度更快一些，这也是 M1 芯片性能提升的关键一点。</p><h3 id="3-2-超大缓存"><a href="#3-2-超大缓存" class="headerlink" title="3.2 超大缓存"></a>3.2 超大缓存</h3><p>上面说的这些也都只是让 CPU 取数据时可以更快一些，但是 CPU 和内存之间的数据传输带宽成为瓶颈不单单是因为物理距离的原因，最根本的原因还是因为 CPU 太快了，<strong>很难做到和内存同步</strong>。所以我们得把计算机经常用到的数据导入 cache，也就是<strong>缓存</strong>，避免计算机去内存要东西，更不应该让计算机去硬盘要东西。</p><h4 id="3-2-1-什么是缓存"><a href="#3-2-1-什么是缓存" class="headerlink" title="3.2.1 什么是缓存"></a>3.2.1 什么是缓存</h4><p>缓存就是数据交换的缓冲区（称作 Cache），是存贮数据（使用频繁的数据）的临时地方。其实在很多地方都用到了缓存，比如当用户查询数据，首先在缓存中寻找，如果找到了则直接执行。如果找不到，则去数据库中查找。</p><p>CPU 也同样设计了一个这样的存在，是一个用于减少处理器访问内存所需平均时间的部件。他的工作原理是：当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl62olzkkvj30n00eqgnd.jpg"></p><p>还是拿搬砖这个例子来加深理解，如果我正在砌砖，就算搬砖的人把砖搬过来了，我也来不及砌，光让他在那站着等也不好，所以就让他把砖放到脚边（缓存），这个砌砖的每次就不用跑去搬砖的那里拿砖了，只需要从脚边（缓存）拿砖就好了。</p><p>所以，我们知道缓存主要是为了<strong>弥补 CPU 和内存之间的读写速度差异</strong>而出现的，因此理论上，在一定范围内，缓存自然是越大越好。</p><h4 id="3-2-2-M1-芯片的缓存设计"><a href="#3-2-2-M1-芯片的缓存设计" class="headerlink" title="3.2.2 M1 芯片的缓存设计"></a>3.2.2 M1 芯片的缓存设计</h4><p>M1 芯片同样也是这么设计的，只是苹果为 M1 芯片带了<strong>超大</strong>的缓存，这个缓存有多大呢，我们来做个简单的比较。（以下数据摘自维基百科和 CPU - Z）</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl62vx9l6cj318i0bggmz.jpg"></p><blockquote><p>L1 表示一级缓存，L2 表示二级缓存，即一级缓存的缓存。一级缓存还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存(Instruction Cache，I-Cache，L1i)，分别用于存放数据及执行数据的指令解码，两者可同时被 CPU 访问，减少了 CPU 多核心、多线程争用缓存造成的冲突，提高了处理器的效能。一般 CPU 的 L1i 和 L1d 具备相同的容量。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl62us555wj30u00bz0v5.jpg"></p><p>这个对比结果非常明显，尤其是在二级缓存，虽然在 M1 芯片中，二级缓存是共享的，但这 16MB 的缓存还是比 i9-10900K 的二级缓存大了不少。虽然 i9-10900K 的三级缓存有 20MB，但是也只是比 M1 的二级缓存大了 4MB，并且三级缓存的速度是比二级缓存慢得多的。</p><p>而且，可别忘了，基于苹果这次的高度集成，DRAM 内存和处理器直接通过 Fabric 高速总线连接在一起，这样使得集成的内存可以<strong>近似看做</strong>是一个<strong>超大容量的 L3 缓存</strong>，苹果用牺牲扩展性换取吞吐量的策略，给 M1 芯片带来了更高的带宽与更低的延迟。当然了，缓存也并不是越大越好，一方面是制作的难度，另一方面<strong>缓存命中率</strong>也是评价缓存性能的一个重要指标。如果缓存过大，命中率就会下降，如果这样就会有些得不偿失了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl62r9ypuwj31540ggaav.jpg"></p><p>其实 M1 芯片之所以可以塞入这么大的缓存，和其制作工艺是有很大的关系的，相较于 10nm、14nm，M1 芯片采用台积电最先进的 5nm 工艺制成，晶体管越小，单位面积内可塞入晶体管的数量就更多，这样就让苹果可以为 M1 芯片设计更大的缓存。这一部分具体我们下一节来说。</p><p>现在再回过头看我们一开始所说的：“所谓统一内存架构，就是通过 Fabric 高速总线将中央处理器、图形处理器、神经网络引擎、缓存、DRAM 内存全部连接在一起。”这不仅仅是简单的将各单元连接在一起，而是苹果这么多年在移动端 SoC 优秀实践经验的结晶，是只属于苹果自己独享的 moment。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl628bjse9j30th0d4q45.jpg"></p><p>所以说，这么一套搞下来，哪怕 M1 芯片的 CPU 芯片的物理性能没有得到提升，性能也不是最强大的，但 UMA 的设计架构也会给 M1 芯片带来综合性能的提升。</p><p>况且，谁说 M1 芯片的 CPU 就不行了呢？</p><h2 id="4-制程-amp-晶体管数量"><a href="#4-制程-amp-晶体管数量" class="headerlink" title="4. 制程&amp;晶体管数量"></a>4. 制程&amp;晶体管数量</h2><p>Apple 官网对于 M1 芯片有如下的介绍：</p><blockquote><p>M1 也是 Apple 首款采用先进 <strong>5 纳米</strong>制程打造的个人电脑芯片，封装了惊人的 <strong>160 亿</strong>个晶体管，其数量为 Apple 所有芯片之最。</p></blockquote><p>这里我将两个重要的数字加粗标注了出来，第一个数字是刚才提到的 5 纳米制程，第二个数字是 160 亿个晶体管。</p><h3 id="4-1-5-纳米制程指的是什么？"><a href="#4-1-5-纳米制程指的是什么？" class="headerlink" title="4.1 5 纳米制程指的是什么？"></a>4.1 5 纳米制程指的是什么？</h3><p>当我们阅读一个和芯片有关的文章时，经常会看到诸如 5nm、7nm、14nm 这些词，例如华为的“最后一款”麒麟芯片，麒麟 9000 就是 5nm 工艺制程，那么这个 5nm 指的到底是什么呢？</p><p>说实话，这一块内容水太深了，我自己也不是从事半导体领域的，很难解释清楚，这里就只能简单的说明一下。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl628y4bdwj30hf08440o.jpg"></p><p>引用知乎的一张图，在上图所示的晶体管结构中，电流从 Source（源极）流入 Drain（漏级），Gate（栅极）相当于闸门，主要负责控制两端源极和漏级的通断。电流会损耗，而栅极的宽度则决定了电流通过时的损耗，表现出来就是手机常见的发热和功耗。宽度越窄，功耗越低。而栅极的最小宽度（栅长），就是 XX nm 工艺中的数值。</p><p>简单来说就是，Leakage Path 越小，电流损耗越小，总体来看就是功耗越小。宏观来看，随着 Leakage Path 越小，晶体管之间的距离就越小，单位面积内可以塞入的晶体管数量就越多，整体的运算性能就越强。</p><p>最近，AMD 疯狂 yes 的原因和其工艺制程的提升有很大关系，而此次 M1 芯片所采用的是目前市面上最先进的 5nm 工艺制程，性能强也是意料之中的事情了。</p><h3 id="4-2-为什么晶体管数量越多，运算性能越强？"><a href="#4-2-为什么晶体管数量越多，运算性能越强？" class="headerlink" title="4.2 为什么晶体管数量越多，运算性能越强？"></a>4.2 为什么晶体管数量越多，运算性能越强？</h3><p>晶体管就可以看成一个小开关，有通断两种状态。你可以理解为通是 1，断是 0，那么一个晶体管的一次开，或者一次关，就提供一个 2 位的数据：0 或者 1。用无数个 0 或者 1 就可以代表所有的数据。这也就是为什么电子时代信息被称为数字化。其实就是把所有的信息用数字来表示。而数字，可以用电脑来处理。电脑是没法直接处理人类的信息的。这就是计算机采用二进制表示数据的的原因。</p><blockquote><p>所以我们要理解，是因为电路的这个特性才让先辈们选择二进制作为机器的语言，而不是因为二进制简单所以采用二进制的。<br>这里提两个小问题：人为什么要使用十进制？生活中有没有使用其他进制计数的例子？欢迎在评论区留下你的想法。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl629j78kaj317q0gy0ze.jpg"></p><p>一个晶体管一次只能表示一个 0，或者 1。那么一大堆晶体管同时工作呢？</p><p>简单的说就像是一个大的存放开关的工厂，每个晶体管就是一个开关，关的时候表示 0，开的时候表示 1，晶体管越多，开关也越多，在处理同一个问题的时候走的线路也就越多。这就像是你以前学初中物理时的并联电路，之路越多流通的线路也越多。同样，CPU 的晶体管越多，单位时间内可以流过的电流的支路也就越多，反映在宏观上就是你在一颗 CPU 上能同时处理的数据也就越多，机器也就越快。</p><p>不过晶体管越多芯片性能越好这一点并不是绝对的，只是相对来说，晶体管多了之后，可设计的空间就更大了，剩下的就要看厂商能否利用好这部分设计空间了。</p><h2 id="5-M1-真的完美吗？"><a href="#5-M1-真的完美吗？" class="headerlink" title="5. M1 真的完美吗？"></a>5. M1 真的完美吗？</h2><p>那么问题来了？说了这么多 M1 芯片的优点，又是采用了 UMA 架构，又是最先进的工艺制程，他是一个完美的芯片吗？我想未必。</p><h3 id="5-1-扩展性"><a href="#5-1-扩展性" class="headerlink" title="5.1 扩展性"></a>5.1 扩展性</h3><p>相比上面的介绍让你对 M1 芯片的统一内存架构有了一定了解，也知道这样的架构对于性能的提升有很大的帮助。</p><p>只是将内存这样焊死在一块 SoC 芯片上，对于后期想要硬件扩展的用户来说，无疑是不可能的。</p><p>而且虽然 M1 的 GPU 的性能很强，但也是相对手机上的 GPU 来说的，和桌面级的 GPU 相比还是有很大的差距的，毕竟体积摆在那了，这对外接显示器或者玩游戏的用户来说也是很难熬的。同样的，外接显卡也是用不了的，不过应该也不会有人用 Mac 玩游戏吧。</p><blockquote><p>Mac 当然可以玩游戏，这里挖个坑，下次我们来窥探一下未来——云游戏。</p></blockquote><h3 id="5-2-兼容性"><a href="#5-2-兼容性" class="headerlink" title="5.2 兼容性"></a>5.2 兼容性</h3><p>从 x86 架构迁移到 ARM 架构，苹果是下了很大决心的，也是布局已久了。为了不让用户担心应用生态会出现较大的变化，苹果给出了三种不同应用的解决方案，分别是<strong>「Universal 通用应用」</strong>、<strong>「Rosetta 2 转译应用」</strong>以及<strong>「原生 ARM 应用」</strong>。其中，Universal 是横跨 ARM 和 X86 平台的应用，目前以后部分开发者将自家软件转向 Universal，例如 Adobe 的 Lightroom，Photoshop 则会在明年更新。这里不得不感慨一下苹果的号召力，apple silicon 一出，各大厂商都在快速跟进，估计隔壁某厂要羡慕哭了。</p><p>如果新应用没有适配 Universal，那你也可以通过 Rosetta 2 转译应用，那些原生的 X86 编译应用可以通过苹果提供的 Rosetta 工具，转译成可以在 ARM 平台直接运行的应用，虽然会损失一些性能，但是可以极大提升兼容性。目前从各种兼容性测试视频来看，Rosetta 2 的完成度非常高，并不像隔壁某厂，推出的是一个半成品。</p><p>如果说，上面两种解决方案还是无法满足你的需求，那么你还可以依托苹果建成依旧的 App Store 生态，直接运行原生 ARM 应用，它们能够直接在 macOS、iOS 和 iPadOS 上运行，相当于苹果打通了小屏到大屏的主要设备。</p><p>即便曾经 macOS 的软件生态还不完善，但在 iOS 几乎已经没有了这个问题，也使得搭载 M1 芯片的 Mac 产品并不需要太过担心没有足够的应用可以使用。</p><p>而且，从此次更新的 macOS Big Sur 也可以看出，苹果也是有意让这三端的风格更加统一。无论是系统界面还是图标样式，都在往 iPad 和 iPhone 上统一。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl62a74ug8j30u00fpngg.jpg"></p><p>那么为什么同样的软件在迁移的时候会有兼容性的问题？这已经和本文要介绍的 M1 没什么关系了，考虑到篇幅问题，我们之后再说。</p><p>那么到底 M1 版 MacBook 能兼容什么软件、不能兼容什么软件？</p><p>一个个软件测试，工程量非常大，而且软件们也处于不停的更新换代中。好在 GitHub 上出现了一个关于 M1 版 MacBook 的兼容性测试项目“DoseitARM”。在这个项目中，可以看到开发工具、影音工具、图形图像工具、剪辑工具等各种生产力软件的兼容性测试。各类软件的兼容性又被分为几种不同的情况，分别如下：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl62au4sakj30vs09qjsy.jpg"></p><p>他的地址是 👉：<a href="https://github.com/ThatGuySam/doesitarm">https://github.com/ThatGuySam/doesitarm</a></p><p>有兴趣的读者可以长期关注该项目。</p><h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6. 最后"></a>6. 最后</h2><p>对于财大气粗的苹果来说，未来无疑将会长期进行大量的投入来对 M 系列芯片进行迭代，并且其自有生态也保证了能够反哺 M 系列芯片的研发。希望国内的企业也可以像苹果一样有属于自己的芯片，未来值得期待！</p><p>如果你觉得我的文章对你有所帮助，不妨点个赞关注我，就当是给我的一点鼓励了，你们的鼓励会让我更加努力做好分享，感谢支持 🙏。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1 暴打 Intel？——x86 与 ARM 的爱恨情仇</title>
      <link href="p/b013.html"/>
      <url>p/b013.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxziu16jij31300sq1gj.jpg"></p><p>最近这段时间数码圈里最火的莫过于苹果最新推出的三款基于自研芯片 M1 的电脑了，分别是 MacBook Air、13 寸的 MacBook Pro 以及 Mac Mini。其热度也是久居不下，哪怕距离发布会已经过去 10 多天了，却仍然能看见各种评测视频、文章层出不穷。在一些平台搜索 MacBook M1 的相关视频、文章，无一例外都是：Apple 真香、性能起飞、虐杀英特尔等等这类词汇。<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkxz4l3jd0j31l20pse81.jpg"><br>最近新出的拆解视频我也有看了一些，可以发现其实新出的 Mac 在模具方面和前几年相比没有什么太大的变化，最大的亮点在于便是其自研的 ARM 芯片 M1 了。</p><p>此次的 M1 芯片的出现，带火了另一个名词，ARM 架构。同时也让一个探讨许久的问题又重新浮出水面：ARM 芯片真的会超越 x86 芯片吗？</p><p>本文先不探讨 M1 芯片的设计思路，先来认识学习下两个经常听见但有可能并不太清楚的名词：ARM 与 x86。</p><h2 id="ARM-与-x86"><a href="#ARM-与-x86" class="headerlink" title="ARM 与 x86"></a>ARM 与 x86</h2><p>随着信息技术的普及，在现在，相信你随便找一个人问他知不知道 CPU 是什么，我想他的答案都会是肯定的。但如果你再问他，知道 CPU 的 x86 架构和 ARM 架构吗，我想一些计算机专业的同学可能都不会太清楚，因此在谈此次苹果的 M1 芯片之前，我们先来聊一聊 ARM 与 x86。</p><p>时下「打工人」这个名词很火，而 CPU 就是整个计算机中最勤劳且最核心的打工人。x86 和 ARM 便是 CPU 中两种不同类型的打工人，这两种架构很大一个区别就是指令集。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkxz4zi5x6j30c80c6n4z.jpg"></p><h2 id="架构？指令集？"><a href="#架构？指令集？" class="headerlink" title="架构？指令集？"></a>架构？指令集？</h2><p>看到这里你是不是很疑惑，架构到底是什么？指令集又是什么？别急，我们还是以打工人为例，将 CPU 代入该角色来说明。</p><p>事实上，CPU 做的事情很简单也最核心，简单来说就是接收指令+运算。CPU 和千千万打工人一样，首先要有正常的<strong>工作能力</strong>（即执行能力/运算能力），然后又有足够的<strong>逻辑能力</strong>（能明白做事的顺序），最后还要有一定的<strong>理解能力，能听懂别人的话</strong>（即指令集），才能正常工作。而把这些<strong>集中在一起</strong>就构成了所谓的「<strong>架构」</strong>。你可以将「架构」理解为一套<strong>“工具”、“方法”和“规范”的集合</strong>。</p><p>不同的架构之间，工具可能不同，方法可能不同，规范也可能不同，这也造成了它们之间的互不兼容——毕竟再大的官威也不能拿前朝的剑斩本朝的官。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkxz55ftt1j308u04fgle.jpg"></p><h2 id="指令集的种类"><a href="#指令集的种类" class="headerlink" title="指令集的种类"></a>指令集的种类</h2><p>指令集说白了是 CPU 所能看懂的语言，从 CPU 发明到现在，出现过非常多种架构，从我们熟悉的 x86，ARM，到不太熟悉的 MIPS，IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即“复杂指令集”与“精简指令集”。因此要想了解 x86 和 ARM，就得先了解精简指令集（RISC）和复杂指令集（CISC） 。</p><p>再以打工人为例，有两类打工人，一类是对领导言听计从，上头说一件事，他做一件事，这种就是<strong>「精简指令集」</strong>。另一种比较滑头，不需要上头把每件事都说清楚，只要上头简单的发送个指令，他就会自动去完成了，这种就是<strong>「复杂指令集」</strong>。</p><p>比如，同样是对于领导说了一句「你把这份文件送到王总那」这个操作，第一个打工人可能需要<strong>问清楚领导</strong>，是哪个王总，什么时候送到，王总的位置在哪。而第二个打工人可能拿了文件就<strong>自己去查</strong>是哪个王总以及王总的位置了。</p><p>这就是“复杂指令集”和“精简指令集”的逻辑区别。简单来说复杂指令集就是<strong>将很多个操作集中在一个指令中，</strong>这样会显得更加智能些，但同时功耗也会更大（毕竟猜领导心思是需要费脑子的）<strong>，</strong>而精简指令集则相反。因此，这两种指令集之间，最大的区别在于它们的设计者<strong>考虑问题方式的不同</strong>。</p><p>而我们所说的 x86 架构就是复杂指令集（CISC）的代表，ARM 架构是精简指令集（RISC）的代表，甚至 ARM 的名字都是直接表明了它的技术：Advanced RISC Machine——高级 RISC 机器。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkxz5ip97gj30u00u6tnk.jpg"></p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><p>看到这可能有人说，明显是复杂指令集好啊，同样数量的指令，复杂指令集包含的操作更多，这样你想完成一件较为复杂的事情是可能只需要发送一个指令就好了，要是精简指令集的话，你还得发送好几个指令才可以。</p><p>事实上，任何事物其本质都具有二重性，有利自然就会有弊，这是自然法则。因此我们根本不好去判断它们之间到底谁好谁坏。</p><p>而且也正是复杂指令集和精简指令集之间设计思路差异之大，直接导致了二者在应用场景分道扬镳——复杂指令集更加专注于<strong>高性能但同时高功耗</strong>的实现，比如大型服务器、高性能笔记本等，最常见的就是 Intel 和 AMD 的桌面处理器。</p><p>而精简指令集则专注于<strong>小尺寸低功耗</strong>领域，例如智能手机、手表、平板等，比如高通、三星、联发科、华为、苹果等。</p><p>在执行高密度的运算任务的时候复杂指令集就更具备优势，而在执行简单重复劳动的时候精简指令集就能占到上风，所以，<strong>抛开使用场景谈优劣就是耍流氓</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxz62d4h7j31240cmmz1.jpg"></p><h2 id="x86-名称的由来"><a href="#x86-名称的由来" class="headerlink" title="x86 名称的由来"></a>x86 名称的由来</h2><p>相比于 1991 年诞生的 ARM 架构，1978 年诞生的 x86 架构更像是一位老者。现在想想，x86 架构会采用复杂指令集也不难理解，在当时计算机资源相对缺乏的年代，当然是要用最少的机器语言指令来完成尽可能多的计算任务，至于功耗什么的？在那种应用场景下真的那么重要吗？显然不是。</p><p>那为什么他要叫 x86 架构呢？</p><p>事情要从 1978 年 6 月 8 日说起，Intel 发布了一款新型的微处理器“8086”。这款处理器在刚出现时并没有得到什么关注，可后来 IBM 采用了 8086 制造出名噪一时的 IBM PC 机，直接带动了 Intel 成为全球首屈一指的芯片巨头，不仅仅使 Intel 平步青云，更是成为了业界的一种标准。</p><p>而后出现的 80286/80386/80486/80586，都是从当初的 80x86 一脉相承下来的架构，只是不断优化、扩充功能、提升性能而已。而其他 x86 处理器厂商，比如 AMD、威盛、全美达（已退出 x86 领域）等，其产品也都兼容 x86 架构。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxz69bsebj31ow0j8nny.jpg"></p><p><strong>因此，之所以叫 x86，实在是因为应用得过于广泛才导致 x86 直接成为了其代名词。</strong></p><h3 id="x64-又是什么？"><a href="#x64-又是什么？" class="headerlink" title="x64 又是什么？"></a>x64 又是什么？</h3><p>除去 x86，还有很多人看见过 x64，而且一度认为 x86 就是 32 位的，x64 就是 64 位的，其实这是一个不怎么正确的理解，但在说这之前，我们先来说一下 32 位、64 位中的<strong>「位」</strong>指的是什么。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxz6nttryj30zk0k074p.jpg"></p><p>我们可以简单的把 CPU 理解为由多个晶体管组合而成的器件，晶体管就是微型电子开关，每个开关有一个操作<strong>位</strong>，每个开关有两种状态：ON（开）和 OFF（关），这一开一关就相等于晶体管的连通与断开，而这两种状态正好与二进制中的基础状态“0”和“1”对应！不同数量、不同位置的 01 可以组合成不同的指令、数据，从而产生无限多的可能性！（这也是我的公众号名称 01 二进制的由来）</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxz79dvlzj30at074aat.jpg"></p><p>再回到 CPU，CPU 中有一块区域叫通用寄存器，是专门用于存放指令的，如果通用寄存器的数据宽度为 64 位（可以简单理解为这个寄存器有 64 个晶体管），也就是说处理器一次可提取 64 位数据（一次提取 8 个字节的数据），比 32 位(一次提取 4 个字节的数据)提高了一倍，理论上性能会相应提升 1 倍。</p><p>再回到 x64 和 x86 的问题，x86 的确是 Intel 的开发的一种 32 位指令集，但随着硬件技术的进步，CPU 开始迈向 64 位的时候，Intel 竟然选择不兼容 x86，而是另辟蹊径，选择了推倒重来，重新设计指令集，被称之为 IA-64，。但是 IA-64 并不与 x86 兼容，且市场反应较冷淡，同时受制于多个专利权，使其他厂商不能模仿，规模没有很大。于是就被另一家芯片制造商 AMD 抢先制作出了兼容 X86 架构的 64 位的商用 CPU，AMD 称之为 AMD64，面世之后获得了用户的一致好评。再后来 Intel 只得放弃 IA-64，选择支持 AMD64 的指令集，但是为了自身的面子换了个名字，叫 Intel 64，但其核心与 AMD64 几乎相同。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxz7fdrs8j3069069wed.jpg"></p><p>再后来苹果公司和 RPM 包管理员以“x86-64”或“x86_64”称呼此 64 位架构。甲骨文公司及 Microsoft 称之为“x64”。BSD 家族及其他 Linux 发行版则使用“amd64”，32 位版本则称为“i386”（或 i486/586/686），Arch Linux 用 x86_64 称呼此 64 位架构。<br>自此 x64 这一名称开始流行起来。</p><h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>说完了这些，我们再来回想一下生活中常见的一个应用场景。我们给电脑新增一个固态硬盘、扩展一下内存是不是很容易，买根内存条自己都能装上去。但如果你想给你的手机扩容到 512G 是不是就很麻烦，不仅要去专门的手机店，还要花大价钱。不知道各位读者有没有想过这背后的原因？</p><p>这其实也是和 CPU 的架构设计有关系。</p><p>x86 结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且 x86 结构的电脑出现了近 30 年，其配套扩展的设备种类多、价格也比较便宜，所以 x86 结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。</p><p>ARM 结构的电脑是通过专用的数据接口使 CPU 与数据存储设备进行连接，所以 ARM 的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用 ARM 结构的系统，一般不考虑扩展，你买来是多大内存的手机就是多大的内存。基本奉行“够用就好”的原则。这一点在下一篇文章对于 M1 芯片的介绍中我会重新提及。</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxz7usywnj30xc0m5402.jpg"></p><p>x86 架构芯片的制造商，大家应该只听过 Intel 和 AMD，可为什么 ARM 架构芯片的制造商有那么多公司？</p><p>其实道理很简单，简单来说就是：ARM 公司不生产芯片，只提供一个芯片设计的 Idea。</p><p>ARM 公司它不制造、不销售任何芯片，只是自己设计 IP，包括指令集架构、微处理器、图形核心、互连架构，然后谁喜欢就把授权卖给谁。大多数生产 ARM 芯片的公司，例如三星、苹果、高通，他们都获得了 ARM 公司的架构级授权，即允许在 ARM 指令集基础上根据需要创建出自己的内核架构。</p><p>可以说，作为一家不生产芯片的芯片厂商，ARM 在全球范围内支撑起了各种嵌入式设备、智能手机、平板电脑的运行，正是他的这种机制，让各个企业得以自己定制芯片架构，让 ARM 生态得以大放异彩，甚至一度有超越 x86 的势头。</p><p>相比之下，x86 的授权就没有这么灵活了。以 Intel 和 AMD 这两家公司为代表，分为两种：</p><p>首先是 Intel 那样的，从头到尾自己大包大揽，架构和芯片的设计、生产一律不依靠任何人。这样做是需要极其雄厚、全方位的实力做保障的，得有钱、有人、有技术。好处当然也是很明显的，不但能完全自己把握自己的命脉，利润也是极其可观，Intel 几乎任何产品都可以享受非常高的利润，想卖多少钱就可以卖多少钱。</p><p>另外一种是无工厂模式(Fabless)。NVIDIA 就是这样，AMD 实在耗不过 Intel 就也变成了这样。这类企业只是<strong>自己设计芯片，制造则交给代工厂</strong>，比如台积电、联电、GlobalFoundries、三星电子。好处很明显了，负担很轻，自己只管设计就行了，不用耗费巨资去兴建晶圆厂、开发新工艺，但坏处同样很突出：你设计出来了，能否造出来、即便造出来又是个什么样子你就无法做主了，得看<strong>代工伙伴的能耐</strong>。</p><p>这两年，英特尔始终在 14nm++，甚至被人调侃成牙膏厂。而与此同时，随着台积电 5nm 工艺的提升，AMD 又崛起了。让我们大声说一句：AMD，YES！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本文的全部内容了，说好的介绍 M1 芯片的，结果竟然花了这么多字来介绍 x86 和 ARM 的事情，不过有了这些前置知识，对于我们理解下一篇文章也是极好的。</p><p>下一篇文章我将会根据目前已有的资料讲解一些与苹果 M1 芯片相关的知识，如果你觉得本文对你有所帮助，不妨点个赞、关注支持一波。你们的支持是我更新的最大动力。</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DO,VO,DTO 你知道吗？</title>
      <link href="p/dff4.html"/>
      <url>p/dff4.html</url>
      
        <content type="html"><![CDATA[<p>作为后端最常用的编程语言之一，Java 已经有很多年的历史了，在阿里内部，Java 也是使用最广泛的一门语言。在阿里实习的这段时间，规范一词是我感受最深的。没有规矩不成方圆，今天来说一下 Java 中的各种 O(bject)。</p><h2 id="为什么会出现这些-O？"><a href="#为什么会出现这些-O？" class="headerlink" title="为什么会出现这些 O？"></a>为什么会出现这些 O？</h2><p>我们知道，这些 O 不管叫什么名字，其本质都还是对象（Object），既然本质都一样，为什么非要给他们套上各种马甲？<br>个人认为原因有三：<br>第一，随着编程工业化的发展，需要有一套合理的体系出现。中国人喜欢造神，外国人喜欢造概念，于是 MVC、MVP、MVVM 等编程模型就出现了，为了搭配这些编程模型的使用，需要对 Object 的功能进行划分，于是我们便看到了这些层出不穷的 Object。当然这里并没有批评这些概念的意思。<br>其二，我认为在团队协作编码中，一个好的命名方式是可以节约很多时间成本的。就比如<code>getItemById</code>一眼看去就知道是通过 id 获取一个 item 对象，<code>ItemVO</code>一眼看去就知道是前端透出的 json 对应的对象。<br>其三，如此划分，可以让项目结构更加清楚，不至于出现东一块西一块，对象乱扔的局面。尽可能避免了在多人协作时对象混乱的情况。<br>总的来说，这一切都是为了让软件编程更加合理、更加规范、更加高效。</p><h2 id="有哪些-O？"><a href="#有哪些-O？" class="headerlink" title="有哪些 O？"></a>有哪些 O？</h2><p>这些 O 有很多衍生出的命名，比如 VO、DO、BO，这里我们把常见的 O 列举出来，然后一一解释。</p><blockquote><p>以下内容参考阿里巴巴 Java 开发手册，如果有需要可以在微信公众号「01 二进制」后台回复「Java 开发手册」获得。</p></blockquote><ul><li>DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li>PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象</li><li>DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li><li>BO（ Business Object）：业务对象。 由 Service 层输出的封装业务逻辑的对象。</li><li>AO（ Application Object）：应用对象。 在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li><li>POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。</li><li>DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体。</li></ul><p>一下子给出 8 个常见的 O，光看解释大家可能会有些迷糊，接下来我们从下面这张图入手，带大家直观的感受下，这些 O 的用处。</p><h3 id="数据的流向"><a href="#数据的流向" class="headerlink" title="数据的流向"></a>数据的流向</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1711761/1595147072886-bfb41912-9c98-4bc0-9918-5b246e0947b1.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=1410&size=56452&status=done&style=none&width=1410"><br>我们知道，一般情况下，前端是不会凭空造出数据的，因此最后前端展示的数据一定是从数据库中来的，数据的流向通常也是从数据库流向页面。我将其分成三个部分：数据访问、业务处理和业务解释。</p><ol><li>数据访问：这一部分是用于从数据库中读取数据，将数据记录转换成数据实体也就是 Java 对象，便于操作。</li><li>业务处理：这一部分是数据流的核心，几乎所有数据的操作都是在这一部分完成的。</li><li>业务解释：这一部分是用于展示给前端的数据，解释业务体现在某些字段/值是需要经过处理的才会呈现的。</li></ol><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>说了这么多，我们整理出以下关键点。</p><ul><li>DAO，是用于<strong>操作数据</strong>而不是描述数据的。</li><li>PO/DO/Entity，其数据结构对应数据表中的一条记录，因此是同一类别的。</li><li>BO，可以理解为 PO 的组合，举个简单的例子，假设 PO 是一条交易记录，BO 就可以是一个人全部的交易记录集合对象。</li><li>DTO，用于传输数据，可能传递给前端，也有可能传递给其他系统。用于<strong>承载数据</strong>。</li><li>VO，这个最好理解，前端最后需要的数据长什么样，对应的对象就是 VO。</li></ul><h2 id="如何使用这些-O？"><a href="#如何使用这些-O？" class="headerlink" title="如何使用这些 O？"></a>如何使用这些 O？</h2><p>说了这么多，在实际的项目中，我们应该如何去使用这些 O？</p><h3 id="教条主义？"><a href="#教条主义？" class="headerlink" title="教条主义？"></a>教条主义？</h3><p>首先，这几个概念很完整，但是我们在用的时候是必须按这个来做吗？<br>答案当然不是的，规矩是死的，人是活的。文章开头我们就说了，之所以引入这些概念，很大程度上是为了提升编程体验，而且系统和系统的复杂度不同，协作水平不同，完全没有必要教条主义，适合自己的才是最好的。</p><h3 id="省略方案"><a href="#省略方案" class="headerlink" title="省略方案"></a>省略方案</h3><ol><li>不管你是叫 PO 还是 DO 还是 Entity，用于描述数据库记录的对象一定要存在，不可省略。</li><li>DTO 和 BO 在一般情况下，如果业务系统不是非常复杂，可以考虑省略。</li><li>VO 和 DTO，DTO 可以用于将数据传递给前端，如果你不需要删减字段的话，VO 可以考虑省略。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>领域模型命名规约：</p><ul><li>数据对象：xxxDO，xxx 即为数据表名。</li><li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li><li>展示对象：xxxVO，xxx 一般为网页名称。</li><li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本篇文章的全部内容了，如果你觉得本篇文章对你有所帮助，不妨关注支持一下。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggwldeh16tj30go0goabc.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口调度者—— API 网关</title>
      <link href="p/8e8e.html"/>
      <url>p/8e8e.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道在微服务架构风格中，一个大应用被拆分成为了多个小的服务系统提供出来，这些小的服务他们自成体系，也就是说这些小系统可以拥有自己的数据库，框架甚至语言等，这些小系统通常以提供 Rest Api 风格的接口来被 H5, Android, IOS 以及第三方应用程序调用。</p><p>在《浅入浅出消息队列》这一篇文章中，我提到了消息队列是方便<strong>服务与服务之间</strong>的通信解耦，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbnt5yslj30kq0cz41n.jpg"></p><p>那么这时候问题来了，如果一个外部的应用（浏览器、App）要去访问这个大应用怎么办？</p><p>很简单啊，直接通过 HTTP 请求不就完了？</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>真的这么简单吗？我们以淘宝的商品详情页为例：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibboc9hzxj30k50igakn.jpg"></p><p>如上图所示，这个页面包含了视频、库存、商品价格、商品评价等内容，这些数据都来自不同的微服务中，所以没办法像传统单体应用一样依靠数据库的 join 查询来得到最终结果，因此就需要多次调用以检索数据，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbokqxvrj30x40fcjuy.jpg" alt="image (2)"></p><p>这就会引发几个严重的问题：</p><ul><li>不同的客户端设备可能需要不同的数据。Web,H5,APP，需要单独写一套 API</li><li>多次客户端请求导致用户体验不佳。移动网络相较于服务于服务间的局域网，有更低的带宽和更高的延时，如果可以同时执行请求倒也还好，但如果客户端要按照顺序执行请求，就会让用户体验变得异常糟糕。</li><li>缺乏封装导致前后端不协调。过分的拆分 API，会导致客户端和服务端过度耦合，再加上移动端 APP 的新版本迭代到每个手机用户时需要很久，这样会使后端很难更改服务的 API。</li></ul><p>这样显然是不好的设计，因此，本期的“天降猛男”就出现了——API 网关。</p><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p>在介绍 API 网关前，我们先来介绍一个设计模式——外观模式。</p><p>外观模式（Facade Pattern）它向现有的系统添加一个接口，来隐藏系统的复杂性。类图如下所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibborcq48j30fk08idi5.jpg" alt="image (3)"></p><p>之所以要在说 API 网关前说一下外观模式，是因为二者的设计理念是类似的。</p><p>和外观模式类似，API 网关封装了应用程序的内部架构，并为其客户端提供 API，他还可能具有其他职责，如<strong>身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理</strong>。下图展示了客户端、API 网关和服务之间的关系。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbpfdfldj30za0hg0uv.jpg"></p><p>所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。其出现也是侧面贯彻了软件工程中**”高内聚，低耦合”**的思想。</p><h3 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h3><p>API 网关负责<strong>请求路由、API 组合和协议转换</strong>。来自<strong>外部客户端</strong>的所有 API 请求首先会先转到 API 网关，后者再将请求路由到相应的服务。API 网关使用 API 组合模式处理其他请求，调用多个服务并聚合结果。同时他还可以在客户端友好的协议（例如 HTTP）与客户端不友好的协议之间进行转换。</p><h4 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h4><p>当 API 网关收到请求时，随机会查询路由映射，该映射将指定请求路由到哪个服务。例如，路由映射可以将 HTTP 方法和路径映射到服务的 HTTP URL，这一点和 Nginx 提供的反向代理的功能是一样的，后面我们也会对其进行一个比较。</p><p>既然有路由映射，那存放在哪就是一个问题了，我们需要为 API 网关设置一个路由映射的存储位置，通过可能会用 zookeeper 等作为注册中心来使用，文末我们也会提一下弊端。</p><h4 id="API-组合"><a href="#API-组合" class="headerlink" title="API 组合"></a>API 组合</h4><p>除去反向代理这个功能外，API 网关还提供了 API 组合的操作。以上面的淘宝详情页为例，如果我们单独获取视频、商品价格、商品评论等信息，需要发多个请求（getVideo,getPrice,getComments）。有了 API 网关后我们就可以将 API 接口组合起来，通过一次请求（getItemDetail）来获取需要的信息，如下图所示，这样可以极大的改善由于网络延时导致的差用户体验。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbpr6eqaj30u017cn2c.jpg"></p><h4 id="协议转换"><a href="#协议转换" class="headerlink" title="协议转换"></a>协议转换</h4><p>API 网关可以为外部客户端提供 RESTful API，即使内部的服务使用混合的通信协议，例如 REST、gRPC 等。这样做的好处是，对于外部客户端而言，服务端更像是一个不可见的黑盒。</p><h2 id="API-网关和-Nginx"><a href="#API-网关和-Nginx" class="headerlink" title="API 网关和 Nginx"></a>API 网关和 Nginx</h2><p>本质上看 API 网关也是做了请求的转发，那既然 Nginx 也可以做请求转发，这两者有什么区别？</p><p>一张图就可以很好的理解了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbq2n3wij30mj0cd41p.jpg"></p><p>Nginx 做负载均衡时，考虑到 API 网关在系统中不止一个（以集群的方式做高可用），我们可以将 Nginx 至于 API 网关前，负责对 API 网关的负载均衡，然后再由网关决定进入到哪个真实的 web 服务器。<br>这样就可以让两者的分工更加明确：<strong>API 网关聚合服务，Nginx 请求转发</strong></p><h2 id="API-网关的优缺点"><a href="#API-网关的优缺点" class="headerlink" title="API 网关的优缺点"></a>API 网关的优缺点</h2><p>API 网关封装了应用程序的内部结构，使得客户端只需要同网关交互，而不必调用特定的服务。同时 API 网关为每一类客户端提供了特定的 API ，从而减少客户端与应用程序间的交互次数，简化客户端代码的处理。</p><p>但就和所有中间件一样，他们都存在一个共同的问题，API 网关的存在使系统增加了一个<strong>必须开发、部署和维护的高可用组件</strong>。如果这个组件没有处理好，那么 API 网关就会变成了应用的性能瓶颈。</p><p>而且为了暴露每个微服务，开发人员必须更新 API 网关，所以就有可能会搭配其他服务发现类的中间件使用，例如 zookeeper，这样就又引入了新的中间件。所以我们需要保证 API 网关的更新过程要尽可能地简单，否则为了更新网关，开发人员将不得不排队等待。</p><p>由此可见，API 网关也并不是一颗”银弹”，我们在中间件的选择上还是需要结合项目的实际情况，万不可追求新颖就滥用中间件，适合自己的才是最好的。不过，API 网关虽然仍有不足，但对于大多数现实世界的应用程序而言使用 API 网关是合理的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本文的全部内容了，如果你觉得本文对你有所帮助，不妨点个赞关注一下，你们的支持是我原创的最大动力！</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbridueuj30go0go40v.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做小偷也要会动态规划——轻松解决&quot;01背包问题&quot;</title>
      <link href="p/f370.html"/>
      <url>p/f370.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小偷不可怕，就怕小偷有文化，更怕小偷学过动态规划。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>白玉汤曾是江湖上赫赫有名的盗圣，奈何岁月不饶人，上了年纪后腿脚便不利索了，无奈一身的本领却没有个传承之人。这天，一位少年前来拜师学艺，希望白玉汤能在偷盗一事上指点一二。白玉汤见这少年骨骼清奇，内心有收其为徒的想法，便出了下面这道题考考少年：</p><blockquote><p>话说地主金馆长家有个专门藏金银财宝的房间，潜入后发现可偷之物太多，奈何自身负重能力有限，你的包只能承重 20kg 的物品，而且每个物品的价值又都不一样，那么问题来了，将哪些物品装入背包才能不虚此行，使价值总和最大呢？物品重量和其价值的关系如下：</p></blockquote><table><thead><tr><th>编号</th><th>重量（w）</th><th>价值（v）</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td></tr><tr><td>4</td><td>5</td><td>8</td></tr><tr><td>5</td><td>9</td><td>10</td></tr></tbody></table><p>少年一看，这不就是一道“01 背包问题吗”，说完便在地上做出了如下分析：</p><p>设我们的背包里面的物品价值为 b，给背包添加两个参数：k 和 c，即 b(k,c),那么 b(k,c)又表示什么什么意思呢？</p><blockquote><p>k 表示你面对的物品编号，即 1~5,<br>c 表示你面对 k 号物品时，背包的剩余容量<br>b(k,c)表示面对 k 号物品，并作出拿或不拿的选择之后，背包里面的物品总价值</p></blockquote><p>举个例子，b(2,20)表示的是，在你的背包容量为 20 的情况下，当你面对 2 号物品时并作出拿或者不拿的选择后，背包中物品的总价值。</p><p>了解了这个概念后我们继续：<br>假设你现在遇见了第 k 号物品，此时你的背包容量为 c，你得做出一个决策，到底要不要拿走第 k 件物品呢？那么拿不拿的前提是啥？当然是这个物品重不重，能不能塞到包里。所以第一种情况就出现了：</p><ol><li>如果第 k 件物品的重量 w[k]比此时的背包的剩余重量 c 大了，那我肯定是拿不动了，即<code>w[k]&gt;c</code>。所以此时包中物品的价值就是我拿的前一个物品之后包中的价值，即 <code>b(k,c)=b(k-1,c).</code>包中剩余空间不变，还是 c。</li></ol><p>那么第二种情况，如果我拿得动第 k 件物品，即第 k 件物品的重量<code>w[k]&lt;c</code>，面对 k 号物品，无外乎两种选择，拿或者不拿，这时我就要根据拿走之后产生的效益进行决策了：</p><ol><li>不拿 k 号物品，那么此时包中物品的总价值<code>b(k,c)=b(k-1,c)</code>，和第一种拿不动 k 号物品的一样。</li><li>拿走 k 号物品，那么此时包中物品的总价值<code>b(k,c)=b(k-1,c-w[k])+v[k]</code>拿了第 k 件物品后，那我的包中的价值肯定就是原先的价值再加上第 k 件物品的价值，而且拿了之后包中的剩余容量就为<code>c-w[k]</code>了。 总结一下，就是如下的公式了：<code>b(k,c)=max&#123;b(k-1,c),b(k-1,c-w[k])+v[k]&#125;</code></li></ol><p>剩下的只需要比较小这两种方式谁的效益大即可。思维导图如下：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-75fdbf8a205171f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01背包问题的递推公式"></p><p>看懂以上描述后，编码就很简单了，这里我用 Java 写出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] w &#x3D; &#123; 0, 2, 3, 4, 5, 9 &#125;;</span><br><span class="line">        int[] v &#x3D; &#123; 0, 3, 4, 5, 8, 10 &#125;;</span><br><span class="line">        int N &#x3D; 6, W &#x3D; 21;</span><br><span class="line">        int[][] b &#x3D; new int[N][W];</span><br><span class="line">        for (int k &#x3D; 1; k &lt; N; k++) &#123;</span><br><span class="line">            for (int c &#x3D; 1; c &lt; W; c++) &#123;</span><br><span class="line">                if (w[k] &gt; c) &#123;</span><br><span class="line">                    b[k][c] &#x3D; b[k - 1][c];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int value1 &#x3D; b[k - 1][c - w[k]] + v[k]; &#x2F;&#x2F; 拿第k件物品</span><br><span class="line">                    int value2 &#x3D; b[k - 1][c]; &#x2F;&#x2F; 不拿第k件物品</span><br><span class="line">                    b[k][c] &#x3D; Math.max(value1, value2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b[5][20]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为 26</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实公众号之前有发过一篇类似的“01 背包问题”的解析——<a href="https://mp.weixin.qq.com/s/Ls4NzJadJUrvFKrLSX6wjA">《使用动态规划解决童年难题》</a>，网上大多数的博客在解析“01 背包问题”时也都是采用画图的形式，类似于这样的：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-c23feabd25d280f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01背包问题的图解"><br>但是我当时看的时候真的是一脸懵逼，然后再带着图去看长篇的解析就更混乱了。希望你能在理解了上述流程之后，再回过头去看公众号之前的文章，对那个图的理解应该就会更加深刻了，二者一起看，辅助理解。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ol><li>推荐一个良心视频，讲解的也很详细——<a href="http://video.tudou.com/v/XMTQ3MzI0NzI2OA==.html?spm=a2hzp.8253869.0.0">01 背包问题</a></li><li>推荐一个在线查看解决“01 背包问题”的网站，详细的描述了变化过程<a href="http://karaffeltut.com/NEWKaraffeltutCom/Knapsack/knapsack.html">Online 0/1 Knapsack problem solver</a><br><img src="https://upload-images.jianshu.io/upload_images/5666077-c4871f0e4a5b0ba7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li></ol><p>如果你觉得本文还不错，麻烦随手点赞与转发吧。😋（扑通</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-8f4e862993c9c180?imageMogr2/auto-orient/strip"></p><p>点赞与转发是最好的支持</p>]]></content>
      
      
      <categories>
          
          <category> 技术科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>趣玩Python——如何帮女朋友快速抢票</title>
      <link href="p/1f44.html"/>
      <url>p/1f44.html</url>
      
        <content type="html"><![CDATA[<p>又到了半年一度的考试季，对于那些翻山越岭外出求学的莘莘学子们，相比于各显神通的考试，更紧张的莫过于买一张回家的车票，相信很多群最近都被下面这样的图占领了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbgsup3tj306o0833yl.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbgrfhdkj306o07qt8p.jpg"></p><p>如今，随着 12306 的抗压能力越来越强，各种第三方抢票软件也是层出不穷，什么智行火车,携程旅游，就连官方都推出的了加速服务，这就导致了大量黄牛都开始感叹：这年头的生意不好做咯！</p><p>而且现在各家的抢票方式都是八仙过海，各显神通，这家让你消费买加速包，那家让你疯狂推销，以至于才出现了上述加速小程序的疯狂炸群（微信小程序恐成最大赢家）。</p><p>作为一个苦逼的学生党，花钱买加速包不大可能，毕竟买加速包的钱都快赶上半张火车票了；让我疯狂用小程序炸群也不大可能，毕竟关系到自己的社交信誉，而且现如今的群成员各个都是大爷，不发红包不点加速。</p><p>那么难道就没有一种 geek 风的抢票软件吗？</p><a id="more"></a><h2 id="12306-购票小助手"><a href="#12306-购票小助手" class="headerlink" title="12306 购票小助手"></a>12306 购票小助手</h2><p>想找各种骚操作的软件，第一想法自然是去最大的同性交友网站啊，无意中发现了一个名为 12306 购票小助手的项目，试了下竟然真的抢到了票，项目已经开源，地址 👉<a href="https://github.com/testerSunshine/12306">https://github.com/testerSunshine/12306</a></p><h3 id="思路图"><a href="#思路图" class="headerlink" title="思路图"></a>思路图</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbh7duetj30nn0ixwfc.jpg" alt="思路图"></p><p>作者也很用心的把程序的思路给画了出来，我们可以简单的看一下。整个思路其实就是模拟一个正常人购票的方式，首先查询下车票剩余的票数，如果有座位提交订单，出现验证码这识别验证码，随后就循环点击提交按钮，这里作者就做了很多的条件判断，比如出现异常则重新查询，提交订单失败也重新查询，直至获取订单成功。订票成功之后还有一个通知机制，即发送到你的邮箱里。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>说了这么多，应该如何使用呢？详细的可以参考作者的 README，这里我用最简单的方式讲述下需要注意的地方以及如何使用用这个购票小助手抢到票：</p><p><strong>注意事项</strong></p><ol><li>python 版本为<strong>2.7.10-2.7.15</strong></li><li>推荐使用 MacOS/Linux</li><li>使用时一定要以 root 用户运行</li></ol><p><strong>准备工作</strong></p><ol><li>注册若快图像识别<a href="http://www.ruokuai.com/client/index?6726">http://www.ruokuai.com/client/index?6726</a>，记住用户名和密码，然后充值 1 块钱兑换 2500 快豆即可，该步骤是为识别验证码做准备。</li><li>下载项目：执行<code>git clone https://github.com/testerSunshine/12306.git</code>将代码下载至本地。</li><li>安装 Python2.7：此处推荐使用 pyenv 管理你的 python 版本，Mac 用户可以参考<a href="https://juejin.im/post/5c389b4b6fb9a049e2323a8a">《mac 下利用 pyenv 管理多个版本的 python》</a>安装制定版本的 python 版本，这里我使用的是 python 2.7.15</li><li>安装依赖库：命令行进入项目根目录后，执行<code>sudo python2 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt</code></li></ol><p><strong>项目配置</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbhqzcqpj30d80de0tc.jpg" alt="配置文件"></p><p>上图中的**<code>ticket_config.yaml</code>**是运行整个项目最重要的配置文件，所有的购票信息都在该文件中，比如车票时间，12306 账号密码，乘车人信息，通知邮箱等等，文件中都有详细的注释，根据要求进行更改即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbhq3sdtj30f00j6my6.jpg"></p><p>把这个配置文件按你的需求填写完毕之后，就可以开始运行了。</p><p><strong>开始抢票</strong></p><p>命令行进入项目根目录后，执行<code>sudo python run.py</code>即可开始抢票了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbhw7kibj30vo0kan37.jpg"></p><p>如果抢到票了，就会输出类似下面的 log：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">车次: DXXX 始发车站: 南京南 终点站: 合肥南 二等座: 16</span><br><span class="line">设置乘车人数为: 1</span><br><span class="line">查询到有余票，尝试提交订单</span><br><span class="line">车票提交通过，正在尝试排队</span><br><span class="line">排队成功, 你排在: 0位, 当前余票还剩余: 16 张</span><br><span class="line">不需要验证码</span><br><span class="line">提交订单成功！</span><br><span class="line">排队等待时间预计还剩 -4 ms</span><br><span class="line">恭喜您订票成功，订单号为：XXXXXX, 请立即打开浏览器登录12306，访问‘未完成订单’，在30分钟内完成支付！</span><br></pre></td></tr></table></figure><p>然后再登录 12306 的官方网站，访问‘未完成订单’即可看到你的购票信息了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibbi28j7tj30yg08y74n.jpg">最后祝愿大家都能抢到回家的票！</p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>趣玩Python——利用python摇身一变社会人</title>
      <link href="p/33d6.html"/>
      <url>p/33d6.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpyhj85psj31400u0qv5.jpg"></p><blockquote><p>本篇文章的代码是我很久之前无意发现的，当时就觉得非常有趣，正直昨天在朋友圈被佩奇的视频刷屏，因而想着今天来蹭波热度，不喜勿喷啊😊</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信大家的朋友圈昨天都被类似下面这样的文章刷屏了：</p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzbwrrw0l7j30m80gotc6.jpg" style="zoom:50%"/><p>是的，在经历了几个月的沉寂之后，社会人“小猪佩奇”又以下面的方式重新回到了大众的视野中了！</p><a id="more"></a><iframe frameborder="0" style="height:500px;width=100%;" src="https://v.qq.com/txp/iframe/player.html?vid=m0828x153iv" allowFullScreen="true"></iframe><p>不知道大家看完这个视频是什么感觉，反正我看完就觉得，到底是中美合拍，这预告片是真的走心啊！所以今天我们就来用python来给视频中的爷爷解释一下“什么是佩奇啊？”👇</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzbxurpeb4g30na0e04qp.gif"></p><h2 id="先来认识一个“海龟”——turtle"><a href="#先来认识一个“海龟”——turtle" class="headerlink" title="先来认识一个“海龟”——turtle"></a>先来认识一个“海龟”——turtle</h2><p>在我们开始画一个小猪佩奇之前，先来认识一个“海龟”，说是海龟，并不是因为中美合作，而是因为他是python中的一个图像绘制库——<strong>“turtle”</strong>。这是他的官方地址：👉<a href="https://docs.python.org/3.3/library/turtle.html?highlight=turtle"><strong>turtle</strong></a></p><blockquote><p>Turtle graphics is a popular way for introducing programming to kids. It was part of the original Logo programming language developed by Wally Feurzig and Seymour Papert in 1966.</p></blockquote><p>是的，这是一个给小孩子的绘图库，那为什么要叫他“turtle”呢？把你的画笔想象成一支小乌龟，在一个横轴为x、纵轴为y的坐标系原点，(0,0)位置开始，它根据一组函数指令的控制，在这个平面坐标系中移动，从而在它爬行的路径上绘制了图形。</p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzbyyre4r8j30zk0jzaek.jpg" style="zoom:40%"/><h3 id="安装turtle"><a href="#安装turtle" class="headerlink" title="安装turtle"></a>安装turtle</h3><p>Python2安装命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install turtulem</span><br></pre></td></tr></table></figure><p>Python3安装命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install turtle</span><br></pre></td></tr></table></figure><p>因为turtle库主要是在Python2中使用的，所以安装的时候可能会提示错误：</p><blockquote><p>Collecting turtle</p><p>  Downloading <a href="http://mirrors.aliyun.com/pypi/packages/ff/f0/21a42e9e424d24bdd0e509d5ed3c7dfb8f47d962d9c044dba903b0b4a26f/turtle-0.0.2.tar.gz">http://mirrors.aliyun.com/pypi/packages/ff/f0/21a42e9e424d24bdd0e509d5ed3c7dfb8f47d962d9c044dba903b0b4a26f/turtle-0.0.2.tar.gz</a></p><p>​    Complete output from command python setup.py egg_info:</p><p>​    Traceback (most recent call last):</p><p>​      File “<string>“, line 1, in <module></p><p>​      File “/private/var/folders/nf/y2318q0x2dg78hz_nnrh3f5c0000gn/T/pip-install-fhotaoh2/turtle/setup.py”, line 40</p><p>​        except ValueError, ve:</p><p>​                         ^</p><p>​    SyntaxError: invalid syntax</p><p>​    </p><p>​    -—————————————</p><p>Command “python setup.py egg_info” failed with error code 1 in /private/var/folders/nf/y2318q0x2dg78hz_nnrh3f5c0000gn/T/pip-install-fhotaoh2/turtle/</p></blockquote><p>仔细查看安装<code>turtle</code>出错的错误信息，可以看到是个<strong>语法错误</strong>。</p><p><code>pip</code>在下载<code>turtle 0.0.2</code>包后，会解压到本地再安装，提示的错误在解压的<code>setup.py</code>文件里面，</p><p>解决的办法就是：<strong>把turtle包<a href="https://files.pythonhosted.org/packages/ff/f0/21a42e9e424d24bdd0e509d5ed3c7dfb8f47d962d9c044dba903b0b4a26f/turtle-0.0.2.tar.gz">下载</a>到本地，手动解压，修改setup.py文件再安装。</strong></p><ul><li>打开<code>setup.py</code>文件，第40行修改为</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">except (ValueError, ve):</span><br></pre></td></tr></table></figure><p>原来的是Python2的写法，没有括号，加了括号之后Python3就能用了。</p><ul><li>用pip3安装：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install -e turtle-0.0.2</span><br></pre></td></tr></table></figure><p><code>-e</code>后面接上我们修改过<code>setup.py</code>文件的目录。</p><ul><li>安装完成</li></ul><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>在学习用turtle画画之前，我们先来了解些基本概念。下部分内容非常枯燥，如果想直接要代码的建议跳过这部分内容直接去最后的代码实现部分。</p><h4 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h4><p>画布就是turtle为我们展开用于绘图区域, 我们可以设置它的大小和初始位置。常用的画布方法有两个：<code>screensize()</code>和<code>setup()</code>。</p><p><strong>1. turtle.screensize(canvwidth=None, canvheight=None, bg=None)</strong></p><p>参数分别为画布的宽(单位像素), 高, 背景颜色</p><p>如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">turtle.screensize(800, 600, &quot;green&quot;)</span><br><span class="line">turtle.screensize() #返回默认大小(400, 300)</span><br></pre></td></tr></table></figure><p><strong>2. turtle.setup(width=0.5, height=0.75, startx=None, starty=None)</strong></p><p>参数:</p><ul><li><code>width, height</code>：输入宽和高为整数时, 表示像素; 为小数时, 表示占据电脑屏幕的比例</li><li><code>(startx, starty)</code>：这一坐标表示 矩形窗口左上角顶点的位置, 如果为空,则窗口位于屏幕中心</li></ul><p>如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">turtle.setup(width&#x3D;0.6, height&#x3D;0.6)</span><br><span class="line">turtle.setup(width&#x3D;800, height&#x3D;800, startx&#x3D;100, starty&#x3D;100)</span><br></pre></td></tr></table></figure><h4 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h4><p>在画布上，默认有一个坐标原点为画布中心的坐标轴, 坐标原点上有一只面朝x轴正方向小乌龟。</p><p>这里我们描述小乌龟时使用了两个词语：标原点(位置)，面朝x轴正方向(方向)，turtle绘图中, 就是使用位置方向描述小乌龟(画笔)的状态</p><p><strong>1. 画笔的属性</strong></p><p>画笔有颜色、画线的宽度等属性。</p><ul><li><p><code>turtle.pensize()</code> ：设置画笔的宽度；</p></li><li><p><code>turtle.pencolor() </code>：没有参数传入返回当前画笔颜色；传入参数设置画笔颜色,可以是字符串如”green”, “red”,也可以是RGB 3元组。</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pencolor(&#39;brown&#39;)</span><br><span class="line">&gt;&gt;&gt; tup &#x3D; (0.2, 0.8, 0.55)</span><br><span class="line">&gt;&gt;&gt; pencolor(tup)</span><br><span class="line">&gt;&gt;&gt; pencolor()</span><br><span class="line">&#39;#33cc8c&#39;</span><br></pre></td></tr></table></figure><ul><li><code>turtle.speed(speed) </code>：设置画笔移动速度,画笔绘制的速度范围[0,10]整数, 数字越大越快</li></ul><p><strong>2. 绘图命令</strong></p><p>操纵海龟绘图有着许多的命令，这些命令可以划分为3种：运动命令，画笔控制命令和全局控制命令</p><p><strong>画笔运动命令</strong></p><table><thead><tr><th>代码</th><th>功能</th></tr></thead><tbody><tr><td>turtle.forward(distance)</td><td>向当前画笔方向移动distance像素长</td></tr><tr><td>turtle.backward(distance)</td><td>向当前画笔相反方向移动distance像素长度</td></tr><tr><td>turtle.right(degree)</td><td>顺时针移动degree°</td></tr><tr><td>turtle.left(degree)</td><td>逆时针移动degree°</td></tr><tr><td>turtle.pendown()</td><td>移动时绘制图形,缺省时也为绘制</td></tr><tr><td>turtle.goto(x,y)</td><td>将画笔移动到坐标为x,y的位置</td></tr><tr><td>turtle.penup()</td><td>移动时不绘制图形,提起笔，用于另起一个地方绘制时用</td></tr><tr><td>turtle.speed(speed)</td><td>画笔绘制的速度范围[0,10]整数</td></tr><tr><td>turtle.circle()</td><td>画圆,半径为正(负),表示圆心在画笔的左边(右边)画圆</td></tr></tbody></table><p> <strong>画笔控制命令</strong></p><table><thead><tr><th>代码</th><th>功能</th></tr></thead><tbody><tr><td>turtle.pensize(width)</td><td>绘制图形时的宽度</td></tr><tr><td>turtle.pencolor()</td><td>画笔颜色</td></tr><tr><td>turtle.fillcolor(colorstring)</td><td>绘制图形的填充颜色</td></tr><tr><td>turtle.color(color1, color2)</td><td>同时设置pencolor=color1, fillcolor=color2</td></tr><tr><td>turtle.filling()</td><td>返回当前是否在填充状态</td></tr><tr><td>turtle.begin_fill()</td><td>准备开始填充图形</td></tr><tr><td>turtle.end_fill()</td><td>填充完成</td></tr><tr><td>turtle.hideturtle()</td><td>隐藏箭头显示</td></tr><tr><td>turtle.showturtle()</td><td>与hideturtle()函数对应</td></tr></tbody></table><p> <strong>全局控制命令</strong></p><table><thead><tr><th>代码</th><th>功能</th></tr></thead><tbody><tr><td>turtle.clear()</td><td>清空turtle窗口，但是turtle的位置和状态不会改变</td></tr><tr><td>turtle.reset()</td><td>清空窗口，重置turtle状态为起始状态</td></tr><tr><td>turtle.undo()</td><td>撤销上一个turtle动作</td></tr><tr><td>turtle.isvisible()</td><td>返回当前turtle是否可见</td></tr><tr><td>stamp()</td><td>复制当前图形</td></tr><tr><td>turtle.write(s[,font=(“font-name”,font_size,”font_type”)])</td><td>写文本，s为文本内容，font是字体的参数，里面分别为字体名称，大小和类型；font为可选项, font的参数也是可选项</td></tr></tbody></table><p> <strong>其他控制命令</strong></p><table><thead><tr><th>代码</th><th>功能</th></tr></thead><tbody><tr><td>turtle.mainloop()或turtle.done()</td><td>启动事件循环 -调用Tkinter的mainloop函数。必须是turtle图形程序中的最后一个语句。</td></tr><tr><td>turtle.mode(mode=None)</td><td>设置turtle模式（“standard”，“logo”或“world”）并执行重置。如果没有给出模式，则返回当前模式。</td></tr><tr><td>turtle.delay(delay=None)</td><td>设置或返回以毫秒为单位的绘图延迟。</td></tr><tr><td>turtle.begin_poly()</td><td>开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。</td></tr><tr><td>turtle.end_poly()</td><td>停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。</td></tr><tr><td>turtle.get_poly()</td><td>返回最后记录的多边形。</td></tr></tbody></table><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在见识过上面中美合拍的感人预告片之后，怎么能不写代码开花呢？现在让我们耐下心来，一步步来看看这文体两开花的代码（含注释）。</p><p><strong>1. 导包</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import turtle as t</span><br></pre></td></tr></table></figure><p><strong>2. 画面的基本设置</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t.pensize(4)  # 设置画笔的大小</span><br><span class="line">t.colormode(255)  # 设置GBK颜色范围为0-255</span><br><span class="line">t.color((255, 155, 192), &quot;pink&quot;)  # 设置画笔颜色和填充颜色(pink)</span><br><span class="line">t.setup(840, 500)  # 设置主窗口的大小为840*500</span><br><span class="line">t.speed(10)  # 设置画笔速度为10</span><br></pre></td></tr></table></figure><p><strong>3. 画鼻子</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 鼻子</span><br><span class="line">t.pu()  # 提笔</span><br><span class="line">t.goto(-100, 100)  # 画笔前往坐标(-100,100)</span><br><span class="line">t.pd()  # 下笔</span><br><span class="line">t.seth(-30)  # 笔的角度为-30°</span><br><span class="line">t.begin_fill()  # 外形填充的开始标志</span><br><span class="line">a &#x3D; 0.4</span><br><span class="line">for i in range(120):</span><br><span class="line">    if 0 &lt;&#x3D; i &lt; 30 or 60 &lt;&#x3D; i &lt; 90:</span><br><span class="line">        a &#x3D; a+0.08</span><br><span class="line">        t.lt(3)  # 向左转3度</span><br><span class="line">        t.fd(a)  # 向前走a的步长</span><br><span class="line">    else:</span><br><span class="line">        a &#x3D; a-0.08</span><br><span class="line">        t.lt(3)</span><br><span class="line">        t.fd(a)</span><br><span class="line">t.end_fill()  # 依据轮廓填充</span><br><span class="line">t.pu()  # 提笔</span><br><span class="line">t.seth(90)  # 笔的角度为90度</span><br><span class="line">t.fd(25)  # 向前移动25</span><br><span class="line">t.seth(0)  # 转换画笔的角度为0</span><br><span class="line">t.fd(10)</span><br><span class="line">t.pd()</span><br><span class="line">t.pencolor(255, 155, 192)  # 设置画笔颜色</span><br><span class="line">t.seth(10)</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(5)  # 画一个半径为5的圆</span><br><span class="line">t.color(160, 82, 45)  # 设置画笔和填充颜色</span><br><span class="line">t.end_fill()</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(20)</span><br><span class="line">t.pd()</span><br><span class="line">t.pencolor(255, 155, 192)</span><br><span class="line">t.seth(10)</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(5)</span><br><span class="line">t.color(160, 82, 45)</span><br><span class="line">t.end_fill()</span><br></pre></td></tr></table></figure><p><strong>4. 画头</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 头</span></span><br><span class="line">t.color((<span class="number">255</span>, <span class="number">155</span>, <span class="number">192</span>), <span class="string">&quot;pink&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">41</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">0</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(<span class="number">180</span>)</span><br><span class="line">t.circle(<span class="number">300</span>, <span class="number">-30</span>)  <span class="comment"># 顺时针画一个半径为300,圆心角为30°的园</span></span><br><span class="line">t.circle(<span class="number">100</span>, <span class="number">-60</span>)</span><br><span class="line">t.circle(<span class="number">80</span>, <span class="number">-100</span>)</span><br><span class="line">t.circle(<span class="number">150</span>, <span class="number">-20</span>)</span><br><span class="line">t.circle(<span class="number">60</span>, <span class="number">-95</span>)</span><br><span class="line">t.seth(<span class="number">161</span>)</span><br><span class="line">t.circle(<span class="number">-300</span>, <span class="number">15</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.goto(<span class="number">-100</span>, <span class="number">100</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(<span class="number">-30</span>)</span><br><span class="line">a = <span class="number">0.4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; <span class="number">30</span> <span class="keyword">or</span> <span class="number">60</span> &lt;= i &lt; <span class="number">90</span>:</span><br><span class="line">        a = a+<span class="number">0.08</span></span><br><span class="line">        t.lt(<span class="number">3</span>)  <span class="comment"># 向左转3度</span></span><br><span class="line">        t.fd(a)  <span class="comment"># 向前走a的步长</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a = a<span class="number">-0.08</span></span><br><span class="line">        t.lt(<span class="number">3</span>)</span><br><span class="line">        t.fd(a)</span><br><span class="line">t.end_fill()</span><br></pre></td></tr></table></figure><p><strong>5. 画耳朵</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 耳朵</span></span><br><span class="line">t.color((<span class="number">255</span>, <span class="number">155</span>, <span class="number">192</span>), <span class="string">&quot;pink&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">-7</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">70</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(<span class="number">100</span>)</span><br><span class="line">t.circle(<span class="number">-50</span>, <span class="number">50</span>)</span><br><span class="line">t.circle(<span class="number">-10</span>, <span class="number">120</span>)</span><br><span class="line">t.circle(<span class="number">-50</span>, <span class="number">54</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">-12</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">30</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(<span class="number">100</span>)</span><br><span class="line">t.circle(<span class="number">-50</span>, <span class="number">50</span>)</span><br><span class="line">t.circle(<span class="number">-10</span>, <span class="number">120</span>)</span><br><span class="line">t.circle(<span class="number">-50</span>, <span class="number">56</span>)</span><br><span class="line">t.end_fill()</span><br></pre></td></tr></table></figure><p><strong>6. 画眼睛</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 眼睛</span></span><br><span class="line">t.color((<span class="number">255</span>, <span class="number">155</span>, <span class="number">192</span>), <span class="string">&quot;white&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">-20</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">-95</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">15</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.color(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">12</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">-3</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">3</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.color((<span class="number">255</span>, <span class="number">155</span>, <span class="number">192</span>), <span class="string">&quot;white&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">-25</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">40</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">15</span>)</span><br><span class="line">t.end_fill()</span><br><span class="line">t.color(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">12</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">-3</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">3</span>)</span><br><span class="line">t.end_fill()</span><br></pre></td></tr></table></figure><p><strong>7. 画腮</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 腮</span></span><br><span class="line">t.color((<span class="number">255</span>, <span class="number">155</span>, <span class="number">192</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">-95</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">65</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.circle(<span class="number">30</span>)</span><br><span class="line">t.end_fill()</span><br></pre></td></tr></table></figure><p><strong>8. 画嘴</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 嘴</span><br><span class="line">t.color(239, 69, 19)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(15)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(-100)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-80)</span><br><span class="line">t.circle(30, 40)</span><br><span class="line">t.circle(40, 80)</span><br></pre></td></tr></table></figure><p><strong>9. 画身体</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 身体</span><br><span class="line">t.color(&quot;red&quot;, (255, 99, 71))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(-20)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(-78)</span><br><span class="line">t.pd()</span><br><span class="line">t.begin_fill()</span><br><span class="line">t.seth(-130)</span><br><span class="line">t.circle(100, 10)</span><br><span class="line">t.circle(300, 30)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(230)</span><br><span class="line">t.seth(90)</span><br><span class="line">t.circle(300, 30)</span><br><span class="line">t.circle(100, 3)</span><br><span class="line">t.color((255, 155, 192), (255, 100, 100))</span><br><span class="line">t.seth(-135)</span><br><span class="line">t.circle(-80, 63)</span><br><span class="line">t.circle(-150, 24)</span><br><span class="line">t.end_fill()</span><br></pre></td></tr></table></figure><p><strong>10. 画手</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 手</span><br><span class="line">t.color((255, 155, 192))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(-40)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(-27)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-160)</span><br><span class="line">t.circle(300, 15)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(15)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(0)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-10)</span><br><span class="line">t.circle(-20, 90)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(30)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(237)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-20)</span><br><span class="line">t.circle(-300, 15)</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(20)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(0)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-170)</span><br><span class="line">t.circle(20, 90)</span><br></pre></td></tr></table></figure><p><strong>11. 画脚</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 脚</span><br><span class="line">t.pensize(10)</span><br><span class="line">t.color((240, 128, 128))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(-75)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(-180)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-90)</span><br><span class="line">t.fd(40)</span><br><span class="line">t.seth(-180)</span><br><span class="line">t.color(&quot;black&quot;)</span><br><span class="line">t.pensize(15)</span><br><span class="line">t.fd(20)</span><br><span class="line">t.pensize(10)</span><br><span class="line">t.color((240, 128, 128))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(90)</span><br><span class="line">t.fd(40)</span><br><span class="line">t.seth(0)</span><br><span class="line">t.fd(90)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(-90)</span><br><span class="line">t.fd(40)</span><br><span class="line">t.seth(-180)</span><br><span class="line">t.color(&quot;black&quot;)</span><br><span class="line">t.pensize(15)</span><br><span class="line">t.fd(20)</span><br></pre></td></tr></table></figure><p><strong>12. 画尾巴</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尾巴</span></span><br><span class="line">t.pensize(<span class="number">4</span>)</span><br><span class="line">t.color((<span class="number">255</span>, <span class="number">155</span>, <span class="number">192</span>))</span><br><span class="line">t.pu()</span><br><span class="line">t.seth(<span class="number">90</span>)</span><br><span class="line">t.fd(<span class="number">70</span>)</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.fd(<span class="number">95</span>)</span><br><span class="line">t.pd()</span><br><span class="line">t.seth(<span class="number">0</span>)</span><br><span class="line">t.circle(<span class="number">70</span>, <span class="number">20</span>)</span><br><span class="line">t.circle(<span class="number">10</span>, <span class="number">330</span>)</span><br><span class="line">t.circle(<span class="number">70</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>总共12步，教你轻松实现一个社会猪。其实思路很简单，就是通过trutle模块实现圆形，椭圆形，曲线然后填充即可，难点在于细心！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“小猪佩奇身上纹，掌声送给社会人！”，是不是很简单？然而</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzc39rnskvg306o06omx1.gif"></p><p><strong>本文参考：</strong></p><ul><li><p><a href="">Python绘图Turtle库详解</a>(<a href="https://blog.csdn.net/zengxiantao1994/article/details/76588580">https://blog.csdn.net/zengxiantao1994/article/details/76588580</a>)</p></li><li><p><a href="https://segmentfault.com/a/1190000015746187">Python3 turtle教程</a></p></li><li><p><a href="https://oomake.com/question/178949">Python3安装turtle提示错误</a></p></li><li><p><a href="https://blog.csdn.net/zhaogeno1/article/details/80298669">用Python画小猪佩奇</a></p></li></ul><p>好了，可以鼓掌了👏</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzc3e4s9wdg307p0671b2.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次服务器被黑后的经历</title>
      <link href="p/23f6.html"/>
      <url>p/23f6.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/6/10/16b3f6942908557f"></p><blockquote><p>该图片由<a href="https://pixabay.com/zh/users/iAmMrRob-5387828/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2903156">Robinraj Premchand</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2903156">Pixabay</a>上发布</p></blockquote><p>我的小程序是在5月26号的时候上线的，运行了还没几天，5月30号的时候就有一个学弟告诉我说小程序用不了了，晚上回家打开电脑查看数据库的时候才发觉大事不好！</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/10/16b3f6772365acfc?w=392&h=396&f=jpeg&s=26510" alt="WX20190605-210513@2x"></p><p>我的ytools数据库下的数据表去哪了，怎么就剩下一个WARING了？？？？</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/10/16b3f67723bd26b4?w=500&h=313&f=jpeg&s=14032" alt="u=3304691937,3517639434&amp;fm=26&amp;gp=0"></p><p>吓得我赶紧百度了一下</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/10/16b3f67733555947?w=1083&h=1080&f=jpeg&s=290763"></p><p>我擦，这是被攻击了吗？为什么腾讯云都没有给我安全警报啊？？？</p><p>不过有没有安全警报都是次要的，最主要的事情还是要弄清楚原因是啥，然后想办法补救和预防，仅以这篇文章记录下自己被攻击后的经历。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>查了一些资料发现，其实被删库的事件屡见不鲜，2016年-2017年间，就曾出现过大量MySQL数据库被攻击，黑客留下QQ号，并索要高额恢复费的事情，哪怕是现在这种事情也经常发生。其实总的来说还是因为我们在服务器安全防范方面，意识相当不够，侥幸心理严重（就像到现在我也不懂我这个小屁民啥事也没做为啥还要搞我一样）。以下两种情况的MySQL最容易被攻击。</p><h3 id="服务器密码过于简单的"><a href="#服务器密码过于简单的" class="headerlink" title="服务器密码过于简单的"></a>服务器密码过于简单的</h3><p>很多人图省事，将服务器密码设置简单，方便记忆与登录，这往往给黑客留下破解空间。一旦服务器密码被破解，那黑客将可以直接登录到服务器，肆意修改数据、删除数据。针对这项，在设置密码时，建议：使用字母、数字、字符组合的密码，尽量在8位10位以上。不定期更换密码。</p><h3 id="网站程序直接使用root权限"><a href="#网站程序直接使用root权限" class="headerlink" title="网站程序直接使用root权限"></a>网站程序直接使用root权限</h3><p>很多新手在使用数据库时，没有进行权限设置（或者纯粹就是图省事，项目跑起来就行了），网站程序直接连接root权限，一旦网站程序被破解，root账号密码也将被hei客获取。MySQL涉及权限的表一共5个，最重要的权限表：user、db。user表里除了root localhost有所有权限外，其他 xxxx %一概没有权限。需要开通权限要在db表里。</p><p>总之千万不要用root以及管理员权限去运行！同时将权限限制到最小！</p><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><p>下面是我查阅资料找到的一些常规的安全防范措施：</p><ol><li>服务器的管理员密码具备一定复杂度，建议使用字母、数字、字符组合的密码。</li><li>服务器关闭远程访问（或关闭外网的远程访问），调整远程访问默认的端口号。</li><li>MySQL的root用户密码具备一定复杂度，建议使用字母、数字、字符组合的密码。</li><li>MySQL不允许任意远程端连接，建议仅对协同系统所在的IP地址放开连接。</li><li>MySQL不使用默认的3306端口，建议修改为其他端口。（mysql的配置文件：Linux下为my.cnf）</li><li>MySQL设置定时备份，并将数据备份包备份在异机（或异地）。</li><li>网站程序不直接使用root权限，单独设立用户权限。</li></ol><h2 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h2><p>针对上述方法措施，在这给出修改过程。</p><h3 id="环境声明"><a href="#环境声明" class="headerlink" title="环境声明"></a>环境声明</h3><p>此次实验的环境为：腾讯云的Ubuntu Server 18.04，数据库为MySQL 5.7.25。</p><h3 id="修改root账户密码"><a href="#修改root账户密码" class="headerlink" title="修改root账户密码"></a>修改root账户密码</h3><p>服务器密码的修改我们直接去控制台更改下就可以了，不多说，这里说下MySQL数据库root密码的更改。</p><ul><li>以root账户登录MySQL </li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>然后输入原先的root密码进入数据库操作（mysql shell）</p><ul><li>选择数据库</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure><ul><li>更新root的密码</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set authentication_string&#x3D;password(&#39;新密码&#39;) where user&#x3D;&#39;root&#39; and host&#x3D;&#39;localhost&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:这里说明下，在MySQL 5.7 <code>password</code>字段已从<code>mysql.user</code>表中删除，新的字段名是<code>authenticalion_string</code>。</p></blockquote><ul><li>刷新权限</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><ul><li>退出MySQL的shell环境并重启MySQL服务</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><h3 id="修改MySQL的使用端口"><a href="#修改MySQL的使用端口" class="headerlink" title="修改MySQL的使用端口"></a>修改MySQL的使用端口</h3><p>我们知道MySQL的默认端口是3306，为了安全起见，建议将MySQL的默认端口号修改成自己想要的（有女朋友的就改成女朋友生日，这样就忘不掉了）。</p><p>查了很多资料说MySQL的配置文件在<code>/etc/mysql/my.cnf</code>路径下，但是当我查看内容的时候却给我下面这样的信息：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/10/16b3f67725b3376e?w=1326&h=792&f=jpeg&s=136958" alt="image-20190610105106423"></p><p>这个文件里面根本没有任何参数设置（<strong>这是由于不同的mysql版本导致的，再次申明下我的系统版本为Ubuntu18.04，MySQL 5.7.25</strong>），只看到下面两行设置，表示导入这两个目录里面的配置文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!includedir &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;</span><br><span class="line">!includedir &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;</span><br></pre></td></tr></table></figure><p>分别尝试打开查看内容后我们发现其实MySQL的相关配置都位于<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>里，进入目录后执行<code>cat mysql.cnf</code>可以看到在**[mysqld]<strong>标签下有很多参数信息，其中有一个参数就是</strong>port**，我们把它设置成自己想要的端口号就可以了（记得用vim时要加上sudo啊）。</p><p>最后重启下mysql就可以了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><h3 id="关闭MySQL的远程访问权限"><a href="#关闭MySQL的远程访问权限" class="headerlink" title="关闭MySQL的远程访问权限"></a>关闭MySQL的远程访问权限</h3><p>MySQL有一套权限系统，他的主要功能是证实连接到一台给定主机的用户，并且赋予该用户在数据库上的SELECT、INSERT、UPDATE和DELETE权限。基于安全考虑root账户一般只能本地访问，但是在开发过程中可能需要打开root的远程访问权限，如果正式上线的时候没有关闭mysql的远程访问权限，就有可能会被利用然后删库。</p><ul><li>以root账户登录MySQL </li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>然后输入原先的root密码进入数据库操作（mysql shell）</p><ul><li>选择数据库</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure><ul><li>关闭远程访问</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set host &#x3D; &quot;localhost&quot; where user &#x3D; &quot;root&quot; and host&#x3D; &quot;localhost&quot;;</span><br></pre></td></tr></table></figure><ul><li>刷新权限</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><ul><li>退出MySQL的shell环境并重启mysql服务</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上述内容是我自己针对此次服务器被攻击后查阅相关资料整理出来的，因为对这方面我也不是很懂，也只能做些简单的防护措施，仅供参考，如果大家有什么建议的可以在评论区或者公众号后台给我留言。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/10/16b3f67fb5121018?w=1196&h=716&f=png&s=659619"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为了预测股票，我用TensorFlow深度学习了股市数据</title>
      <link href="p/ffc6.html"/>
      <url>p/ffc6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>完整源码可在微信公众号：「01 二进制」后台回复：「股市分析」获取</p><p>阅读此文前建议先阅读<a href="https://mp.weixin.qq.com/s/GVd7jxQH1_vXagBTBPvFdw">《找对象的过程中，我竟然理解了什么是机器学习！》</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信大家这几天或多或少的都开始关注到股市了，虽然我还不是很懂里面的一些套路，但是从最近各个公众号的推送里面，我也看到最近的股市确实是形势大好。对很多人来说，股票就和房价一样，他的升与降牵动着众多人的心。这几天很多 qq 群、微信群都开始讨论起股票了，各位坊间大神也纷纷开始预测各种股票走势了。</p><p>股票价格是典型的时间序列数据（简称时序数据），会受到经济环境、政府政策、人为操作多种复杂因素的影响，所以说股票价格预测是一件非常唬人的事情。但是基于历史数据，以股票价格为例，介绍如何对时序数据进行预测，仍然值得一做。</p><p>不过今天我们不聊股市，因为我也不是很懂，今天我们来聊聊我们知道的东西。如今深度学习在金融市场的应用越来越广泛，我们能否利用已有的历史数据通过深度学习的方式来进行预测呢？</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>答案自然是可以的，虽然我们无法非常准确的进行预测，但是作为一个深度学习入手的项目是完完全全可以的。</p><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>老样子，以免出现因环境导致的问题，先将实验环境列出：</p><ul><li>MacOS 10.14.3</li><li>Python 3.6.8（Anaconda）</li><li>Jupyter Notebook</li><li>使用的包有：<ul><li>TensorFlow</li><li>Keras</li><li>matplotlib</li><li>pandas</li></ul></li></ul><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>此次实验，我们采用<strong>STATWORX</strong>的<code>S&amp;P 500</code>股价数据，该数据集爬取自 Google Finance API，已经进行过缺失值处理。他们的官方网站是：<a href="https://www.statworx.com/%E3%80%82">https://www.statworx.com/。</a></p><blockquote><p>数据集可在微信公众号：「01 二进制」后台回复：「股市数据集」获取</p></blockquote><h4 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h4><p>在这里我们还是使用 pandas，主要用于数据清洗和整理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data=pd.read_csv(<span class="string">&#x27;data/data_stocks.csv&#x27;</span>)</span><br><span class="line">data.info()</span><br></pre></td></tr></table></figure><p>执行<code>data.info()</code>可以查看特征的概要：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span><br><span class="line">RangeIndex: 41266 entries, 0 to 41265</span><br><span class="line">Columns: 502 entries, DATE to NYSE.ZTS</span><br><span class="line">dtypes: float64(501), int64(1)</span><br><span class="line">memory usage: 158.0 MB</span><br></pre></td></tr></table></figure><p>从上述结果可知：该数据集数据共 502 列，41266 行，502 列分别为：</p><ul><li><code>DATE</code>：该行数据的时间戳</li><li><code>SP500</code>：可以理解为大盘指数</li><li>其他：可以理解为 500 支个股的股价</li></ul><p>查看数据的前五行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.head()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ed6b751fb444ab46?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>绘制大盘趋势折线图</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.plot(data[&#39;SP500&#39;])</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-06f54a1f77d5669a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>Tips：此次实验的调试环境为 Jupyter Notebook，我们最好在开头导入<code>matplotlib</code>包的时候在加一行<code>%matplotlib inline</code>，这样就可以在 Jupyter Notebook 中内嵌绘图，并且省略掉 plt.show()这一步。</p></blockquote><h4 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h4><p>在这里，我们需要将数据集分为训练和测试数据。分配比为 8:2，即训练数据包含总数据集的 80％。当然在这之前我们需要先将<code>DATE</code>这个无关变量舍去。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.drop(&#39;DATE&#39;, axis&#x3D;1, inplace&#x3D;True)</span><br><span class="line">data_train &#x3D; data.iloc[:int(data.shape[0] * 0.8), :]</span><br><span class="line">data_test &#x3D; data.iloc[int(data.shape[0] * 0.8):, :]</span><br></pre></td></tr></table></figure><p>我们来查看一下训练集和测试集的<code>shape</code>：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-6d5120d7e6fa9a10?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h4 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h4><p>将属性缩放到一个指定的最大和最小值（通常是（-1，1））之间，这可以通过<code>sklearn.preprocessing.MinMaxScaler</code>类实现。</p><p>使用这种方法的目的包括：</p><ol><li><p>对于方差非常小的属性可以增强其稳定性。</p></li><li><p>维持稀疏矩阵中为 0 的条目。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaler = MinMaxScaler(feature_range=(<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">scaler.fit(data_train)</span><br><span class="line">data_train = scaler.transform(data_train)</span><br><span class="line">data_test = scaler.transform(data_test)</span><br></pre></td></tr></table></figure><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>在此次预测过程中，我采用 TensorFlow 这个深度学习框架，它是目前领先的深度学习和神经网络计算框架。这一部分推荐<strong>有基础的人</strong>阅读，在这推荐我还在整理的<a href="https://juejin.im/post/5c751da2f265da2dba022fd9">TensorFlow 系列</a>，有兴趣的可以了解下。</p><p>这里我们需要解决的问题是：<strong>使用当前时刻的 500 支个股股价，预测当前时刻的大盘指数</strong>。即一个回归问题，<strong>输入共 500 维特征，输出一维</strong>，即<code>[None, 500] =&gt; [None, 1]</code></p><h3 id="设置-X-与-Y"><a href="#设置-X-与-Y" class="headerlink" title="设置 X 与 Y"></a>设置 X 与 Y</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = data_train[:, <span class="number">1</span>:]</span><br><span class="line">y_train = data_train[:, <span class="number">0</span>]</span><br><span class="line">X_test = data_test[:, <span class="number">1</span>:]</span><br><span class="line">y_test = data_test[:, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这里的 x 和 y 是已经分类好的数据集，只是用 X 和 Y 两个变量表示，可以理解为函数里面的 X 和 Y。</p><h3 id="设置超参数"><a href="#设置超参数" class="headerlink" title="设置超参数"></a>设置超参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_dim = X_train.shape[<span class="number">1</span>]</span><br><span class="line">output_dim = <span class="number">1</span></span><br><span class="line">hidden_1 = <span class="number">1024</span></span><br><span class="line">hidden_2 = <span class="number">512</span></span><br><span class="line">hidden_3 = <span class="number">256</span></span><br><span class="line">hidden_4 = <span class="number">128</span></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">epochs = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这里我们设置了几个超参数，<code>input_dim</code>表示输入数据的维度，即 500。<code>output_dim</code>表示输出数据的维度，即 1。在该模型中设置了 4 层隐藏层，第一层包含 1024 个神经元，略大于输入大小的两倍。 后续的隐藏层总是前一层的一半大小，即分别为 512,256 和 128 个神经元。 每个后续层的神经元数量的减少压缩了网络在先前层中识别的信息。 当然，其他网络架构和神经元配置也是可能的，只是由于本文只是一个入门的项目所以并未深究。</p><blockquote><p>在机器学习中，<strong>超参数</strong>是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。</p></blockquote><h3 id="设置占位符（placeholder）"><a href="#设置占位符（placeholder）" class="headerlink" title="设置占位符（placeholder）"></a>设置占位符（placeholder）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = tf.placeholder(shape=[<span class="literal">None</span>, input_dim], dtype=tf.float32)</span><br><span class="line">Y = tf.placeholder(shape=[<span class="literal">None</span>], dtype=tf.float32)</span><br></pre></td></tr></table></figure><p>为了适应我们的模型，我们需要两个占位符：X（神经网络的输入）和 Y（神经网络的输出）。</p><h3 id="设置神经网络"><a href="#设置神经网络" class="headerlink" title="设置神经网络"></a>设置神经网络</h3><p>根据之前设置好的超参数进行神经网络的配置，其中<strong>w</strong>为权重，<strong>b</strong>为偏置值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一层</span></span><br><span class="line">W1 = tf.get_variable(<span class="string">&#x27;W1&#x27;</span>, [input_dim, hidden_1], initializer=tf.contrib.layers.xavier_initializer(seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.get_variable(<span class="string">&#x27;b1&#x27;</span>, [hidden_1], initializer=tf.zeros_initializer())</span><br><span class="line"><span class="comment"># 第二层</span></span><br><span class="line">W2 = tf.get_variable(<span class="string">&#x27;W2&#x27;</span>, [hidden_1, hidden_2], initializer=tf.contrib.layers.xavier_initializer(seed=<span class="number">1</span>))</span><br><span class="line">b2 = tf.get_variable(<span class="string">&#x27;b2&#x27;</span>, [hidden_2], initializer=tf.zeros_initializer())</span><br><span class="line"><span class="comment"># 第三层</span></span><br><span class="line">W3 = tf.get_variable(<span class="string">&#x27;W3&#x27;</span>, [hidden_2, hidden_3], initializer=tf.contrib.layers.xavier_initializer(seed=<span class="number">1</span>))</span><br><span class="line">b3 = tf.get_variable(<span class="string">&#x27;b3&#x27;</span>, [hidden_3], initializer=tf.zeros_initializer())</span><br><span class="line"><span class="comment"># 第四层</span></span><br><span class="line">W4 = tf.get_variable(<span class="string">&#x27;W4&#x27;</span>, [hidden_3, hidden_4], initializer=tf.contrib.layers.xavier_initializer(seed=<span class="number">1</span>))</span><br><span class="line">b4 = tf.get_variable(<span class="string">&#x27;b4&#x27;</span>, [hidden_4], initializer=tf.zeros_initializer())</span><br><span class="line"><span class="comment"># 输出层</span></span><br><span class="line">W5 = tf.get_variable(<span class="string">&#x27;W5&#x27;</span>, [hidden_4, output_dim], initializer=tf.contrib.layers.xavier_initializer(seed=<span class="number">1</span>))</span><br><span class="line">b5 = tf.get_variable(<span class="string">&#x27;b5&#x27;</span>, [output_dim], initializer=tf.zeros_initializer())</span><br></pre></td></tr></table></figure><p>了解输入层，隐藏层和输出层之间所需的变量尺寸非常重要。作为多层感知器(MLP，这里使用的网络类型)的一个经验法则，前一层的第二维是当前层中权重矩阵的第一维。这可能听起来很复杂，但实质上只是每个图层都将其输出作为输入传递到下一图层。偏差维度等于当前图层的权重矩阵的第二维度，其对应于该层中的神经元的数量。</p><h3 id="设置网络体系结构"><a href="#设置网络体系结构" class="headerlink" title="设置网络体系结构"></a>设置网络体系结构</h3><p>在定义所需的权重和偏置变量后，需要指定网络拓扑结构和网络结构。因此，占位符(数据)和变量(权重和偏置)需要组合成一个连续矩阵乘法系统。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h1 = tf.nn.relu(tf.add(tf.matmul(X, W1), b1))</span><br><span class="line">h2 = tf.nn.relu(tf.add(tf.matmul(h1, W2), b2))</span><br><span class="line">h3 = tf.nn.relu(tf.add(tf.matmul(h2, W3), b3))</span><br><span class="line">h4 = tf.nn.relu(tf.add(tf.matmul(h3, W4), b4))</span><br><span class="line">out = tf.transpose(tf.add(tf.matmul(h4, W5), b5))</span><br></pre></td></tr></table></figure><p>此外，网络的隐藏层需要被激活函数激活。激活函数是网络体系结构的重要组成部分，因为它们将非线性引入到系统中。这里采用最常见的 ReLU 激活函数。</p><p>下图说明了网络架构。 该模型由三个主要构建块组成。 输入层，隐藏层和输出层。 该体系结构称为前馈网络。 前馈表示该批数据仅从左向右流动。 其他网络架构，例如递归神经网络，也允许数据在网络中“向后”流动。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-404f59c387130323?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="设置损失函数（loss-function）和优化器（Optimizer）"><a href="#设置损失函数（loss-function）和优化器（Optimizer）" class="headerlink" title="设置损失函数（loss function）和优化器（Optimizer）"></a>设置损失函数（loss function）和优化器（Optimizer）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.squared_difference(out, Y))</span><br><span class="line">optimizer = tf.train.AdamOptimizer().minimize(loss)</span><br></pre></td></tr></table></figure><p>这一部分没啥好说的，记住这么写就可以了，想了解的话可以去<a href="https://juejin.im/post/5c751da2f265da2dba022fd9">我的 TensorFlow</a>中了解下。</p><h3 id="执行训练过程"><a href="#执行训练过程" class="headerlink" title="执行训练过程"></a>执行训练过程</h3><p>在定义好神经网络的占位符，结构，损失函数函数和优化器之后，我们就可以开始对模型进行训练了。训练数据集分为 n / batch_size 批次，这些批次按顺序送入网络。 此时占位符 X 和 Y 开始起作用。 它们存储输入和目标数据，并将它们作为输入和目标呈现给网络。</p><p>数据 X 分批次流经网络，直到到达输出层。 在那里，TensorFlow 将模型预测与当前批次中实际观察到的目标 Y 进行比较。 之后，TensorFlow 进行优化步骤并更新与所选学习方案相对应的网络参数。 更新了权重和偏差后，对下一批进行采样，并重复该过程。 该过程将继续，直到所有批次都已呈现给网络。对所有数据进行一次全面扫描被称为一个<strong>epoch（轮）</strong>。</p><p>一旦达到了最大数量的 epochs 或用户定义的另一个停止标准，网络的训练就会停止。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># 初始化所有变量</span></span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(epochs):</span><br><span class="line">        <span class="comment"># 将数据打乱</span></span><br><span class="line">        shuffle_indices = np.random.permutation(np.arange(y_train.shape[<span class="number">0</span>]))</span><br><span class="line">        X_train = X_train[shuffle_indices]</span><br><span class="line">        y_train = y_train[shuffle_indices]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(y_train.shape[<span class="number">0</span>] // batch_size):</span><br><span class="line">            start = i * batch_size</span><br><span class="line">            batch_x = X_train[start : start + batch_size]</span><br><span class="line">            batch_y = y_train[start : start + batch_size]</span><br><span class="line">            sess.run(optimizer, feed_dict=&#123;X: batch_x, Y: batch_y&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">&#x27;MSE Train:&#x27;</span>, sess.run(loss, feed_dict=&#123;X: X_train, Y: y_train&#125;))</span><br><span class="line">                print(<span class="string">&#x27;MSE Test:&#x27;</span>, sess.run(loss, feed_dict=&#123;X: X_test, Y: y_test&#125;))</span><br><span class="line">                y_pred = sess.run(out, feed_dict=&#123;X: X_test&#125;)</span><br><span class="line">                y_pred = np.squeeze(y_pred)</span><br><span class="line">                plt.plot(y_test, label=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">                plt.plot(y_pred, label=<span class="string">&#x27;pred&#x27;</span>)</span><br><span class="line">                plt.title(<span class="string">&#x27;Epoch &#x27;</span> + str(e) + <span class="string">&#x27;, Batch &#x27;</span> + str(i))</span><br><span class="line">                plt.legend()</span><br><span class="line">                plt.show()</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MSE Train: 9.56518e-05</span><br><span class="line">MSE Test: 0.0025863606</span><br><span class="line">MSE Train: 6.0618047e-05</span><br><span class="line">MSE Test: 0.0025002975</span><br><span class="line">MSE Train: 0.00014856807</span><br><span class="line">MSE Test: 0.0017371146</span><br><span class="line">MSE Train: 0.00016200903</span><br><span class="line">MSE Test: 0.0025396077</span><br><span class="line">MSE Train: 0.00010259051</span><br><span class="line">MSE Test: 0.0030134947</span><br><span class="line">MSE Train: 7.979905e-05</span><br><span class="line">MSE Test: 0.0023832247</span><br><span class="line">MSE Train: 5.92488e-05</span><br><span class="line">MSE Test: 0.0032762515</span><br><span class="line">MSE Train: 8.747634e-05</span><br><span class="line">MSE Test: 0.004848172</span><br><span class="line">MSE Train: 8.5051965e-05</span><br><span class="line">MSE Test: 0.0032768336</span><br></pre></td></tr></table></figure><p>最后测试集的 loss 在 0.003 左右，可以说是比较精确了。</p><p>可视化训练结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-58fa7bd9365e1b5b?imageMogr2/auto-orient/strip" alt="20190226203532"></p><p>有很多方法可以进一步改善这一结果：增加隐藏层和改进神经元的设计，选择不同的初始化和激活方案，提前停止等等。 此外，不同类型的深度学习模型，例如循环神经网络，可以在此任务上实现更好的性能。 但是，这不是这篇介绍性文章的范围。有兴趣的小伙伴可以自行查找资料。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>正如开头所说，股票的价格会受到经济环境、政府政策、人为操作多种复杂因素的影响，真正想要预测股市走向单靠这篇文章里面所叙述的远远不够，本文旨在结合时下热点进行一次有关 TensorFlow 的技术推荐。</p><p>TensorFlow 的发布是深度学习研究中的一个里程碑事件。作为一个学生，笔者也在积极的学习中，有兴趣学习的小伙伴可以在公众号后台（就是文末的那个公众号）回复「<strong>TensorFlow 视频</strong>」获取一份质量较高的 TensorFlow 视频，也可以添加我的微信一起交流进步。</p><blockquote><p>完整源码可在微信公众号：「01 二进制」后台回复：「股市分析」获取</p></blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://vimsky.com/article/3847.html">使用 TensorFlow 进行股票价格预测的简单深度学习模型</a></li><li><a href="https://blog.csdn.net/zhl493722771/article/details/82779315">深度有趣 | 10 股票价格预测</a></li></ul><hr><p>“万水千山都是情，给个关注行不行 👇”</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-218fabb971dad637?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊数据库（MySQL）设计中的数据类型优化</title>
      <link href="p/e25d.html"/>
      <url>p/e25d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gasp6ye49vj30jy0c3tbt.jpg"></p><p>良好的逻辑设计和物理设计事高性能的基石，在进行数据库设计时，我们应该要考虑到未来将会执行的查询语句，这就需要对各种因素进行权衡。本文将会聊一聊数据库（MySQL）设计中有关数据类型优化的一些内容。以下内容总结自《高性能 MysQL》。</p><h2 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>我们知道 MySQL 支持多种数据类型，通常情况下，很多数据类型都可以完成相同的工作，选择正确的数据类型对于高性能至关重要。在明确需要优化的数据类型前，我们需要先掌握几个原则，这些原则有助于我们作出更好的选择。</p><ul><li>选择相对轻量的数据类型</li></ul><p>这里的轻量指的是，在一般情况下，应该使用可以正确存储数据的最小数据类型。例如一个列中的最大值为 2020，那就没必要选择 INT 以及更大的数据类型。</p><ul><li>简单就好</li></ul><p>简单的数据类型通常意味着处理时需要更少的 CPU 周期。例如，整型比字符操作代价更低；存储日期/时间应该用内置的数据类型而不是字符串；存储 IP 地址时应该用整型而不是字符串。</p><ul><li>避免 NULL</li></ul><p>通常情况下，应该设置列为 NOT NULL。因为 NULL 会使某个列的索引、值等数据的处理变得复杂。而且可为 NULL 的列会使用更多的存储空间。</p><h3 id="针对具体的数据类型"><a href="#针对具体的数据类型" class="headerlink" title="针对具体的数据类型"></a>针对具体的数据类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>对于整数，可选的数据类型有 TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT。分别使用 8、16，24，32，64 位存储空间。同时可选的属性有<strong>UNSIGNED</strong>，表示不允许有负值，这可以让正数的上限提高一倍。例如 TINYINT 的存储范围是<code>-128～127</code>，TINYINT UNSIGNED 的存储范围是<code>0~255</code>。</p><blockquote><p>MySQL 可以为整数类型制定宽度，例如 INT(11)，但是并不会限制数值的合法范围，只会控制某些交互工具用来显示字符的个数，对于存储和计算来说，INT(1)和 INT(20)是相同的。即括号中的数字只是用于控制显示的字符数，和实际可以存储的字符数无关。</p></blockquote><h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><p>实数是带有小数部分的数字，MySQL 中使用 DECIMAL 类型用于存储精确的小数，但是 CPU 不支持对 DECIMAL 的直接计算，因此 MySQL 服务器自身实现了 DECIMAL 的高精度计算。</p><p>与此同时 CPU 支持原生浮点计算，因此浮点数的运算速度相对 DECIMAL 会更快。浮点分为两种：FLOAT 和 DOUBLE。由于 DOUBLE 相对于 FLOAT 有更高的精度和更大的范围，MySQL 使用 DOUBLE 作为内部浮点计算的类型。</p><blockquote><p>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行<strong>精确计算</strong>时才使用 DECIMAL，例如财务数据。数据量较大时，也可以考虑使用 BIGINT 代替 DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。</p></blockquote><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>常用的是 VARCHAR 和 CHAR</p><p><strong>VARCHAR</strong></p><ul><li>存储可变长字符串</li><li>比定长类型省空间，越短的字符串使用空间越少</li><li>使用 1 或 2 个额外字节记录字符串的长度。列的最大长度小于或等于 255 字节，使用 1 个字节表示，否则使用 2 个字节表示</li></ul><p><strong>CHAR</strong></p><ul><li>存储定长字符串</li><li>对于经常变更的数据，使用 CHAR 存储不易产生碎片</li></ul><p>因此二者的使用场景也很明显：</p><p>VARCHAR 适合字符串列的最大长度比平均长度大很多，同时列的更新很少，以及列中的字符串使用复杂的字符集，每个字符都使用不同的字节数进行存储（UTF-8）。</p><p>CHAR 适合存储<strong>很短</strong>的字符串，或者所有值都接近同一个长度，例如存储密码的 MD5 值，或者用 CHAR(1)存储只有 Y 和 N 的值，因为 CHAR(1)需要一个字节，VARCHAR(1)需要两个字节（需要一个记录长度的额外字节）。</p><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p><strong>DATETIME</strong></p><ul><li>可以保存从 1001 年到 9999 年，精度为秒</li><li>将日期和时间封装到格式为 YYYYMMDDHHMMSS 的整数中，与时区无关。</li><li>使用 8 个字节的存储空间</li></ul><p><strong>TIMESTAMP</strong></p><ul><li>保存了从 1970 年 1 月 1 日午夜以来的秒数</li><li>只使用 4 个字节存储，因此范围会小很多（最多表示从 1970 年到 <strong>2038</strong> 年）</li><li>和时区有关</li></ul><blockquote><p>因为 TIMESTAMP 是用 4 个字节存储，因此最多只能保存到 2038 年，这一点也造成了非常著名的<a href="https://baike.baidu.com/item/2038%E5%B9%B4%E9%97%AE%E9%A2%98">2038 年问题</a>。</p></blockquote><h4 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h4><p>标识符是用于标识列与其他值进行比较（例如关联操作中，通过标识列寻找其他列），标识列在选择数据类型时，应该跟关联表中的对应列一样的类型。</p><p>整数类型通常是最好的选择，效率高且可以自增长（例如主键）。如果可以，尽量避免使用字符串作为标识列，消耗空间，且查询速度慢。</p><h4 id="特殊数据"><a href="#特殊数据" class="headerlink" title="特殊数据"></a>特殊数据</h4><p>有些特殊的数据需要用一些数据类型专门存储，例如存储 IP 地址应该用无符号整数，因为 IP 地址本质上是 32 位无符号数，并不是字符串，用小数点将地址分成四段只是方便阅读。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>想要提高 MySQL 的效率，可以做的功课非常多，数据库的数据类型优化也只是其中很小的一点，本文也只是挑出了常用的数据类型进行介绍。有兴趣的可以仔细阅读《高性能 MySQL》这本书，你可以在微信公众号「01 二进制」后台回复「高性能 MySQL」获取本书。</p><p>大道至简，尽可能将事情保持简单总是好的，MySQL 喜欢简单，希望使用数据库的你也会喜欢简单。</p><hr><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5x01onq5yj31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李鬼见李逵——我用翟天临的论文做了分析</title>
      <link href="p/9f29.html"/>
      <url>p/9f29.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5666077-ec641bc3b0e097e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>完整源码可在公众号：「01 二进制」后台回复：「翟天临」获取</p></blockquote><p>昨天是元宵节，在南京，元宵节一到也意味着这个年过完了，我们也该回到自己的工作岗位上了。都说今年的瓜特别多（葫芦娃的那种），但是过年期间最甜的我想非翟天临的“<strong>知网是什么？</strong>”莫属了吧。</p><p>前段时间，微博上开始不断爆出翟天临学术不端，论文抄袭的消息，以至于牵扯到其导师、院长甚至整个北京电影学院。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-d74168e7bcbe2799.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我平常不怎么关注娱乐圈，所以刚开始并没有把这件事放在心上，直到网上爆出翟的论文大篇幅抄袭陈坤论文的消息，我才对这位娱乐圈博士的文章起了兴趣。接下来就让我们以一个 coder 的角度来硬核分析下翟的论文吧。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>工欲善其事，必先利其器，在开始分析之前，我先说明此次分析所处的实验环境，以免出现异常：</p><ul><li>MacOS 10.14.3</li><li>Python 3.6.8（Anaconda）</li><li>Visual Studio Code</li><li>使用的包有：<ul><li>pkuseg（分词）</li><li>matplotlib（绘图）</li><li>wordcloud（词云）</li><li>numpy（数学计算）</li><li>sklearn（机器学习）</li></ul></li></ul><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>说实话，起初我以为就算翟不知“知网”为何物，“知网”也该收录翟的文章吧，可我在知网搜了好久也没能找到翟的论文，好在我在今日头条上找到了他的文章，保存在<code>data/zhai.txt</code>中。说到这，还真要感谢翟天临啊，都是因为他，大家才变得这么有学术精神，开始研究起本科硕士博士论文了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-689e5af30a6f0d0a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h2><p>上一节我们已经将他的论文保存到一个 txt 中了，所以我们需要先将文章加载到内存中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据获取（从文件中读取）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readFile</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    content = []</span><br><span class="line">    <span class="keyword">with</span> open(file_path, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">    <span class="keyword">return</span> content</span><br></pre></td></tr></table></figure><p>我统计了下，除去开头的标题和末尾的致谢，总共 25005 个字。</p><p>接下来我们来进行数据清理，在这里我用了<strong>pkuseg</strong>对内容进行分词处理，同时去掉停用词后输出分词的结果。</p><blockquote><p>所谓停用词就是在语境中没有具体含义的文字，例如这个、那个，你我他，的得地，以及标点符合等等。因为没人在搜索的时候去用这些没意义的停用词搜索，为了使得分词效果更好，我就要把这些停用词过滤掉。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据清理（分词和去掉停用词）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanWord</span>(<span class="params">content</span>):</span></span><br><span class="line">    <span class="comment"># 分词</span></span><br><span class="line">    seg = pkuseg.pkuseg()</span><br><span class="line">    text = seg.cut(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取停用词</span></span><br><span class="line">    stopwords = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;stopwords/哈工大停用词表.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        stopwords = f.read()</span><br><span class="line"></span><br><span class="line">    new_text = []</span><br><span class="line">    <span class="comment"># 去掉停用词</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> text:</span><br><span class="line">        <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> stopwords:</span><br><span class="line">            new_text.append(w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_text</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-0aa905c8273e07e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="这里我提两点："><a href="#这里我提两点：" class="headerlink" title="这里我提两点："></a>这里我提两点：</h3><ol><li>为什么分词工具用的是<strong>pkuseg</strong>而不是<strong>jieba</strong>？</li></ol><p><strong>pkuseg</strong>是北大推出的一个分词工具，官方地址是：<a href="https://github.com/lancopku/pkuseg-python%EF%BC%8C%E4%BB%96%E7%9A%84README%E4%B8%AD%E8%AF%B4%E4%BB%96%E6%98%AF%E7%9B%AE%E5%89%8D%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%B7%A5%E5%85%B7%E4%B8%AD%E6%95%88%E6%9E%9C%E6%9C%80%E5%A5%BD%E7%9A%84%E3%80%82">https://github.com/lancopku/pkuseg-python，他的README中说他是目前中文分词工具中效果最好的。</a></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-bd5ee379d6fffcd5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ol start="2"><li>为什么用哈工大的停用词表？</li></ol><p>停用词表的下载地址在：<a href="https://github.com/YueYongDev/stopwords%E3%80%82%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%81%9C%E7%94%A8%E8%AF%8D%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A">https://github.com/YueYongDev/stopwords。以下是几个常用停用词表的对比：</a></p><table><thead><tr><th>停用词表</th><th>效果较好的文本种类</th></tr></thead><tbody><tr><td>哈工大停用词表</td><td>文献期刊类文本</td></tr><tr><td>百度停用词表</td><td>新闻报道类文本</td></tr><tr><td>四川大学停用词表</td><td>邮件文献类文本</td></tr></tbody></table><blockquote><p>参考文献：官琴, 邓三鸿, 王昊. 中文文本聚类常用停用词表对比研究[J]. 数据分析与知识发现, 2006, 1(3).</p><p>有兴趣阅读此篇论文的可在公众号：「01 二进制」后台回复：「停用词表对比研究」获取</p></blockquote><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>说是数据统计，其实也没什么好统计的，这里简单化一下，就是统计下各个词出现的频率，然后输出词频最高的 15 个词</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据整理（统计词频）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">statisticalData</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="comment"># 统计每个词的词频</span></span><br><span class="line">    counter = Counter(text)</span><br><span class="line">    <span class="comment"># 输出词频最高的15个单词</span></span><br><span class="line">    pprint.pprint(counter.most_common(<span class="number">15</span>))</span><br></pre></td></tr></table></figure><p>打印的结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a56b796bd74ac70f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>真的是个不可多得的“好演员”啊，能将角色带入生活，即使肚中无货却仍用自己的表演能力为自己设立一个“学霸”人设，人物形象如此饱满，兴许这就是创作的艺术吧！</p></blockquote><p>文章中说的最多的就是生活、角色、人物、性格这些词，这些正是一个好演员的精神所在，如果我们将这些词做成<strong>词云</strong>的话，可能效果会更好。</p><h3 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h3><p>词云生成这个部分我采用的是<strong>wordcloud</strong>库，使用起来非常简单，网上教程也有很多，这里需要提一点的就是：为了防止中文乱码情况的发生，需要配置<strong>font_path</strong>这个参数。中文字体可以选用系统的，也可以网上找，这里我推荐一个免费的中文字体下载的网址：<a href="http://www.lvdoutang.com/zh/0/0/1/1.html">http://www.lvdoutang.com/zh/0/0/1/1.html</a></p><p>下面是生成词云的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据可视化（生成词云）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawWordCloud</span>(<span class="params">text, file_name</span>):</span></span><br><span class="line">    wl_space_split = <span class="string">&quot; &quot;</span>.join(text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置词云背景图</span></span><br><span class="line">    b_mask = plt.imread(<span class="string">&#x27;assets/img/bg.jpg&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置词云字体（若不设置则无法显示中文）</span></span><br><span class="line">    font_path = <span class="string">&#x27;assets/font/FZZhuoYTJ.ttf&#x27;</span></span><br><span class="line">    <span class="comment"># 进行词云的基本设置（背景色，字体路径，背景图片，词间距）</span></span><br><span class="line">    wc = WordCloud(background_color=<span class="string">&quot;white&quot;</span>,font_path=font_path, mask=b_mask, margin=<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 生成词云</span></span><br><span class="line">    wc.generate(wl_space_split)</span><br><span class="line">    <span class="comment"># 显示词云</span></span><br><span class="line">    plt.imshow(wc)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="comment"># 将词云图保存到本地</span></span><br><span class="line">    path = os.getcwd()+<span class="string">&#x27;/output/&#x27;</span></span><br><span class="line">    wc.to_file(path+file_name)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/5666077-23706de5c2b9f13f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="真假李逵（文章对比）"><a href="#真假李逵（文章对比）" class="headerlink" title="真假李逵（文章对比）"></a>真假李逵（文章对比）</h2><p>分析完了“李鬼”，我们有必要请出他的真身“李逵”兄弟了，同样还是和之前一样的套路，先找到数据，然后分词统计词频，这里就不重复操作了，直接放出词云图。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-8d937b44f0d5e096.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>看到这图是不是觉得和翟的词云图异常相似，那么，这“真假李逵”之间到底有多像呢？接下来我们来计算下两篇文章的相似度吧。</p><h3 id="文章相似度比较"><a href="#文章相似度比较" class="headerlink" title="文章相似度比较"></a>文章相似度比较</h3><h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>文章相似度的比较有很多种方法，使用的模型也有很多类别，包括<strong>TF-IDF,LDA,LSI</strong>等，这里方便起见，就只使用 TF-IDF 来进行比较了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-672b7351fb2cb023.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>TF-IDF 实际上就是在词频 TF 的基础上再加入 IDF 的信息，IDF 称为逆文档频率，不了解的可以看下阮一峰老师的讲解：<a href="https://www.ruanyifeng.com/blog/2013/03/tf-idf.html">https://www.ruanyifeng.com/blog/2013/03/tf-idf.html</a>，里面对 TFIDF 的讲解也是十分透彻的。</p><h4 id="Sklearn"><a href="#Sklearn" class="headerlink" title="Sklearn"></a>Sklearn</h4><p>scikit-learn 也简称 sklearn, 是机器学习领域当中最知名的 Python 模块之一，官方地址为：<a href="https://github.com/scikit-learn/scikit-learn%EF%BC%8C%E5%85%B6%E5%8C%85%E5%90%AB%E4%BA%86%E5%BE%88%E5%A4%9A%E7%A7%8D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E5%80%9F%E5%8A%A9%E4%BA%8E">https://github.com/scikit-learn/scikit-learn，其包含了很多种机器学习的方式，下面我们借助于</a> Sklearn 中的模块<strong>TfidfVectorizer</strong>来计算两篇文章之间的相似度，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算文本相似度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateSimilarity</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_space</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(cleanWord(s))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将字中间加入空格</span></span><br><span class="line">    s1, s2 = add_space(s1), add_space(s2)</span><br><span class="line">    <span class="comment"># 转化为TF矩阵</span></span><br><span class="line">    cv = TfidfVectorizer(tokenizer=<span class="keyword">lambda</span> s: s.split())</span><br><span class="line">    corpus = [s1, s2]</span><br><span class="line">    vectors = cv.fit_transform(corpus).toarray()</span><br><span class="line">    <span class="comment"># 计算TF系数</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(vectors[<span class="number">0</span>], vectors[<span class="number">1</span>]) / (norm(vectors[<span class="number">0</span>]) * norm(vectors[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><blockquote><p>除了 Sklearn，我们还可以使用<strong>gensim</strong>调用一些模型进行计算，考虑到文章篇幅，就由读者自己去搜集资料实现吧。</p></blockquote><p>我们将翟的论文和陈的论文分别传入该函数后，输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两篇文章的相似度为：</span><br><span class="line">0.7074857881770839</span><br></pre></td></tr></table></figure><p>其实这个结果我还是挺意外的，只知道这“李鬼”长得像，却没想到相似度竟然高达 70.7%。当然，作为弟弟，翟的这个事和吴秀波的事比起来，那都不是个事。🙈</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-781ddda619dbf8f1.gif?imageMogr2/auto-orient/strip"></p><blockquote><p>完整源码可在公众号：「01 二进制」后台回复：「翟天临」获取</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/5666077-994c916804762b5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把你的IDE搬进浏览器里——JetBrains Projector 初体验</title>
      <link href="p/6511.html"/>
      <url>p/6511.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.ytools.xyz/uPic/gR6ziC%E4%BA%91%E7%AB%AF%E7%BC%96%E7%A8%8B.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于云端编程，我想大多数人的第一想法应该是微软推出的 VSCode Remote，这个功能基于开源的 VSCode，通过 SSH 远程连接到服务器，开发者可以通过端口转发、SCP 等一系列实用功能快速实现<strong>远程开发</strong>。我曾体验过这种编程方式，极大减轻了电脑性能的压力，但我认为这并不是云端编程的最终形态，因为我仍然需要在自己的电脑上安装 VSCode 才可以使用这个功能。</p><p>最近 2021 款的 iPad Pro 上市了，这次搭载的是和 Mac 同款的 M1 芯片，性能强大到甚至有让人利用 iPad 编程的想法，只是迫于各大厂商没有推出适配 iPad 的 IDE，便也只能沦为“买钱生产力，买后爱奇艺”的工具了。那么有没有什么办法可以在不安装 IDE 的情况下使用 iPad 编程吗？自然是有的，JetBrains 公司提出了一种新的解决方案：把 IDE 搬进浏览器里。这便是本文的主角——JetBrains Projector。</p><p><img src="https://cdn.ytools.xyz/uPic/ncqLVhBlog_1280x720.png"></p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>提起 JetBrains，你会想到什么？各路强大的 IDE，比如 Android Studio、IDEA、WebStorm……这些对于开发者来说耳熟能详的产品都出自这家公司，这些 IDE 的功能强大，但同时也只能运行在用户自己的电脑上，其“内存黑洞”的称号更是让开发者们又爱又恨。</p><p><img src="https://cdn.ytools.xyz/uPic/wt6DBiiShot2021-05-04%2019.46.53.png"></p><p>事实上，目前所有的 JetBrains IDE 都使用 Java Swing 绘制 UI，其他基于 IntelliJ 的 IDE 也是如此，比如 Android Studio。鉴于 Swing 是 Java GUI 的一个库，而 Java 本身就是一门很吃内存的编程语言，虽然可以充分利用 Java 跨平台的特性，这也是这些 IDE 在 macOS、Windows 和 Linux 上 UI 几乎一致的原因。但现在，Swing <strong>跨桌面平台</strong>的特性却也成为阻碍其发展的一个原因了，在一些瘦客户端的情况下，“内存黑洞”屡屡被人诟病，Swing 也无法发挥其优势，于是 Projector 便应运而生了。</p><h2 id="横向比较"><a href="#横向比较" class="headerlink" title="横向比较"></a>横向比较</h2><p><img src="https://cdn.ytools.xyz/uPic/AcZUVvAWS_Cloud9_Asset01_R3_P.22c006faf1258710ffbdd756ec83ea97449e9da3.png"></p><p>JetBrains Projector 是 JetBrains 提出的“远程开发”解决方案，基于 Client + Server 架构，虽然对标的是微软 VSCode 的<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">Remote Development</a>方案，但是二者的原理和体验效果还是相差很多的。</p><ul><li>VSCode 通过 SSH 等技术，只传输代码、索引等数据，仅将计算匀给服务器，而渲染显示等还是依赖本地的 VSCode 客户端，这种情况下，你<strong>仍然需要安装 VSCode</strong>。</li><li>Projector 改动了 Swing 的渲染机制，通过网络传输渲染指令，最终使用 Web 技术将界面展现出来。这样做的好处是，你可以直接使用<strong>浏览器</strong>访问安装在服务器上的 IDEA。</li></ul><p>笔者在查阅资料的过程中发现，经常有很多人将这两者弄混，通过上述内容，相信你也有一个直观的感受了，这两者使用体验的差距类似于<strong>VNC 与 SSH</strong>之间使用体验的差距。因此笔者认为这其实是对于「云端编程」的两种不同的解决方案，针对的使用场景虽有交叉，但很多情况下是不一样的，因此并不会有哪一方会完全取代另一方的情况出现。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>既然上文已经提到了，JetBrains Projector 和 VSCode Remote 的使用场景并不相同，那这一节就来简单说说 Projector 特别适合解决的问题：</p><ol><li>在<strong>运行时或数据库</strong>附近运行代码以减少往返次数。</li><li><strong>高度安全</strong>的企业环境。</li><li>真正的<strong>大型项目</strong>。</li><li>禁止<strong>源代码</strong>本地复制。</li><li>用户<strong>硬件约束</strong>。</li><li><strong>瘦客户端</strong>。</li><li>需要在 Windows 机器甚至是 ChromeOS 等<strong>非传统操作系统</strong>上的 GNU/Linux 环境中运行 IDE。</li><li>需要在<strong>关闭计算机</strong>后让应用在服务器上继续运行。</li><li><strong>远程调试</strong>服务器端（devtest、devprod）。</li><li>具有调试源和预配置 IDE 的<strong>VM 或 Docker 映像</strong>。</li><li>需要<strong>远程访问的配置</strong>。</li></ol><p>Note：Projector <strong>不支持</strong>协作开发。</p><h2 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h2><p>前文说了 JetBrains Projector 是基于 Client + Server 架构的，因此为了体验 Projector，我们需要分别安装 Client 端和 Server 端。</p><h3 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h3><p><img src="https://cdn.ytools.xyz/uPic/MzUr2viShot2021-05-04%2019.57.11.png"></p><p>官方给出了三种搭建 Server 端的方式，分别是：</p><ol><li><a href="https://github.com/JetBrains/projector-docker">Docker 镜像</a>：Docker 是在云环境中运行 Projector 的最简单的方法，需要额外安装 Docker 环境。不需要额外安装 IDEA，如果只是为了体验，推荐该方式。</li><li><a href="https://github.com/JetBrains/projector-installer">Python 脚本</a>：通过 PyPi 安装，这是一个独立的发行版，目前仅适用于 GNU/Linux 主机。</li><li><a href="https://github.com/JetBrains/projector-server">IDE 插件</a>：需要有图形界面的电脑支持并运行 Jetbrains IDE，通过安装 Projector 插件来作为服务端。<blockquote><p>PS：个人觉得第三种方式有多此一举的嫌疑，既然远程服务器都已经具备图形界面了，那我直接使用 VNC 不就好了吗？</p></blockquote></li></ol><p>搭建过程很简单，这里选择 Docker 搭建 Projector 服务，直接选择以下几个命令安装指定 IDE 即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-clion</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-datagrip</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-goland</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-idea-c</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-idea-u</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-phpstorm</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-pycharm-c</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-pycharm-p</span><br><span class="line">docker pull registry.jetbrains.team/p/prj/containers/projector-webstorm</span><br></pre></td></tr></table></figure><p>例如，这个代码段可以拉取 IntelliJ IDEA Community Edition：</p><p><code>docker pull registry.jetbrains.team/p/prj/containers/projector-idea-c</code></p><p>然后运行镜像，执行以下命令，将<IMAGE_ID>换成刚刚下载完成的镜像 ID 即可。</p><p><code>docker run --rm -p 8887:8887 -it &lt;IMAGE_ID&gt;</code></p><p>出现以下内容说明 Server 端安装成功 👇</p><p><img src="https://cdn.ytools.xyz/uPic/udOlTlimage.png"></p><h3 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h3><p>JetBrains 官方给出两种 Client 端的使用方式，一种是直接通过浏览器访问，另一种是使用官方开发的客户端。</p><p>官方客户端的地址在：<a href="https://github.com/JetBrains/projector-client">https://github.com/JetBrains/projector-client</a></p><h4 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h4><p>我们先通过浏览器访问<a href="http://localhost:8887/">http://localhost:8887/</a>，同意 Policy 后便可以看到如下页面 👇</p><p><img src="https://cdn.ytools.xyz/uPic/RPXJopiShot2021-05-04%2017.03.25.png"></p><p>显示效果和本地的 IDEA 几乎没有差别，当然了，使用体验也还是和服务器的性能有很大关系。</p><h4 id="官方-Client-App"><a href="#官方-Client-App" class="headerlink" title="官方 Client App"></a>官方 Client App</h4><p>我们打开官方提供的客户端后填入刚才的地址便会显示同样的效果。</p><p><img src="https://cdn.ytools.xyz/uPic/Fkl5VeiShot2021-05-04%2017.11.55.png"></p><p>在简单阅读了这个官方 App 的源码后发现这个 Desktop App 其实是基于 Electron 的，有趣的是，虽然使用的是自家的 Kotlin 语言编写，但不知道为什么不顺便使用自家的<strong>Compose for Desktop</strong>。</p><h4 id="浏览器访问的一些缺点"><a href="#浏览器访问的一些缺点" class="headerlink" title="浏览器访问的一些缺点"></a>浏览器访问的一些缺点</h4><p>虽然通过官方 App 使用 Projector 很方便，但说到底我还是要下载一个应用程序，既然都这样了，和 VSCode Remote 也没什么区别，我为什么不直接使用浏览器访问呢？<br>其实官方文档中已经针对这个疑问做了详细的<a href="https://jetbrains.github.io/projector-client/mkdocs/latest/ij_user_guide/accessing/#known-issues">说明</a>：</p><ol><li>iPad 不支持 self-signed WebSockets，即不安全的 Websockets 连接（较新的安卓其实也不支持），因此想利用 iPad 访问局域网内的 Projector 会有些麻烦，当然了，你给服务器添加 HTTPS 访问也是可以的。</li><li>一些快捷键会被浏览器拦截，例如，Windows/Linux 中的 Ctrl+Q 或 Mac 中的 Cmd+N 是由浏览器处理的。这可能会导致你在使用 Projector 无法使用一些快捷键。</li><li>剪切板不同步，服务端的剪切板会有一些限制，使得开发过程中的复制与粘贴会出现一些问题。</li></ol><p>也正是因为上述这些问题，官方才推出了自己的客户端 App。</p><h2 id="头脑风暴——VSCode-on-Browser"><a href="#头脑风暴——VSCode-on-Browser" class="headerlink" title="头脑风暴——VSCode on Browser"></a>头脑风暴——VSCode on Browser</h2><p>通过上述的介绍，相信你对 JetBrains Projector 已经有了一定的了解了，其原理就是改变 Swing 的渲染方式，使其最终可以使用 Web 技术将界面展现出来。</p><p>这时候，我们可以头脑风暴一下，既然 VSCode 基于的 Electron 技术本质上是让运行在浏览器中的网页可以顺畅的运行在桌面端，那么是不是可以进行一个<strong>“逆向”</strong>，将运行在桌面的 VSCode 反向运行在浏览器中呢？这种方式的思路不同于 VSCode Remote，反而和 JetBrains Projector 有些类似，答案当然是可以的，国外也已经有大神将源码开源出来了，详情参考 👉<a href="https://github.com/cdr/code-server">https://github.com/cdr/code-server</a>，这里就不再多说了，感兴趣的读者们可以自行查阅相关资料。</p><p><img src="https://cdn.ytools.xyz/uPic/eSZbixiShot2021-05-04%2017.55.49.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>先前我曾在<a href="https://mp.weixin.qq.com/s/yvprXpCfIIVvm3P6eaO1vg">《云游戏在革谁的命？》</a>一文中讨论过云游戏对于传统游戏的影响以及是否会取代 PC 游戏，其实云端编程和云游戏类似，都需要高速且稳定的网络，在这个万物上云的时代，只有解决了这两点才可以真正将云游戏和云编程推广，我相信这一天很快就会到来。</p><p>以上就是本篇文章的全部内容了，如果觉得对你有所帮助，不妨点个赞，新来的读者不妨给个关注支持一下，你们的支持是我继续更文的最大动力。</p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速适配 Flutter 之语言国际化</title>
      <link href="p/5daa.html"/>
      <url>p/5daa.html</url>
      
        <content type="html"><![CDATA[<p>如果你希望你的 APP 走出海外，那么就需要你在编写代码时考虑支持不同的语言环境，设置一些“本地化”的值，例如文本/布局。Flutter 本身是具备国际化的，在适配方面也较为简单，今天我将会介绍一个名为<strong>Flutter Intl</strong>的插件快速实现 Flutter 的语言国际化。</p><h2 id="Flutter-Intl"><a href="#Flutter-Intl" class="headerlink" title="Flutter Intl"></a>Flutter Intl</h2><p>之前在学习适配国际化的时候，出现最多的一个组件叫做<a href="https://github.com/long1eu/flutter_i18n">flutter_i18n</a>，不过由于一些原因，这个插件已经停止维护了，后来无意中发现了一个名为<a href="https://github.com/localizely/flutter-intl-intellij">Flutter Intl</a>的插件，我们只需要在 VSCode/Android Studio 中安装他即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekw2p60q9j317y0piaeh.jpg"></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>默认情况下，Flutter 仅提供<strong>美国英语</strong>本地化。要添加对其他语言的支持，应用程序必须指定其他 MaterialApp 属性，并包含一个名为的单独包-“flutter_localizations”。</p><p>在<code>pubspec.yaml</code>中添加<code>flutter_localizations</code>依赖并执行<code>packages get</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 国际化</span><br><span class="line">flutter_localizations:</span><br><span class="line">    sdk: flutter</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekw876vqjj30j809474w.jpg"></p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>接下来我们选择<code>Tools -&gt; Flutter Intl -&gt; Initialize for the Project</code>就会对项目进行初始化</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekw46bw6sj31bz0u0trk.jpg"></p><p>初始化结束后，<code>pubspec.yaml</code>中会自动增加以下字段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter_intl:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p>表示国际化已经开启。与此同时，<code>lib</code>目录下会新增<code>generated</code>和<code>l10n</code>两个目录。</p><ul><li><code>l10n</code>目录下为 arb 文件</li><li><code>generated</code>目录下为根据 arb 文件自动生成以下 dart 代码</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekwbdzt1gj30es07saaj.jpg"></p><h2 id="ARB-文件"><a href="#ARB-文件" class="headerlink" title="ARB 文件"></a>ARB 文件</h2><p>ARB 文件扩展名为：Application Resource Bundle 意为应用程序资源包，并得到 Google 的支持，每个<code>.arb</code>文件都包含一个 JSON 表，该表从资源 ID 映射到本地化值，文件名包含已为其转换值的语言环境。</p><p>所以，如果我们想新增一门语言支持的话，只需要<strong>通过插件</strong>添加相应的 arb 文件即可。</p><h2 id="新增语言"><a href="#新增语言" class="headerlink" title="新增语言"></a>新增语言</h2><ul><li>通过插件新增 arb 文件</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekx73udtnj30w60u04fk.jpg"></p><p>然后填入相应的 local 值生成 arb 文件，如<code>zh</code>表示中文。</p><p>之后便会在<code>lib/generated/intl/</code>目录下会生成新的<code>messages_xx.dart</code>文件</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekx9buhvcj30g409qgmd.jpg"></p><h2 id="配置语言"><a href="#配置语言" class="headerlink" title="配置语言"></a>配置语言</h2><p>arb 文件生成成功后，剩下的便是在<code>MaterialApp</code>中配置<code>supportedLocales</code>和<code>localizationsDelegates</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">…………</span><br><span class="line">    <span class="comment">// 设置语言</span></span><br><span class="line">    localizationsDelegates: <span class="keyword">const</span> [</span><br><span class="line">    S.delegate,</span><br><span class="line">    GlobalMaterialLocalizations.delegate,</span><br><span class="line">    GlobalCupertinoLocalizations.delegate,</span><br><span class="line">    GlobalWidgetsLocalizations.delegate</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 讲zh设置为第一项,没有适配语言时，英语为首选项</span></span><br><span class="line">    supportedLocales: S.delegate.supportedLocales,</span><br><span class="line">…………</span><br><span class="line">）</span><br></pre></td></tr></table></figure><p>我们来解释下上面这段代码出现的变量</p><ul><li><p><code>localizationsDelegates</code>列表中的元素是生成本地化值集合的工厂。</p></li><li><p><code>S.delegate</code> 我们项目的本地化委托类，<strong>插件自动生成</strong>，他会根据你的<code>arb</code>文件自动生成对应的函数。</p></li><li><p><code>GlobalMaterialLocalizations.delegate</code> 为 Material Components 库提供了本地化的字符串和其他值。</p></li><li><p><code>GlobalCupertinoLocalizations.delegate</code> 为 Cupertino Components 库提供了本地化的字符串和其他值。</p></li><li><p><code>GlobalWidgetsLocalizations.delegate</code>定义 widget 默认的文本方向，从左到右或从右到左。</p></li></ul><ul><li><code>supportedLocales</code>支持的本地化。</li><li><code>S.delegate.supportedLocales</code>我们项目支持的本地化，<strong>插件自动生成</strong>，它会在你添加<code>arb</code>文件时自动更新你的支持的本地化。</li></ul><p>有关这些应用程序属性的更多信息，它们所依赖的类型以及如何国际化 Flutter 应用程序，可以查阅官方文档 👉<a href="https://flutter.cn/docs/development/accessibility-and-localization/internationalization">《Flutter 应用里的国际化》</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>上文提到了，配置好该插件后，我们需要做的便是在 arb 文件中编辑相应的字段即可，这里给出示例。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geky2xxaz8j32240s4k2o.jpg"></p><p>如果有其他语言，只需要再添加一份 arb 文件即可。</p><p>接下来我么只需要将字符串部分替换掉即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekydyf6wwj31um0dk0wv.jpg"></p><p>然后保存文件，插件就会在<code>message_xx.adart</code>中自动添加对应的函数方便获取该字符串。</p><p>当然，arb 还支持其他语法，这里说下最常见的占位符语法：</p><ul><li>arb 文件</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dialogTip&quot;</span>: <span class="string">&quot;Hello $name&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">S.of(context).dialogTip(<span class="string">&quot;Rhyme&quot;</span>);</span><br></pre></td></tr></table></figure><p>更多使用方式见<a href="https://pub.dev/packages/intl">intl | Dart Package</a></p><h2 id="切换语言"><a href="#切换语言" class="headerlink" title="切换语言"></a>切换语言</h2><p>上面说了这么多都只是告诉我们如何适配多种语言，上面这些操作均是跟随系统自动调整语言的，那么有什么办法可以让用户自定义切换语言呢？自然是可以的。</p><p>我们只需要在合适的地方调用以下代码即可。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">S.load(Locale(<span class="string">&#x27;zh&#x27;</span>, <span class="string">&#x27;CN&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这里的 zh/CN 可以换成其他语言代码。</p><p>然后我们将选择好的语言用<code>SharedPreference</code>保存，每次启动 App 时检查用户设置的语言即可。效果如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekz7ugwlmg30ko17ajyy.gif"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本文的全部内容了，总的来说，有了 Flutter Intl 工具之后，开发者可以省去繁琐的代码配置，安心将精力花在文字适配（翻译）上。</p><p>代码已上传至 Github，觉得有帮助的不妨给个 star👇</p><p><a href="https://github.com/YueYongDev/flutter_challenge/tree/master/lib/localizations">https://github.com/YueYongDev/flutter_challenge/tree/master/lib/localizations</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://pub.dev/packages/intl">intl | Dart Package</a></li><li><a href="https://juejin.im/post/5c701379f265da2d9b5e196a#heading-10">Flutter-国际化适配终结者</a></li><li><a href="https://juejin.im/post/5e4536d0e51d4526ef5f85a9">FunFlutter 系列之国际化 Intl 方案</a></li><li><a href="https://flutter.cn/docs/development/accessibility-and-localization/internationalization">Flutter 应用里的国际化</a></li></ul><hr><p>年前给自己定了一个小目标，如果公众号读者超过 2000 就拉一个读者交流群，有兴趣的可以扫描下方二维码关注公众号「01 二进制」后台回复「加群」，我们一起交流，一起进步，一起成长！</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekzi4r5faj31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当 Python 遇到了你的微信好友</title>
      <link href="p/f791.html"/>
      <url>p/f791.html</url>
      
        <content type="html"><![CDATA[<p>临近毕业，慢慢的也感伤起来，回想大学这几年，除了技术的成长，最值得庆幸的就是结交了一帮志同道合的好友。后期自己做了公众号，微信好友的数量也越来越多，身边人所扮演的角色也越来越丰富，有早已结婚生子为人父母的同学，有沉迷科研学术的教师，当然也少不了一众还在 996 的程序猿。事实上，你所处圈子的质量很大程度上就决定了你的人生质量，那么今天我们就来看看当 Python 遇到了你的微信好友后能擦出怎样的火花。</p><blockquote><p>完整代码可在公众号：「01 二进制」后台回复：「微信好友」获取_</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次我们直奔主题，本文要做的是以下几件事：</p><ol><li>分析微信好友的总人数、男生数、女生数、男女比</li><li>分析好友的地域分布</li><li>利用 <strong>自然语言处理</strong> 的方法分析出你好友的情感倾向</li><li>获取微信好友的头像并拼接成指定图片</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>还是老样子，做实验前，先做好准备工作，实验环境如下：</p><ul><li><p>Python 3.6 （虚拟环境的管理为 Pipenv）</p></li><li><p>Pycharm</p></li><li><p>主要使用到的包有：</p><ul><li>itchat</li><li>pyecharts</li><li>baidu-aip</li><li>photomosaic</li><li>pillow</li></ul></li></ul><blockquote><p>对 Pipenv 这个虚拟环境管理工具不熟悉的可以去看我之前的文章：<a href="https://mp.weixin.qq.com/s/KBLgdsL2UaXfayT0Hdi04A">《Python 管理哪家强？》</a>，里面对于 Pipenv 这个虚拟环境管理工具有一些介绍。</p><p>itchat 是一个开源的微信个人号接口，可以让我们使用 python 来调用微信</p><p>pyecharts 是 python+echarts 的结合，用于进行数据的可视化</p><p>baidu-aip 是百度推出的一个 nlp 的包</p><p>photomosaic 是用来生成蒙太奇马赛克图片的</p></blockquote><p>大家获取到源码之后只需要将 <strong>Pipfile</strong> 复制到你们的项目根路径下，然后再终端执行 <code>pipenv install</code> 即可创建一个安装好所有包的虚拟环境了（前提是你的电脑上已经安装了 pipenv 了）</p><p>做好准备工作后我们就开始吧。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-初始化-itchat"><a href="#1-初始化-itchat" class="headerlink" title="1. 初始化 itchat"></a>1. 初始化 itchat</h3><p>只需一行代码即可初始化 itchat：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itchat.auto_login(hotReload=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>hotReload(热加载)，True 表示其短时间内不需要再次扫码登陆</p><h3 id="2-获取好友列表"><a href="#2-获取好友列表" class="headerlink" title="2. 获取好友列表"></a>2. 获取好友列表</h3><p>同样的也只需要一行代码即可获取：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">friends = itchat.get_friends(update=<span class="literal">True</span>)[<span class="number">0</span>:]</span><br></pre></td></tr></table></figure><p>返回的数据是类 JSON 格式的，我们用 Python 可以很方便的解析，因为篇幅原因，返回的示例我就不展示了，你们自己输出查看就可以了。</p><h3 id="3-分析男女分布情况"><a href="#3-分析男女分布情况" class="headerlink" title="3. 分析男女分布情况"></a>3. 分析男女分布情况</h3><p>首先我们需要获取好友的性别信息，通过分析返回的 JSON 字符串我们发现，在好友的信息中有 Sex 标签，其规律是当其值为 1 是表示男生，2 表示女生，0 表示没有填写的，因而我们可以这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对好友数进行分析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_friends_num</span>(<span class="params">friends</span>):</span></span><br><span class="line">    <span class="comment"># 初始化性别的变量(男、女、其他，其他表示的是注册时没有填写性别信息的)</span></span><br><span class="line">    male = female = others = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 循环得到的全部好友</span></span><br><span class="line">    <span class="comment"># 在好友的信息中有Sex标签,发现规律是当其值为1是表示男生,2表示女生,0表示没有填写的</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> friends[<span class="number">1</span>:]:</span><br><span class="line">        sex = i[<span class="string">&#x27;Sex&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> sex == <span class="number">1</span>:</span><br><span class="line">            male += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sex == <span class="number">2</span>:</span><br><span class="line">            female += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            others += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 总人数</span></span><br><span class="line">    total = len(friends[<span class="number">2</span>:])</span><br><span class="line">    print(<span class="string">&quot;总人数为&quot;</span>, total, <span class="string">&quot;其中男性&quot;</span>, male, <span class="string">&quot;人，女性&quot;</span>, female, <span class="string">&quot;人，男女比为&quot;</span>, round((male / female), <span class="number">2</span>), <span class="string">&quot;:1&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行的结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总人数为 387 其中男性 228 人，女性 116 人，男女比为 1.97 :1</span><br></pre></td></tr></table></figure><p>更加直观的显示如下（可视化的代码在 <strong>utiils</strong> 包下，这里就不放出了，有需要的自己看源码）：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9a809c70dc954b85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="friends_num"></p><p>我的好友里男女比竟然是 2:1（那些没填性别信息的人里面不知道还有多少男生），活该没有女朋友啊，看来下次要多加一些女生的微信了。</p><h3 id="4-好友地域分布"><a href="#4-好友地域分布" class="headerlink" title="4. 好友地域分布"></a>4. 好友地域分布</h3><p>这里我们只要获取到好友的地域信息，然后用两个 <em>dict</em> （分别是省和市）保存即可，key 为地域， value 为该地域的好友数，循环遍历 friends 最后用饼图表示分布最多的 5 个省，用柱状图表示分布最多的 15 个市，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析好友的地域分布</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_friends_location</span>(<span class="params">friends</span>):</span></span><br><span class="line">    province = &#123;&#125;</span><br><span class="line">    city = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> friends[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">&#x27;Province&#x27;</span>] == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            i[<span class="string">&#x27;Province&#x27;</span>] = <span class="string">&#x27;其他&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">&#x27;City&#x27;</span>] == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            i[<span class="string">&#x27;City&#x27;</span>] = <span class="string">&#x27;其他&#x27;</span></span><br><span class="line"></span><br><span class="line">        province[i[<span class="string">&#x27;Province&#x27;</span>]] = province.get(i[<span class="string">&#x27;Province&#x27;</span>], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        city[i[<span class="string">&#x27;City&#x27;</span>]] = city.get(i[<span class="string">&#x27;City&#x27;</span>], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sorted_province = sorted(province.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    sorted_city = sorted(city.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画出分布图</span></span><br><span class="line">    draw_friends_location(sorted_province[<span class="number">0</span>:<span class="number">5</span>], sorted_city[<span class="number">0</span>:<span class="number">15</span>])</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-e77608c929b5231e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-6cf47eeec6f25ce1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>看到这大家应该也能猜到我主要的活动区域是哪了吧，有兴趣的大家可以猜一猜然后在文末留言哦。</p><h3 id="5-好友情感分析"><a href="#5-好友情感分析" class="headerlink" title="5. 好友情感分析"></a>5. 好友情感分析</h3><p>当你想要了解一个人心态（注意是心态而不是动态）的时候，你往往都会去看他的签名而不是朋友圈，因为签名更改的频率很低，很大程度上会反映这个人的情绪和心态。相比之下，朋友圈更新的频率较高，因为是要分享自己近期的动态的（我就见过有的女生一条朋友圈分成好几条发，每次只发几个字）。因此对好友的签名进行分析是可以分析出她的情绪的，那么我们该如何分析情感呢？</p><p>这里实名夸奖一下百度，作为国内技术的老大哥，很久之前百度就已经<strong>免费开放</strong>了他的一些人工智能接口，其中就有情感倾向分析，官网是<a href="https://ai.baidu.com/tech/nlp_apply/sentiment_classify">https://ai.baidu.com/tech/nlp_apply/sentiment_classify</a>，这些<strong>免费的</strong>人工智能接口的开放对于我们这些个人开发者无疑是个福音。下面是他的功能演示截图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-46dddf29d6e5bde9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>他的用法也很简单，安装好<em>baidu-aip</em>包之后，申请下 appkey、appid 和 secretkey 后即可使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = AipNlp(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_text</span>(<span class="params">text</span>):</span></span><br><span class="line">    res = client.sentimentClassify(text.strip())</span><br><span class="line">    <span class="keyword">return</span> res[<span class="string">&#x27;items&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;sentiment&#x27;</span>]</span><br></pre></td></tr></table></figure><p>因此我们要做的无非就是获取好友的签名，然后传入<code>analyze_text</code>函数即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析好友的签名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_friends_signature</span>(<span class="params">friends</span>):</span></span><br><span class="line">    positive = <span class="number">0</span></span><br><span class="line">    negative = <span class="number">0</span></span><br><span class="line">    others = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;签名情感分析中，请稍后......&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(friends[<span class="number">1</span>:]):</span><br><span class="line">        text = item[<span class="string">&#x27;Signature&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> text != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                print(<span class="string">&#x27;正在分析第&#x27;</span>, index, <span class="string">&#x27;条签名：&#x27;</span>, text, <span class="string">&#x27;他的作者是：&#x27;</span>, item[<span class="string">&#x27;NickName&#x27;</span>], <span class="string">&#x27;你给他的备注是：&#x27;</span>, item[<span class="string">&#x27;RemarkName&#x27;</span>])</span><br><span class="line">                res = analyze_text(text)</span><br><span class="line">                <span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">                    negative = negative + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res == <span class="number">1</span>:</span><br><span class="line">                    others = others + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res == <span class="number">2</span>:</span><br><span class="line">                    positive = positive + <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>看到这有人会有疑问了，我的好友人数有上千，免费的接口能用这么多次吗？事实上，他真的可以用这么多次 😂</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-73cc4d2877b07e30.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>看到这我突然想给百度打 call，这也太良心了吧。请问贵公司还缺实习生吗，我想去应聘 😂。然后我们来看看我的好友的情绪分析图吧。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-f77ae45100ad3c42.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>没想到我的好友里面竟然还有 17.83%的人有消极情绪，看来必要的时候得”we need to talk”了。</p><h3 id="6-利用好友的微信头像生成指定的照片"><a href="#6-利用好友的微信头像生成指定的照片" class="headerlink" title="6. 利用好友的微信头像生成指定的照片"></a>6. 利用好友的微信头像生成指定的照片</h3><p>看标题你们可能不懂是什么意思，直接放图你们就明白了：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-5c451aca78577b21.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这张图远看是一张一个人跳舞的图片，其实仔细看就知道了，构成这张图的是我的 300 多张微信好友的图像，这里我使用到了一个名为<code>photomosaic</code>的库，它是专门用来制作这种蒙太奇马赛克风格的图片的，是我无意中在知乎上看到的，所以大家有事没事还是逛逛知乎，多少能发现些好玩意。</p><p>接下来我们来看看如何生成上述图片。</p><p><strong>第一步，我们先获取好友的头像：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取好友头像</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_friends_avatar</span>(<span class="params">friends</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(friends):</span><br><span class="line">        print(<span class="string">&quot;正在下载第 %d 张头像&quot;</span> % index)</span><br><span class="line">        img = itchat.get_head_img(userName=item[<span class="string">&quot;UserName&quot;</span>])</span><br><span class="line">        file_image = open(os.getcwd() + <span class="string">&quot;/app/temp/&quot;</span> + item[<span class="string">&quot;UserName&quot;</span>] + <span class="string">&quot;.jpg&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        file_image.write(img)</span><br><span class="line">        file_image.close()</span><br></pre></td></tr></table></figure><p>也很简单，直接调用 itchat 的<code>get_head_img</code>方法然后保存到本地指定文件夹下即可。</p><p><strong>第二步，利用 photomosaic 生成目标图片</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用好友头像生成蒙太奇马赛克图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_friends_mosaic_image</span>():</span></span><br><span class="line">    <span class="comment"># 读取基准图，即要生成的蒙太奇马赛克图片的原始图</span></span><br><span class="line">    image = pm.imread(os.getcwd() + <span class="string">&#x27;/assets/cxk.jpg&#x27;</span>)</span><br><span class="line">    <span class="comment"># 定义图片库</span></span><br><span class="line">    pool = pm.make_pool(os.getcwd() + <span class="string">&#x27;/temp/*.jpg&#x27;</span>)</span><br><span class="line">    <span class="comment"># 制作50*50的拼图马赛克,(50, 50)是指每一行和每一列使用图片库中的图像的个数</span></span><br><span class="line">    mosaic = pm.basic_mosaic(image, pool, (<span class="number">50</span>, <span class="number">50</span>))</span><br><span class="line">    <span class="comment"># 保存制作好的图片</span></span><br><span class="line">    pm.imsave(os.getcwd() + <span class="string">&#x27;/output/friends_mosaic_image.jpg&#x27;</span>, mosaic)</span><br></pre></td></tr></table></figure><p>四行代码即可，原理的话知乎上有写，有兴趣的可以自己去搜一搜。</p><p>当然了，不是每个人的微信好友都有上千人，所以拼接出来的效果就不是很好，比如我自己的那个就不是很好，既然这样的话我就推荐另一个拼接头像的方法，不过效果要稍微差点，拼成的图长这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-2d428bc6a4e7b90a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="friends_avators"></p><p>这里的代码来自我关注的一个公众号，就不放出代码了，大伙感兴趣的可以去看下他的文章：<a href="https://mp.weixin.qq.com/s/T22CF1y1urvlCQwv3yxRVA">《一键拼出你的微信好友图片墙》</a></p><p>这张图虽然观赏效果不如上一张，但好在每个头像都很清楚，大伙儿看看能不能快速找到自己的头像呢？欢迎在留言区评论互动哦～</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>完整代码可在公众号：「01 二进制」后台回复：「微信好友」获取</p></blockquote><p>方法教给大家了，图片素材可以优化，大家可以生成自己喜欢的蒙太奇图片，发到朋友圈，让代码骚动起来吧！</p><p>写到这，我想说的是，你朋友的质量决定你生命的质量，想成为一个高层次的人，那就请跟优秀的朋友为舞</p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter主题切换——让你的APP也能一键换肤</title>
      <link href="p/adf2.html"/>
      <url>p/adf2.html</url>
      
        <content type="html"><![CDATA[<p>为了让你的 App 更美观，主题切换已经是一个必不可少的功能了，但如果想在传统的 Android 和 iOS 上分别适配不同的主题相当繁琐。但这一切，在 Flutter 中都非常容易实现。今天我们就来看看，如何在 Flutter 中给你的 App 添加换肤功能。我们要实现的效果如下：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge4zj2hqp4g30io12ywz4.gif" style="zoom:33%;" /><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在该案例中，我使用到了 <code>provider</code> 和 <code>flustars</code> 两个库，简单介绍一下这两个库：</p><h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p>官方推荐的<strong>状态管理</strong>库，相比其他状态管理库使用起来比较方便。</p><blockquote><p>状态管理：通俗的讲，当我们想在多个页面（组件/Widget）之间共享状态（数据），或者一个页面（组件/Widget）中的多个子组件之间共享状态（数据），这个时候我们就可以用 Flutter 中的状态管理来管理统一的状态（数据），实现不同组件直接的传值和数据共享。</p></blockquote><h3 id="flustars"><a href="#flustars" class="headerlink" title="flustars"></a>flustars</h3><p>号称“Flutter 全网最全常用工具类”，其中包括了<code>SpUtil</code>、<code>ScreenUtil</code>、<code>TimelineUtil</code>等常见工具类，这里我们要使用的是<code>SpUtil</code>这个部分，用于存储用户所选择的主题信息。</p><hr><p>以上就是关于我们使用的两个第三方库的介绍，如果想要使用，我们需要在<code>pubspec.yaml</code>文件中添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">provider:</span> <span class="string">^4.0.5</span></span><br><span class="line"><span class="attr">flustars:</span> <span class="string">^0.2.6+1</span></span><br></pre></td></tr></table></figure><p>准备工作做好了，接下来我们就开始编码吧。</p><h2 id="添加主题样式"><a href="#添加主题样式" class="headerlink" title="添加主题样式"></a>添加主题样式</h2><p>我们需要先想好自己所需要切换的主题样式列表，如果觉得麻烦的可以直接用下面的内容：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Color&gt; themeColorMap = &#123;</span><br><span class="line">  <span class="string">&#x27;gray&#x27;</span>: Colors.grey,</span><br><span class="line">  <span class="string">&#x27;blue&#x27;</span>: Colors.blue,</span><br><span class="line">  <span class="string">&#x27;blueAccent&#x27;</span>: Colors.blueAccent,</span><br><span class="line">  <span class="string">&#x27;cyan&#x27;</span>: Colors.cyan,</span><br><span class="line">  <span class="string">&#x27;deepPurple&#x27;</span>: Colors.purple,</span><br><span class="line">  <span class="string">&#x27;deepPurpleAccent&#x27;</span>: Colors.deepPurpleAccent,</span><br><span class="line">  <span class="string">&#x27;deepOrange&#x27;</span>: Colors.orange,</span><br><span class="line">  <span class="string">&#x27;green&#x27;</span>: Colors.green,</span><br><span class="line">  <span class="string">&#x27;indigo&#x27;</span>: Colors.indigo,</span><br><span class="line">  <span class="string">&#x27;indigoAccent&#x27;</span>: Colors.indigoAccent,</span><br><span class="line">  <span class="string">&#x27;orange&#x27;</span>: Colors.orange,</span><br><span class="line">  <span class="string">&#x27;purple&#x27;</span>: Colors.purple,</span><br><span class="line">  <span class="string">&#x27;pink&#x27;</span>: Colors.pink,</span><br><span class="line">  <span class="string">&#x27;red&#x27;</span>: Colors.red,</span><br><span class="line">  <span class="string">&#x27;teal&#x27;</span>: Colors.teal,</span><br><span class="line">  <span class="string">&#x27;black&#x27;</span>: Colors.black,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-Provider-进行全局状态管理"><a href="#使用-Provider-进行全局状态管理" class="headerlink" title="使用 Provider 进行全局状态管理"></a>使用 Provider 进行全局状态管理</h2><p>然后我们就需要使用 Provider 来进行全局的状态管理了。首先先创建一个<code>app_provider.dart</code>文件，然后添加如下代码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppInfoProvider</span> <span class="title">with</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _themeColor = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> themeColor =&gt; _themeColor;</span><br><span class="line"></span><br><span class="line">  setTheme(<span class="built_in">String</span> themeColor) &#123;</span><br><span class="line">    _themeColor = themeColor;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是全局的状态管理，接下来我们需要在<code>main.dart</code>文件中配置一下刚才创建的 provider，有多个状态管理就使用 MultiProvider，单个的使用 Provider.value 就行了。（考虑到未来项目的扩展，这里我就直接使用 MultiProvider）了</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  Color _themeColor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [ChangeNotifierProvider.value(value: AppInfoProvider())],</span><br><span class="line">      child: Consumer&lt;AppInfoProvider&gt;(</span><br><span class="line">        builder: (context, appInfo, _) &#123;</span><br><span class="line">          <span class="built_in">String</span> colorKey = appInfo.themeColor;</span><br><span class="line">          <span class="keyword">if</span> (themeColorMap[colorKey] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            _themeColor = themeColorMap[colorKey];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> MaterialApp(</span><br><span class="line">            title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">            theme: ThemeData(</span><br><span class="line">              primaryColor: _themeColor,</span><br><span class="line">              floatingActionButtonTheme:</span><br><span class="line">                  FloatingActionButtonThemeData(backgroundColor: _themeColor),</span><br><span class="line">            ),</span><br><span class="line">            home: MyHomePage(title: <span class="string">&#x27;Flutter Theme Change demo&#x27;</span>),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要在某个地方改变主题，我们只需要执行下面这行代码即可。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Provider.of&lt;AppInfoProvider&gt;(context).setTheme(colorKey);</span><br></pre></td></tr></table></figure><p>我们先来说说上面这段代码，重点就在于 ThemeData 的设置：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge4y775ad5j31g406udha.jpg"></p><p>我们看看<code>ThemeData</code>部分数据定义：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ThemeData(&#123;</span><br><span class="line">  Brightness brightness, <span class="comment">//深色还是浅色</span></span><br><span class="line">  MaterialColor primarySwatch, <span class="comment">//主题颜色样本，见下面介绍</span></span><br><span class="line">  Color primaryColor, <span class="comment">//主色，决定导航栏颜色</span></span><br><span class="line">  Color accentColor, <span class="comment">//次级色，决定大多数Widget的颜色，如进度条、开关等。</span></span><br><span class="line">  Color cardColor, <span class="comment">//卡片颜色</span></span><br><span class="line">  Color dividerColor, <span class="comment">//分割线颜色</span></span><br><span class="line">  ButtonThemeData buttonTheme, <span class="comment">//按钮主题</span></span><br><span class="line">  Color cursorColor, <span class="comment">//输入框光标颜色</span></span><br><span class="line">  Color dialogBackgroundColor,<span class="comment">//对话框背景颜色</span></span><br><span class="line">  <span class="built_in">String</span> fontFamily, <span class="comment">//文字字体</span></span><br><span class="line">  TextTheme textTheme,<span class="comment">// 字体主题，包括标题、body等文字样式</span></span><br><span class="line">  IconThemeData iconTheme, <span class="comment">// Icon的默认样式</span></span><br><span class="line">  TargetPlatform platform, <span class="comment">//指定平台，应用特定平台控件风格</span></span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面只是<code>ThemeData</code>的一小部分属性，完整的数据定义读者可以查看 SDK。</p><blockquote><p>之所以使用<code>floatingActionButtonTheme</code>单独设置<code>floatingActionButton</code>而不是使用<code>accentTextTheme</code>，是因为会有警告 ⚠️<code>The support for configuring the foreground color of FloatingActionButtons using ThemeData.accentIconTheme has been deprecated. Please use ThemeData.floatingActionButtonTheme instead. See https://flutter.dev/go/remove-fab-accent-theme-dependency. This feature was deprecated after v1.13.2.</code>意思就是这个属性将会在<code>1.13.2</code>中被废弃。不过并不影响我们现在的使用。</p></blockquote><p>更多关于主题的内容可以参考 👉<a href="https://book.flutterchina.club/chapter7/theme.html">颜色和主题</a></p><h2 id="持久化选择的主题"><a href="#持久化选择的主题" class="headerlink" title="持久化选择的主题"></a>持久化选择的主题</h2><p>这里就需要使用到一开始提到的<code>flustars</code>中的<code>SpUtil</code>了，我们一般会在页面初始化加载的时候读取保存的颜色信息，所以我们需要在初始化页面配置如下代码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> _colorKey;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  _initAsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; _initAsync() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> SpUtil.getInstance();</span><br><span class="line">  _colorKey = SpUtil.getString(<span class="string">&#x27;key_theme_color&#x27;</span>, defValue: <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">  <span class="comment">// 设置初始化主题颜色</span></span><br><span class="line">  Provider.of&lt;AppInfoProvider&gt;(context, listen: <span class="keyword">false</span>).setTheme(_colorKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>await SpUtil.getInstance();</code>这段代码用于加载<code>SpUtil</code>库，通过看源码我们知道，这个库采用了<strong>单例模式</strong>，当然，这不是这篇文章的重点。</p></blockquote><p>上面这段代码用于初始化主题，我们通过<code>SpUtil.getString(&#39;key_theme_color&#39;, defValue: &#39;blue&#39;);</code>获取保存的主题信息，然后再使用<code>Provider.of&lt;AppInfoProvider&gt;(context, listen: false).setTheme(_colorKey);</code>设置主题即可。</p><p>初始化主题弄好了，那选择的代码又如何编写呢？</p><p>很简单，只需要才合适的地方调用下面的代码就可以了。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setState(() &#123;</span><br><span class="line">  _colorKey = key;</span><br><span class="line">&#125;);</span><br><span class="line">SpHelper.putString(<span class="string">&#x27;key_theme_color&#x27;</span>, key);</span><br><span class="line">Provider.of&lt;AppInfoProvider&gt;(context).setTheme(key);</span><br></pre></td></tr></table></figure><p>思路和上面大同小异，无非是将<code>getString</code>换成了<code>putString</code>。</p><h2 id="切换主题控件的编写"><a href="#切换主题控件的编写" class="headerlink" title="切换主题控件的编写"></a>切换主题控件的编写</h2><p>上面的代码提供了切换主题的思路，但是对于用户来说，他们所要做的是有一个界面可以让他们直接切换主题，因此，下面我们来编写切换主题的控件。</p><p>因为切换主题通常会在设置界面中出现，所以这里我用了一个<code>ExpansionTile</code>，这是一个可以展开的<code>ListTile</code>，代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">…………</span><br><span class="line">ExpansionTile(</span><br><span class="line">  leading: Icon(Icons.color_lens),</span><br><span class="line">  title: Text(<span class="string">&#x27;颜色主题&#x27;</span>),</span><br><span class="line">  initiallyExpanded: <span class="keyword">false</span>,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Padding(</span><br><span class="line">      padding: EdgeInsets.only(left: <span class="number">10</span>, right: <span class="number">10</span>, bottom: <span class="number">10</span>),</span><br><span class="line">      child: Wrap(</span><br><span class="line">        spacing: <span class="number">8</span>,</span><br><span class="line">        runSpacing: <span class="number">8</span>,</span><br><span class="line">        children: themeColorMap.keys.map((key) &#123;</span><br><span class="line">          Color value = themeColorMap[key];</span><br><span class="line">          <span class="keyword">return</span> InkWell(</span><br><span class="line">            onTap: () &#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                _colorKey = key;</span><br><span class="line">              &#125;);</span><br><span class="line">              SpUtil.putString(<span class="string">&#x27;key_theme_color&#x27;</span>, key);</span><br><span class="line">              Provider.of&lt;AppInfoProvider&gt;(context, listen: <span class="keyword">false</span>)</span><br><span class="line">                  .setTheme(key);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Container(</span><br><span class="line">              width: <span class="number">40</span>,</span><br><span class="line">              height: <span class="number">40</span>,</span><br><span class="line">              color: value,</span><br><span class="line">              child: _colorKey == key</span><br><span class="line">                  ? Icon(</span><br><span class="line">                      Icons.done,</span><br><span class="line">                      color: Colors.white,</span><br><span class="line">                    )</span><br><span class="line">                  : <span class="keyword">null</span>,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;).toList(),</span><br><span class="line">      ),</span><br><span class="line">    )</span><br><span class="line">  ],</span><br><span class="line">),</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge4zei70qqj30gu06amx9.jpg"></p><p>上面这段代码就是将我们最开始选定的一些主题<code>themeColorMap</code>展示出来，告诉用户可以切换哪些主题。其中<code>onTap</code>内的代码就是上一节中提到的设置颜色主题的方法，<code>InkWell</code>主要用于提供主题色的点击效果，换成<code>GestureDetector</code>也是可以的。</p><p>至此我们的换肤功能也就完成了，想要获取完整代码的可以关注公众号「01 二进制」，后台回复「Flutter 主题切换」。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是关于如何在 Flutter 中切换主题的详细内容了。可以看出，相较于原生应用主题的适配，在 Flutter 中实现换肤的功能简单很多了。</p><p>最后来发布一篇预告，因为 iOS 13 和 Android 10 系统上都新增了「深色模式」，在文中我也提到了<code>ThemeData</code>的<code>Brightness brightness</code>属性用于表示深色还是浅色。下一篇文章我就来聊一聊深色模式的适配。</p><p>如果你觉得我的文章对你有所帮助，不妨给个赞 👍 或者关注支持一下。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge4zz9ffphj30go0goabc.jpg" alt="黑白大气神秘简约微信公众号二维码" style="zoom:75%;" />]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在腾讯云 Ubuntu18.04 安装配置 MySQL 5.7（踩坑警告⚠️）</title>
      <link href="p/7980.html"/>
      <url>p/7980.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5x0th0e8jj31mi0tc7ea.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>和标题一样，本文的主要内容就是在腾讯云 Ubuntu18.04 上安装配置 MySQL 5.7，之所以要写这篇文章是因为前两天和朋友讨论现在的 mysql 设置 root 账户的密码上和以前不一样了而且后续的操作也比以前麻烦了，他不信相信，然后为了向他验证我的说法，我就把我的一台暂时闲置的腾讯云服务器重装了下系统（程序员较起真来就是这么不讲理 😜）</p><p><img src="http://ww2.sinaimg.cn/bmiddle/006tNc79ly1g5wwtpbjojj30si0s00zo.jpg"></p><p>这不，虽然我证实了我说的，但我也付出了要重新配置我这台服务器的惨痛代价，既然这样倒不如把安装配置的过程记录下。话不多说，我们就开始吧。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>一台腾讯云服务器</li><li>系统环境为 Ubuntu 18.04</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 mysql 非常简单，只需要执行下面两个命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br></pre></td></tr></table></figure><p>检查 MySQL 是否运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><p>如果成功安装，我的会显示如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp6       0      0 [::]:1030               [::]:*                  LISTEN      5743/mysqld</span><br></pre></td></tr></table></figure><p>顺便在这里提一下 **重启/打开/关闭 MySQL ** 的方法是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart/start/stop</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>虽然我们可以通过执行两个命令就能很方便的安装好 MySQL，但是我在安装过程中并没有出现要我写用户名和密码的地方，这让我一脸懵逼，索性在终端输入<code>mysql -u root -p</code>之后，要求我输入密码，可是我并不知道密码，心想可能默认密码就是空吧，直接回车不对，随便输入一个密码也不对，终于在查找了很多资料后，我找到了解决方案。</p><h3 id="查看初始用户名和密码"><a href="#查看初始用户名和密码" class="headerlink" title="查看初始用户名和密码"></a>查看初始用户名和密码</h3><p>查看一个文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cat /etc/mysql/debian.cnf</span><br></pre></td></tr></table></figure><p>在这个文件里面有着 MySQL 默认的用户名和用户密码，<br>最最重要的是：用户名默认的不是 root，而是 debian-sys-maint，如下所示</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically generated for Debian scripts. DO NOT TOUCH!</span></span><br><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = skFz7zS0Fl1t2QHK</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line">[mysql_upgrade]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = skFz7zS0Fl1t2QHK</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></figure><p>记下这里的 <strong><em>user</em></strong> 和 <strong><em>password</em></strong>，然后到终端里输入 <code>mysql -u debian-sys-maint -p </code>，随即会让我们输入密码，此时输入我们刚才记下的密码即可进入 mysql 的 shell 环境了。</p><h3 id="更改访问账户和密码"><a href="#更改访问账户和密码" class="headerlink" title="更改访问账户和密码"></a>更改访问账户和密码</h3><p>每次都这么登录自然很麻烦，因此先想到了更改 root 密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; update mysql.user set authentication_string&#x3D;password(&#39;password&#39;) where user&#x3D;&#39;root&#39;and Host &#x3D; &#39;localhost&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:这里说明下，在 MySQL 5.7 password 字段已从<code>mysql.user</code>表中删除，新的字段名是<code>authenticalion_string</code>。</p></blockquote><p>然后你以为在终端输入<code>mysql -u root -p</code>，然后再输入你刚才设置的密码就可以访问了吗？</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5wxjbrmjaj30f708cglv.jpg"></p><p>天真，怎么会那么简单，想要成长，怎么能不被无情的现实蹂躏一番。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5wxg7dpxxj30ve0300ta.jpg"></p><p>可我明明就已经改过密码了，为啥还是登陆不进去。</p><p>于是我又开始在度娘上搜索，终于找到了问题的原因：</p><blockquote><p>原因是因为在最近的 Ubuntu 安装（当然也可能是其他安装）中，MySQL 默认使用了<code>UNIX auth_socket plugin</code>插件。</p><p>简单来说这意味着当<code>db_users</code>使用数据库时，<strong>将会通过系统用户认证表进行认证</strong>。</p></blockquote><p>你可以通过下面的命令看看你的 root 用户是否设置成了这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE mysql;</span><br><span class="line">mysql&gt; SELECT User, Host, plugin FROM mysql.user;</span><br><span class="line"></span><br><span class="line">+------------------+-----------------------+</span><br><span class="line">| User             | plugin                |</span><br><span class="line">+------------------+-----------------------+</span><br><span class="line">| root             | auth_socket           |</span><br><span class="line">| mysql.sys        | mysql_native_password |</span><br><span class="line">| debian-sys-maint | mysql_native_password |</span><br><span class="line">+------------------+-----------------------+</span><br></pre></td></tr></table></figure><p>如果是这样的话就说明 root 用户正在使用<code>auth_socket</code>插件，对于这种问题，有两种解决方案：</p><ol><li><p><strong>设置你的 root 用户使用 mysql_native_password 插件</strong></p></li><li><p><strong>创建一个与你的系统用户一致的新的数据库用户（推荐）</strong></p></li></ol><h4 id="设置-root-用户使用-mysql-native-password-插件"><a href="#设置-root-用户使用-mysql-native-password-插件" class="headerlink" title="设置 root 用户使用 mysql_native_password 插件"></a><strong>设置 root 用户使用 mysql_native_password 插件</strong></h4><p>因为不推荐采用这种方式，所以这里只是给出要执行的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; update user set plugin&#x3D;&#39;mysql_native_password&#39; where user&#x3D;&#39;root&#39;;</span><br><span class="line">mysql&gt; alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure><h4 id="创建一个新用户"><a href="#创建一个新用户" class="headerlink" title="创建一个新用户"></a>创建一个新用户</h4><p>重点来说下这种方式。之所以要新建一个用户，不单单是为了解决修改 root 账户密码的情况。我们知道，当一个项目的体量上去了，数据库的维护就变得非常重要了，如果发展到一定程度后用户名仍然是 root（如果这时候还开通了外网访问），那安全性就会大大降低。况且每个项目的开发人员肯定不止一个，不同 coder 的权限等级也不一样，能对数据库进行的操作肯定也是不一样的。所以综上所述，我依旧推荐在刚开始安装 mysql 时就新建一个用户进行配置。</p><p><strong>命令：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以<strong>从任意远程主机登陆</strong>，可以使用通配符<code>%</code></li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul><p><strong>举例：</strong></p><p>如果我想创建一个用户名为”lyy”，密码为 123456，且<strong>允许从任意远程主机登陆</strong>，可以执行下面这条命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;lyy&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br></pre></td></tr></table></figure><h4 id="给新创建的用户授权"><a href="#给新创建的用户授权" class="headerlink" title="给新创建的用户授权"></a>给新创建的用户授权</h4><p><strong>命令：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>privileges：用户的操作权限，如<code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>等，如果要授予所的权限则使用<code>ALL</code></li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<code>*</code>表示，如<code>*.*</code></li></ul><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#39;lyy&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;lyy&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><p>这样我们在回到 shell 环境中，执行<code>mysql -u lyy -p</code>然后输入密码就可以进入 mysql 的 shell 环境了。</p><blockquote><p>Tips：如果想要更新某个用户的密码只需要执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set authentication_string&#x3D;password(&#39;password&#39;) where user&#x3D;&#39;username&#39; and host&#x3D;&#39;host&#39;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="设置-mysql-可以外网访问"><a href="#设置-mysql-可以外网访问" class="headerlink" title="设置 mysql 可以外网访问"></a>设置 mysql 可以外网访问</h3><p>在使用 mysql 的过程中，我们往往都会使用 Navicat 等工具对数据库进行可视化管理，这时就需要设置 mysql 外网访问了。</p><p>设置过程分为两步：</p><ol><li>设置用户可以<strong>从任意远程主机登陆</strong></li><li>修改配置文件，注释掉 <code>bind_ip_address</code></li></ol><p>第一步在上面已经说过了，这里来说下第二步：</p><p>mysql 5.7 的配置文件路径在：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>，当我们执行<code>sudo cat /etc/mysql/mysql.conf.d/mysqld.cnf</code>命令时结果如下所示：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5wzesj2e2j30zq0pkjva.jpg"></p><p>在<code>bind-address</code>前添加<code>#</code>注释掉该行即可。</p><blockquote><p>Tips：出于安全考虑，如果我们想要修改 mysql 的启动端口，可以修改上述图片中的 <strong>port</strong> 部分为自己想要的端口号。</p></blockquote><p>在这一切都弄好之后别忘了重新启动下 mysql 哦 😯</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service restart mysql</span><br></pre></td></tr></table></figure><h2 id="连接到-MySQL"><a href="#连接到-MySQL" class="headerlink" title="连接到 MySQL"></a>连接到 MySQL</h2><p>这里我们使用 Navicat 连接到 mysql，其实步骤很简单，打开软件-&gt;新建链接-&gt;编辑信息就可以了，如下所示：</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5wzr04welj30ok0d4ta4.jpg" alt="WX20190812-164325@2x"></p><p>至于怎么下载安装破解 Navicat 这里就不多说了。</p><h2 id="删除-mysql"><a href="#删除-mysql" class="headerlink" title="删除 mysql"></a>删除 mysql</h2><p>最后说下如何卸载 mysql</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove --purge mysql-server-5.7</span><br><span class="line">sudo apt-get remove mysql-server</span><br><span class="line">sudo apt-get autoremove mysql-server</span><br><span class="line">sudo apt-get remove mysql-common</span><br></pre></td></tr></table></figure><p>上面的可能会有些是多余的，之后需要清理残余数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -l |grep ^rc|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> |sudo xargs dpkg -P</span><br></pre></td></tr></table></figure><hr><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5x01onq5yj31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Flutter 中使用 WebView</title>
      <link href="p/d8d0.html"/>
      <url>p/d8d0.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5qvji1u67j30zk0k03zr.jpg"></p><blockquote><p>本文示例代码可在微信公众号「01二进制」后台回复「WebView」查看下载</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道在开发 Native App 时经常会有打开网页的需求，可供的选择通常只有两种：</p><ol><li>在 App 内部打开网页</li><li>通过调用系统自带浏览器打开网页</li></ol><p>以「微信」举例，我们在微信内阅读公众号的时候就是第一种情况，但是微信同时也提供了**<em>Open with Browser**</em> 这一选项，这就是第二种情况了。</p><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5qvvyjigcj315v0u0b29.jpg" alt="image-20190807100211727"></p><h2 id="简单的介绍下-Android-中的-WebView"><a href="#简单的介绍下-Android-中的-WebView" class="headerlink" title="简单的介绍下 Android 中的 WebView"></a>简单的介绍下 Android 中的 WebView</h2><p>想实现第一种效果，我们需要使用一个名为 <strong><em>WebView</em></strong> 的东西，先来看看在 Android 中如何实现一个 WebView 吧。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5qw3u3clgj30s80actai.jpg"></p><p>在 Android 中我们需要先在一个 Layout 中放入 WebView 这个控件，然后在对应的 Activity 或者 Fragment 或者各种 Custom View 中执行一个个的 findViewById……</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5r794x67lj30ws0pywix.jpg"></p><p>额，Android 开发者一定知道我在说什么（真的很麻烦）</p><h2 id="WebView-in-Flutter"><a href="#WebView-in-Flutter" class="headerlink" title="WebView in Flutter"></a>WebView in Flutter</h2><p>Flutter 的 WebView 出现已经有一段时间了，在 Flutter 插件社区官网搜索 WebView 即可搜索到比较流行的插件，如下图所示：</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5qx4de5hij31ii0rate7.jpg"></p><p>其中 <strong><em>webview_flutter</em></strong> 是官方维护的 WebView 插件，特性是基于原生和 Flutter SDK 封装，继承 StatefulWidget，因此支持内嵌于 <em>flutter Widget</em> 树中，这是比较灵活的；</p><p><strong><em>flutter_webview_plugin</em></strong> 则是基于原生 WebView 封装的 Flutter 插件，将原生的一些基本使用 API 封装好提供给 Flutter 调用，因此并不能内嵌于 Flutter Widget 树中，因此在界面的跳转必须得先释放掉，返回后又要重新初始化，所以显示会有很多限制性；</p><p><strong><em>interactive_webview</em></strong> 则是基于 <em>webview_flutter</em> 封装的 Flutter 插件，因此原理特性上基本与官方 WebView 一致的；</p><p>在2018年 Flutter 发展初期，官方的 <em>webview_flutter</em> 插件有很多问题，不过好在官方一直没有放弃，现在的插件已经修复了很多 bug 了，基本功能也在不断完善中👏。</p><p><em>flutter_webview_plugin</em> 插件由于其特性原因使用不灵活，因此本文我将会选择官方提供的 <strong><em>webview_flutter</em></strong> 作为加载网页的 WebView 插件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong><em>webview_flutter</em></strong> 插件的地址为👉<a href="https://pub.flutter-io.cn/packages/webview_flutter">https://pub.flutter-io.cn/packages/webview_flutter</a></p><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>和任何一个 Flutter package 一样，我们需要在 <strong><code>pubspec.yml</code></strong> 中的 <strong><code>dependencies</code></strong> 下加入 <em>webview_flutter</em> 的 package </p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">webview_flutter:</span> <span class="string">^0.3.10+4</span></span><br></pre></td></tr></table></figure><p>然后点击标签栏出现的 <strong><em>Packages get</em></strong>，或者在终端输入 <code>Flutter package get</code>，顺序如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5r53w28g6j32l80son7b.jpg"></p><h3 id="新建一个-Widget"><a href="#新建一个-Widget" class="headerlink" title="新建一个 Widget"></a>新建一个 Widget</h3><p>接下来我们新建一个 WebViewWidget，这个 Widget 接收两个参数，分别是浏览器页面标题和浏览页面的 Url，我将其命名为 <code>    Browser</code> ，并存放在 <code>browser.dart</code> 文件中。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:webview_flutter/webview_flutter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Browser(&#123;Key key, <span class="keyword">this</span>.url, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> url;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(title),</span><br><span class="line">      ),</span><br><span class="line">      body: WebView(</span><br><span class="line">        initialUrl: url,</span><br><span class="line">        javascriptMode: JavascriptMode.unrestricted,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用该页面"><a href="#使用该页面" class="headerlink" title="使用该页面"></a>使用该页面</h3><p>在这里我们用一个新的页面来盛放 WebView，因此我们想使用他的时候只需要跳转到该页面，并传入标题和网址即可。这里以某个 <strong><em>RaisedButton</em></strong> 的 <code>onPressed()</code> 举例</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: () &#123;</span><br><span class="line">  Navigator.of(context)</span><br><span class="line">      .push(<span class="keyword">new</span> MaterialPageRoute(builder: (_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Browser(</span><br><span class="line">      url: <span class="string">&quot;https://flutter-io.cn/&quot;</span>,</span><br><span class="line">      title: <span class="string">&quot;Flutter 中文社区&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对了别忘了要在 IOS 模块的 Runner 中的 <strong><em>info.plist</em></strong> 文件中加入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;io.flutter.embedded_views_preview&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;YES&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure><p>不然这个 package 可没办法在 iOS 设备上运行！</p><p>运行效果如下图所示：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5r5w4s06cg30dc0do1kz.gif"></p><blockquote><p>这里只是简单介绍 webview 在 Flutter 中的使用，其中的高级特性比如与 JavaScript 交互并没有介绍到，有兴趣的读者可以自行查找资料阅读。</p></blockquote><h3 id="这就结束了吗？"><a href="#这就结束了吗？" class="headerlink" title="这就结束了吗？"></a>这就结束了吗？</h3><p>其实到这里的时候应该是就已经结束了，但是我在使用过程中发现了一个很严重的问题，如果我们的 URL 是 HTTP 而不是 HTTPS 的话，那么就只可以在 Android 9.0 以下的设备运行（iOS同样不可以）。</p><p>如果运行在 iOS 上会出现白屏，如果运行在 Android 9.0+ 的设备上就会出现 <strong>net：：ERR_CLEARTEXT_NOT_PERMITTED</strong> 的错误。</p><p>其实原因很简单，因为无论是 iOS 还是 Android 9.0+ 都对非 HTTPS 的请求做了一些限制，下面给出我的解决方案。</p><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>我们需要在  IOS 模块的 Runner 中的 <strong><em>info.plist</em></strong> 文件中添加如下字段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;&#x2F;key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;NSAllowsArbitraryLoads&lt;&#x2F;key&gt;</span><br><span class="line">&lt;true&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure><p>然后执行 <code>flutter clean</code> 后重新运行即可访问 HTTP 网页了。</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>很抱歉，其实到现在我也没找到在 Android 9.0+ 上通过 flutter 的 webview 访问 HTTP 网站的办法，我写在这里也是希望如果我的读者找到了解决方案的话欢迎在评论区留言。这里就说一下我尝试的一些解决办法。</p><p>其实如果是 Android <strong>原生</strong>想解决 HTTP 限制问题有以下几种方案：</p><ol><li>切换到 HTTPS </li><li>将 <strong><em>targetSdkVersion</em></strong> 的版本号改到 28 以下</li><li>在 <code>AndroidManifest.xml</code> 文件中增加 <code>android:usesCleartextTraffic=&quot;true&quot;</code> 配置项</li></ol><p>第一个解决方法通常是针对自己的网站的，毕竟你总不能让第三方网站申请 HTTPS 证书吧。</p><p>第二个解决方案在 Flutter 中是无法实现的，因为 Flutter 的运行是需要 Android SDK 28 以上的。</p><p>第三种方法我也试了，但是并没有效果。</p><p>我查阅了很多资料，也发现了一个曲线救国的做法，就是检测要访问的网页，如果是 HTTPS 的就利用 WebView 访问，如果是 HTTP 的就调用第三方浏览器访问。</p><p>额，这个做法吧，不好评价。</p><p>我已经在 StackOverflow 和 Flutter 的 issue 提交了问题，如果后续有解决方案，我会持续更新的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，随着 Google 对 WebView 控件的不断更新，其体验越来越好了，使用起来相对于原生的 WebView 也更加简便，如果你有在你的 App 内使用 WebView 的想法不妨尝试一下😊</p><blockquote><p>本文示例代码可在微信公众号「01二进制」后台回复「WebView」查看下载</p></blockquote><p><strong>参考</strong></p><ol><li><a href="https://medium.com/@chloe.thhsu/%E5%A6%82%E4%BD%95%E5%9C%A8-flutter-%E4%B8%AD%E4%BD%BF%E7%94%A8-webview-%E5%B0%8F%E5%A5%B3-android-%E5%B7%A5%E7%A8%8B%E5%B8%AB%E5%AF%A6%E9%A9%97%E7%AD%86%E8%A8%98-75969b36abba">如何在 Flutter 中使用 WebView？- 小女 Android 工程師實驗筆記</a></li><li><a href="https://www.concettolabs.com/blog/webviews-in-flutter-what-an-amazing-breakthrough/">WebViews in Flutter – What an Amazing Breakthrough!</a></li><li><a href="https://stackoverflow.com/questions/57040443/android-9-cleartext-http-traffic-not-permitted-in-webview">Android 9: Cleartext HTTP traffic not permitted in webview</a></li></ol><hr><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5r75b6xx2j31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像检索系列——利用深度学习实现以图搜图</title>
      <link href="p/cd72.html"/>
      <url>p/cd72.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>文中源码可在微信公众号「01 二进制」后台回复「图像检索」获取。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/rDJywEUcJ_tOgb6vlMOB0w">《图像检索系列——利用 Python 检测图像相似度》</a>中，我们介绍了一个在图像检索领域非常常用的算法——<strong>感知哈希算法</strong>。这是一个很简单且快速的算法，其原理在于针对每一张图片都生成一个特定的“指纹”，然后采取一种相似度的度量方式得出两张图片的近似程度。</p><p>然而随着深度学习的崛起，极大的推动了图像领域的发展，在提取特征这方面而言，神经网络目前有着不可替代的优势。在上一篇文章中我们也介绍了图像检索往往是基于图像的特征比较，看特征匹配的程度有多少，从而检索出相似度高的图片。而检测图像特征，VGG16 具有得天独厚的优势。</p><p>接下来本文将会通过一个简单的案例来实现一个基于深度学习的图像检索小工具。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>老样子，先来准备好我们此次需要使用到的工具：</p><ul><li>IDE：Pycharm</li><li>Python：3.7</li><li>Packages：Keras + TensorFlow + Pillow + Numpy</li></ul><p><strong>keras</strong></p><p>Keras 是一个高层神经网络 API，Keras 由纯 Python 编写而成并基<a href="https://github.com/tensorflow/tensorflow">Tensorflow</a>、<a href="https://github.com/Theano/Theano">Theano</a>以及<a href="https://github.com/Microsoft/cntk">CNTK</a>后端。简单来说，keras 就是对 TF 等框架的再一次封装，使得使用起来更加方便。</p><p><strong>基于 vgg16 网络提取图像特征</strong><br>我们都知道，vgg 网络在图像领域有着广泛的应用，后续许多层次更深，网络更宽的模型都是基于此扩展的，vgg 网络能很好的提取到图片的有用特征，本次实现是基于 Keras 实现的，提取的是最后一层卷积特征。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主要思路是基于 CVPR2015 的论文<a href="http://www.iis.sinica.edu.tw/~kevinlin311.tw/cvprw15.pdf">《Deep Learning of Binary Hash Codes for Fast Image Retrieval》</a>实现的海量数据下的基于内容图片检索系统。简单说来就是对图片数据库的每张图片抽取特征(一般形式为特征向量)，存储于数据库中，对于待检索图片，抽取同样的特征向量，然后并对该向量和数据库中向量的距离（相似度计算），找出最接近的一些特征向量，其对应的图片即为检索结果。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6lk16x1wfj30h90b90v0.jpg"></p><p>用户请求和预处理部分主要是 Web 服务端应该做的，这里不加以讨论，接下来我们主要进行红线标注部分的实现。</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="提取图片特征"><a href="#提取图片特征" class="headerlink" title="提取图片特征"></a>提取图片特征</h3><p>keras 在其<a href="https://keras-cn.readthedocs.io/en/latest/other/application/">中文文档</a>中提供了一个利用 VGG16 提取特征的 demo</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.applications.vgg16 <span class="keyword">import</span> VGG16</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing <span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">from</span> keras.applications.vgg16 <span class="keyword">import</span> preprocess_input</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">model = VGG16(weights=<span class="string">&#x27;imagenet&#x27;</span>, include_top=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&#x27;elephant.jpg&#x27;</span></span><br><span class="line">img = image.load_img(img_path, target_size=(<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">x = image.img_to_array(img)</span><br><span class="line">x = np.expand_dims(x, axis=<span class="number">0</span>)</span><br><span class="line">x = preprocess_input(x)</span><br><span class="line"></span><br><span class="line">features = model.predict(x)</span><br></pre></td></tr></table></figure><p>这里我们需要对其进行简单修改，封装成一个类以便后期调用。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ljn7emj4j31b50u012t.jpg"></p><blockquote><p>考虑到篇幅，文中代码图片已删除较多注释，如需了解详细注释信息，可在微信公众号「01 二进制」后台回复「图像检索」获取源代码。下同</p></blockquote><h3 id="将特征以及对应的文件名保存为-h5-文件"><a href="#将特征以及对应的文件名保存为-h5-文件" class="headerlink" title="将特征以及对应的文件名保存为 h5 文件"></a><strong>将特征以及对应的文件名保存为 h5 文件</strong></h3><h4 id="什么是-h5-文件"><a href="#什么是-h5-文件" class="headerlink" title="什么是 h5 文件"></a>什么是 h5 文件</h4><p>h5 文件是层次数据格式第 5 代的版本（Hierarchical Data Format，HDF5），用以存储和组织大规模数据。</p><p>H5 将文件结构简化成两个主要的对象类型:</p><ol><li><p>数据集 dataset,就是同一类型数据的多维数组</p></li><li><p>组 group,是一种容器结构,可以包含数据集和其他组,若一个文件中存放了不同种类的数据集,这些数据集的管理就用到了 group</p></li></ol><p>直观的理解,可以参考我们的文件系统,不同的文件存放在不同的目录下:</p><p>目录就是 hdf5 文件中的 group,描述了数据集 DataSet 的分类信息,通过 group 有效的将多种 dataset 进行管理和划分。文件就是 hdf5 文件中的 dataset，表示具体的数据</p><p>下图就是数据集和组的关系：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6lk8jnh10j318y0g2q7c.jpg"></p><p>在 Python 中，我们通常使用 h5py 库对 .h5 文件进行操作，具体的读写方法自行百度，这里不在演示。</p><h4 id="抽取数据集中的图像特征保存到-h5-文件中"><a href="#抽取数据集中的图像特征保存到-h5-文件中" class="headerlink" title="抽取数据集中的图像特征保存到 h5 文件中"></a>抽取数据集中的图像特征保存到 h5 文件中</h4><p>我们在项目根目录下命名一个 database 文件夹作为数据集，然后编写一个获取文件夹内图片的方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_imlist</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [os.path.join(path, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path) <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.jpg&#x27;</span>)]</span><br></pre></td></tr></table></figure><p>随后我们便可以依次读取数据然后，一一提取其特征保存到文件中了。如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6lkhn7r8lj31490u0dov.jpg"></p><p>至此，我们就已经算是完成了模型的训练了。</p><h2 id="选一张测试图片测试检索效果"><a href="#选一张测试图片测试检索效果" class="headerlink" title="选一张测试图片测试检索效果"></a>选一张测试图片测试检索效果</h2><p>经过上述操作，我们已经将数据集中的所有图片的特征保存到模型中了，剩下的就是抽取待测图片的特征，然后和特征集中的特征一一比较向量间的相似度（余弦相似度），然后按照相似度排序返回给用户即可。</p><blockquote><p>Tips：各种相似度的 Python 表示可以参考<a href="https://blog.csdn.net/qq_19707521/article/details/78479532">Python Numpy 计算各类距离</a></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ll8o4itmj30u013k4b9.jpg"></p><p>以某一个包包为测试图片，输出结果如下所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6llfgpvc1j30ty046t9f.jpg"></p><p>在 PyCharm 中可以很方便的查看 matplotlib 生成的图片，第一张为测试图片，后面三张为检索图片，可以看出效果相当好了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6llgmdukoj30vy0u0wju.jpg"></p><blockquote><p>Tips：如果想用 Resnet 或者 Densenet 提取特征，只需针对上述代码做出相应的修改，去掉注释修改部分代码即可。详见源码。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此我们已经利用深度学习实现了一个图片检索的小工具了，如何将其和 web/app 结合到一起就不在本文的讨论范围了，有兴趣可以下载本文源码自行更改，也可扫描下方二维码关注微信公众号「01 二进制」与我取得联系。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6llqr08xij31970oxq5a.jpg"></p><p><strong>参考</strong></p><ol><li><a href="https://blog.csdn.net/han_xiaoyang/article/details/50856583">深度学习与计算机视觉(11)_基于 deep learning 的快速图像检索系统</a></li><li><a href="https://www.cnblogs.com/linkmust/articles/9607604.html">基于 VGG-16 的海量图像检索系统（以图搜图升级版）</a></li><li><a href="https://www.twblogs.net/a/5c122893bd9eee5e4183c88d/zh-cn">基于深度学习实现以图搜图功能</a></li><li><a href="https://www.cnblogs.com/chenpeng9/articles/4605577.html">各种相似度计算的 python 实现</a></li><li><a href="https://keras-cn.readthedocs.io/en/latest/other/application/">Application 应用</a></li><li><a href="https://blog.csdn.net/qq_19707521/article/details/78479532">Python Numpy 计算各类距离</a></li><li><a href="https://www.cnblogs.com/abella/p/11125466.html">h5 文件简介</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 以图搜图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 Python 破解 ZIP 或 RAR 文件密码</title>
      <link href="p/4d94.html"/>
      <url>p/4d94.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gakf21vy14j31ax0u0myf.jpg"></p><p>我们经常会从网络上下载一些带密码的压缩包，想要获取里面的内容，往往就要给提供商支付一些费用。想要白嫖其中的内容，常见的做法是百度搜索一些压缩包密码破解软件，但后果相信体验过的人都知道。本文将会利用 Python 破解压缩包的密码，这里以 ZIP/RAR 为例。</p><blockquote><p>本文源码可在微信公众号「01 二进制」后台留言「破解压缩包」获得</p></blockquote><h2 id="破解原理"><a href="#破解原理" class="headerlink" title="破解原理"></a>破解原理</h2><p>其实原理很简单，一句话概括就是「大力出奇迹」，Python 有两个压缩文件库：<code>zipfile</code> 和 <code>rarfile</code>，这两个库提供的解压缩方法 <code>extractall()</code> 可以指定密码，这样的话首先<strong>生成一个密码字典</strong>（手动或用程序），然后依次尝试其中的密码，如果能够正常解压缩则表示密码正确。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>本文采取的虚拟环境为 Pipenv，有关 Pipenv 的详细介绍可以参考我的这篇文章 👉<a href="https://juejin.im/post/5c8b2d01518825068d1d24c3#heading-1">《Python 管理哪家强？》</a></p><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><ul><li><p>zipfile：Python 标准库，使用时直接导入即可</p></li><li><p>rarfile：Python 第三方库，使用时需要安装，API 文档(<a href="https://rarfile.readthedocs.io/en/latest/api.html">https://rarfile.readthedocs.io/en/latest/api.html</a>)</p></li></ul><p><strong>利用 Pipenv 安装 rarfile</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv install rarfile</span><br></pre></td></tr></table></figure><p>最后，再将一个带有密码的压缩包放入实验环境中即可。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>知道原理后，编码就会非常简单了</p><h3 id="准备密码本"><a href="#准备密码本" class="headerlink" title="准备密码本"></a>准备密码本</h3><p>「密码本」其实就是一个包含了所有可能密码的文件，用户可以手动录入，也可以用程序录入。文末还会有一个介绍。</p><h3 id="读取压缩文件"><a href="#读取压缩文件" class="headerlink" title="读取压缩文件"></a>读取压缩文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据文件扩展名，使用不同的库</span></span><br><span class="line"><span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">    fp = zipfile.ZipFile(filename)</span><br><span class="line"><span class="keyword">elif</span> filename.endswith(<span class="string">&#x27;.rar&#x27;</span>):</span><br><span class="line">    fp = rarfile.RarFile(filename)</span><br></pre></td></tr></table></figure><h3 id="尝试解压"><a href="#尝试解压" class="headerlink" title="尝试解压"></a>尝试解压</h3><p>先尝试不用密码解压缩，如果成功则表示压缩文件没有密码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp.extractall(desPath)</span><br><span class="line">fp.close()</span><br><span class="line">print(<span class="string">&#x27;No password&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 读取密码本文件</span></span><br><span class="line">    fpPwd = open(<span class="string">&#x27;pwd.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&#x27;No dict file pwd.txt in current directory.&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> pwd <span class="keyword">in</span> fpPwd:</span><br><span class="line">    pwd = pwd.rstrip()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fp.extractall(path=desPath, pwd=pwd.encode())</span><br><span class="line">        print(<span class="string">&#x27;Success! ====&gt;&#x27;</span>+pwd)</span><br><span class="line">        fp.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">fpPwd.close()</span><br></pre></td></tr></table></figure><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(filename) <span class="keyword">and</span> filename.endswith((<span class="string">&#x27;.zip&#x27;</span>, <span class="string">&#x27;.rar&#x27;</span>)):</span><br><span class="line">        decryptRarZipFile(filename)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;Must be Rar or Zip file&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如果想要使用上述代码，我们只需在命令行执行<code>python main.py &lt;filename&gt;</code>即可。例如<code>python main.py test.zip</code></p><p>运行结果：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ python main.py test.zip</span><br><span class="line">Success! ====&gt;323126</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="密码本如何获取？"><a href="#密码本如何获取？" class="headerlink" title="密码本如何获取？"></a>密码本如何获取？</h3><p>看到这里，细心的小伙伴一定会发现，最核心的其实不是代码，而是<strong>「密码本」</strong>。理论上只要密码本中的密码足够多，就一定能获取到压缩包的密码，这也就是俗称的<strong>「撞库」</strong>。</p><p>这时问题又来了，如何搜集到足够多的密码？我在搜索资料的时候发现已经有人整理好了，我 fork 了一份到了自己的仓库，有兴趣的可以点击 👉<a href="https://github.com/YueYongDev/Blasting_dictionary">爆破字典</a></p><h3 id="如何加速破解过程？"><a href="#如何加速破解过程？" class="headerlink" title="如何加速破解过程？"></a>如何加速破解过程？</h3><p>解决了密码本的问题，深入思考的小伙伴的一定又会有新的疑问，密码本既然如此庞大，那如何加速破解的过程呢？这里给出两个思路</p><h4 id="多线程（进程）破解"><a href="#多线程（进程）破解" class="headerlink" title="多线程（进程）破解"></a>多线程（进程）破解</h4><p>密码本如果很多且密码数量庞大时，我们可以采用多线程（进程）的方式读取密码，一个进程读一个密码本，一个线程分段读密码。当然，如果是在 python 中，建议不要采用多线程，因为 python 中的线程就是鸡肋，有兴趣的可以阅读相关资料。</p><h4 id="利用-GPU-加速"><a href="#利用-GPU-加速" class="headerlink" title="利用 GPU 加速"></a>利用 GPU 加速</h4><p>我们以上的代码都是运行在 CPU 上的，即使开启多线程（进程）也只是利用到 CPU 的资源，但如果想要加速破解过程，我们其实还可以利用闲置的 GPU 资源。</p><p>在介绍为什么可以利用 GPU 加速前，我们需要明确一个观点，两者都为了<strong>完成计算任务</strong>而设计。</p><p>那为什么会想到使用 GPU 加速呢？这是就要说到两者的不同了：CPU 虽然有多核，但总数没有超过两位数，并且每个核的运算能力极其强大。而 GPU 的核数远超 CPU，但每个核的运算能力与 CPU 的核相比就相差甚远了。</p><p>我们可以简单的举个例子，解一道题，CPU 就是博士生，GPU 就是小学生，CPU 负责理解题目并且整理出解题的步骤以及解法，而 GPU 负责其中很简单但是数量又很大的简单运算就行了。</p><p>因此理论上在破解密码的过程中，我们完全可以使用 GPU 来加速这一过程。</p><p>事实上，这样的工具也已经出现了，<strong>Hashcat</strong> 便是最出名的一个，它号称是世界上最快的密码恢复工具，可以基于 CPU/GPU 等工作。有兴趣的可以访问他的<a href="https://hashcat.net/hashcat/">官网</a><a href="https://hashcat.net/hashcat/%E8%BF%9B%E8%A1%8C%E4%BA%86%E8%A7%A3%E3%80%82">https://hashcat.net/hashcat/进行了解。</a></p><hr><p>关注微信公众号「01 二进制」，获取更多 IT 资讯和技巧</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gakgye5et2j31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Python让你的命令行像坤坤一样会打篮球</title>
      <link href="p/7839.html"/>
      <url>p/7839.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1u2kzcj7ej31900u012z.jpg"></p><p>该图片由<a href="https://pixabay.com/zh/users/ArtisticOperations-4161274/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2801140">F. Muhammad</a>在<a href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2801140">Pixabay</a>上发布</p><blockquote><p>完整代码可在公众号：「01二进制」后台回复：「蔡xx篮球」获取</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>承接上文，作为一个经常逛b站的肥宅，近期b站上除了流行”品如”素材的视频，更多的莫过于蔡xx打球视频的了，有模仿的，有对比的，有手绘的，更过分的是竟然有人在命令行输出了他的打球视频，地址在：<a href="https://www.bilibili.com/video/av47306085?from=search&amp;seid=11282891256876390136">https://www.bilibili.com/video/av47306085?from=search&amp;seid=11282891256876390136</a>，不过视频中的动画好像是用某个软件生成的txt文件，看到这我就在想既然都可以用txt输出了，为啥不能用python在命令行中输出呢？说到这我便开始搜索资料，然后制作了下面一段视频：</p><p><video src="/Users/lyy/Downloads/Apr-03-2019 23-21-58.mp4"></video></p><p>代码是我在网上查询资料后自己修改的，本着学习和分享的精神，今天我来分享下上面这段视频的制作过程。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>既然要开始做东西，首要的问题就是想好要怎么做，大家都知道视频是由一系列图片一帧一帧组成的，因此视频转字符动画最基本的便是图片转字符画。</p><p>在这里简单的说一下图片转字符画的原理：首先将图片转为灰度图，每个像素都只有亮度信息（用 0~255 表示）。然后我们构建一个有限字符集合，其中的每一个字符都与一段亮度范围对应，我们便可以根据此对应关系以及像素的亮度信息把每一个像素用对应的字符表示，这样字符画就形成了。</p><blockquote><p>Tips:如果对”灰度图像”这个概念不太理解的可以查阅<a href="https://baike.baidu.com/item/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F">百度百科</a></p></blockquote><p>计算一张图片的灰度图像的方法如下（来自百度百科）：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1u371mownj318w0fun03.jpg" alt="image-20190407151024627"></p><p>所以我们要做的就只是让字符画在命令行里面动起来就可以了。</p><blockquote><p>Tips:图片转字符画可以参考：<a href="https://www.shiyanlou.com/courses/370">https://www.shiyanlou.com/courses/370</a></p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>环境和工具：</p><ul><li>vscode</li><li>Mac OS</li><li>python 3.7</li></ul><p>这次实验使用到的核心的库是opencv-python，关于opencv上篇文章已经简单介绍过了，这里不多阐述了，只要知道这是一个和计算机视觉有关的库就可以了。</p><blockquote><p>Tips：这里分享一个我觉得还不错的opencv-python的中文文档：<a href="https://www.kancloud.cn/aollo/aolloopencv/269602">https://www.kancloud.cn/aollo/aolloopencv/269602</a></p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验开始前我们需要安装opencv-python的包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h3 id="读取视频"><a href="#读取视频" class="headerlink" title="读取视频"></a>读取视频</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genCharVideo</span>(<span class="params">self, filepath</span>):</span></span><br><span class="line">    self.charVideo = []</span><br><span class="line">    <span class="comment"># 用opencv读取视频</span></span><br><span class="line">    cap = cv2.VideoCapture(filepath)</span><br><span class="line">    self.timeInterval = round(<span class="number">1</span> / cap.get(<span class="number">5</span>), <span class="number">3</span>)</span><br><span class="line">    nf = int(cap.get(<span class="number">7</span>))</span><br><span class="line">    print(<span class="string">&#x27;Generate char video, please wait...&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pyprind.prog_bar(range(nf)):</span><br><span class="line">        <span class="comment"># 转换颜色空间，第二个参数是转换类型，cv2.COLOR_BGR2GRAY表示从BGR↔Gray</span></span><br><span class="line">        rawFrame = cv2.cvtColor(cap.read()[<span class="number">1</span>], cv2.COLOR_BGR2GRAY)</span><br><span class="line">        frame = self.convert(rawFrame, os.get_terminal_size(), fill=<span class="literal">True</span>)</span><br><span class="line">        self.charVideo.append(frame)</span><br><span class="line">    cap.release()</span><br></pre></td></tr></table></figure><p>这里的<code>VideoCapture</code>是用来读取视频的，<code>cv2.cvtColor(input_imageﬂag)</code>用于转换颜色空间，其中ﬂag就是转换类型。对于BGR↔Gray的转换，我们使用的ﬂag就是cv2.COLOR_BGR2GRAY。对于BGR↔HSV的转换我们用的ﬂag就是cv2.COLOR_BGR2HSV。</p><h3 id="将帧转换成字符画"><a href="#将帧转换成字符画" class="headerlink" title="将帧转换成字符画"></a>将帧转换成字符画</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ascii_char = <span class="string">&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&#x27;. &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 像素映射到字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pixelToChar</span>(<span class="params">self, luminance</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.ascii_char[int(luminance / <span class="number">256</span> * len(self.ascii_char))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将普通帧转为 ASCII 字符帧</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, img, limitSize=<span class="number">-1</span>, fill=False, wrap=False</span>):</span></span><br><span class="line">    <span class="keyword">if</span> limitSize != <span class="number">-1</span> <span class="keyword">and</span> (img.shape[<span class="number">0</span>] &gt; limitSize[<span class="number">1</span>] <span class="keyword">or</span> img.shape[<span class="number">1</span>] &gt; limitSize[<span class="number">0</span>]):</span><br><span class="line">        img = cv2.resize(img, limitSize, interpolation=cv2.INTER_AREA)</span><br><span class="line">    ascii_frame = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    blank = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> fill:</span><br><span class="line">        blank += <span class="string">&#x27; &#x27;</span> * (limitSize[<span class="number">0</span>] - img.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> wrap:</span><br><span class="line">        blank += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(img.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(img.shape[<span class="number">1</span>]):</span><br><span class="line">            ascii_frame += self.pixelToChar(img[i, j])</span><br><span class="line">        ascii_frame += blank</span><br><span class="line">    <span class="keyword">return</span> ascii_frame</span><br></pre></td></tr></table></figure><p>这段代码其实就是将已经转变的灰度图的像素值映射到<code>ascii_char</code>上，然后输出到控制台。</p><h3 id="控制输出"><a href="#控制输出" class="headerlink" title="控制输出"></a>控制输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">getchar = threading.Thread(target=getChar)</span><br><span class="line"><span class="comment"># 设置为守护线程</span></span><br><span class="line">getchar.daemon = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 启动守护线程</span></span><br><span class="line">getchar.start()</span><br><span class="line"><span class="comment"># 输出的字符画行数</span></span><br><span class="line">rows = len(self.charVideo[<span class="number">0</span>]) // os.get_terminal_size()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> frame <span class="keyword">in</span> self.charVideo:</span><br><span class="line">    <span class="comment"># 接收到输入则退出循环</span></span><br><span class="line">    <span class="keyword">if</span> breakflag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    self.streamOut(frame)</span><br><span class="line">    self.streamFlush()</span><br><span class="line">    time.sleep(self.timeInterval)</span><br><span class="line">    <span class="comment"># 共 rows 行，光标上移 rows-1 行回到开始处</span></span><br><span class="line">    self.streamOut(<span class="string">&#x27;\033[&#123;&#125;A\r&#x27;</span>.format(rows - <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 光标下移 rows-1 行到最后一行，清空最后一行</span></span><br><span class="line">self.streamOut(<span class="string">&#x27;\033[&#123;&#125;B\033[K&#x27;</span>.format(rows - <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 清空最后一帧的所有行（从倒数第二行起）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows - <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 光标上移一行</span></span><br><span class="line">    self.streamOut(<span class="string">&#x27;\033[1A&#x27;</span>)</span><br><span class="line">    <span class="comment"># 清空光标所在行</span></span><br><span class="line">    self.streamOut(<span class="string">&#x27;\r\033[K&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> breakflag:</span><br><span class="line">    self.streamOut(<span class="string">&#x27;User interrupt!\n&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.streamOut(<span class="string">&#x27;Finished!\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>最后在main函数中设置下要读取的文件名，再play一下就可以了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    v2char = V2Char(<span class="string">&#x27;vedio.mp4&#x27;</span>)</span><br><span class="line">    v2char.play()</span><br></pre></td></tr></table></figure><p>完整代码可在公众号：「01二进制」后台回复：「蔡xx篮球」获取</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>方法教给大家了，视频素材可以优化，大家可以自己收集好的视频素材，发到朋友圈，让代码骚动起来！</p><hr><p>喜欢的小伙伴可以长按下方二维码关注哦～。👇</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1pv5gwz3sj307i07ijt1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo搭建一个个人博客网站</title>
      <link href="p/aca.html"/>
      <url>p/aca.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fymfgzoorjj30zp0d5t9a.jpg"></p><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><blockquote><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p></blockquote><blockquote><p>推荐阅读<a href="http://www.jianshu.com/p/1e402922ee32/">Markdown——入门指南</a></p></blockquote><a id="more"></a><h2 id="如何安装Hexo"><a href="#如何安装Hexo" class="headerlink" title="如何安装Hexo"></a>如何安装Hexo</h2><p>安装 Hexo 只需几分钟时间，若您在安装过程中遇到问题或无法找到解决方式，请在微信内回复，我们会尽力解决您的问题。</p><h3 id="安装前提-windows环境下"><a href="#安装前提-windows环境下" class="headerlink" title="安装前提(windows环境下)"></a>安装前提(windows环境下)</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><a href="http://nodejs.cn/">node.js</a></li><li><a href="https://git-scm.com/">git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>如果您的电脑中尚未安装所需要的程序，请参考以下安装链接指示完成安装。</p><ul><li><a href="http://www.jianshu.com/p/03a76b2e7e00">Node.js安装及环境配置之Windows篇 - 简书</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰的官方网站</a></li></ul><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><blockquote><p>npm 通常称为node包管理器。顾名思义，它的主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。</p></blockquote><blockquote><p><a href="https://www.npmjs.com/">npm官网</a></p></blockquote><p>安装命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="如何利用Hexo建站"><a href="#如何利用Hexo建站" class="headerlink" title="如何利用Hexo建站"></a>如何利用Hexo建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p><folder>就是你建博客的根目录</p></blockquote><p>然后执行以下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate   &#x2F;&#x2F;hexo g也可以,用于生成静态页面</span><br><span class="line">hexo server     &#x2F;&#x2F;hexo s也可以,用于启动本地服务，预览调试</span><br></pre></td></tr></table></figure><p>接下来在浏览器输入<a href="http://localhost:4000/%E5%8D%B3%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88">http://localhost:4000/即可实现浏览</a></p><h2 id="将博客发布到GitHub上"><a href="#将博客发布到GitHub上" class="headerlink" title="将博客发布到GitHub上"></a>将博客发布到GitHub上</h2><p>当然我们写博客肯定不能只在本地运行，一定也是希望让别人可以看见自己的文章的，怎么把文章发不到网上去呢？<br>这里采用的方法是将博客发布到GitHub Page上</p><blockquote><p><a href="https://github.com/">Github</a>是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名为Github</p></blockquote><blockquote><p><a href="https://pages.github.com/">Github Page</a>可以被认为是用户编写的、托管在Github上的静态网页。</p></blockquote><h3 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h3><p>这里我们就不多讲了，小伙伴们可以点击<a href="https://github.com/">Github官网</a>，进入官网进行注册。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>注册好登录账号后，在Github页面的右上方选择New repository进行仓库的创建。</p><p><img src="https://github.com/YueYongDev/MarkDownPhotos/blob/master/new_repo.png?raw=true" alt="New repository"></p><p><img src="https://github.com/YueYongDev/MarkDownPhotos/blob/master/repo_info.png?raw=true" alt="仓库的详细地址"></p><p>在仓库名字输入框中输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Github昵称.github.io</span><br></pre></td></tr></table></figure><blockquote><p>千万注意，前面的昵称是你注册GitHub时的昵称，结尾一定是’github.io’</p></blockquote><p>然后点击Create repository即可完成仓库的创建。</p><blockquote><p>Tips:复制此时的仓库地址<br><img src="https://github.com/YueYongDev/MarkDownPhotos/blob/master/copy_url.png?raw=true" alt="复制仓库地址"></p></blockquote><h3 id="配置GitHub-Page"><a href="#配置GitHub-Page" class="headerlink" title="配置GitHub Page"></a>配置GitHub Page</h3><p>完成仓库创建后，找到仓库的Setting，跳转到GitHub Page部分，Source部分设置如下：<br><img src="https://github.com/YueYongDev/MarkDownPhotos/blob/master/GitHub_page_info.png?raw=true" alt="Github Page配置"></p><h3 id="配置Hexo，完成博客的上传"><a href="#配置Hexo，完成博客的上传" class="headerlink" title="配置Hexo，完成博客的上传"></a>配置Hexo，完成博客的上传</h3><p>至此，GitHub部分的配置就结束了，现在开始进行Hexo部分的配置。</p><p>找到博客根目录下的_config.yml文件，下面是该文件的默认配置信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: # The title of your website</span><br><span class="line">subtitle: # The subtitle of your website</span><br><span class="line">description: # The description of your website</span><br><span class="line">author: # Your name</span><br><span class="line">language: # The language of your website</span><br><span class="line">timezone: </span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;yoursite.com&#x2F;child</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><p>看到这里，大家千万别被一长串英文给吓到了，我们实际上要修改的配置只有几项，拿我自己的配置，我们继续往下看：</p><h4 id="1-修改网站信息"><a href="#1-修改网站信息" class="headerlink" title="1 修改网站信息"></a>1 修改网站信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Blog</span><br><span class="line">subtitle:</span><br><span class="line">description: 从0开始，厚积薄发</span><br><span class="line">author: Yue Yong</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><blockquote><p>注意：每一项的填写，其:后面都要保留一个空格，下同。</p></blockquote><h4 id="2-配置统一资源定位符（个人域名）"><a href="#2-配置统一资源定位符（个人域名）" class="headerlink" title="2 配置统一资源定位符（个人域名）"></a>2 配置统一资源定位符（个人域名）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;yueyongdev.github.io&#x2F;</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><h4 id="3-配置部署"><a href="#3-配置部署" class="headerlink" title="3 配置部署"></a>3 配置部署</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YueYongDev&#x2F;YueYongDev.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>其中repo项是之前Github上创建好的仓库的地址.</p><p>branch是项目的分支，我们默认用主分支master。</p><h3 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h3><p>首先将写好的markdown文件放入本地博客文件夹source/_post文件夹下。<br>然后我们只要在终端执行这样的命令即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这时候我们的博客已经部署到网上了，我们可以在浏览器地址输入栏输入我们的网址即可，如我的博客是：<br><a href="https://yueyongdev.github.io/">https://yueyongdev.github.io/</a></p><p>本教程为博客搭建入门教程，大家可以根据自己的需求做进一步改进，如更换主题、删除文章等，详情参考<a href="https://hexo.io/zh-cn/docs/">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像检索系列——利用 Python 检测图像相似度</title>
      <link href="p/cf73.html"/>
      <url>p/cf73.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006y8mN6ly1g6cb7g9aquj31910u0dtp.jpg"></p><blockquote><p>本文的代码可在微信公众号「01二进制」后台回复「检测图像相似度」获得。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个海量图片检索的项目，可以简单的理解为“以图搜图”，这个功能一开始是搜索引擎带火的，但是后来在电商领域变得非常实用。在制作这个图片检索的项目前，笔者搜索了一些资料，如今项目临近结尾，便在这里做一些简单的分享。本文先介绍图像检索最基础的一部分知识——利用 Python 检测图像相似度。</p><p>提到检测“某某”的相似度相信很多人第一想法就是将需要比较的东西构建成两个向量，然后利用余弦相似度来比较两个向量之间的距离，这种方法应用很广泛，例如比较两个用户兴趣的相似度、比较两个文本之间的相似度。但是这个方法在比较图片相似度的时候用到的并不多，原因我之后再说，这里先来介绍下另外两个概念——<strong>图像指纹</strong>和<strong>汉明距离</strong>。</p><h2 id="图像指纹"><a href="#图像指纹" class="headerlink" title="图像指纹"></a>图像指纹</h2><p>图像指纹和人的指纹一样，是身份的象征，而图像指纹简单点来讲，<strong>就是将图像按照一定的哈希算法，经过运算后得出的一组二进制数字。</strong>如下图所示：</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g6c0hdyju5j30k405njss.jpg"></p><p>在给定的输入的图像中，我们可以使用一个散列函数， 并基于图像视觉上的外观计算它的“图像散列”值，相似的头像，它的散列值应该也是相似的。构建图像指纹的算法被称为<strong>感知哈希算法（Perceptual Hash Algorithm）</strong>。</p><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p>通过上述对图像指纹的描述我们知道了可以利用<strong>感知哈希算法</strong>将图片转换成某种字符串，而比较字符串有一种名为<strong>汉明距离</strong>的表示方法。以下定义摘自维基百科：</p><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E8%AE%BA">信息论</a>中，两个等长<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>之间的<strong>汉明距离</strong>（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，<strong>它就是将一个字符串变换成另外一个字符串所需要<em>替换</em>的字符个数。</strong></p></blockquote><p>通常用汉明距离来<strong>衡量两张图片的差异</strong>，汉明距离越小，则代表相似度越高。汉明距离为0，即代表两张图片完全一样。</p><h2 id="感知哈希算法"><a href="#感知哈希算法" class="headerlink" title="感知哈希算法"></a>感知哈希算法</h2><p>常用的感知哈希算法有三个，分别是平均哈希算法(aHash)、感知哈希算法(pHash)、差异值哈希算法(dHash)。至于这三种哈希算法的介绍和比较很多博客都有写，而且很多库都支持直接计算哈希值，调用一下相关函数就可以了。这里就不多说了，推荐一篇文章👉    <a href="https://www.cnblogs.com/Kalafinaian/p/11260808.html">《图像相似度中的Hash算法》</a></p><blockquote><p>代码可在微信公众号「01二进制」后台回复「检测图像相似度」获得</p></blockquote><p>三种哈希算法的实现代码如下：</p><h3 id="ahash"><a href="#ahash" class="headerlink" title="ahash"></a>ahash</h3><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g6c9wjx4wjj30x70u0469.jpg"></p><h3 id="dhash"><a href="#dhash" class="headerlink" title="dhash"></a>dhash</h3><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g6c9vr5qzwj310k0riq8g.jpg"></p><h3 id="phash"><a href="#phash" class="headerlink" title="phash"></a>phash</h3><p><img src="http://ww1.sinaimg.cn/large/006y8mN6ly1g6caiyyckbj312g0rin3l.jpg"></p><p>当然，你也可以选择安装**<em>ImageHash**</em>库，然后调用相应的hash函数来实现计算。</p><h2 id="比较两个图片相似度的思路"><a href="#比较两个图片相似度的思路" class="headerlink" title="比较两个图片相似度的思路"></a>比较两个图片相似度的思路</h2><p>所以看到这对于比较两张图片的相似度我们就有了一个简单的想法了，只要通过<strong>感知哈希算法</strong>获得图像的图像指纹，然后比较两个哈希值之间的<strong>汉明距离</strong>就可以了。</p><p>详细的步骤，阮一峰介绍了一个简单的图片搜索原理，可分为下面几步：</p><ol><li>缩小尺寸。将图片缩小到 8x8 的尺寸，总共 64 个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。</li><li>简化色彩。将缩小后的图片，转为 64 级灰度。也就是说，所有像素点总共只有 64 种颜色。</li><li>计算平均值。计算所有 64 个像素的灰度平均值。</li><li>比较像素的灰度。将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为 1 ；小于平均值，记为 0。</li><li>计算哈希值。将上一步的比较结果，组合在一起，就构成了一个 64 位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。</li></ol><p>这种方法对于寻找<strong>一模一样</strong>的图片是有效的，但是搜索「相似图片」的效果很差，也不能局部搜索，因此通常应用在<strong>「检测图片是否侵权」</strong>上。现在诸如谷歌识图、百度识图几乎都是采用深度学习的方式进行相似性检索，这个下篇文章介绍。</p><h2 id="为什么余弦相似度不适合用来检测图片相似度"><a href="#为什么余弦相似度不适合用来检测图片相似度" class="headerlink" title="为什么余弦相似度不适合用来检测图片相似度"></a>为什么余弦相似度不适合用来检测图片相似度</h2><p>最后我们来讨论下为什么不使用余弦相似度来检测图片的相似度。开篇我们就说过如果需要用余弦相似度来衡量相似性，我们需要先构造两个向量。通常情况下我们会将图片转化为像素向量(基于像素点灰度值的频次)，从而计算两个图片的相似度，这种做法其实就是计算两个图片的直方图的相似度，然而这样就只保留了像素的频次信息，丢掉了像素的位置信息，信息损失太大，只在某些场景下适用。用余弦相似度表示图片相似度的代码同样可以微信公众号「01二进制」后台回复「检测图像相似度」获得。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍的方法都是通过非深度学习的手段来检测图像的相似度，虽然理解起来都很容易，但是每种方法都有局限性。想要制作一个图像检索系统虽然第一步都是比较图像的相似度，但现如今大多数都是通过深度学习的方法提取出图像特征，然后再进行比较，准确率大大提升。之后我将会讲述如何通过深度学习抽取图像特征的方式来比较图片的相似度。</p><blockquote><p>由于能力有限，在整理描述的过程中难免会有些错误，如有建议，可以留言区批评指正🙏</p></blockquote><hr><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g6cb75xph2j31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 以图搜图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 Docker 安装 Hadoop 集群并通过 Java API 访问 HDFS</title>
      <link href="p/d81e.html"/>
      <url>p/d81e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近刚好在学习 Hadoop，在安装过程中遇到了一些小麻烦，正好将此次过程记录并分享出来，希望能对准备学习本块内容的读者们有所帮助。本次操作在 Ubuntu 中完成，如何安装 Ubuntu 本文不再赘述。</p><blockquote><p>本文所涉及到的代码及配置文件可在微信公众号「01 二进制」后台回复「hadoop」获取。</p></blockquote><h2 id="在-Ubuntu-中安装配置-Docker"><a href="#在-Ubuntu-中安装配置-Docker" class="headerlink" title="在 Ubuntu 中安装配置 Docker"></a>在 Ubuntu 中安装配置 Docker</h2><h3 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h3><p>安装命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><h3 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h3><p>之后我们会利用 docker 拉取一些镜像，国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。这里以 ubuntu 系统为例，我们可以通过修改 daemon 配置文件<code>/etc/docker/daemon.json</code>来使用加速器</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行以下命令重启 docker 服务即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Hadoop-集群安装"><a href="#Hadoop-集群安装" class="headerlink" title="Hadoop 集群安装"></a>Hadoop 集群安装</h2><h3 id="1-拉取-docker-镜像"><a href="#1-拉取-docker-镜像" class="headerlink" title="1. 拉取 docker 镜像"></a>1. 拉取 docker 镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull kiwenlau/hadoop:1.0</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv3851w8wj30kq085whm.jpg"></p><h3 id="2-下载启动脚本"><a href="#2-下载启动脚本" class="headerlink" title="2. 下载启动脚本"></a>2. 下载启动脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kiwenlau/hadoop-cluster-docker</span><br></pre></td></tr></table></figure><h3 id="3-创建网桥"><a href="#3-创建网桥" class="headerlink" title="3. 创建网桥"></a>3. 创建网桥</h3><p>由于 Hadoop 的 master 节点需要与 slave 节点通信，需要在各个主机节点配置节点 IP，为了不用每次启动都因为 IP 改变了而重新配置，在此配置一个 Hadoop 专用的网桥，配置之后各个容器的 IP 地址就能固定下来。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker network create --driver=bridge hadoop</span><br></pre></td></tr></table></figure><h3 id="4-下载完成后进入该目录"><a href="#4-下载完成后进入该目录" class="headerlink" title="4. 下载完成后进入该目录"></a>4. 下载完成后进入该目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hadoop-cluster-docker/</span><br></pre></td></tr></table></figure><h3 id="5-编辑并运行-docker-的启动脚本"><a href="#5-编辑并运行-docker-的启动脚本" class="headerlink" title="5. 编辑并运行 docker 的启动脚本"></a>5. 编辑并运行 docker 的启动脚本</h3><p>为了方便后续通过 Java API 访问 HDFS，需要修改脚本，添加一个端口映射，将容器的 9000 端口映射到本地的 9000 端口，我们需要在<code>-p 8088:8088 \</code>下添加一行，如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv38gritbj30kl0k1q51.jpg"></p><p>然后执行以下命令完成 docker 容器的启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start-container.sh</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv38oold7j30hu024jrj.jpg"></p><p>随即会进入容器内的终端</p><h3 id="6-在容器内启动-hadoop"><a href="#6-在容器内启动-hadoop" class="headerlink" title="6. 在容器内启动 hadoop"></a>6. 在容器内启动 hadoop</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start-hadoop.sh</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv38upk4zj30kq078780.jpg"></p><p>至此，hadoop 集群启动完成。</p><p>我们可以分别访问<code>http://localhost:8088</code>和<code>http://localhost:50070/</code>来访问 hadoop 集群的可视化界面</p><ul><li><strong><a href="http://localhost:8088/">http://localhost:8088</a></strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv390sevrj30kq03ojs3.jpg" alt="image.png"></p><ul><li><strong><a href="http://localhost:50070/">http://localhost:50070/</a></strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv394igtmj30kq049weq.jpg" alt="image.png"></p><h3 id="7-查看-hadoop-使用情况"><a href="#7-查看-hadoop-使用情况" class="headerlink" title="7. 查看 hadoop 使用情况"></a>7. 查看 hadoop 使用情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop dfsadmin -report</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv398sxc2j30kq0o1dpw.jpg"></p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="1-关闭-Linux-防火墙并编辑-hosts-文件"><a href="#1-关闭-Linux-防火墙并编辑-hosts-文件" class="headerlink" title="1. 关闭 Linux 防火墙并编辑 hosts 文件"></a>1. 关闭 Linux 防火墙并编辑 hosts 文件</h3><p>由于在本案例中使用的是 docker 部署集群，如果想通过 Java API 访问 hadoop 集群，我们就需要给 docker 开放一个外网访问的权限，这里采用的方式是关闭防火墙+编辑 hosts 文件映射</p><h4 id="1-1-关闭-Linux-防火墙"><a href="#1-1-关闭-Linux-防火墙" class="headerlink" title="1.1 关闭 Linux 防火墙"></a>1.1 关闭 Linux 防火墙</h4><p>我们可以通过<code>sudo ufw status</code>命令查看防火墙状态</p><p>如果返回结果为<code>Status: inactive</code>则说明防火墙已关闭，否则我们执行以下代码关闭防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw <span class="built_in">disable</span></span><br></pre></td></tr></table></figure><p>另外，我们也可以通过<code>sudo ufw enable</code>命令开启防火墙。</p><h4 id="1-2-编辑-hosts-文件"><a href="#1-2-编辑-hosts-文件" class="headerlink" title="1.2 编辑 hosts 文件"></a>1.2 编辑 hosts 文件</h4><p>执行<code>sudo vim /etc/hosts</code>来编辑文件</p><p>在文档末尾添加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">172.18.0.2 hadoop-master</span><br><span class="line">172.18.0.3 hadoop-slave1</span><br><span class="line">172.18.0.4 hadoop-slave2</span><br></pre></td></tr></table></figure><h4 id="1-3-通过-ping-命令来查看集群的访问情况"><a href="#1-3-通过-ping-命令来查看集群的访问情况" class="headerlink" title="1.3 通过 ping 命令来查看集群的访问情况"></a>1.3 通过 ping 命令来查看集群的访问情况</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv39gacwoj30kq0cbgsh.jpg"></p><h2 id="利用-Java-API-访问-Hadoop-集群"><a href="#利用-Java-API-访问-Hadoop-集群" class="headerlink" title="利用 Java API 访问 Hadoop 集群"></a>利用 Java API 访问 Hadoop 集群</h2><h3 id="1-编写-Java-代码"><a href="#1-编写-Java-代码" class="headerlink" title="1. 编写 Java 代码"></a>1. 编写 Java 代码</h3><h4 id="1-1-新建-maven-工程"><a href="#1-1-新建-maven-工程" class="headerlink" title="1.1 新建 maven 工程"></a>1.1 新建 maven 工程</h4><p>此步骤省略</p><h4 id="1-2-编辑-pom-xml"><a href="#1-2-编辑-pom-xml" class="headerlink" title="1.2 编辑 pom.xml"></a>1.2 编辑 pom.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-创建-HDFSApp-java-并编辑"><a href="#1-3-创建-HDFSApp-java-并编辑" class="headerlink" title="1.3 创建 HDFSApp.java 并编辑"></a>1.3 创建 HDFSApp.java 并编辑</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.security.UserGroupInformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedExceptionAction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现java远程操作hdfs：远程创建目录、创建文件、上传文件、下载文件、读取文件、重命名、删除文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HDFSApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem hdfs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化访问hdfs的配置信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UserGroupInformation ugi = UserGroupInformation.createRemoteUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ugi.doAs(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">                    conf.set(<span class="string">&quot;dfs.client.use.datanode.hostname&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                    conf.set(<span class="string">&quot;fs.defaultFS&quot;</span>, <span class="string">&quot;hdfs://127.0.0.1:9000/&quot;</span>);</span><br><span class="line">                    conf.set(<span class="string">&quot;fs.hdfs.impl&quot;</span>, <span class="string">&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;</span>);</span><br><span class="line">                    Path path = <span class="keyword">new</span> Path(<span class="string">&quot;hdfs://127.0.0.1:9000/&quot;</span>);</span><br><span class="line">                    hdfs = FileSystem.get(path.toUri(), conf);</span><br><span class="line">                    <span class="comment">//hdfs = path.getFileSystem(conf); // 这个也可以</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：创建文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String fileName = <span class="string">&quot;/test/myfile.txt&quot;</span>;</span><br><span class="line">        String fileContent = <span class="string">&quot;this is new file&quot;</span>;</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(fileName);</span><br><span class="line">        <span class="keyword">if</span> (hdfs.exists(dst)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error:文件已存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将文件内容转成字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = fileContent.getBytes();</span><br><span class="line">            FSDataOutputStream output = hdfs.create(dst);</span><br><span class="line">            output.write(bytes);</span><br><span class="line">            output.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;创建文件\t&quot;</span> + fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：读取HDFS文件，并在本地控制台打印</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String uri = <span class="string">&quot;/test/myfile.txt&quot;</span>;</span><br><span class="line">        <span class="comment">// 判断文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!hdfs.exists(<span class="keyword">new</span> Path(uri))) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error;文件不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = hdfs.open(<span class="keyword">new</span> Path(uri));</span><br><span class="line">            <span class="comment">// 复制到标准输出流</span></span><br><span class="line">            IOUtils.copyBytes(in, System.out, <span class="number">4096</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeStream(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法6：重命名hdfs上面的文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String oldName = <span class="string">&quot;/test/myfile.txt&quot;</span>;</span><br><span class="line">        String newName = <span class="string">&quot;/test/myfile1.txt&quot;</span>;</span><br><span class="line">        Path oldPath = <span class="keyword">new</span> Path(oldName);</span><br><span class="line">        Path newPath = <span class="keyword">new</span> Path(newName);</span><br><span class="line">        <span class="keyword">if</span> (hdfs.exists(oldPath)) &#123;</span><br><span class="line">            hdfs.rename(oldPath, newPath);</span><br><span class="line">            System.out.println(<span class="string">&quot;rename success&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在,rename fail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法7：给hdfs上面的文件追加内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String fileName = <span class="string">&quot;/test/myfile1.txt&quot;</span>;</span><br><span class="line">        String appendContent = <span class="string">&quot;这是追加的内容&quot;</span>;</span><br><span class="line">        Path dst = <span class="keyword">new</span> Path(fileName);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = appendContent.getBytes();</span><br><span class="line">        <span class="comment">//如果文件不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!hdfs.exists(dst)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error:文件不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FSDataOutputStream output = hdfs.append(dst);</span><br><span class="line">        output.write(bytes);</span><br><span class="line">        output.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;success:追加内容到\t&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法8：删除hdfs上面的文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(fileName)) &#123;</span><br><span class="line">            fileName = <span class="string">&quot;/test/myfile1.txt&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Path f = <span class="keyword">new</span> Path(fileName);</span><br><span class="line">        <span class="keyword">boolean</span> isExists = hdfs.exists(f);</span><br><span class="line">        <span class="keyword">if</span> (isExists) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isDel = hdfs.delete(f, <span class="keyword">true</span>);</span><br><span class="line">            System.out.println(fileName + <span class="string">&quot;删除状态：&quot;</span> + isDel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(fileName + <span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        createFile();</span><br><span class="line">        readFile();</span><br><span class="line"><span class="comment">//        deleteFile(&quot;/test/myfile.txt&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-执行代码并查看返回结果"><a href="#2-执行代码并查看返回结果" class="headerlink" title="2. 执行代码并查看返回结果"></a>2. 执行代码并查看返回结果</h3><h4 id="2-1-函数入口"><a href="#2-1-函数入口" class="headerlink" title="2.1 函数入口"></a>2.1 函数入口</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv39r1hk8j30g403kt8x.jpg"></p><h4 id="2-2-在-hdfs-上创建文件"><a href="#2-2-在-hdfs-上创建文件" class="headerlink" title="2.2 在 hdfs 上创建文件"></a>2.2 在 hdfs 上创建文件</h4><p>我们先在创建一个文件，创建的文件名为<code>&quot;/test/myfile.txt&quot;</code>，文件内容为<code>&quot;this is new file&quot;</code>，创建的代码如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv39vp3aaj30f008qq3y.jpg"></p><h4 id="2-3-读取-hdfs-上的文件"><a href="#2-3-读取-hdfs-上的文件" class="headerlink" title="2.3 读取 hdfs 上的文件"></a>2.3 读取 hdfs 上的文件</h4><p>随后读取 hdfs 上的<code>&quot;/test/myfile.txt&quot;</code>文件</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv3a1qwcnj30ih0aigmr.jpg"></p><p>执行结果如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjv3a8do5jj30kq04bwfd.jpg"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上就是本文的全部内容了，如果你觉得对你有所帮助，不放关注点赞支持一波。</p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为了更好的运营，我剖析了某公众号的数据</title>
      <link href="p/9fa7.html"/>
      <url>p/9fa7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>完整源码可在公众号：「01 二进制」后台回复：「公众号数据分析」获取</p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在同学的影响下，我在 18 年 9 月注册了一个公众号「01 二进制」，因为种种原因（其实就是懒）直到 11 月 11 日才在这个公众号上发布了第一篇文章。到写这篇文的时候，我已经发布过 21 篇文章，用户也只有 86 人，这不禁引发了我深深的思考。为啥我的公号没有用户？</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-0f176383d061438e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>为此我还特地请教了我的好友 🐔 哥，他告诉我，文笔是一方面，另一方面还要能抓住热点，说完便给我发了一份某知名公众号的相关数据，让我给安排安排。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-97ec66c605dad825?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这不，一分析才发现原来想让公众号有阅读量也是要讲究套路的，接下来就让我们以一个 coder 的角度去分析下究竟是哪些套路吧。</p><h2 id="2-分析目的"><a href="#2-分析目的" class="headerlink" title="2. 分析目的"></a>2. 分析目的</h2><p>笔者在本项目中的分析目的主要有 3 个：</p><p>（1）对某知名公众号内容运营方面的若干分析，主要是对发文量、点赞量、发文时间等方面的描述性分析；</p><p>（2）通过对标题的分析，来说明什么样标题更受人喜欢；</p><p>（3）将冗杂无序的结构化数据和非结构化数据进行可视化，展现数据之美。</p><h2 id="3-实验环境"><a href="#3-实验环境" class="headerlink" title="3. 实验环境"></a>3. 实验环境</h2><p>工欲善其事，必先利其器，在开始分析之前，我先说明此次分析所处的实验环境，以免出现异常：</p><ul><li>MacOS 10.14.3</li><li>Python 3.6.8（Anaconda）</li><li>Visual Studio Code（开发）</li><li>Jupyter Notebook（调试环境）</li><li>使用的包有：<ul><li>pkuseg（分词）</li><li>pyecharts（绘图）</li><li>numpy（数学计算）</li><li>pandas（数据计算）</li></ul></li></ul><h2 id="4-数据获取及预览"><a href="#4-数据获取及预览" class="headerlink" title="4. 数据获取及预览"></a>4. 数据获取及预览</h2><h3 id="4-1-数据获取"><a href="#4-1-数据获取" class="headerlink" title="4.1 数据获取"></a>4.1 数据获取</h3><p>本次数据集是通过网络爬虫爬取某公众号的所以文章整理而成，该部分不进行阐述，需要数据集可以直接下载源码查看或者在公众号：「01 二进制」后台回复：「公众号数据集」获取。</p><h3 id="4-2-数据预览"><a href="#4-2-数据预览" class="headerlink" title="4.2 数据预览"></a>4.2 数据预览</h3><p>在该项目中，我使用了 Pandas 进行数据的读取和预览，Pandas 在数据科学中使用非常广泛，有兴趣的小伙伴可以去搜索相关资料了解下。</p><p>数据预览代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line">df=pd.read_excel(<span class="string">&#x27;data/data.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示前五行数据</span></span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><p>此次的数据集长下面这样 👇：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-bb761b35cf132b55?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我统计了下，截至 2019 年 1 月 22 日，该公众号总共发表文章 1111 篇（对单身 🐶 还真是一个友好的数字呢）。</p><h2 id="5-描述性分析"><a href="#5-描述性分析" class="headerlink" title="5. 描述性分析"></a>5. 描述性分析</h2><p>该部分中，笔者将会对该数据集中主要的数值型数据进行描述性的统计分析，属于较为常规的数据分析，能揭示出一些问题。可视化工具采用的是<strong>pyecharts</strong>，官网地址：<a href="http://pyecharts.org/#/%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E4%BB%96%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E5%9B%A0%E4%B8%BA%E4%BB%96%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%A5%BD%E7%9C%8B%EF%BC%88%E9%A2%9C%E5%8D%B3%E6%AD%A3%E4%B9%89%EF%BC%89%E3%80%82">http://pyecharts.org/#/，推荐使用他的原因是因为他的图表好看（颜即正义）。</a></p><h3 id="5-1-文章来源"><a href="#5-1-文章来源" class="headerlink" title="5.1 文章来源"></a>5.1 文章来源</h3><p>单靠一个人的力量想要让公众号保持每日一文的活跃度很难。所以，很多公众号都会适时的转载一些别人写的比较好的文章。但如果转载文章过多，原创性就大大降低了，那么比例要多少比较好呢？我们来看看该知名公众号的转载文章数量和原创文章数量吧：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取转载文章</span></span><br><span class="line">df_copy = df[df[<span class="string">&#x27;原文链接&#x27;</span>].str.len() &gt; <span class="number">5</span>]</span><br><span class="line">print(<span class="string">&#x27;转载文章数量为：&#x27;</span>+str(len(df_copy)))</span><br><span class="line">print(<span class="string">&#x27;原创文章数量为：&#x27;</span>+str(len(df)-len(df_copy)))</span><br></pre></td></tr></table></figure><p>在该数据集中，只要原文链接这一栏里有数据的则默认为转载，没有数据的默认为原创，输出的结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转载文章数量为：249</span><br><span class="line">原创文章数量为：862</span><br></pre></td></tr></table></figure><p>粗略计算下比例大约为<strong>3.5:1</strong></p><h3 id="5-2-他到底有多火"><a href="#5-2-他到底有多火" class="headerlink" title="5.2 他到底有多火"></a>5.2 他到底有多火</h3><p>从文章开始我就在说这个数据集是某知名公众号的数据集，那么到底有多知名呢？接下来我们从发文数量、点赞数量和平均每篇文章的点赞数量入手来一探究竟。</p><p>其实这个部分的思路不难：只需要创建一个 5 行 4 列（表示 5 年，4 个季度）的矩阵，获取到时间所在的年份和季度后再在相应位置上加 1：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取文章数随季度变化的矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPostJiDu</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="comment"># 生成一个5行4列全为0的矩阵</span></span><br><span class="line">    list_jidu = [[<span class="number">0</span>]*<span class="number">4</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">    <span class="keyword">for</span> articleTime <span class="keyword">in</span> df[<span class="string">&#x27;发文时间&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 获取日期</span></span><br><span class="line">        date = str(articleTime).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 获取所在年份</span></span><br><span class="line">        year = getYear(date)</span><br><span class="line">        <span class="comment"># 获取所在季度</span></span><br><span class="line">        jidu = getJiDu(date)</span><br><span class="line">        list_jidu[year<span class="number">-2015</span>][jidu<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> list_jidu</span><br></pre></td></tr></table></figure><p>然后在利用<strong>pyecharts</strong>将图标画出来即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画出发文数量随季度变化的走势图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawPostJiDu</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="comment"># 获取文章季度矩阵</span></span><br><span class="line">    res_list = getPostJiDu(df)</span><br><span class="line">    <span class="comment"># 构造标题列表</span></span><br><span class="line">    attr = []</span><br><span class="line">    <span class="keyword">for</span> year <span class="keyword">in</span> range(len(res_list)):</span><br><span class="line">        <span class="keyword">for</span> month <span class="keyword">in</span> range(len(res_list[year])):</span><br><span class="line">            attr.append(<span class="string">&quot;&#123;&#125;年第&#123;&#125;季度&quot;</span>.format(str(year+<span class="number">2015</span>),str(month+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造值列表</span></span><br><span class="line">    v1 = reduce(operator.add, res_list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去掉无用值</span></span><br><span class="line">    attr = attr[<span class="number">2</span>:<span class="number">-3</span>]</span><br><span class="line">    v1 = v1[<span class="number">2</span>:<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">    line = Line(<span class="string">&quot;发文数量变化走势图&quot;</span>, width=<span class="number">1500</span>, height=<span class="number">500</span>)</span><br><span class="line">    line.add(<span class="string">&quot;某知名公众号&quot;</span>, attr, v1, is_stack=<span class="literal">True</span>,</span><br><span class="line">             is_label_show=<span class="literal">True</span>, is_smooth=<span class="literal">True</span>, is_fill=<span class="literal">True</span>,  xaxis_name=<span class="string">&#x27;季度&#x27;</span>, yaxis_name=<span class="string">&#x27;发文数&#x27;</span>,xaxis_rotate=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> line</span><br></pre></td></tr></table></figure><blockquote><p>这里提一下，因为该公众号 2015 年第 1、2 季度和 2019 年 2、3、4 季度均没有数据，所以需要执行一步去掉无用值的操作。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/5666077-48469c449983668b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><p>以此类推我们也可以得到点赞数量随时间变化的走势图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-8e05e39f9a81b1ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>下面是平均每篇文章点赞数量的变化。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ee9adbfca2362958?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>不得不说，这个公众号的流量真的不容小觑，平均一篇文章能有 1w+的点赞量（还不算阅读量），难怪广告商都排队买她家的广告位，据说有的广告商甚至开出了 30w 的广告费！（啥时候我的文章也能有这么多流量啊 😢）</p><h3 id="5-3-会不会是标题党"><a href="#5-3-会不会是标题党" class="headerlink" title="5.3 会不会是标题党"></a>5.3 会不会是标题党</h3><p>说实话，笔者在做分析的时候，看到上面的数据异常震惊，他每天到底发的是什么样的文章才能有这么庞大的流量啊。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-325774ec18b6feaf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>高中语文老师经常跟我们提起，一个好的文章标题可以给你的文章加分不少。想到这我就开始怀疑这家伙会不会是一个标题党？又或是它的标题真的那么吸引人？实践是检验整理的唯一标准。来来来，收起笑容，我们来分析下。</p><h4 id="5-3-1-什么样的文章标题更讨喜"><a href="#5-3-1-什么样的文章标题更讨喜" class="headerlink" title="5.3.1 什么样的文章标题更讨喜"></a>5.3.1 什么样的文章标题更讨喜</h4><p>这一部分我们的思路如下：获取到文章标题，然后进行分词、停用词过滤、统计词频，生成词云。这些都是上篇文章介绍过的，如果不清楚，移步<a href="https://juejin.im/post/5c6e4cb5e51d4536ee336431">《李鬼见李逵——我用翟天临的论文做了分析》</a>，这里直接上代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择文章标题并分析</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseMostPop50Titles</span>(<span class="params">df</span>):</span></span><br><span class="line">    texts=[]</span><br><span class="line">    <span class="keyword">for</span> title <span class="keyword">in</span> list(df[<span class="string">&#x27;标题&#x27;</span>]):</span><br><span class="line">        <span class="comment"># 防止出现没有标题的文章</span></span><br><span class="line">        <span class="keyword">if</span> len(str(title))&gt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> str(title) <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;分享图片&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 分词、去掉停用词</span></span><br><span class="line">                text=cleanWord(str(title))</span><br><span class="line">                texts.append(text)</span><br><span class="line">    <span class="comment"># 将二维数组变成一维数组</span></span><br><span class="line">    title_cuts=reduce(operator.add, texts)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计每个词的词频</span></span><br><span class="line">    counter = Counter(title_cuts)</span><br><span class="line">    <span class="comment"># 选出词频最高的50个</span></span><br><span class="line">    counter=counter.most_common(<span class="number">50</span>)</span><br><span class="line">    <span class="comment"># 输出词频最高的50个单词</span></span><br><span class="line">    pprint.pprint(counter)</span><br><span class="line">    name = []</span><br><span class="line">    value = []</span><br><span class="line">    <span class="keyword">for</span> count <span class="keyword">in</span> counter:</span><br><span class="line">        name.append(count[<span class="number">0</span>])</span><br><span class="line">        value.append(count[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> drawWordCloud(name,value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据可视化（生成词云)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawWordCloud</span>(<span class="params">name, value</span>):</span></span><br><span class="line">    wordcloud = WordCloud(width=<span class="number">800</span>, height=<span class="number">400</span>)</span><br><span class="line">    wordcloud.add(<span class="string">&quot;标题词云图&quot;</span>, name, value, word_size_range=[</span><br><span class="line">                  <span class="number">20</span>, <span class="number">100</span>], rotate_step=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> wordcloud</span><br></pre></td></tr></table></figure><p>考虑到篇幅的问题，词频统计的结果我就不放出来了，这里直接放出词云图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-5800527281dba2e1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>看到这张词云图，大致就能猜到该公众号面向的主要群体是哪一类人了。有兴趣的可以在评论区留言说说你对这张词云图的想法。</p><h4 id="5-3-2-标题多长比较好"><a href="#5-3-2-标题多长比较好" class="headerlink" title="5.3.2 标题多长比较好"></a>5.3.2 标题多长比较好</h4><p>标题能抓住痛点自然是好事，但是和长度有没有关系呢？（这个部分很简单，就是归类下长度，所以直接放代码了）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画出标题长度和点赞数之间的关系</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawTitleLenAndFavourite</span>(<span class="params">df</span>):</span></span><br><span class="line">    v1 = [<span class="number">0</span>]*<span class="number">6</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(df[<span class="string">&#x27;标题&#x27;</span>])):</span><br><span class="line">        title_len = len(str(df[<span class="string">&#x27;标题&#x27;</span>][i]))</span><br><span class="line">        <span class="keyword">if</span> title_len &gt;= <span class="number">5</span> <span class="keyword">and</span> title_len &lt;= <span class="number">8</span>:</span><br><span class="line">            v1[<span class="number">0</span>] += df[<span class="string">&#x27;点赞&#x27;</span>][i]</span><br><span class="line">        <span class="keyword">elif</span> title_len &gt;= <span class="number">9</span> <span class="keyword">and</span> title_len &lt;= <span class="number">12</span>:</span><br><span class="line">            v1[<span class="number">1</span>] += df[<span class="string">&#x27;点赞&#x27;</span>][i]</span><br><span class="line">        <span class="keyword">elif</span> title_len &gt;= <span class="number">13</span> <span class="keyword">and</span> title_len &lt;= <span class="number">16</span>:</span><br><span class="line">            v1[<span class="number">2</span>] += df[<span class="string">&#x27;点赞&#x27;</span>][i]</span><br><span class="line">        <span class="keyword">elif</span> title_len &gt;= <span class="number">17</span> <span class="keyword">and</span> title_len &lt;= <span class="number">20</span>:</span><br><span class="line">            v1[<span class="number">3</span>] += df[<span class="string">&#x27;点赞&#x27;</span>][i]</span><br><span class="line">        <span class="keyword">elif</span> title_len &gt;= <span class="number">20</span> <span class="keyword">and</span> title_len &lt;= <span class="number">24</span>:</span><br><span class="line">            v1[<span class="number">4</span>] += df[<span class="string">&#x27;点赞&#x27;</span>][i]</span><br><span class="line">        <span class="keyword">elif</span> title_len &gt;= <span class="number">25</span>:</span><br><span class="line">            v1[<span class="number">5</span>] += df[<span class="string">&#x27;点赞&#x27;</span>][i]</span><br><span class="line">    attr = [<span class="string">&#x27;5-8&#x27;</span>, <span class="string">&#x27;9-12&#x27;</span>, <span class="string">&#x27;13-16&#x27;</span>, <span class="string">&#x27;17-20&#x27;</span>, <span class="string">&#x27;21-24&#x27;</span>, <span class="string">&#x27;24+&#x27;</span>]</span><br><span class="line">    bar = Bar(<span class="string">&quot;标题长度和点赞数之间的关系&quot;</span>, title_pos=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">    bar.add(<span class="string">&quot;&quot;</span>, attr, v1, is_label_show=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> bar</span><br></pre></td></tr></table></figure><p>可视化结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-11abf8572aed3d01?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>现在想想，高中语文老师说的标题不宜过长，也不宜过短，13-16 字之间最适宜原来不是忽悠我啊。</p><h3 id="5-4-什么时候发文章比较好"><a href="#5-4-什么时候发文章比较好" class="headerlink" title="5.4 什么时候发文章比较好"></a>5.4 什么时候发文章比较好</h3><p>每个人看文章的时间都不确定，但是大多数人的空闲时间还是差不多的，所以到这就有人会问了什么时候推送文章会比较好呢？我们先来看看这个公众号是怎么安排的。</p><h4 id="5-4-1-发文数量和所在时间段的关系"><a href="#5-4-1-发文数量和所在时间段的关系" class="headerlink" title="5.4.1 发文数量和所在时间段的关系"></a>5.4.1 发文数量和所在时间段的关系</h4><p>粗略的浏览了下数据发现大多都是在晚上，所以这里我觉得采用饼状图来可视化二者之间的关系比较好（其实就是想顺便换个图表试试）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画出发文数量和所在小时之间的饼状关系图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawPostHour</span>(<span class="params">df</span>):</span></span><br><span class="line">    <span class="comment"># 获取发文时间</span></span><br><span class="line">    list_hour = getPostHour(df)</span><br><span class="line">    array = np.array(list_hour)</span><br><span class="line">    <span class="comment"># 获取发文时间最多的5个时间段</span></span><br><span class="line">    attr = list(sorted(np.argsort(array)[<span class="number">-5</span>:]))</span><br><span class="line">    attr = [<span class="string">&quot;&#123;&#125;时&quot;</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> attr]</span><br><span class="line">    <span class="comment"># 获取发文时间最多的5个时间的数量</span></span><br><span class="line">    v1 = list(array[sorted(np.argsort(array)[<span class="number">-5</span>:])])</span><br><span class="line">    pie = Pie(<span class="string">&quot;发文时间分布图&quot;</span>)</span><br><span class="line">    pie.add(<span class="string">&quot;&quot;</span>, attr, v1, is_label_show=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> pie</span><br></pre></td></tr></table></figure><p>在上述代码中，我们用<code>getPostHour()</code>这个函数来生成一个集合，思路和上面类似，先生成一个全为 0 的列表，在时间内的加一就可以了。下面是生成的饼图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-4a819899cab60754?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到该公众号大多数文章都是在晚上 10 点、11 点左右推送的，细想一下确实也是。大多数上班族在睡觉之前也就是这个时间段躺在床上刷手机，久而久之都让用户养成每天睡觉前必看一篇文章的习惯了，不得不说这种用户黏性是真的强啊！</p><h4 id="5-4-2-用户点赞量如何"><a href="#5-4-2-用户点赞量如何" class="headerlink" title="5.4.2 用户点赞量如何"></a>5.4.2 用户点赞量如何</h4><p>公众号推文给用户，那用户对文章的反应怎么样呢？我们来看看用户点赞随发文时间的柱状图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-76662f3151b7cef6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>代码的思路和之前的一致，这里就不放出来了，总的来说，这个公众号的点赞量还是很可观的。</p><h2 id="6-结语"><a href="#6-结语" class="headerlink" title="6. 结语"></a>6. 结语</h2><p>通过上述几个分析，我觉得如果想让公众号有更多的读者和阅读量上一个台阶可以从下面 2 个角度去考虑：</p><ul><li>要起一个好的标题，这个标题一定要符合你面向群体的喜好，而且不能太长</li><li>思考一下你面向群体的空闲时间，在空闲时间内推送文章，逐渐让用户对公众号产生黏性</li></ul><p>此外，本文是基础的探索性质的数据分析文，不是数据分析报告，重在启迪思路，授人以渔，而且受限于数据规模，得出结论不是本文的目的，对结果的分析分散在各个部分，“文末结论控”不喜勿喷。</p><blockquote><p>完整源码可在公众号：「01 二进制」后台回复：「公众号数据分析」获取</p></blockquote><hr><p>“万水千山都是情，给个关注行不行 👇”</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-3115d324eaba8d74?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyenv下使用python matplotlib模块的问题解决</title>
      <link href="p/9bdc.html"/>
      <url>p/9bdc.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpyebydkqj309c046wec.jpg"></p><h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>先来描述一下我遇到的问题，在进行matplotlib学习时，<code>plot.show()</code>总是无法成功运行，总是会报一个错：</p><blockquote><p>RuntimeError: <code>Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. </code>See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of ‘python’ with ‘pythonw’. See ‘Working with Matplotlib on OSX’ in the Matplotlib FAQ for more information.</p></blockquote><p>其实意思很简单，就是我用的python并不是一个作为系统框架存在的，因为我为了方便管理python的版本，选择了<strong>pyenv</strong>这个管理工具，是一个独立出来的python环境。</p><a id="more"></a><h2 id="尝试解决无果"><a href="#尝试解决无果" class="headerlink" title="尝试解决无果"></a>尝试解决无果</h2><p>参考网上众多的解决方法，例如以下两个最常见的：</p><p><strong><em>方法一：</em></strong><br>添加如下两行 代码解决:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import matplotlib</span><br><span class="line">&gt;&gt;&gt; matplotlib.use(&#39;TkAgg&#39;)</span><br><span class="line">##在import matplotlib下的模块，如pyplot等之前添加上面2句</span><br><span class="line">&gt;&gt;&gt; import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure><p><strong><em>方法二：</em></strong><br>添加一下matplotlib的配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;backend: TkAgg&quot; &gt;&gt; ~&#x2F;.matplotlib&#x2F;matplotlibrc</span><br></pre></td></tr></table></figure><p>然而，以上这两种解决方式都**<em>无法解决我的问题**</em>,此时出现了第二个错误：</p><blockquote><p>No module named ‘_tkinter’</p></blockquote><p>说是找不到<code>tkinter</code>这个模块，找了网上大多数方法，全都是linux系统下的解决方案，我真的很好奇没有一个使用mac的用户出现我这样的问题吗？<br>究其原因，是因为，使用<strong>pyenv</strong>独立安装出来的python中并没有<code>tkinter</code>这个模块，于是尝试直接安装<code>tkinter</code>，结果竟然提示没有发现<code>tkinter</code>包！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install tkinter</span><br><span class="line">Collecting tkinter</span><br><span class="line">Could not find a version that satisfies the requirement tkinter (from versions: )</span><br><span class="line">No matching distribution found for tkinter</span><br></pre></td></tr></table></figure><p>来到这，我不禁陷入了深深的思考，这个<code>tkinter</code>到底是何方神圣，去了Python社区：<a href="https://docs.python.org/3/library/tkinter.html">https://docs.python.org/3/library/tkinter.html</a>，这才懂了他是啥玩意：</p><blockquote><p>The <a href="https://docs.python.org/3/library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code>tkinter</code></a> package (“Tk interface”) is the standard Python interface to the Tk GUI toolkit. Both Tk and <a href="https://docs.python.org/3/library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code>tkinter</code></a> are available on most Unix platforms, as well as on Windows systems. (Tk itself is not part of Python; it is maintained at ActiveState.)<br>Running <code>python -m tkinter</code> from the command line should open a window demonstrating a simple Tk interface, letting you know that <a href="https://docs.python.org/3/library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code>tkinter</code></a> is properly installed on your system, and also showing what version of Tcl/Tk is installed, so you can read the Tcl/Tk documentation specific to that version.</p></blockquote><p>说白了，<code>tkinter</code> 就是一个利用python做GUI(图形用户界面)，它提供各种标准的 GUI 接口项，以利于迅速进行高级应用程序开发。</p><p>那么究竟去哪安装这个<code>tkinter</code>包，说实话到现在我也不知道如何利用<strong>pyenv</strong>去安装<code>tkinter</code>，那这个问题又该怎么解决呢？</p><h2 id="曲线救国"><a href="#曲线救国" class="headerlink" title="曲线救国"></a>曲线救国</h2><p>既然<code>tkinter</code>这个GUI库没用，那换个库是不是就好了呢？结果的确和我想的一样，在我换了一个GUI库之后，他的确成功了。<br>具体操作如下：<br>在出现<code>Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. </code>这个错误的时候，在终端输入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;backend : Qt5Agg&quot; &gt; ~&#x2F;.matplotlib&#x2F;matplotlibrc</span><br></pre></td></tr></table></figure><p>如果提示你没有安装<code>PyQt</code>的话，你就需要执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pyqt</span><br></pre></td></tr></table></figure><p>然后在执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install PyQt5</span><br></pre></td></tr></table></figure><p>这时候在运行你的代码就可以了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-5292df553463fe3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> pyenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac下利用pyenv管理多个版本的python</title>
      <link href="p/1282.html"/>
      <url>p/1282.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzpydn9g1ij313s0u0acm.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常遇到这样的情况：</p><ul><li>系统自带的Python是2.x，自己需要Python 3.x；</li><li>某些机器学习的框架（如PaddlePaddle/Tensorflow）需要的版本是python3.5，但是你的系统支持的python版本较高，且无法删除（因为某些软件会和python产生依赖）</li></ul><p>此时需要在系统中安装多个Python，但又不能影响系统自带的Python，即需要实现Python的多版本共存。<a href="https://github.com/yyuu/pyenv">pyenv</a>就是这样一个Python版本管理器。</p><a id="more"></a><p><strong>pyenv</strong>可以进行全局的 Python 版本切换，也可以给单个项目提供对应的 Python 版本。用了 「pyenv」以后，就可以很容易的安装不同的 Python 版本，不同版本之间的切换也变得 so easy。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>Pyenv只会管理通过Pyenv安装的Python版本，你自己在Python官网上下载的直接安装的Pyenv<code>并不能被管理！！！</code>同样除了系统自带的python包外,<code>其他直接安装</code>的python包是<code>识别不出来</code>的,即使使用的brew安装的也识别不出来.</p></blockquote><h2 id="pyenv的安装"><a href="#pyenv的安装" class="headerlink" title="pyenv的安装"></a>pyenv的安装</h2><ol><li>安装工具：<a href="https://brew.sh/index_zh-cn">brew</a></li><li>系统环境：<img src="https://upload-images.jianshu.io/upload_images/5666077-b573ed4d6756ec14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li></ol><h3 id="通过homebrew安装"><a href="#通过homebrew安装" class="headerlink" title="通过homebrew安装"></a>通过homebrew安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><p>但是github提示了一句话</p><blockquote><p>After installation, you’ll need to <code>add eval &quot;$(pyenv init -)&quot; to your profile</code> (as stated in the caveats displayed by Homebrew — to display them again, usebrew info pyenv). You only need to add that to your profile once.</p></blockquote><p>意思就是说我们需要在profile文件里面添加一句</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval &quot;$(pyenv init -)&quot; </span><br></pre></td></tr></table></figure><p>博主亲测，如果没有这一步，后面执行<code>pyenv global [version]</code>是不会成功的。</p><h4 id="编辑-bash-profile文件"><a href="#编辑-bash-profile文件" class="headerlink" title="编辑.bash_profile文件"></a>编辑.bash_profile文件</h4><hr><p>在终端中输入如下命令，进入当前用户的Home目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~ </span><br></pre></td></tr></table></figure><p>输入如下命令，打开.bash_profile文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open .bash_profile</span><br></pre></td></tr></table></figure><p>如不存在，则输入如下命令，创建文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch .bash_profile</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure><p>在弹出的.bash_profile文件中新增</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure><p>command + s 保存文件,然后在终端中输入如下命令，刷新之前配置的.bash_profile文件.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><h3 id="验证pyenv是否安装成功"><a href="#验证pyenv是否安装成功" class="headerlink" title="验证pyenv是否安装成功"></a>验证pyenv是否安装成功</h3><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv --help</span><br></pre></td></tr></table></figure><p>上面命令行的意思是获取 prenv 的帮助信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-e0358401b5843a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="pyenv的常用命令"><a href="#pyenv的常用命令" class="headerlink" title="pyenv的常用命令"></a>pyenv的常用命令</h2><p><img src="https://upload-images.jianshu.io/upload_images/5666077-1dc672875082b73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上图是官方文档中的例子，以下是整理的一些pyenv的常用命令，如果想要查看完整命令列表，可以点击查看<a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#command-reference">pyenv命令列表</a></p><ul><li>查看pyenv支持哪些Python版本</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5666077-34180201b67c6a5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="查看可以安装的版本"></p><ul><li>查看已经安装的python版本</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5666077-b3cd0f47a0508a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="查看已经安装的版本"></p><ul><li>查看当前使用的python版本</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv version</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5666077-5a4b5af4f711a865.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="查看当前使用的Python版本"></p><ul><li>安装一个python版本如3.5.6</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.5.6</span><br></pre></td></tr></table></figure><ul><li>安装完成之后需要对数据库进行更新：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure><ul><li>卸载一个python版本如3.5.6</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall  3.5.6</span><br></pre></td></tr></table></figure><ul><li>设置全局python版本如3.5.6</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv global 3.5.6</span><br><span class="line">&#x2F;&#x2F;很多人不推荐这么做,说是mac操作系统的文件也会调用原生的2.7的python版本</span><br><span class="line">&#x2F;&#x2F;这种说法感觉有点:恐惧来自未知的感觉.持保留意见</span><br></pre></td></tr></table></figure><ul><li>这个时候确认一下当前python的版本</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5666077-4b911293e5787e60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="确认当前python的版本"><br>发现已经更改为3.5.6了</p><ul><li>设置目录级python版本如3.5.6</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv local 3.5.6</span><br></pre></td></tr></table></figure><ul><li>为当前shell会话设置python版本如3.5.6</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv shell 3.5.6</span><br></pre></td></tr></table></figure><h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><ol><li><code>pyenv install [version]</code>下载太慢<br>只需要在python的官网下载你需要的python版本的<code>tar.xz</code>文件然后放到 <code>/User/.pyenv/cache</code>中然后再执行<code>pyenv install [version]</code>就可以了</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5666077-4c9dbf9675a8f1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="下载第二个文件"></p><blockquote><p>在这里提一下：<code>/.pyenv</code> 在mac中是隐藏文件夹，mac显示隐藏文件夹的快捷键是：<code>shift+command+.</code></p></blockquote><ol start="2"><li>出现 <code>zipimport.ZipImportError: can&#39;t decompress data; zlib not available</code> 的问题</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ pyenv install 3.5-dev</span><br><span class="line">Cloning https:&#x2F;&#x2F;hg.python.org&#x2F;cpython...</span><br><span class="line">Installing Python-3.5-dev...</span><br><span class="line"> </span><br><span class="line">BUILD FAILED (OS X 10.11.6 using python-build 20150818)</span><br><span class="line"> </span><br><span class="line">Inspect or clean up the working tree at &#x2F;var&#x2F;folders&#x2F;23&#x2F;4kbs9t712jv1mvmw6cpjwr2m0000gn&#x2F;T&#x2F;python-build.20160815000934.22185</span><br><span class="line">Results logged to &#x2F;var&#x2F;folders&#x2F;23&#x2F;4kbs9t712jv1mvmw6cpjwr2m0000gn&#x2F;T&#x2F;python-build.20160815000934.22185.log</span><br><span class="line"> </span><br><span class="line">Last 10 log lines:</span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;folders&#x2F;23&#x2F;4kbs9t712jv1mvmw6cpjwr2m0000gn&#x2F;T&#x2F;python-build.20160815000934.22185&#x2F;Python-3.5-dev&#x2F;Lib&#x2F;ensurepip&#x2F;__main__.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    ensurepip._main()</span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;folders&#x2F;23&#x2F;4kbs9t712jv1mvmw6cpjwr2m0000gn&#x2F;T&#x2F;python-build.20160815000934.22185&#x2F;Python-3.5-dev&#x2F;Lib&#x2F;ensurepip&#x2F;__init__.py&quot;, line 209, in _main</span><br><span class="line">    default_pip&#x3D;args.default_pip,</span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;folders&#x2F;23&#x2F;4kbs9t712jv1mvmw6cpjwr2m0000gn&#x2F;T&#x2F;python-build.20160815000934.22185&#x2F;Python-3.5-dev&#x2F;Lib&#x2F;ensurepip&#x2F;__init__.py&quot;, line 116, in bootstrap</span><br><span class="line">    _run_pip(args + [p[0] for p in _PROJECTS], additional_paths)</span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;folders&#x2F;23&#x2F;4kbs9t712jv1mvmw6cpjwr2m0000gn&#x2F;T&#x2F;python-build.20160815000934.22185&#x2F;Python-3.5-dev&#x2F;Lib&#x2F;ensurepip&#x2F;__init__.py&quot;, line 40, in _run_pip</span><br><span class="line">    import pip</span><br><span class="line">zipimport.ZipImportError: can&#39;t decompress data; zlib not available</span><br><span class="line">make: *** [install] Error 1</span><br></pre></td></tr></table></figure><p>解决方案参考<a href="https://github.com/pyenv/pyenv/issues/451">#451</a><br>用如下命令就可以解决了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ CFLAGS&#x3D;&quot;-I$(brew --prefix openssl)&#x2F;include -I$(xcrun --show-sdk-path)&#x2F;usr&#x2F;include&quot; \</span><br><span class="line">  LDFLAGS&#x3D;&quot;-L$(brew --prefix openssl)&#x2F;lib&quot; \</span><br><span class="line">  pyenv install -v 3.5-dev</span><br></pre></td></tr></table></figure><ol start="3"><li><code>pyenv global [verion]</code>命令失效<br>这个问题我已经在上面说过了，需要在<code>bash_profile</code>文件里面添加一句</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval &quot;$(pyenv init -)&quot; </span><br></pre></td></tr></table></figure><p>添加方式上面已经详细介绍过了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文参考：</p><ol><li><a href="https://github.com/pyenv/pyenv">Simple Python Version Management: pyenv</a></li><li><a href="https://www.jianshu.com/p/cea9259d87df">Mac下 Pyenv 的安装使用</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> pyenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 管理哪家强？</title>
      <link href="p/b3ec.html"/>
      <url>p/b3ec.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13dkeueaoj30k009g75s.jpg" alt="Pipenv - The Officially Recommended Python Packaging Tool"></p><p>之前介绍过<a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247483652&idx=1&sn=5679544151f62a06b3935a713ad42fc5&chksm=ceb3d5b6f9c45ca072623be7ce1c7794a467b01d0f3149d4e20a7455c5c5e7dc5df39d9cf623&token=155766547&lang=zh_CN#rd">《利用pyenv管理多个版本的python》</a>，pyenv 是一个非常好用的 Python 版本管理工具，利用它我们可以在同一台电脑上安装多个版本的 Python ，这个过程非常简单。Mac系统的电脑一行命令就可以安装了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><p>pyenv 的安装和使用详见开篇提到的文章，这里不再赘述。</p><p>今天主要是想介绍另一个非常好用的 Python 工具——**”Pipenv”**</p><h2 id="Pipenv是什么？"><a href="#Pipenv是什么？" class="headerlink" title="Pipenv是什么？"></a>Pipenv是什么？</h2><blockquote><p><strong>Pipenv</strong> is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. <em>Windows is a first-class citizen, in our world.</em></p><p>It automatically creates and manages a virtualenv for your projects, as well as adds/removes packages from your <code>Pipfile</code> as you install/uninstall packages. It also generates the ever-important <code>Pipfile.lock</code>, which is used to produce deterministic builds.</p></blockquote><p>上段引用自官方文档，简单来说就是 Pipenv 是希望成为 Python 界最好的包管理工具，成为 Python 界的 <em>npm</em>。你可以使用 Pipenv 这一个工具来安装、卸载、跟踪和记录依赖性，并创建、使用和组织你的虚拟环境。<br>当你使用它启动一个项目时，如果你还没有使用虚拟环境的话，Pipenv 将自动为该项目创建一个虚拟环境。<br>Pipenv 使用 <code>Pipfile</code> 和 <code>Pipfile.lock</code> 来管理依赖包，并且在使用 pipenv 添加或删除包时，自动维护 Pipfile 文件，同时生成 Pipfile.lock 来锁定安装包的版本和依赖信息，避免构建错误。相比pip需要手动维护requirements.txt 中的安装包和版本，具有很大的进步。</p><h2 id="为什么要使用-Pipenv"><a href="#为什么要使用-Pipenv" class="headerlink" title="为什么要使用 Pipenv"></a>为什么要使用 Pipenv</h2><p>设想一个场景：你手头有多个开发项目，其中项目 A 和项目 B 要求用 Python3，项目C需要用 Python2，而项目 A 和项目 B 又要求第三方依赖包相互独立，互不干扰。</p><p>这个时候，为了满足版本的不同我们需要使用 Pyenv 安装多个版本的 Python ，同时为了使不同项目之间隔离开来，我们可以使用 Pipenv 创建虚拟的开发环境。</p><p>那有的人就要问了，<code>virtualenv</code>不就可以创建虚拟环境了吗，为什么还要使用 Pipenv ，这里先卖个关子，文末我再来比较这些常见工具之间的差异性。</p><h2 id="使用-Pipenv"><a href="#使用-Pipenv" class="headerlink" title="使用 Pipenv"></a>使用 Pipenv</h2><h3 id="安装-Pipenv"><a href="#安装-Pipenv" class="headerlink" title="安装 Pipenv"></a>安装 Pipenv</h3><p>如果你是Mac电脑，那么推荐使用Homebrew来安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install pipenv</span><br></pre></td></tr></table></figure><p>如果不是Mac电脑，建议 使用Python3的pip3 安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pipenv</span><br></pre></td></tr></table></figure><p>执行pipenv，可以查看pipenv的帮助信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv</span><br></pre></td></tr></table></figure><p>如果出现如下信息，就说明安装成功了：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13bfa496rj30vo0kadqb.jpg" alt="image-20190315112449577"></p><h3 id="为项目创建虚拟环境"><a href="#为项目创建虚拟环境" class="headerlink" title="为项目创建虚拟环境"></a>为项目创建虚拟环境</h3><p>默认地，虚拟环境会创建在<code>~/.local/share/virtualenvs</code>目录里面。<br>如果我们希望在每个项目的根目录下保存虚拟环境目录（.venv），需要在 <code>.bashrc</code> 或 <code>.bash_profile</code> 中配置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PIPENV_VENV_IN_PROJECT&#x3D;1</span><br></pre></td></tr></table></figure><p>要想使配置生效，执行下<code>source ~/.bashrc</code>或者<code>source ~/.bash_profile</code>即可使环境变量生效。<br>接下来我们为项目创建虚拟环境。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir pipenv_demo</span><br><span class="line">cd pipenv_demo</span><br><span class="line">pipenv --python 3.6.7 # 为当前初始化一个版本为 3.6.7 的python环境</span><br></pre></td></tr></table></figure><h3 id="首次运行"><a href="#首次运行" class="headerlink" title="首次运行"></a>首次运行</h3><p>如果是第一次在项目中运行 <code>pipenv</code> 命令的话，会在项目中创建一个名为 <code>Pipfile</code> 的文件，文件内容类似下面这样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[source]]</span><br><span class="line">url &#x3D; &quot;https:&#x2F;&#x2F;pypi.org&#x2F;simple&quot;</span><br><span class="line">verify_ssl &#x3D; true</span><br><span class="line">name &#x3D; &quot;pypi&quot;</span><br><span class="line"></span><br><span class="line">[packages]</span><br><span class="line">requests-html &#x3D; &quot;*&quot;</span><br><span class="line"></span><br><span class="line">[dev-packages]</span><br><span class="line"></span><br><span class="line">[requires]</span><br><span class="line">python_version &#x3D; &quot;3.7&quot;</span><br></pre></td></tr></table></figure><p>这个文件就类似于 maven 中的 <code>pom.xml</code>、npm 中的 <code>package.json</code> 文件。如果运行过install、update等命令的话，还会创建一个<code>Pipfile.lock</code>文件，类似npm中的lock文件。这两个文件就是pipenv用于管理第三方库的配置文件，如果同时使用版本控制软件的话，需要将它们也加入进去。</p><blockquote><p>Tips：对于这个文件我们需要先做一件事，就是更改 <strong>[[source]]</strong> 中的 url 为国内镜像。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[source]]</span><br><span class="line"> url &#x3D; &quot;https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&quot;</span><br></pre></td></tr></table></figure></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="安装项目依赖"><a href="#安装项目依赖" class="headerlink" title="安装项目依赖"></a>安装项目依赖</h4><p>如果我想在项目中安装requests这个包，运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install requests</span><br></pre></td></tr></table></figure><p>如果需要指定具体版本号，可以这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install requests&#x3D;&#x3D;2.13.0</span><br></pre></td></tr></table></figure><p>如果是第一次运行pipenv的话，会先创建Pipfile文件，否则会修改Pipfile文件。</p><p>该命令还有一个常用参数-d或–dev，用于安装仅供开发使用的包。</p><blockquote><p>Tips：用 git 管理项目时候，要把 <code>Pipfile</code> 和 <code>Pipfile.lock</code> 加入版本跟踪。这样 clone 了这个项目的同学，只需要执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install</span><br></pre></td></tr></table></figure><p>就可以安装所有的Pipfile中 [packages]部分的包了，并且自动为项目在自己电脑上创建了虚拟环境。</p></blockquote><h4 id="卸载某个依赖"><a href="#卸载某个依赖" class="headerlink" title="卸载某个依赖"></a>卸载某个依赖</h4><p>相应的还有命令来卸载第三方包，该命令还有两个参数<code>--all</code>和<code>--all-dev</code>用于卸载所有包和所有开发包。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv uninstall requests</span><br></pre></td></tr></table></figure><h4 id="更新项目依赖"><a href="#更新项目依赖" class="headerlink" title="更新项目依赖"></a>更新项目依赖</h4><p>查看所有需要更新的包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv update --outdated</span><br></pre></td></tr></table></figure><p>更新所有包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv update</span><br></pre></td></tr></table></figure><p>更新指定的包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv update &lt;包名&gt;</span><br></pre></td></tr></table></figure><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv -h  # 查看帮助</span><br><span class="line">pipenv graph  # 查看已安装的包</span><br><span class="line">pipenv shell  # 启动shell</span><br><span class="line">pipenv run python hello.py  # 运行脚本</span><br></pre></td></tr></table></figure><h3 id="Python-管理哪家强？"><a href="#Python-管理哪家强？" class="headerlink" title="Python 管理哪家强？"></a>Python 管理哪家强？</h3><p>还记得在最开始提出的问题吗？明明<code>virtualenv</code>就可以创建虚拟环境了吗，为什么还要使用 Pipenv 呢？</p><p>接下来我们来横向对比下几个常见的容易弄混的 python 管理工具（我在初学的时候总是分不清😂）</p><table><thead><tr><th>工具</th><th>介绍</th><th>原理</th></tr></thead><tbody><tr><td>pip</td><td>包管理工具</td><td></td></tr><tr><td>virtualenv</td><td>虚拟环境管理工具</td><td>切换目录</td></tr><tr><td>virtualenvwrapper</td><td>虚拟环境管理工具加强版</td><td></td></tr><tr><td>pyenv</td><td>python版本管理工具</td><td>修改环境变量</td></tr><tr><td>pyenv-virtualenv</td><td>虚拟环境管理工具</td><td></td></tr><tr><td>pipenv</td><td>项目环境管理工具</td><td></td></tr><tr><td>anaconda</td><td>一个包含180+的科学包及其依赖项的发行版本（不只是 Python 可用）</td><td></td></tr></tbody></table><p>同时在推荐一个我在 stackoverflow 上看到的回答：<a href="https://stackoverflow.com/questions/38217545/what-is-the-difference-between-pyenv-virtualenv-anaconda/39928067#39928067">What is the difference between pyenv, virtualenv, anaconda?</a></p><h3 id="实践建议："><a href="#实践建议：" class="headerlink" title="实践建议："></a>实践建议：</h3><p>建议团队内开发人员，在自己电脑上都安装 pyenv 和 pipenv 。Pipfile 和 Pipfile.lock 加入版本跟踪，.venv 不要加入版本管理。为自己的每一个项目建立独立的虚拟环境。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://stackoverflow.com/questions/38217545/what-is-the-difference-between-pyenv-virtualenv-anaconda/39928067#39928067">What is the difference between pyenv, virtualenv, anaconda?</a></li><li><a href="https://blog.csdn.net/liuchunming033/article/details/79582617">利用pipenv和pyenv管理多个相互独立的Python虚拟开发环境</a></li><li><a href="https://blog.csdn.net/u011054333/article/details/82891847">pipenv快速入门</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISE头条号海报生成器</title>
      <link href="p/3f5e.html"/>
      <url>p/3f5e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0vtglskw9j30zk0npn4j.jpg" alt="题图：来自Pixabay"></p><blockquote><p>完整源码可在公众号：「01二进制」后台回复：「海报生成器」获取</p></blockquote><p>最近自闭了一段时间，仔细思考一番后还是决定要把自己心中所想坚持下去。今天来分享一个日常生活中经常见到，但是制作起来又可能会一时没有思路的东西，主要功能就是生成带二维码的卡片或者海报。</p><p>之前莫名其妙的被导师安排负责管理实验室的头条号，任务不难，就是接收实验室学长学姐翻译转述的论文，然后再发布到今日头条的头条号上，最后再生成如下所示的宣传图即可：</p><p><img src="https://ws2.sinaimg.cn/bmiddle/006tKfTcgy1g0vtqxipsfj30jp0pz400.jpg"></p><p>当时觉得，不就是发发文章，然后再用<strong>ps</strong>做个图这么简单吗。可接手之后才发现我毕竟图样图森破啊，从去年11月我开始发文章到今天，期间从未有一天断过，但是这头条号的编辑器也从未更新过，一个这么大的自媒体企业，文章的编辑器竟然烂的跟坨💩一样，不支持外部图片，不支持markdown，不支持数学公式，不支持多级标题。（别跟我说什么可以把markdown转成html然后再复制进头条号的编辑器里面，样式都变成鬼了）</p><p>扯远了扯远了，回到正题。之前这么多天实现上述需要的主要流程如下：</p><ol><li>（采取各种方式优化排版）把文章发布到（不支持各种常用功能的）头条号上</li><li>文章发布后，获取其文章链接，并到草料二维码生成器网站，上传实验室logo后生成二维码下载至本地</li><li>利用PhotoShop将封面图、文章标题和文章二维码合成在一起后发给老师。</li></ol><p>在经历了100天上述这样重复的操作之后，我厌烦了。难道就没有一个工具可以让我只输入文章链接和标题就自动生成海报的吗？</p><p>苦苦寻觅半天无果，也罢，有条件要上，没条件创造条件也要上。没有现成的轮子，那就只能自己打造一个了，Python无疑是开发这个小工具的首选。</p><p>一般用于推广的海报或卡片样式都差不多，需要改变的主要就是二维码，所以只需要准备好海报的背景图，然后根据用户提供的二维码，将其贴在海报指定的位置上即可。</p><p>此次实验的项目结构如下：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0vusz8kw8j30ak07wt8y.jpg"></p><blockquote><p>assets文件夹中包含一些资源文件，例如<code>msyhl.ttc（字体文件）</code>、<code>template.jpg（背景模版图片）</code>。output是生成的海报存放的路径</p></blockquote><h2 id="生成带logo的二维码"><a href="#生成带logo的二维码" class="headerlink" title="生成带logo的二维码"></a>生成带logo的二维码</h2><p>本次生成二维码依赖于 <strong>PIL 模块</strong>和 <strong>qrcode 库</strong>，官方地址为：<a href="https://pypi.org/project/qrcode/5.1/%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E8%A7%A3%E9%87%8A%E7%94%A8%E6%B3%95%EF%BC%8C%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%8B%E4%BA%86%E8%A7%A3%E3%80%82%E8%BF%99%E9%87%8C%E5%B0%B1%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BB%A3%E7%A0%81%E4%BA%86%EF%BC%8C%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E7%9A%84%E7%94%A8%E6%84%8F%E8%AF%A6%E8%A7%81%E6%B3%A8%E9%87%8A%EF%BC%9A">https://pypi.org/project/qrcode/5.1/，这里不解释用法，感兴趣的自己去官方文档下了解。这里就直接上代码了，具体代码的用意详见注释：</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个带logo的二维码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateQRCode</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    qr = qrcode.QRCode(</span><br><span class="line">        version=<span class="number">5</span>, error_correction=qrcode.constants.ERROR_CORRECT_H, box_size=<span class="number">8</span>)</span><br><span class="line">    <span class="comment"># 添加内容</span></span><br><span class="line">    qr.add_data(url)</span><br><span class="line">    qr.make(fit=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    img = qr.make_image()</span><br><span class="line">    img = img.convert(<span class="string">&quot;RGBA&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取logo</span></span><br><span class="line">    icon = Image.open(<span class="string">&quot;assets/logo.jpg&quot;</span>)</span><br><span class="line">    <span class="comment"># 设置logo</span></span><br><span class="line">    img_w, img_h = img.size</span><br><span class="line">    factor = <span class="number">4</span></span><br><span class="line">    size_w = int(img_w / factor)</span><br><span class="line">    size_h = int(img_h / factor)</span><br><span class="line"></span><br><span class="line">    icon_w, icon_h = icon.size</span><br><span class="line">    <span class="keyword">if</span> icon_w &gt; size_w:</span><br><span class="line">        icon_w = size_w</span><br><span class="line">    <span class="keyword">if</span> icon_h &gt; size_h:</span><br><span class="line">        icon_h = size_h</span><br><span class="line">    icon = icon.resize((icon_w, icon_h), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将logo并入原二维码中</span></span><br><span class="line">    w = int((img_w - icon_w)/<span class="number">2</span>)</span><br><span class="line">    h = int((img_h - icon_h)/<span class="number">2</span>)</span><br><span class="line">    icon = icon.convert(<span class="string">&quot;RGBA&quot;</span>)</span><br><span class="line">    img.paste(icon, (w, h), icon)</span><br><span class="line">    rgb_im = img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存到指定路径下</span></span><br><span class="line">    today = datetime.date.today()</span><br><span class="line">    folder_path = <span class="string">&#x27;output/&#x27;</span>+str(today)</span><br><span class="line">    mkdir(folder_path)</span><br><span class="line">    rgb_im.save(folder_path+<span class="string">&#x27;/qr.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="生成海报"><a href="#生成海报" class="headerlink" title="生成海报"></a>生成海报</h2><p>我们先来梳理下，想要生成一张满足我们需求的海报需要哪些元素：</p><ul><li>二维码（qrImg）</li><li>背景模版图片（template.jpg）</li><li>文章标题（postTitle）</li><li>和文章有关的封面图（postPic）</li></ul><blockquote><p>换一种方式呈现代码，推荐一个将代码转换成图片的美化工具<strong>Carbonize</strong></p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0vvdgbhbyj30u00xxqep.jpg"></p><p>其实仔细阅读过这段代码之后才觉得整体的思路一目了然：先读取需要的素材文件（二维码、标题），然后将素材粘贴到背景图片的指定位置。唯一复杂点的就是要找到一个合适的粘贴点，这个没办法，只能自己去试。</p><blockquote><p>完整源码可在公众号：「01二进制」后台回复：「海报生成器」获取</p></blockquote><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这里有点我要提下，就是利用<code>PIL</code>更改图片大小那块，也就是<code>postPic.thumbnail((width/1.5, height/1.5))</code>这个地方，其实PIL中还有一个方法叫做<code>resize</code>也是用来更改图片的大小的，那两者有何区别呢？</p><p>使用PIL生成缩略图用两种方式，<code>resize</code>和<code>thumbnail</code>,区别在于使用<code>reszie</code>会返回一个新对象，<br>而使用<code>thumbnail</code>则会在原对象上进行修改，即<code>thumbnail</code>会覆盖原图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im = Image.open(<span class="string">&#x27;a.jpg&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im.size   <span class="comment"># 原图尺寸</span></span><br><span class="line">(<span class="number">3264</span>, <span class="number">2448</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(im)</span><br><span class="line"><span class="number">140253860921640</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>resize_im = im.resize((<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>resize_im</span><br><span class="line">&lt;PIL.Image.Image image mode=RGB size=<span class="number">100</span>x100 at <span class="number">0x7F8F65A0A518</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(resize_im)</span><br><span class="line"><span class="number">140253862077720</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thumb_im = im.thumbnail((<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thumb_im</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im.size   <span class="comment"># 使用thumbnail后的原图尺寸改变，resize后的结果不一定等于指定的尺寸，因为是按比例缩放的</span></span><br><span class="line">(<span class="number">100</span>, <span class="number">75</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter实现文件下载</title>
      <link href="p/aa30.html"/>
      <url>p/aa30.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前有做一个工具集的微信小程序「开挂 Lite」，但是由于小程序自身限制，没有办法实现下载文件的功能，只能把下载链接解析出来。而且受限于微信平台，小程序的审核是一件很麻烦的事情，因此有了将其 APP 化的想法。</p><p>自从去年 Flutter 横空出世后，我便一直关注它的发展，时隔一年后重新拾起，发现它的生态已经初具规模，于是决定采用 Flutter 重做一个「开挂 Lite」。后期我也会不定时更新一些和 Flutter 有关的文章，希望大家可以多多支持。本文记录的便是我利用 Flutter 实现文件下载功能的过程。</p><blockquote><p>完整源码可在公众号：「01 二进制」后台回复：「Flutter 文件下载」获取</p></blockquote><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>我们先看一下实现的效果：</p><p><strong>iOS</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-18bd38bf54024947.gif?imageMogr2/auto-orient/strip"></p><p><strong>Android</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-aabdea4546e0d26a.gif?imageMogr2/auto-orient/strip"></p><p>本 demo 的实现效果非常简单，就是点击一个按钮，然后下载文件，完成后提示用户是否打开文件。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在本 demo 中使用的 IDE 为 <strong>Android Studio</strong>，同时使用到了以下几个库：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter_downloader: ^<span class="number">1.1</span><span class="number">.7</span></span><br><span class="line">path_provider: <span class="number">1.1</span><span class="number">.2</span></span><br><span class="line">permission_handler: ^<span class="number">3.1</span><span class="number">.0</span></span><br><span class="line">progress_dialog: ^<span class="number">1.1</span><span class="number">.0</span>+<span class="number">1</span></span><br><span class="line">toast: ^<span class="number">0.1</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>我们先新建一个空项目，然后将上述依赖添加到项目的<code>pubspec.yaml</code>文件，添加位置如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-ef41d7d38b8fe720.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来我们可以在 <strong>Terminal</strong> 中输入<code>flutter packages get</code>或者点击 IDE 左上角的<code>Packages get</code>字样安装依赖。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-0293aec0cca1885f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后将初始项目中的多余代码删除，并在中间添加一个按钮。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Center(</span><br><span class="line">  child: Column(</span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      RaisedButton(</span><br><span class="line">        child: Text(<span class="string">&quot;点我下载文件&quot;</span>),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">// 执行下载操作</span></span><br><span class="line">          _doDownloadOperation();</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>其中<code>_doDownloadOperation()</code>便是我们执行下载操作的方法，至此，前期准备工作结束。</p><h2 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h2><p>虽然整个下载演示的过程非常简单，但还是有必要来分析整个下载的流程，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-7c2c112bb5f2a7b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>所以我们接下来要做的事情便是：</p><ol><li>获取权限：网络权限、存储权限</li><li>获取下载路径</li><li>设置下载回调（用于监听下载过程）</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a>获取权限</h3><p>这里使用到一个权限获取插件：<code>permission_handler</code>，这个插件提供了跨平台（Android 和 iOS）的权限检查以及获取 API，地址在：<a href="https://pub.flutter-io.cn/packages/permission_handler%E3%80%82%E5%9C%A8%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90%E5%89%8D%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%88%E7%94%B3%E6%98%8E%E6%9D%83%E9%99%90%EF%BC%88Android%EF%BC%89%E3%80%82">https://pub.flutter-io.cn/packages/permission_handler。在获取权限前我们需要先申明权限（Android）。</a></p><p>打开项目根目录下的<code>android/app/src/main/AndroidManifest.xml</code>文件，位置如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-1deb409d3863b356.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后添加我们需要使用的权限的申明，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-c55a8c420aa35cfd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来我们就可以写代码来获取所需的权限了。创建一个<code>_checkPermission()</code>函数用于判断权限是否给予。当然由于平台差异，我们需要判断其为 Android 平台，申请代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请权限</span></span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; _checkPermission() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// 先对所在平台进行判断</span></span><br><span class="line">  <span class="keyword">if</span> (Theme.of(context).platform == TargetPlatform.android) &#123;</span><br><span class="line">    PermissionStatus permission = <span class="keyword">await</span> PermissionHandler()</span><br><span class="line">        .checkPermissionStatus(PermissionGroup.storage);</span><br><span class="line">    <span class="keyword">if</span> (permission != PermissionStatus.granted) &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;PermissionGroup, PermissionStatus&gt; permissions =</span><br><span class="line">          <span class="keyword">await</span> PermissionHandler()</span><br><span class="line">              .requestPermissions([PermissionGroup.storage]);</span><br><span class="line">      <span class="keyword">if</span> (permissions[PermissionGroup.storage] == PermissionStatus.granted) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取下载路径"><a href="#获取下载路径" class="headerlink" title="获取下载路径"></a>获取下载路径</h3><p>这里是使用的插件是<code>path_provider</code>，它是一个配合 Dart 的 IO 库以便在 Flutter 中实现文件读写的插件，Flutter 中文网对该插件有着详细的介绍(<a href="https://flutterchina.club/reading-writing-files/)%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%98%8E%E7%99%BD%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B0%B1%E6%98%AFiOS%E6%B2%A1%E6%9C%89%E5%A4%96%E7%BD%AE%E5%AD%98%E5%82%A8%E8%BF%99%E4%B8%80%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%9B%A0%E6%AD%A4%E9%9C%80%E8%A6%81%E5%AF%B9%E5%B9%B3%E5%8F%B0%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">https://flutterchina.club/reading-writing-files/)，这里我们需要明白一个问题，就是iOS没有外置存储这一概念，因此需要对平台进行判断，代码如下：</a></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取存储路径</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; _findLocalPath() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// 因为Apple没有外置存储，所以第一步我们需要先对所在平台进行判断</span></span><br><span class="line">  <span class="comment">// 如果是android，使用getExternalStorageDirectory</span></span><br><span class="line">  <span class="comment">// 如果是iOS，使用getApplicationSupportDirectory</span></span><br><span class="line">  <span class="keyword">final</span> directory = Theme.of(context).platform == TargetPlatform.android</span><br><span class="line">      ? <span class="keyword">await</span> getExternalStorageDirectory()</span><br><span class="line">      : <span class="keyword">await</span> getApplicationSupportDirectory();</span><br><span class="line">  <span class="keyword">return</span> directory.path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码我们便可以获取存储路径，但是如果我们不想把文件下载到存储路径呢？比如我就喜欢单独设置一个<code>/Download</code>路径专门用于保存下载文件，其实也很简单：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取存储路径</span></span><br><span class="line"><span class="keyword">var</span> _localPath = (<span class="keyword">await</span> _findLocalPath()) + <span class="string">&#x27;/Download&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> savedDir = Directory(_localPath);</span><br><span class="line"><span class="comment">// 判断下载路径是否存在</span></span><br><span class="line"><span class="built_in">bool</span> hasExisted = <span class="keyword">await</span> savedDir.exists();</span><br><span class="line"><span class="comment">// 不存在就新建路径</span></span><br><span class="line"><span class="keyword">if</span> (!hasExisted) &#123;</span><br><span class="line">  savedDir.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>下载文件这里我找了一些资料，发现貌似只有一个<code>flutter_downloader</code>插件，也不知道是什么情况。该插件的配置过程也是挺复杂的，好在文档(<a href="https://pub.flutter-io.cn/packages/flutter_downloader)%E5%86%99%E7%9A%84%E8%BF%98%E7%AE%97%E6%98%8E%E7%99%BD%E3%80%82%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%88%86%E5%88%AB%E5%9F%BA%E4%BA%8E">https://pub.flutter-io.cn/packages/flutter_downloader)写的还算明白。这个插件可以实现后台下载，分别基于</a> Android 中的 <a href="https://developer.android.com/topic/libraries/architecture/workmanager"><code>WorkManager</code></a> 和 iOS 中的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloadtask?language=objc"><code>NSURLSessionDownloadTask</code></a> 实现的。</p><p>接下来分别说下在 iOS 端和 Android 端的设置。</p><h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><p><strong>iOS 端配置</strong></p><ul><li>启用 <strong>background mode</strong></li></ul><p>想要执行这一步，我们在 Xcode 中打开该项目的 _iOS module_，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-a490d106d8654cc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后双击左侧<strong>Runner</strong>选项，选择 <strong>Capabilities</strong> 选项，按图中所示启用<em>background mode</em></p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-0acdf54405e40eb4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-35f904b896d16c1c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>添加 <strong>sqlite</strong> 依赖库</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5666077-5b01d6d6e383adcf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-61b9cf42dc3bcc9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>文档中还提供了一些<strong>可选配置</strong>：</p><ul><li>设置 HTTP 请求支持</li></ul><p>为了安全起见，苹果官方已经默认不让开发者使用不安全的 http 通信协议了，而是建议开发者使用安全的 https 协议。若我们还是需要使用 http 协议需要做一些配置，文档中给了两种方式配置，一种是允许单个 HTTP 请求的域名，另一种是允许所有 HTTP 请求的域名，这里出于演示目的，选择第二种。</p><p>只需要在<code>Info.plist</code>文件中添加如下代码即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置最大同时下载数</li></ul><p>默认支持同时下载最多 3 个文件，如果你需要更改同样需要更改<code>Info.plist</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>FDMaximumConcurrentTasks<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">integer</span>&gt;</span>5<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设置下载完成通知</li></ul><p>同样的，修改<code>Info.plist</code>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>FDAllFilesDownloadedMessage<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>All files have been downloaded<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Android 端配置</strong></p><p>说完了 iOS 端的配置，我们再来说下 Android 端的配置。在 <code>AndroidManifest.xml</code> 文件中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;vn.hunghd.flutterdownloader.DownloadedFileProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.flutter_downloader.provider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">&quot;@xml/provider_paths&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>位置如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-afa38a74f243f9ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>还有其他类似于 iOS 端的可选配置，功能大同小异，这里就不说了，详见官网。</p><h4 id="编写下载代码"><a href="#编写下载代码" class="headerlink" title="编写下载代码"></a>编写下载代码</h4><p>配置结束后，其实下载的代码很简单：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 downloadUrl 和 savePath 下载文件</span></span><br><span class="line">_downloadFile(downloadUrl, savePath) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> FlutterDownloader.enqueue(</span><br><span class="line">    url: downloadUrl,</span><br><span class="line">    savedDir: savePath,</span><br><span class="line">    showNotification: <span class="keyword">true</span>,</span><br><span class="line">    <span class="comment">// show download progress in status bar (for Android)</span></span><br><span class="line">    openFileFromNotification:</span><br><span class="line">        <span class="keyword">true</span>, <span class="comment">// click on notification to open downloaded file (for Android)</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们需要提前引入<code>flutter_downloader</code>库</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_downloader/flutter_downloader.dart&#x27;</span>;</span><br></pre></td></tr></table></figure><p>文档中还提供了其他 API，譬如暂停下载、取消下载，这里就不再阐述了，文档已经写的很清楚了。</p><p>到这其实就已经完成了下载的逻辑，然而下载的逻辑是实现了，想要让用户用的明白，我们还需要加一些提示信息，就像开头 demo 展示的有下载进度条和下载完成的提示框，接下来我们就来为下载设置这些提示信息吧。</p><h3 id="设置下载提示信息"><a href="#设置下载提示信息" class="headerlink" title="设置下载提示信息"></a>设置下载提示信息</h3><p>这里以对话框和进度条的形式展现下载过程，我们使用到了<code>progress_dialog</code>这个插件，可以很方便的显示出一个下载对话框，地址是<a href="https://pub.flutter-io.cn/packages/progress_dialog%E3%80%82">https://pub.flutter-io.cn/packages/progress_dialog。</a></p><p>使用<code>progress_dialog</code>插件非常简单，首先我们引入依赖文件：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:progress_dialog/progress_dialog.dart&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后创建一个对话框：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ProgressDialog pr;</span><br></pre></td></tr></table></figure><p>如果想要创建一个下载提示对话框的话我们只需要在合适的地方初始化这个 Dialog：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">pr = <span class="keyword">new</span> ProgressDialog(context,ProgressDialogType.Download);</span><br></pre></td></tr></table></figure><p>然后执行<code>pr.show();</code>即可显示对话框。取消这个对话框也非常的简单，只需执行<code>pr.hide();</code></p><p>如果想要更新对话框中的提示信息，比如下载进度，只需执行下述代码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">pr.update(progress: percentage,message: <span class="string">&quot;Please wait...&quot;</span>);</span><br></pre></td></tr></table></figure><p>同时我们还可以通过<code>isShowing()</code>函数判断对话框是否显示</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isProgressDialogShowing = pr.isShowing();</span><br></pre></td></tr></table></figure><p>是不是非常方便呢？</p><p>有了展示的对话框，下一步自然就是获取下载进度了，好在<code>flutter_downloader</code>已经给我们提供了一个下载回调，我们可以在下面的这个回调函数中更新我们的 UI。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FlutterDownloader.registerCallback((id, status, progress) &#123;</span><br><span class="line">  <span class="comment">// code to update your UI</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中<strong>id</strong>是下载任务的 id，<strong>status</strong>是当前 id 下载任务的状态，有<code>undefined,enqueued,running,complete,failed,canceled,paused</code>这几种状态，<strong>progress</strong>便是当前 id 下载任务的进度。</p><p>这里方便起见我选择在<code>initState()</code>函数中初始化下载回调函数和对话框：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  <span class="comment">// 初始化进度条</span></span><br><span class="line">  ProgressDialog pr = <span class="keyword">new</span> ProgressDialog(context, ProgressDialogType.Download);</span><br><span class="line">  pr.setMessage(<span class="string">&#x27;下载中…&#x27;</span>);</span><br><span class="line">  <span class="comment">// 设置下载回调</span></span><br><span class="line">  FlutterDownloader.registerCallback((id, status, progress) &#123;</span><br><span class="line">  <span class="comment">// 打印输出下载信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Download task (<span class="subst">$id</span>) is in status (<span class="subst">$status</span>) and process (<span class="subst">$progress</span>)&#x27;</span>);</span><br><span class="line">    ......</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>然后我们需要根据下载的状态分情况讨论</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 设置下载回调</span></span><br><span class="line">  FlutterDownloader.registerCallback((id, status, progress) &#123;</span><br><span class="line">  <span class="comment">// 打印输出下载信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Download task (<span class="subst">$id</span>) is in status (<span class="subst">$status</span>) and process (<span class="subst">$progress</span>)&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pr.isShowing()) &#123;</span><br><span class="line">      pr.<span class="keyword">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == DownloadTaskStatus.running) &#123;</span><br><span class="line">      pr.update(progress: progress.toDouble(), message: <span class="string">&quot;下载中，请稍后…&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == DownloadTaskStatus.failed) &#123;</span><br><span class="line">      showToast(<span class="string">&quot;下载异常，请稍后重试&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (pr.isShowing()) &#123;</span><br><span class="line">        pr.<span class="keyword">hide</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == DownloadTaskStatus.complete) &#123;</span><br><span class="line">      <span class="built_in">print</span>(pr.isShowing());</span><br><span class="line">      <span class="keyword">if</span> (pr.isShowing()) &#123;</span><br><span class="line">        pr.<span class="keyword">hide</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实到这里下载文件的操作就算结束了，但是通常在下载完成后 APP 都会提示你是否要打开，于是在这我们干脆 就拓展一下，实现打开我们已经下载好的文件。</p><h3 id="打开下载完成的文件"><a href="#打开下载完成的文件" class="headerlink" title="打开下载完成的文件"></a>打开下载完成的文件</h3><p>那如何打开已经下载好的文件呢？插件已经提供好了打开下载文件的 API，我们只需要像下面这样使用就可以了。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据taskId打开下载文件</span></span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; _openDownloadedFile(taskId) &#123;</span><br><span class="line">  <span class="keyword">return</span> FlutterDownloader.open(taskId: taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要打开已经下载完成的文件，我们必须要要确保文件已经下载好了。所以我们需要紧接上面的代码中判断下载完成的函数。这里我们以弹出对话框的形式询问用户是否打开文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-fa8cb8781b818726.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>代码如下</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (status == DownloadTaskStatus.complete) &#123;</span><br><span class="line">      <span class="built_in">print</span>(pr.isShowing());</span><br><span class="line">      <span class="keyword">if</span> (pr.isShowing()) &#123;</span><br><span class="line">        pr.<span class="keyword">hide</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 显示是否打开的对话框</span></span><br><span class="line">      showDialog(</span><br><span class="line">          <span class="comment">// 设置点击 dialog 外部不取消 dialog，默认能够取消</span></span><br><span class="line">          barrierDismissible: <span class="keyword">false</span>,</span><br><span class="line">          context: context,</span><br><span class="line">          builder: (context) =&gt; AlertDialog(</span><br><span class="line">                title: Text(<span class="string">&#x27;提示&#x27;</span>),</span><br><span class="line">                <span class="comment">// 标题文字样式</span></span><br><span class="line">                content: Text(<span class="string">&#x27;文件下载完成，是否打开？&#x27;</span>),</span><br><span class="line">                <span class="comment">// 内容文字样式</span></span><br><span class="line">                backgroundColor: CupertinoColors.white,</span><br><span class="line">                elevation: <span class="number">8.0</span>,</span><br><span class="line">                <span class="comment">// 投影的阴影高度</span></span><br><span class="line">                semanticLabel: <span class="string">&#x27;Label&#x27;</span>,</span><br><span class="line">                <span class="comment">// 这个用于无障碍下弹出 dialog 的提示</span></span><br><span class="line">                shape: Border.all(),</span><br><span class="line">                <span class="comment">// dialog 的操作按钮，actions 的个数尽量控制不要过多，否则会溢出 `Overflow`</span></span><br><span class="line">                actions: &lt;Widget&gt;[</span><br><span class="line">                  <span class="comment">// 点击取消按钮</span></span><br><span class="line">                  FlatButton(</span><br><span class="line">                      onPressed: () =&gt; Navigator.pop(context),</span><br><span class="line">                      child: Text(<span class="string">&#x27;取消&#x27;</span>)),</span><br><span class="line">                  <span class="comment">// 点击打开按钮</span></span><br><span class="line">                  FlatButton(</span><br><span class="line">                      onPressed: () &#123;</span><br><span class="line">                        Navigator.pop(context);</span><br><span class="line">                        <span class="comment">// 打开文件</span></span><br><span class="line">                        _openDownloadedFile(id).then((success) &#123;</span><br><span class="line">                          <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                            Scaffold.of(context).showSnackBar(SnackBar(</span><br><span class="line">                                content: Text(<span class="string">&#x27;Cannot open this file&#x27;</span>)));</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                      &#125;,</span><br><span class="line">                      child: Text(<span class="string">&#x27;打开&#x27;</span>)),</span><br><span class="line">                ],</span><br><span class="line">              ));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对话框的使用上述代码已经注释的很详细了。</p><p>至此，我们便使用 Flutter 完成了一个完整的下载文件的过程了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，利用 Flutter 实现文件下载的思路还是很清楚的，<strong>获取权限-&gt;获取路径-&gt;开始下载-&gt;监听下载进程</strong>，一气呵成。同时，借助于 Flutter 社区的快速发展，已经有很多优秀的开发者开发了一些非常好用的插件，凭借着这些插件我们可以快速实现自己想要的功能。在这个 demo 中整个界面编写+逻辑实现总共也才 <strong>223</strong> 行代码，虽然界面有些丑陋，但考虑到 Dart 语言的迷之缩进这个行数也是很短的了。</p><p>最后想要源码可以扫描下面的二维码关注我的公众号「01 二进制」，后台回复「Flutter 文件下载」即可，后期我也会不定时更新一些和 Flutter 有关的文章，希望大家可以多多支持。</p><hr><p><img src="https://upload-images.jianshu.io/upload_images/5666077-336aa719993c3a45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速适配 Flutter 之深色模式</title>
      <link href="p/9234.html"/>
      <url>p/9234.html</url>
      
        <content type="html"><![CDATA[<p>深色模式（Dark Mode），也被称为暗黑模式，是一种高对比度，或者反色模式的显示模式，开启之后在夜间可以缓解疲劳，更易于阅读，同时也能在一定程度上达到省电的效果。iOS 和安卓分别从 iOS 13 和 Android 10（不同厂商不尽相同，部分 Android 9 也支持） 开始加入深色模式的支持，各大浏览器纷纷开始支持深色模式，强如微信也终于在 iOS 客户端 7.0.12、Android 客户端 7.0.13 支持了深色模式，等网页端适配深色模式后将更进一步提高用户体验的一致性。</p><p>Flutter 作为一个先进的跨平台框架，自然也考虑到了深色模式的使用，我在上一篇文章<a href="https://juejin.im/post/5ea2b8b5e51d4546d72d5007">《Flutter 主题切换——让你的 APP 也能一键换肤》</a>的结尾提到了<code>Brightness brightness</code>属性可用于适配跟随系统的 DarkMode，我们可以直接在<code>MaterialApp</code>的<code>darkTheme</code>选项中使用</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">    theme: ThemeData(</span><br><span class="line">        brightness: Brightness.light,</span><br><span class="line">        primaryColor: Colors.blue,</span><br><span class="line">    ),</span><br><span class="line">    darkTheme: ThemeData(</span><br><span class="line">        brightness: Brightness.dark,</span><br><span class="line">    ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也可以写成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">darkTheme: ThemeData.dark()</span><br></pre></td></tr></table></figure><p>这样写的好处是，用户无需单独设置深/浅色模式，完全根据系统设置来切换。</p><p>但白天不懂夜的黑，有的人就是喜欢一套深色主题用一天，这时就需要用户可以手动开启深色模式了。</p><p>我们先来看下实现的效果：</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geitge3bqdg30u01t0x6u.gif" style="zoom: 33%;" /><h2 id="手动开启深色模式"><a href="#手动开启深色模式" class="headerlink" title="手动开启深色模式"></a>手动开启深色模式</h2><p>其实思路和上一篇文章类似，通过<a href="https://github.com/flutter/plugins/tree/master/packages/shared_preferences#usage">shared_preferences</a>保存用户设置，通过<a href="https://pub.dev/packages/provider">Provider</a>实现状态管理，这两个依赖的使用我在上一篇文章中已经介绍了，这里就不多说了。详情点击 👉<a href="https://juejin.im/post/5ea2b8b5e51d4546d72d5007#heading-0">Flutter 主题切换——让你的 APP 也能一键换肤</a>。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>我们在<code>pubspec.yaml</code>文件中添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">provider:</span> <span class="string">^4.0.5</span></span><br><span class="line"><span class="attr">flustars:</span> <span class="string">^0.2.6+1</span></span><br></pre></td></tr></table></figure><h3 id="深色模式状态管理类"><a href="#深色模式状态管理类" class="headerlink" title="深色模式状态管理类"></a>深色模式状态管理类</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flustars/flustars.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutterchallenge/constant.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DarkModeProvider</span> <span class="title">with</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">深色模式 0: 关闭 1: 开启 2: 随系统</span></span></span><br><span class="line">  <span class="built_in">int</span> _darkMode;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> darkMode =&gt; _darkMode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> changeMode(<span class="built_in">int</span> darkMode) <span class="keyword">async</span> &#123;</span><br><span class="line">    _darkMode = darkMode;</span><br><span class="line"></span><br><span class="line">    notifyListeners();</span><br><span class="line">    SpUtil.putInt(SpConstant.DARK_MODE, darkMode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>changeMode()</code>函数来进行模式的切换，其中<code>notifyListeners();</code>用于通知顶层容器状态的变化，<code>SpUtil.putInt(SpConstant.DARK_MODE, darkMode);</code>用于保存用户设置。</p><h3 id="修改-MaterialApp"><a href="#修改-MaterialApp" class="headerlink" title="修改 MaterialApp"></a>修改 MaterialApp</h3><p>接下来我们需要在顶层容器中配置我们的状态管理类，和上文类似，这里同样使用了 MultiProvider</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        ChangeNotifierProvider.value(value: DarkModeProvider()),</span><br><span class="line">      ],</span><br><span class="line">      child: Consumer&lt;DarkModeProvider&gt;(</span><br><span class="line">        builder: (context, darkModeProvider, _) &#123;</span><br><span class="line">          <span class="keyword">return</span> darkModeProvider.darkMode == <span class="number">2</span></span><br><span class="line">              ? MaterialApp(</span><br><span class="line">                  title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">                  theme: ThemeData(</span><br><span class="line">                    primarySwatch: Colors.blue,</span><br><span class="line">                  ),</span><br><span class="line">                  darkTheme: ThemeData.dark(),</span><br><span class="line">                  home: MyHomePage(title: <span class="string">&#x27;Flutter Challenge Demo&#x27;</span>),</span><br><span class="line">                )</span><br><span class="line">              : MaterialApp(</span><br><span class="line">                  title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">                  theme: darkModeProvider.darkMode == <span class="number">1</span></span><br><span class="line">                      ? ThemeData.dark()</span><br><span class="line">                      : ThemeData(</span><br><span class="line">                          primarySwatch: Colors.blue,</span><br><span class="line">                        ),</span><br><span class="line">                  home: MyHomePage(title: <span class="string">&#x27;Flutter Challenge Demo&#x27;</span>),</span><br><span class="line">                );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果手动控制是否开启夜间模式，可以设置<code>MaterialApp</code>的<code>theme</code>选项为<code>ThemeData.dark()</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: ThemeData.dark()</span><br></pre></td></tr></table></figure><p>因为需要同时保留随系统自动切换与手动切换，而<code>darkTheme</code>选项和<code>theme</code>又有冲突，所以这里需要根据<code>darkModeProvider.darkMode</code>的取值来渲染不同的<code>MaterialApp</code>，如果是手动模式再根据<code>darkModeProvider.darkMode</code>的取值来渲染不同的<code>theme</code>。</p><h3 id="选择深色模式"><a href="#选择深色模式" class="headerlink" title="选择深色模式"></a>选择深色模式</h3><p>接下来如果想要切换深色模式，我们只需要执行下面这行代码即可。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Provider.of&lt;DarkModeProvider&gt;(context, listen: <span class="keyword">false</span>).changeMode(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中，0 表示浅色，1 表示深色，2 表示跟随系统。</p><blockquote><p>至此，本文内容结束，这里我们头脑风暴一下，能否将上文中提到的主题选择和本文的深色模式结合起来呢？欢迎各位在评论区留言。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这里说下最近遇到的一件很不痛快的事情，在之前的文章中，示例代码需要关注我的公众号才可获得，结果就被某个人评论说我割韭菜。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geiu47gmhtj30yk064q3w.jpg"></p><p>我不知道他是白嫖习惯了还是怎么的，代码是我自己付出努力写的，从头到尾我就没说过代码是开源的，凭什么要无缘无故给你白嫖代码？</p><p>说这些其实也是希望看到这里的读者不要养成总是白嫖他人的习惯，如果觉得我的文章对你有所帮助，不妨给个赞 👍 或者关注支持一下。</p><p>对了，本期的代码 👉：<a href="https://github.com/YueYongDev/flutter_challenge">https://github.com/YueYongDev/flutter_challenge</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geiudxpj5xj30go0goabc.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一统江湖？——Flutter for All Screens初体验</title>
      <link href="p/c346.html"/>
      <url>p/c346.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018 年 2 月 27 日，Google 发布了 Flutter 的第一个 Beta 版本，由于自己是一个 Google 粉，所以很快就下载尝鲜了，之后还在简书上发过一篇博客《你好，Flutter》，是我的第一篇阅读量过 10w 的文章。在学习 flutter 期间也做过一些零散的笔记，但由于当时觉悟不高，并没整理成册，而且当时正准备保研，手头事情很多加上可学习的资料很少，中途便放弃了。</p><p>机缘巧合，最近阅读到了一篇谷歌开发者的文章<a href="https://developers.googleblog.com/2019/05/Flutter-io19.html">《Flutter: a Portable UI Framework for Mobile, Web, Embedded, and Desktop》</a>，说是现在的 Flutter 已经可以运行在 Android、ios、MacOS、Linux、Windows 和嵌入式设备上了。在好奇心的作祟下，我尝试着利用 Flutter 在一些平台上运行了一些 demo，本文便是记录我利用 Flutter 实现了移动端、桌面端和 Web 端的过程，由于移动端应用的 demo 网上教程很多，所以本文尽快略过，重点将放在桌面端和 web 端。</p><h2 id="Flutter-for-Mobile"><a href="#Flutter-for-Mobile" class="headerlink" title="Flutter for Mobile"></a>Flutter for Mobile</h2><p>初次了解到 Flutter 的时候便是一个横跨 iOS 和 Android 两个平台的框架，无论是在 Mac/Linux 还是 Windows 上搭建 Flutter 的开发环境都很简单，Windows 上的环境搭建可以参考这篇文章 👉<a href="https://www.jianshu.com/p/84942e400298">《安装搭建 Flutter 环境》</a>，Mac/Linux 可以参考中文官网给出的教程 👉<a href="https://flutter-io.cn/docs/get-started/install">《安装和环境配置》</a></p><blockquote><p>如果你在中国的网络环境下使用 Flutter，注意一定要按照要求设置好两个环境变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn</span><br></pre></td></tr></table></figure></blockquote><p>配置好 Flutter 开发环境后，我们通过 Android Studio 新建一个 Flutter 项目，然后启动 iOS/Android 模拟器，选中要运行的模拟器，直接运行 Flutter 项目即可。运行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-131001c30c3df936?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>这里针对移动端的介绍很少，主要是因为官方文档已经讲解的非常详细，直接阅读即可 👉<a href="https://flutter-io.cn/docs/get-started/install">《安装和环境配置》</a></p></blockquote><h2 id="Flutter-for-Desktop"><a href="#Flutter-for-Desktop" class="headerlink" title="Flutter for Desktop"></a>Flutter for Desktop</h2><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>要使 Flutter 在桌面上运行，我们<strong>必须</strong>使用 Flutter 的<strong>master</strong>分支。执行以下代码即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flutter channel master</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure><p>现在我们再来执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>应该是可以看到类似于下图的结果（截至 2019 年 7 月 1 日）：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-bd1d8d64ab0a3d98?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>默认情况下，Flutter 没有启用桌面支持。我们可以通过设置环境变量<code>ENABLE_FLUTTER_DESKTOP = true</code>来实现。</p><p>为此，我们需要在不同的终端中执行不同的命令（临时生效）：</p><p>在 macOS 或者 Linux 上:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ENABLE_FLUTTER_DESKTOP&#x3D;true</span><br></pre></td></tr></table></figure><p>在 Windows 上:</p><p>PowerShell:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$env:ENABLE_FLUTTER_DESKTOP&#x3D;&quot;true&quot;</span><br></pre></td></tr></table></figure><p>CMD:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set ENABLE_FLUTTER_DESKTOP&#x3D;true</span><br></pre></td></tr></table></figure><blockquote><p>**Tips:**以上设置环境变量的方式是临时的，只会在当前终端中生效，想要永久生效请自行配置系统的环境变量</p></blockquote><p>现在我们来执行以下命令，来确保桌面设备已经连接了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter devices</span><br></pre></td></tr></table></figure><p>如果设置成功是会出现下面的结果的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ flutter devices</span><br><span class="line">1 connected devices:</span><br><span class="line"></span><br><span class="line">macOS  • macOS  • darwin-x64     • Mac OS X 10.14.5 18F203</span><br></pre></td></tr></table></figure><h3 id="针对不同系统手动配置"><a href="#针对不同系统手动配置" class="headerlink" title="针对不同系统手动配置"></a>针对不同系统手动配置</h3><p>时至今日，Flutter for Desktop 仍然是一个实验性功能，这意味着 Flutter 没有工具支持，无法通过 flutter create 命令直接新建出一个桌面应用程序。因此，唯一的选择是手动配置系统特定的文件。值得庆幸的是，Google 的 Flutter 团队已经为我们做好了这件事。</p><p>不过在运行 Flutter for Desktop 之前，我们需要先针对 Windows/MacOS 进行手动配置（Linux 的配置与 MacOS 类似）。</p><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><p>执行<code>flutter doctor -v</code>，根据输出信息选择我们需要安装配置的包，Xcode 的下载直接在 Mac App Store 下载即可，Xcode 相关开发包的安装直接执行下面的命令即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo xcode-select --switch &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer</span><br></pre></td></tr></table></figure><p>然后通过输入命令 <code>sudo xcodebuild -license</code> 来确保已经同意 Xcode 的许可协议。</p><p>这里重点提一下 CocoaPods 的安装配置。</p><p>CocoaPods 是 iOS 开发、macOS 开发中的包依赖管理工具，效果如 Java 中的 Maven，nodejs 的 npm。</p><p>安装只需执行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>如果下载太慢可以更换一下国内源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem sources --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br><span class="line">gem sources -a http:&#x2F;&#x2F;gems.ruby-china.com&#x2F;</span><br></pre></td></tr></table></figure><p>然后我们需要对 CocoaPods 初始化，由于 CocoaPods 包有 500 兆左右的大小，直接执行<code>pod setup</code>会从 github 上 clone 得极其漫长，这里给出解决方案。</p><p>依次执行下面的命令即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br><span class="line">pod repo remove master</span><br><span class="line">git clone https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;CocoaPods&#x2F;Specs.git master</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>感谢微软爸爸提供的 VS 套件，很多开发环境通过 Visual Studio 直接安装就可以了，如何下载安装 VS 自行百度，安装的时候记得选以下桌面开发的套件：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-087a6bc75168eda4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="运行官方-demo"><a href="#运行官方-demo" class="headerlink" title="运行官方 demo"></a>运行官方 demo</h3><p>根据不同系统配置好环境后，我们便可以开始运行 Google 团队提供的 Flutter for Desktop 案例了。</p><p>在终端中执行下述命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/flutter-desktop-embedding.git</span><br><span class="line"><span class="built_in">cd</span> example</span><br></pre></td></tr></table></figure><p><strong>example</strong>文件夹是这个 demo 的示例应用程序，它具有所有必需的构建脚本，这些脚本在 MacOS，Windows 和 Linux 上运行 Flutter 是必需的。如果我们在 VS Code 中打开示例文件夹，我们将能够看到如下内容：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-17d61597392d4f56?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><code>lib/main.dart</code>是整个 flutter 项目的启动文件，这里我们无需过多关注 linux/macos/windows 里面的内容。</p><p>接下来在<strong>example</strong>目录下执行下面命令来获取项目所需要的依赖文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure><p>在我们开始运行我们的应用程序之前，还有最后一步。虽然我们之前已经配置好了 Flutter 的开发环境，但是由于桌面开发仍有一些配置项是不一样的，所以我们需要执行下面一个命令来确保所有需要的依赖都被安装成功了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter precache --macos</span><br></pre></td></tr></table></figure><p>根据你自己的系统切换所需的该命令之后的参数。</p><p>现在我们可以将我们的 Flutter 应用程序作为桌面应用程序运行了。</p><p>在终端执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure><p>终端输出的结果应该是类似下面这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-64bd8ddde62454cf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>运行起来的结果应该如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-1c4564efc24ae415?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>是不是和之前的 App 一模一样呢？运行在 windows 上也是一样的（因为我没有在 Linux 下配置 Flutter 的环境，所以这里就不放出来了）。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-03d292643a212bf3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p><strong>Tips</strong>：如果无法运行 demo，记得执行<code>flutter doctor -v</code>命令查看究竟还缺少什么依赖</p></blockquote><h3 id="简单分析下-lib-main-dart"><a href="#简单分析下-lib-main-dart" class="headerlink" title="简单分析下 lib/main.dart"></a>简单分析下 lib/main.dart</h3><p>其实我们新建一个 Flutter 的移动端项目时的 main.dart 代码和该 demo 中的 main.dart 代码几乎类似，但在开头几行还是有些不一样的地方。</p><ul><li>Flutter for Mobile：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5666077-b3a100fda9b72b57?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>Flutter for Desktop：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5666077-67f8188853f0d5a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>此代码提供了一种覆盖默认目标平台的方法。这可以根据应用程序的要求使用。要了解更多相关信息，可以查看<a href="https://github.com/flutter/flutter/wiki/Desktop-shells#target-platform-override">《Target Platform Override》</a></p><h3 id="运行已经存在的-Flutter-项目"><a href="#运行已经存在的-Flutter-项目" class="headerlink" title="运行已经存在的 Flutter 项目"></a>运行已经存在的 Flutter 项目</h3><p>现在我们有了必要的配置文件和脚本。也走过了基本的配置流程，接下来我们就可以在桌面上运行<em>几乎</em>任何已有的 Flutter 项目了。</p><p>有两种方法可以实现上述需求：</p><ol><li>我们可以将系统特定文件夹（linux，mac 或 windows）从 example 目录复制到已有项目目录（和 andorid 或 ios 目录同级）并且在 main.dart 中按照上一节的区别修改部分代码。</li><li>我们可以使用已有项目中的 lib 文件夹替换 example 目录中的 lib 文件夹，并将 pubspec.yaml 文件替换为现有文件。</li></ol><p>Flutter Community 的 Ayush Shekhar 建议采用第二种方式，因为他在使用第一种方式迁移的时候经常出问题，不过我在运行的时候并没有发现问题，所以因人而异吧。</p><p>之前做过一款名为“果核”的校园 App，这是他运行在 mac 上的亚子。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-4e8c5ece1db69344?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p><strong>Tips：</strong>我在使用 Flutter for Desktop 的时候发现了一个小 Bug，就是拖动窗口调整大小时，窗口整体会出现红色的闪烁。我猜可能是窗口绘制刷新导致的。</p></blockquote><h2 id="Flutter-for-Web"><a href="#Flutter-for-Web" class="headerlink" title="Flutter for Web"></a>Flutter for Web</h2><p>说完了 Flutter for Mobile/Desktop，我们来请出今天的最后一位嘉宾，Flutter for Web。</p><p>与其说是 Flutter for Web 倒不如说是 Dart for Web，从 Dart 这个语言诞生之初，它就一直在尝试编译成 JavaScript。谷歌怎么想的，咱也不知道，咱也不敢问。在 Flutter 刚诞生的时候其实并没有针对 web 的计划，不过后来谷歌的工程师大笔一挥，干脆重写了新的 dart:ui，这也就导致不可能将所有的 Flutter 代码都运行到 Web 端（有些特性是平台独有的），因此这里我们仅仅是跑通官方 Demo。</p><h3 id="安装-Dart-SDK"><a href="#安装-Dart-SDK" class="headerlink" title="安装 Dart SDK"></a>安装 Dart SDK</h3><p>篇幅原因，这里就只给出在 Mac 上安装 Dart SDK 的过程了。因为要开发 web 工程，我们还需要安装 Dartium 和 Content Shell，好在 Mac 下的 homebrew 非常强大，这里直接执行下面命令就可以了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap dart-lang&#x2F;dart</span><br><span class="line">brew install dart --with-content-shell --with-dartium</span><br></pre></td></tr></table></figure><p>如果觉得 brew 下载太慢的话，可以考虑更换中科大的镜像源，只需执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">替换brew.git:</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;brew.git</span><br><span class="line"></span><br><span class="line">替换homebrew-core.git:</span><br><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-core.git</span><br></pre></td></tr></table></figure><p>之后再执行<code>brew install</code>就会快很多了。</p><p>安装完成后。在终端中执行下述命令来检查 Dart SDK 的版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info dart</span><br></pre></td></tr></table></figure><h3 id="安装-flutter-web-开发工具包"><a href="#安装-flutter-web-开发工具包" class="headerlink" title="安装 flutter_web 开发工具包"></a>安装 flutter_web 开发工具包</h3><p>由于 Flutter for Web 采用的库和 Flutter 有所差异，所以我们还需要安装 webdev 包，终端执行下面语句即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flutter pub global activate webdev</span><br></pre></td></tr></table></figure><p>确保<code>$HOME/.pub-cache/bin</code>路径在你的环境变量中，这样你就可以直接在终端中执行<code>webdev</code>命令了。</p><h3 id="新建一个-Flutter-for-Web-项目"><a href="#新建一个-Flutter-for-Web-项目" class="headerlink" title="新建一个 Flutter for Web 项目"></a>新建一个 Flutter for Web 项目</h3><p>在 VS Code 中打开命令面板后输入<code>flutter web</code>则会自动提示你让你新建一个 web 程序，然后输入项目名即可创建一个 web 项目。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-4f1c102b8fa2ac13?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后执行<code>flutter packages get</code>即可安装依赖。</p><h3 id="启动你的第一个-web-项目"><a href="#启动你的第一个-web-项目" class="headerlink" title="启动你的第一个 web 项目"></a>启动你的第一个 web 项目</h3><p>现在来执行最后一个命令来运行项目：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webdev serve</span><br></pre></td></tr></table></figure><p>终端的输出结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-f3a27c966bf95b7b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们打开浏览器并输入：<code>http://127.0.0.1:8000</code>，然后我们就可以在浏览器上看到神奇的结果了：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-085ed699c9410b91?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>目前发现 Firefox 和 Chrome 均可运行，Safari 无法显示界面，原因还有待查找。</p></blockquote><p>回顾代码我们可以发现 Flutter for Web 项目的 main.dart 和普通的 Flutter 项目的代码几乎一致：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-79134df3665af95c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>唯一的区别就是第一行中引入的 fltter_web 库了。</p><p>因为对 Flutter for Web 我也没过多了解，这一部分推荐你去查看<a href="https://github.com/flutter/flutter_web">官方文档</a>了解更多关于我们上面执行的命令或者网页的信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Flutter 的发展势头和谷歌想要让 Flutter 一统所有平台的野心大家是有目共睹的，就在前不久，Fuchsia OS 的官网也悄然上线，作为新系统的指定开发工具，Flutter 自然备受关注。目前 Flutter for Mobile 已经发展的挺好了，虽然配置 Desktop 应用和 Web 应用时仍有些繁琐，开发时仍会有许多 bug，但冰冻三尺非一日之寒，我们应该给予足够的耐心。</p><p><strong>参考文章</strong></p><ol><li><a href="https://zhuanlan.zhihu.com/p/52218677">在 macOS 上运行 Flutter 桌面端项目</a></li><li><a href="https://flutter-io.cn/docs/get-started/install/macos">在 macOS 上安装和配置 Flutter 开发环境</a></li><li><a href="https://medium.com/flutter-community/flutter-for-desktop-create-and-run-a-desktop-application-ebeb1604f1e0">Flutter for Desktop: Create and Run a Desktop Application</a></li><li><a href="https://blog.usejournal.com/getting-started-with-flutter-web-e187829c9dd3">Getting started with Flutter Web</a></li><li><a href="https://github.com/google/flutter-desktop-embedding">Desktop Embedding for Flutter</a></li><li><a href="http://dart.goodev.org/install/mac">在 Mac 安装 Dart</a></li></ol><hr><p><img src="https://upload-images.jianshu.io/upload_images/5666077-383e7858432f4710?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装 RocketMQ 并结合 SpringBoot 使用实例</title>
      <link href="p/ca50.html"/>
      <url>p/ca50.html</url>
      
        <content type="html"><![CDATA[<p>在之前的<a href="https://mp.weixin.qq.com/s/Chhy36IEAz0HGarGDpb2Nw">《浅入浅出消息队列》</a>一文中，我们了解了消息队列的作用、优缺点和使用场景，相信你对消息队列已经有了一个大致的概念，文末给自己埋的坑说日后会写一篇实战教程，正好现在实习结束了，也许久没有写实战教程了，于是这就来填坑了。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>阅读本文前，建议有一些前置知识，包括且不限于：</p><ul><li>常见的 Linux 命令</li><li>消息队列的相关知识</li><li>Docker 的基本使用</li><li>docker-compose 的基础知识</li><li>SpringBoot 的基本使用</li></ul><p>那废话不多说，我们就开始吧。</p><blockquote><p>本文的所涉及到的代码可在微信公众号「01 二进制」后台回复「rocketmq」获得。</p></blockquote><h2 id="为什么要以-RocketMQ-为例？"><a href="#为什么要以-RocketMQ-为例？" class="headerlink" title="为什么要以 RocketMQ 为例？"></a>为什么要以 RocketMQ 为例？</h2><p>本文主要是为了通过实例的方式直观的了解消息队列。那么问题来了，消息队列那么多（ActiveMQ、RabbitMQ、Kafka），<strong>我</strong>为什么要选择 RocketMQ 呢？这里我们不谈原理，只说说体验，<strong>仅是个人选择，不喜勿喷。</strong></p><ol><li>背靠阿里，不看测评，纯粹看他经历过多次双十一的检验就已经知道其性能是处于第一批次的。</li><li>作为一个 Java 程序员，如果选择一个纯 Java 编写的软件，后期阅读其源码难度也会小很多。（RabbitMQ 底层是 Erlang，kafka 底层是 Scala）</li><li>在阿里实习的时候一直都是使用 RocketMQ 的内部版本，于我而言，RocketMQ 更熟悉。</li></ol><h2 id="初识-RocketMQ"><a href="#初识-RocketMQ" class="headerlink" title="初识 RocketMQ"></a>初识 RocketMQ</h2><p>在使用消息队列前，我们要知道消息队列是什么，这一块内容参考之前的文章<a href="https://mp.weixin.qq.com/s/Chhy36IEAz0HGarGDpb2Nw">《浅入浅出消息队列》</a>，这里不再赘述。</p><p>本段节来讲解 RocketMQ 所涉及到的相关概念，我们先来简单看下官方给出的 RocketMQ 架构图<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtpeiatlrj313y0msgoe.jpg"><br>从上图我们可以很直观的看出，一个完整的 RocketMQ 架构包含四个部分：<strong>NameServer、Broker、Producer 和 Consumer</strong>。</p><ul><li>NameServer：主要用作注册中心，用于管理 Topic 信息和路由信息的管理</li><li>Broker：负责存储、消息 tag 过滤和转发。需将自身信息上报给注册中心 NameServer</li><li>Producer：生产者</li><li>Consumer：消费者</li></ul><h3 id="从寄信的角度理解"><a href="#从寄信的角度理解" class="headerlink" title="从寄信的角度理解"></a>从寄信的角度理解</h3><p>上面的解释可能难以理解，我们从寄信这一实例来看以下四个部分所承担的责任。</p><ul><li>Producer 和 Consumer 不必多说，消息的生产者和消费者，生产者负责投递消息，消费者负责接收消息，<strong>是我们要编写的应用程序</strong>。可以理解为寄信人和收信人。</li><li>Broker 负责消息存储，以 Topic（主题）为维度，以队列的形式存储消息。可以理解为信箱，专门存储信件，收信人（Consumer）可以从这里获取信件。</li><li>NameServer 负责对源数据进行管理，包括了对 Topic 和 Broker 的管理。可以理解为邮局，负责管理邮件的分发，维护信箱（Broker）的状态。</li></ul><p>由上各部分角色的功能可知，我们需要先安装启动 NameServer，再启动 Broker 即可搭建完 RocketMQ</p><h2 id="安装-RocketMQ"><a href="#安装-RocketMQ" class="headerlink" title="安装 RocketMQ"></a>安装 RocketMQ</h2><blockquote><p>如果你的电脑上已经配置好了 rocketmq 的相关环境，可以跳过本章节。</p></blockquote><p>从上面的介绍我们可以得知，在生产和消费消息之前，我们需要安装好<strong>Broker 和 NameServer。</strong></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了部署方便，我推荐使用 docker 搭建服务。此外，由于 rocketmq 需要分别部署 broker 与 nameserver ，考虑到分开部署比较麻烦，这里我将会使用 docker-compose。因此，你需要在你的宿主机中安装好 docker 和 docker-compose。</p><p>此外，我们还需要搭建一个 web 可视化控制台，用于监控 mq 服务状态，以及消息消费情况，这里使用 rocketmq-console，同样该程序也将使用 docker 安装。</p><blockquote><p>如果对 docker 不熟悉的话，可以先阅读菜鸟教程的 docker 教程学习 👉<a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程</a></p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><p>Linux：</p><p>执行以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>Mac：</p><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure><p>Win:</p><p>下载对应的安装文件，然后双击运行安装。下载地址在：<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a></p><blockquote><p>考虑到下载该文件需要科学上网，你可以在微信公众号「01 二进制」后台回复「docker」获取 docker 安装包的下载链接。</p></blockquote><p>如果你的 win10 系统可以使用 winget，那就执行以下命令。(win 终于也有自己的包管理工具了 🙏)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">winget install Docker.DockerDesktop</span><br></pre></td></tr></table></figure><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。配置教程可参考 👉<a href="https://www.runoob.com/docker/docker-mirror-acceleration.html">Docker 镜像加速</a></p><h4 id="安装-RocketMQ-镜像"><a href="#安装-RocketMQ-镜像" class="headerlink" title="安装 RocketMQ 镜像"></a>安装 RocketMQ 镜像</h4><p>rocketmq 的 docker 镜像我们可以自己制作，官方文档中有详细介绍 👉<a href="https://github.com/apache">apache</a>/<strong><a href="https://github.com/apache/rocketmq-docker">rocketmq-docker</a></strong></p><p>为了方便起见，这里我们直接使用别人已经制作好的镜像，镜像地址 👉 <a href="https://hub.docker.com/r/foxiswho/rocketmq">foxiswho/rocketmq</a></p><p>新建一个目录用于存放相关脚本，然后在终端执行下面的命令 👇</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/foxiswho/docker-rocketmq.git</span><br><span class="line">cd docker-rocketmq</span><br><span class="line">cd rmq</span><br><span class="line">chmod +x  start.sh</span><br><span class="line">./start.sh</span><br></pre></td></tr></table></figure><p>在经过一段时间的等待后，我们通过浏览器访问<code>localhost:8180</code>查看到以下页面则说明安装成功。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtwv48yc3j315g0np415.jpg"></p><h3 id="安装脚本解析"><a href="#安装脚本解析" class="headerlink" title="安装脚本解析"></a>安装脚本解析</h3><p>通过脚本的方式一键安装确实很方便，但如果只是安装完成就万事大吉了自然是不行的，本着授人以渔的态度，我们来看看安装脚本里都有些啥：</p><h4 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtwval912j30za0sun1s.jpg"></p><p>4-7 行在创建目录，10-13 行在给刚才创建的目录设置权限，至于原因我们之后再说。</p><p>我们看到 16 行使用 docker-compose 命令启动了容器，并设置为了后台自动启动，因此我们来看一下这个 docker-compose.yml 文件。</p><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">rmqnamesrv:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">foxiswho/rocketmq:4.7.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmqs/logs:/opt/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmqs/store:/opt/store</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPT_EXT:</span> <span class="string">&quot;-Duser.home=/opt -Xms512M -Xmx512M -Xmn128m&quot;</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;mqnamesrv&quot;</span>]</span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">rmq:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">rmqnamesrv</span></span><br><span class="line">  <span class="attr">rmqbroker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">foxiswho/rocketmq:4.7.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/logs:/opt/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/store:/opt/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/brokerconf/broker.conf:/etc/rocketmq/broker.conf</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPT_EXT:</span> <span class="string">&quot;-Duser.home=/opt -Xms512M -Xmx512M -Xmn128m&quot;</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">&quot;sh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mqbroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/etc/rocketmq/broker.conf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;rmqnamesrv:9876&quot;</span>,</span><br><span class="line">        <span class="string">&quot;autoCreateTopicEnable=true&quot;</span>,</span><br><span class="line">      ]</span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">rmq:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">rmqbroker</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">rmqconsole:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">styletang/rocketmq-console-ng</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqconsole</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8180</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">&quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">rmq:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">rmqconsole</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">rmq:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rmq</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>我们创建了三个服务，这三个服务的名字分别是 rmqnamesrv、rmqbroker 和 rmqconsole，分别对应我们之前所说的 nameserver、broker 和可视化控制台。并且对不同的服务做了不同的端口映射，同时将本地指定的文件目录挂载到 docker 容器中，并以网桥（bridge）的形式进行网络连接。</p><p>以<code>rmqnamesrv</code>为例，其基础镜像为<code>foxiswho/rocketmq:4.7.0</code>，创建的容器名为<code>rmqnamesrv</code>，并将其内部的 9876 端口映射到宿主机的 9876 端口，并将本地的<code>./rmqs/logs</code>文件挂载到 docker 容器的<code>/opt/logs</code>目录中。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rmqnamesrv:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">foxiswho/rocketmq:4.7.0</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./rmqs/logs:/opt/logs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./rmqs/store:/opt/store</span></span><br></pre></td></tr></table></figure><blockquote><p>如果对于 docker-compose 不熟悉的读者，可以先参考相关的教程学习一下 👉<a href="https://www.runoob.com/docker/docker-compose.html">Docker Compose</a></p></blockquote><h2 id="SpringBoot-整合-RocketMQ-小实例"><a href="#SpringBoot-整合-RocketMQ-小实例" class="headerlink" title="SpringBoot 整合 RocketMQ 小实例"></a>SpringBoot 整合 RocketMQ 小实例</h2><p>在完成了相对复杂的安装、配置后，我们终于可以实现一个小的 demo 来打通整个流程了。</p><h3 id="创建消息主题和订阅组"><a href="#创建消息主题和订阅组" class="headerlink" title="创建消息主题和订阅组"></a>创建消息主题和订阅组</h3><p>使用 RocketMQ 进行发消息时，<strong>必须要指定 topic</strong>，对于 topic 的设置有一个开关<code>autoCreateTopicEnable</code>，一般在<strong>开发测试</strong>环境中会使用默认设置<code>autoCreateTopicEnable = true</code>，但是这样就会导致 topic 的设置不容易规范管理，没有统一的审核等等，所以在正式环境中会在 Broker 启动时设置参数<code>autoCreateTopicEnable = false</code>。这样当需要增加 topic 时就需要在 web 管理界面上添加即可。</p><p>在 web 界面添加 topic 的方式如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtwvp4it8j315g0l076f.jpg"></p><p>同理，在接受消息时，我们同样需要对消息订阅组进行配置，对于消息的订阅设置有一个开关<code>autoCreateSubscriptionGroup</code>，通常情况下，在生产环境下，我们需要设置为<code>autoCreateSubscriptionGroup=false</code>，这就要求了管理者必须去 web 管理界面上创建订阅组才可以收到消息。</p><p>在 web 界面添加订阅组的方式类似，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtwvxy8rfj315g0g876e.jpg"></p><blockquote><p>如果只是测试环境，我们可以在配置文件中将这两个开关打开，配置文件在 <code>rmq/rmq/brokerconf</code> 目录下</p></blockquote><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>apache 官方已经提供了 rocketmq 对应的 springboot starter，这极大的简化了我们所需要做的配置工作，因此我们要做的就是先新建一个 springboot 项目，然后按照下面的方式着手实现。</p><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>首先先在 pom.xml 中导入 apache 官方提供的 starter</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.rocketmq&#x2F;rocketmq-spring-boot-starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置-application-yml"><a href="#配置-application-yml" class="headerlink" title="配置 application.yml"></a>配置 application.yml</h3><p>依赖导入后，我们需要在 application.yml 配置一个 name-server 地址，具体值看你的机器。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="string">localhost:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">myGroup</span></span><br></pre></td></tr></table></figure><h3 id="创建一个生产者类"><a href="#创建一个生产者类" class="headerlink" title="创建一个生产者类"></a>创建一个生产者类</h3><p>生产者发送消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line">    <span class="comment">// 发送给Broker，默认会自动创建topic，topic和tag用冒号分隔</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rocket/send&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rocketSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;rocket-topic-2&quot;</span>, currentTime.toString());</span><br><span class="line">        <span class="keyword">return</span> currentTime.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延时消息，RocketMQ支持这几个级别的延时消息，不能自定义时长</span></span><br><span class="line">    <span class="comment">// 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rocket/delayMsg/send&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rocketDelayMsgSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">        rocketMQTemplate.syncSend(<span class="string">&quot;rocket-topic-2:tag-2&quot;</span>, MessageBuilder.withPayload(currentTime.toString()).build(), <span class="number">2000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> currentTime.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个消费者"><a href="#创建一个消费者" class="headerlink" title="创建一个消费者"></a>创建一个消费者</h3><p>消费者监听消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RokcetServiceListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(consumerGroup = &quot;consumer-group-1&quot;, topic = &quot;rocket-topic-2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;consumer1 rocket收到消息：&#123;&#125;&quot;</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RocketMQ支持两种消费方式，集器消费和广播消费</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(consumerGroup = &quot;consumer-group-2&quot;, topic = &quot;rocket-topic-2&quot;,</span></span><br><span class="line"><span class="meta">            selectorExpression = &quot;tag2&quot;, messageModel = MessageModel.BROADCASTING)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;consumer2 rocket收到消息：&#123;&#125;&quot;</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们在浏览器中访问<code>localhost:8080/rocket/send</code>，即可看到返回的时间戳。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtww7r7bsj315g08bq46.jpg"><br>同时在控制台也可以看到消费者已经获取到这条信息了<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtwwczwpjj315g0ac483.jpg"></p><p>同样的，我们也可以在可视化控制台查看到相应的消息</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtwwim4qqj31230u0aem.jpg"></p><p>我们同样可以在可视化控制台查看消费者和生产者对于消息的生产与消费的情况，这些就留给读者自己探索了。至此，一个完整的利用 Docker 安装 RocketMQ 并结合 SpringBoot 使用的实例就结束了。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题-1：No-route-info-of-this-topic-xxxxxx"><a href="#问题-1：No-route-info-of-this-topic-xxxxxx" class="headerlink" title="问题 1：No route info of this topic: xxxxxx"></a>问题 1：No route info of this topic: xxxxxx</h3><p>通过翻译我们可以知道，这个错误产生的原因是因为消息队列中并未产生相对应的<strong>topic</strong>，所以我们要做的应该是去控制台新建一个 topic</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjtwwom5h8j315g0l076f.jpg"></p><h3 id="问题-2：连接异常"><a href="#问题-2：连接异常" class="headerlink" title="问题 2：连接异常"></a>问题 2：连接异常</h3><p>如果出现类似下述这种连接异常的错误</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;172.0.0.120:10909&gt; failed</span><br></pre></td></tr></table></figure><p>可能的原因是你并没有将项目放至 docker 容器中，因此你的项目代码不能直接与 rocketmq 容器访问，因此我们需要将<code>broker.conf</code>中的 <code>#brokerIP1=xxxxx</code> 前面<code>#</code>号去掉，并且把后面的<code>IP地址</code>改成你的<code>rocketmq</code>容器宿主机<code>IP地址</code>，配置文件在 <code>rmq/rmq/brokerconf</code> 目录下。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>为了填坑，我选择了 rocketmq 作为实例讲解的对象，并在第一节阐述了我为什么要使用 RocketMQ 的原因，之后解释了 RocketMQ 中几个重要的概念，然后利用 docker 快速的部署安装了一个 rocketmq 的单机实例，并分析了安装脚本。最后我们通过 springboot 这一目前主流的 web 框架实现了一个生产者与消费者的实例，并说明了可能会遇到的问题及解决方案。</p><p>以上就是本文的全部内容了，如果你觉得对你有所帮助，不放关注点赞支持一波，你们的支持是我更新的最大动力。</p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> rocketmq </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI画家第四弹——利用Flask发布风格迁移API</title>
      <link href="p/a56b.html"/>
      <url>p/a56b.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5666077-172f3e6d74027f33?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上篇文章介绍了python web开发中经常使用到的一个框架flask，如果有遗忘的，可以点此回顾👉<a href="https://mp.weixin.qq.com/s/2Q4lp5SdLfVNoYg3J8lPRw">AI画家第三弹——毕业设计大杀器之Flask</a>，本文的主要任务就是完成上篇文章末尾的要求，利用Flask发布你自己的风格迁移API。</p><blockquote><p>本文源码可在微信公众号「01二进制」后台回复「风格迁移API」获得</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们知道软件工程的第一步就是需求分析，放在这里就是要知道我们需要实现的功能是什么样的。我画了一张简陋的图来描述这次的需求：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ad30c7ba1ec026e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>真的是很简陋的一张图啊，其实理解起来很容易，就是用户上传一张图片，Flask获取到这张图片，调用风格迁移的模型，然后生成结果图，在传递回前端即可。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>既然明白了需求，那么接下来要做的事情自然是环境搭建了，老样子，这里我们仍然使用Pipenv来创建虚拟环境，如何搭建pipenv环境我就不说了，在微信公众号「01二进制」后台回复「风格迁移API」获得源码之后直接在终端输入<code>pipenv install</code>即可。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>我们首先在项目根目录创建一个main.py的文件作为整个项目的启动文件，上文我们说过，为了简化大型应用并为扩展提供集中的注册入口，我们并不会将所有的视图函数直接写在main.py，而是采用蓝图的方式分模块开发，因此我们需要在项目根目录新建<code>app/</code>文件夹，在其中的<code>__init__.py</code>中编写如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure><p>这样我们就可以通过在main.py中编写如下代码实现一个hello world应用了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line">app = create_app()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>启动main.py即可发现项目启动了，在浏览器输入<code>localhost:8080</code>即可看到<code>hello,world</code>字样。</p><h3 id="蓝图编写"><a href="#蓝图编写" class="headerlink" title="蓝图编写"></a>蓝图编写</h3><p>我们肯定是不能满足于小小的hello world的，既然说到了模块化开发，那怎么个模块法？</p><p>这里每个人的想法都是不一样的，其实也没有一个统一的标准，这里我就说下我自己的分级方法吧。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-684ebb9c31e516bf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>stylize是项目根路径</li><li>app是项目</li><li>app/api是项目的api部分，一个项目肯定不只有api，还可能会有web等页面内容</li><li>app/api/v1表明该api的版本是v1，当然日后也有可能会有v2、v3等等</li><li>app/api/v1/img表明这里存放的都是和img有关的api</li><li>app/api/v1/img/stylize.py表明这个文件存放的是风格迁移的视图函数</li></ul><p>认识完结构的划分之后，就来编写我们的蓝图吧。</p><p>首先我们需要在<code>app/api/v1/img/__init__.py</code>中编写如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个蓝图</span></span><br><span class="line">img = Blueprint(<span class="string">&#x27;img&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app.api.v1.img <span class="keyword">import</span> stylize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这段代码用来测试该接口是否可用</span></span><br><span class="line"><span class="meta">@img.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;这里是图片处理类的接口&#x27;</span></span><br></pre></td></tr></table></figure><p>这样我们就定义了一个叫做img的蓝图，然后我们在<code>app/api/v1/__init__.py</code>中编写如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个蓝图</span></span><br><span class="line">v1 = Blueprint(<span class="string">&#x27;v1&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app.api.v1.img <span class="keyword">import</span> img</span><br></pre></td></tr></table></figure><p>这样我们就实现了v1蓝图的编写。</p><p>那这样是不是就可以使用蓝图了呢？当然不是，我们还需要在app中配置这个蓝图，把蓝图加载到app中，否则flask是无法识别蓝图的。加载的方法也很简单，我们在<code>app/__init__.py</code>文件中添加一个函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_blueprint</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">from</span> app.api.v1 <span class="keyword">import</span> v1</span><br><span class="line">    <span class="keyword">from</span> app.api.v1.img <span class="keyword">import</span> img</span><br><span class="line"></span><br><span class="line">    app.register_blueprint(v1, url_prefix=<span class="string">&#x27;/api/v1&#x27;</span>)</span><br><span class="line">    app.register_blueprint(img, url_prefix=<span class="string">&#x27;/api/v1/img&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将这两个蓝图注册到app中，其中<code>url_prefix</code>这个参数用来标注路由的。有人可能不清楚，这里举个例子你就懂了。我们启动这个项目之后，在浏览器输入的是<code>localhost:8080</code>，如果加了<code>url_prefix</code>这个参数之后，我们访问img下的视图函数时就需要把路径改为<code>localhost:8080/api/v1/img/</code>了。</p><p>然后在<code>create_app()</code>函数中调用这个方法即可，main.py的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">    register_blueprint(app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_blueprint</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">from</span> app.api.v1 <span class="keyword">import</span> v1</span><br><span class="line">    <span class="keyword">from</span> app.api.v1.img <span class="keyword">import</span> img</span><br><span class="line"></span><br><span class="line">    app.register_blueprint(v1, url_prefix=<span class="string">&#x27;/api/v1&#x27;</span>)</span><br><span class="line">    app.register_blueprint(img, url_prefix=<span class="string">&#x27;/api/v1/img&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    create_app()</span><br></pre></td></tr></table></figure><p>接下来我们测试下这个蓝图是否真的注册成功了，我们启动该项目，并打开Postman输入：<code>localhost:8080/api/v1/img</code>，我们可以看到如下信息：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9083fa54cc7ed190?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>说明我们的蓝图已经注册</p><h3 id="编写风格迁移工具类"><a href="#编写风格迁移工具类" class="headerlink" title="编写风格迁移工具类"></a>编写风格迁移工具类</h3><p>既然蓝图都已经编写好了，那么视图函数的编写也就非常简单了，因此这里我们先把风格迁移的工具类写好，最后再编写视图函数。</p><p>上上篇文章我们介绍了图像风格迁移，记不清的可以看这篇文章👉<a href="https://mp.weixin.qq.com/s/q0KxclMm3egPfc4U4_p23g">AI绘画第二弹——图像风格迁移</a>，这篇文章介绍了最传统的图像风格迁移，想要生成一张图片的速度非常非常慢，肯定是没办法作为实际使用的，因此这篇文章所采用的生成风格迁移的图片的方法并不是这篇文章，而是基于李飞飞等人的一篇论文《Perceptual Losses for<br>Real-Time Style Transfer and Super-Resolution》所实现的快速图像风格迁移。这里只介绍如何拿训练好的模型去运用，有兴趣的自己下载这篇文章去研究。</p><p>我们新建一个文件夹：<code>app/utils/stylize</code>，这个文件夹中包含了风格迁移的工具类，项目结构如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-37988e90d6a24a56?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中output为最终的生成文件夹、src存放风格迁移的文件（可以不用管）、evaluate.py是之前用于评估模型性能的文件（其实也就是生成图片的文件，不用管+1）、trained_model文件夹存放了我们已经训练好的模型、temp存放的是我们从前端上传的图片，create_stylize_photo.py包含的是我们对外提供的风格迁移工具类。</p><p>因此这整个文件夹我们只需要关注<code>create_stylize_photo.py</code>这一个文件就可以了，其他的下载源码之后自己看就可以了。</p><h4 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress_image</span>():</span></span><br><span class="line">    im = Image.open(content_image)</span><br><span class="line">    <span class="keyword">if</span> content_image.endswith(<span class="string">&quot;.png&quot;</span>):</span><br><span class="line">        im = im.convert(<span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">    im.save(content_image, optimize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="选择图片风格即所需要使用的模型"><a href="#选择图片风格即所需要使用的模型" class="headerlink" title="选择图片风格即所需要使用的模型"></a>选择图片风格即所需要使用的模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">style_list = [<span class="string">&#x27;la_muse&#x27;</span>, <span class="string">&#x27;rain_princess&#x27;</span>, <span class="string">&#x27;scream&#x27;</span>, <span class="string">&#x27;udnie&#x27;</span>, <span class="string">&#x27;wave&#x27;</span>, <span class="string">&#x27;wreck&#x27;</span>]</span><br><span class="line">style = style_list[int(image_style)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型的 checkpoint 的位置</span></span><br><span class="line">check_point_dir = trained_models_path + style + <span class="string">&#x27;.ckpt&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="执行生成图片的操作"><a href="#执行生成图片的操作" class="headerlink" title="执行生成图片的操作"></a>执行生成图片的操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最终生成的图片路径</span></span><br><span class="line">result_image = path + <span class="string">&#x27;/output/&#x27;</span> + <span class="string">&#x27;output.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行生成图片的操作</span></span><br><span class="line">ffwd_to_img(content_image, result_image, check_point_dir)</span><br></pre></td></tr></table></figure><p>执行完上述步骤后，我们就可以在<code>utils/stylize/output</code>中看到已经生成的风格迁移图片了。</p><h3 id="利用七牛云存储结果图片"><a href="#利用七牛云存储结果图片" class="headerlink" title="利用七牛云存储结果图片"></a>利用七牛云存储结果图片</h3><p>由于服务器带宽限制，我们最后返回给前端的结果肯定不能是我们自己服务器的url（毕竟学生机的带宽只有1M），所以这里我建议使用七牛云存储的功能将生成的结果保存到七牛云上，然后返回一个url即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将生成的图片上传到七牛云</span></span><br><span class="line"><span class="comment"># 传入filename和filepath，返回图片的URL</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_pic_to_qiniu</span>(<span class="params">filename, filepath</span>):</span></span><br><span class="line">    <span class="keyword">from</span> app.secure <span class="keyword">import</span> QINIU_AK</span><br><span class="line">    <span class="keyword">from</span> app.secure <span class="keyword">import</span> QINIU_SK</span><br><span class="line"></span><br><span class="line">    access_key = QINIU_AK</span><br><span class="line">    secret_key = QINIU_SK</span><br><span class="line"></span><br><span class="line">    q = Auth(access_key, secret_key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 要上传的空间</span></span><br><span class="line">    bucket_name = <span class="string">&#x27;ytools&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成上传 Token，可以指定过期时间等</span></span><br><span class="line">    token = q.upload_token(bucket_name, filename, <span class="number">3600</span>)</span><br><span class="line"></span><br><span class="line">    ret, info = put_file(token, filename, filepath)</span><br><span class="line">    <span class="keyword">return</span> BASE_URL + ret[<span class="string">&#x27;key&#x27;</span>]</span><br></pre></td></tr></table></figure><p>然后我们在<code>create_stylize_photo.py</code>中加一句存储的代码即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img_url &#x3D; upload_pic_to_qiniu(filename, result_image)</span><br></pre></td></tr></table></figure><h3 id="编写风格迁移API"><a href="#编写风格迁移API" class="headerlink" title="编写风格迁移API"></a>编写风格迁移API</h3><p>现在我们通过风格迁移工具类已经可以实现输入一张原始图片返回生成图片的URL的功能，现在我们来将目光聚焦到风格迁移API的编写上。</p><h4 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@img.route(&#x27;/stylize/create&#x27;, methods=[&#x27;POST&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_style_changed_img</span>():</span></span><br></pre></td></tr></table></figure><h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><p>我们定义一个函数<code>create_style_changed_img()</code>，方法采用POST方式，我们需要接受前端发来的两个参数，分别是img和type</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = request.files.get(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">type = request.form.get(<span class="string">&#x27;type&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="生成图片及URL"><a href="#生成图片及URL" class="headerlink" title="生成图片及URL"></a>生成图片及URL</h4><p>然后我们将接收到的文件保存到之前新建的temp文件加中，然后调用工具类的方法返回图片的url</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img.save(path + <span class="string">&#x27;/temp/&#x27;</span> + <span class="string">&#x27;temp.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">img_url = change_style(int(type))</span><br></pre></td></tr></table></figure><h4 id="定义返回格式"><a href="#定义返回格式" class="headerlink" title="定义返回格式"></a>定义返回格式</h4><p>作为一个好的api，我们肯定不只能返回一张图片的url就可以了，我们还需要记录下生成的时间，因此我们在代码执行的开始和结束的时候分别添加一段代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = datetime.datetime.now()</span><br><span class="line">end = datetime.datetime.now()</span><br></pre></td></tr></table></figure><p>然后我们再定义返回格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">status = <span class="number">200</span></span><br><span class="line">msg = <span class="string">&#x27;图片生成成功&#x27;</span></span><br><span class="line">info = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;img_url&#x27;</span>: img_url,</span><br><span class="line">        <span class="string">&#x27;created_time&#x27;</span>: get_date_now(),</span><br><span class="line">        <span class="string">&#x27;finish_time&#x27;</span>: (end - start).seconds</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后将结果返回</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res_json = Res(status, msg, info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jsonify(res_json.__dict__)</span><br></pre></td></tr></table></figure><p>这里的Res是我定义的一个返回的实体信息类，长得是下面这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Res</span>:</span></span><br><span class="line">    status = <span class="number">200</span></span><br><span class="line">    msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    info = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, status, msg, info</span>):</span></span><br><span class="line">        self.status = status</span><br><span class="line">        self.msg = msg</span><br><span class="line">        self.info = info</span><br></pre></td></tr></table></figure><p>最后我们调用flask的jsonify方法，就可以返回json结果。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>到这里我们就已经完成了一个风格迁移API的编写，接下来我们测试下我们的API吧，首先先启动项目，然后打开Postman，将请求方法改为post，添加两个参数img和type，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-f50855a1a6adac51?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>选择图片的时候，图片的质量尽量不要太大，否则可能会出现卡死的情况</p></blockquote><p>最后的返回结果如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;created_time&quot;</span>: <span class="string">&quot;2019-05-15 15:17:25&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;finish_time&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;img_url&quot;</span>: <span class="string">&quot;https://user-gold-cdn.xitu.io/2019/5/15/16aba682a31521a7?w=640&amp;h=360&amp;f=jpeg&amp;s=39700&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;图片生成成功&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问该URL即可看到如下图片（感觉还蛮好看的）：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-036c361470844817?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>至此我们已经实现了利用Flask发布一个风格迁移API了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>本文源码可在微信公众号「01二进制」后台回复「风格迁移API」获得</p></blockquote><p>最后总结下，在这篇文章中介绍了如何利用Flask发布一个风格迁移API，其中我们介绍了应该如何利用蓝图进行模块化开发，并给出了我自己认为的比较好的分层方法，同时利用七牛云存储为我们的服务器减压，最后利用postman请求该API完成测试。下一篇将会介绍如何将该API部署到腾讯云（阿里云）上实现外网访问，有兴趣的小伙伴给个关注，你的支持才是我更新的最大动力！</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-66aaf87bc830ff04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI画家 </tag>
            
            <tag> TensorFlow </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI画家第六弹——终章</title>
      <link href="p/96d2.html"/>
      <url>p/96d2.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g3zuoy7mbuj30zk0nrwmw.jpg"></p><blockquote><p>Photo by <strong>Tim Gouw</strong> from <strong>Pexels</strong></p></blockquote><p>正如文章标题所言，本文是我的<strong>《AI画家》</strong>系列的终章，从4月16号开始的第一篇文章<a href="https://mp.weixin.qq.com/s/ulRiY237EJxgzxPbAjBe-Q">《介绍一下我的毕业设计》</a>到今天已经过了将近2个月了（2个月就更新7篇文章我也是服了我自己了😂），其实这个系列就是我的毕业设计，如今我的毕设做完了，论文也定稿了，想着也该给这个系列画个句号了。</p><p>在公众号上发系列文章是我的一次尝试，因为知道自己的文笔不好，写不好什么感悟感想，只能水水技术文了，然而即使要写技术文也得找个切入点，可事实上哪会有那么多切入点，无奈只能靠弄个技术文系列，吸引下路人的眼球，勉强度日了。</p><p>既然是终章，那就对整个系列做个简单的总结吧，希望这篇不会是烂尾文。</p><h3 id="开题"><a href="#开题" class="headerlink" title="开题"></a>开题</h3><p>在<a href="https://mp.weixin.qq.com/s/ulRiY237EJxgzxPbAjBe-Q">《介绍一下我的毕业设计》</a>一文中我提到，刚开始我单纯因为觉得好玩才开始研究图像风格迁移，后来认为名字逼格够高，足够唬住老师才把这个课题作为我的毕设，现在回过头来结合最后的答辩觉得自己选这个题目的毕设是真的傻X，不是因为这个选题不好，而是把这个选题作为毕业设计的题目真的傻X，说到这就想起一些在答辩现场不好的事情了，溜了溜了。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3zzjvdcwqj30690690sk.jpg"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>作者自认为在这个系列中思路还是比较清晰的。</p><p>首先是第一弹，想要做深度学习有关的东西，刚开始肯定是要搭建好一个深度学习的环境的。在这篇文章中，详细的介绍了在我的游戏本上利用GPU搭建深度学习环境的过程，包括<strong>安装nvidia drive、CUDA、cuDNN和TensorFlow的GPU版本</strong>，以及简单介绍了如何利用Pyenv和Pipenv管理自己电脑上的Python虚拟环境。</p><p>然后是第二弹，介绍了什么是图像风格迁移，以及如何用TensorFlow实现了一个基本的图像风格迁移的程序，在这篇文章中我只是简单的介绍了<strong>图像风格迁移的原理</strong>，一方面是因为公式实在是有点多，公众号对于公式的支持不是很好，另一方面作为一个入门介绍，放太多的数学公式的话估计本来人数不多的公众号又要取关一批人了。</p><p>第三弹介绍了一个目前非常流行的Python web框架<strong>Flask</strong>，介绍他的原因不仅仅是因为我的毕业设计就是用这玩意做的，而且在开题的时候我也提到了最后要将这个深度学习算法落地，能够做出一个可用的RESTful API，而相较于其他Web框架，Flask有着得天独厚的优势：首先TensorFlow的首选语言是Python，Flask也是用Python写的，调用起来非常方便；相对于Django，Flask非常轻便，使用起来也非常的灵活。然而在用Flask之前，必须要有些基础知识，因此在这篇文章开篇，我又介绍了<strong>前后端分离</strong>，介绍了什么是<strong>RESTful API</strong>，如果对这些概念没有理解的话就算把代码写出来了也很难知道是干嘛的。</p><p>既然在第三弹介绍了一个用来编写RESTful API的工具，那第四弹自然就是如何<strong>编写这个RESTful API</strong>了。其实在第二弹中就指出了那个算法的不足之处——“慢”，所以在这篇文章中就使用了第二个算法训练出来的模型，之所以不介绍新的风格迁移算法，主要是因为这个算法有点难度，我理解的时候也花了好长时间，等到基本上理解了，第四弹都已经写完了😂。所以在这篇文章中我干脆直接用别人训练好的现成的模型了。其中介绍了如何利用<strong>蓝图（BluePrint）</strong>进行<strong>模块化开发</strong>，并给出了我自己认为的比较好的分层方法，然后利用<strong>七牛云存储</strong>为服务器减压，最后利用Postman请求该API完成测试。</p><p>第五弹的主要内容就是介绍如何将第四弹中已经在本地测试成功的项目发布到服务器上实现<strong>公网访问</strong>，介绍了如何使用了XX云主机，并在上面安装配置了项目所需要使用到的环境的过程，介绍了<strong>Termius</strong>、<strong>FileZilla</strong>等工具。在这篇文章中我希望会有些和别的文章不一样的东西，因此我不仅把实现过程展现了出来，还分享了一些我在实际使用过程中产生的疑问，踩到的坑以及我个人在部署过程中总结的一些经验。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>总的来说，这个系列不仅仅是我在做毕业设计时的一个缩影，也是我自己对于公众号运营的一个探索。期间也收到了很多读者的支持与鼓励，感谢你们的一路陪伴🙏</p><p><strong>推荐阅读</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/ulRiY237EJxgzxPbAjBe-Q">《介绍一下我的毕业设计》</a></li><li><a href="https://mp.weixin.qq.com/s/6qi9rnEhPdAqB_PNQh2EBw">《AI 绘画第一弹——用GPU为你的训练过程加速》</a></li><li><a href="https://mp.weixin.qq.com/s/q0KxclMm3egPfc4U4_p23g">《AI绘画第二弹——图像风格迁移》</a></li><li><a href="https://mp.weixin.qq.com/s/2Q4lp5SdLfVNoYg3J8lPRw">《AI画家第三弹——毕业设计大杀器之Flask》</a></li><li><a href="https://mp.weixin.qq.com/s/QN7JiZ1hm94NRJRurhQm4Q">《AI画家第四弹——利用Flask发布风格迁移API》</a></li><li><a href="https://mp.weixin.qq.com/s/XYObGSYc5eQoLko_N70tcg">《AI画家第五弹——从0到1部署你的RESTful API》</a></li></ol><hr><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4230c3tnkj30x80jwast.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI画家 </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI画家第五弹——从0到1部署你的RESTful API</title>
      <link href="p/257a.html"/>
      <url>p/257a.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5666077-92489cf0e2045c42?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上一篇文章中我们已经<a href="https://mp.weixin.qq.com/s/QN7JiZ1hm94NRJRurhQm4Q">利用 Flask 制作了一个 RESTful API</a>，然而文中末尾我们我们将代码运行起来的时候确发现是 localhost:xxxx，这也就意味着我们没法通过外网访问我们提供的 API，所以这样做出来的程序即使部署到服务器上也没有任何用处。这一篇我们就来详细的说下怎么部署到服务器上然后实现外网访问吧。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>工欲善其事，必先利其器。还是老样子，既然要选择部署到服务器上，我们首先肯定得要有一个服务器，这里我选择 XX 云的学生机（别问为什么，问就是便宜）。系统选择 Ubuntu18.04，需要安装的东西有：</p><ul><li>Python 3.6</li><li>Nginx</li><li>pyenv</li><li>pipenv</li><li>Flask + Gunicorn</li></ul><p>这里我们用 pyenv 管理不同的 python 版本，这里可能就有人要问了，Ubuntu 不是自带 python2 和 python3 吗，为什么还要用 pyenv 来管理，之前的文章我们也说过，用 pyenv 管理 python 会非常的方便，方便到只需要一行代码就可以安装切换系统的 Python 版本，废话不多说，接下来就开始我们的操作吧。</p><h3 id="连接到远程服务器"><a href="#连接到远程服务器" class="headerlink" title="连接到远程服务器"></a>连接到远程服务器</h3><p>如何购买 XX 云的云主机我就不多说了，当你买好之后我们在后台查看到我们购买的云主机的外网 IP，比如我的服务器的外网 IP 地址就是<code>94.191.9.43</code>（希望各位大佬手下留情，别弄他）：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9e1ff9ab46dd919a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来就是连接到服务器了，工具有很多，xshell、putty 或者 terminal 都可以，这里我推荐一个工具<strong>Termius</strong>，推荐他的原因有两个：<strong>颜值</strong>，作为一个颜控，Termius 是我见过的最好看的 SSH 客户端，没有之一。同时还是跨平台的，win/mac/linux/android/ios 都支持，这点不知道比 xshell 高到哪里去了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-8ce6616d7a187d11?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5c7eb7590c28be6ee5c8afdb_termius"></p><p>连接也很简单，我们在 termius 中添加需要连接的 host，然后输入用户名和密码即可登录了，出现如下字样说明登录成功。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-d9e71a5e186892d2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="利用-pyenv-安装制定版本的-python"><a href="#利用-pyenv-安装制定版本的-python" class="headerlink" title="利用 pyenv 安装制定版本的 python"></a>利用 pyenv 安装制定版本的 python</h3><p>之前的文章介绍过如何在 mac 下安装 pyenv，虽然 linux 下的安装方法类似，但毕竟本文的题目是是从 0 到 1 部署，还是再详细说一下吧。</p><ul><li>下载安装 pyenv</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><ul><li>先查看是否存在<code>~/.bash_profile</code>文件</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.bash_profile</span><br></pre></td></tr></table></figure><ul><li>如果没有就新建该文件</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch ~/.bash_profile</span><br></pre></td></tr></table></figure><ul><li>然后执行以下命令将 pyenv 添加到系统变量中</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>接下来执行<code>pyenv</code>命令，如果出现下图则说明安装成功。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ad7e946f235330de?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来我们利用 pyenv 来安装不同版本的 python，只需要一行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install xxx（版本号）</span><br></pre></td></tr></table></figure><p>比如说我们想安装 python 3.6.7，只需要执行<code>pyenv install 3.6.7</code>即可。这一步可能有点慢，主要看服务器的网速和性能了。</p><p>如果出现安装失败的话，可以尝试执行下面代码安装一些依赖库后再重新安装 python：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \</span><br><span class="line">libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \</span><br><span class="line">xz-utils tk-dev libffi-dev liblzma-dev</span><br></pre></td></tr></table></figure><p>出现如下字样说明安装成功。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-669be50025b9ae33?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190527155431084"></p><p>接下来我们执行<code>pyenv versions</code>查看我们系统中目前已有的 python</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* system (set by &#x2F;home&#x2F;ubuntu&#x2F;.pyenv&#x2F;version)</span><br><span class="line">  3.6.7</span><br></pre></td></tr></table></figure><p>执行<code>pyenv global 3.6.7</code>将 3.6.7 作为系统默认的 python 环境，执行下 python 命令查看系统 python 版本，如下图所示我们已经将系统的默认 python 版本切换为 3.6.7 了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-763f98c167629def?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190527155707337"></p><h3 id="安装-pipenv-管理项目的虚拟环境"><a href="#安装-pipenv-管理项目的虚拟环境" class="headerlink" title="安装 pipenv 管理项目的虚拟环境"></a>安装 pipenv 管理项目的虚拟环境</h3><ul><li>先升级 pip</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><ul><li>然后安装 pipenv</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure><p>最后执行 pipenv 查看是否安装成功。</p><p>他的具体用法参考我之前的一篇文章 👉<a href="https://mp.weixin.qq.com/s/KBLgdsL2UaXfayT0Hdi04A">《Python 管理哪家强？》</a></p><h3 id="将项目上传至服务器"><a href="#将项目上传至服务器" class="headerlink" title="将项目上传至服务器"></a>将项目上传至服务器</h3><p>其实到这里项目环境基本算是搭建完成了，不过也只是刚刚能用，离我们最终需要搭建的环境还差点东西，这个后期再说，先来把项目上传到我们的服务器上，这里我选择的工具是 FileZilla，一个开源免费的 FTP 客户端（而且颜值也不错），新建站点后添加服务器 IP，输入用户名和密码后点击连接即可连接到远程服务器，如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a598c8c61e74ff3b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>连接成功后我们可以在工具右侧看到服务器的文件列表，我个人比较喜欢在/home/ubuntu 下新建一个 dev 文件夹专门用来存放项目的代码，方便管理，如下所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-02a2517195867545?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190527162745456"></p><p>我们在工具左侧选择要上传的文件，拖到指定文件夹中即可实现文件上传。这里我讲代码存放到<code>/home/ubuntu/dev/python/stylize</code>路径下了，我们也可以通过 terminal 查看到文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9879ddf1980c1805?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>这个代码在上篇文章中有提到，可在微信公众号「01 二进制」后台回复「风格迁移 API」获得</p></blockquote><h2 id="实现外网访问"><a href="#实现外网访问" class="headerlink" title="实现外网访问"></a>实现外网访问</h2><h3 id="最原始的办法"><a href="#最原始的办法" class="headerlink" title="最原始的办法"></a>最原始的办法</h3><p>我们已经将项目代码上传至服务器了，命令行进入该文件夹，然后执行<code>pipenv install</code>创建虚拟环境并下载所需依赖。接下来再执行<code>pipenv shell</code>进入虚拟环境，这时我们可以看见路径前会有一个括号，里面是虚拟环境的名字，如下所示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(stylize) ubuntu@VM-0-10-ubuntu:~&#x2F;dev&#x2F;python&#x2F;stylize$</span><br></pre></td></tr></table></figure><p>对上一节提供的<code>main.py</code>代码，我们需要对 main 函数进行一些修改：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">8080</span>, debug=app.config[<span class="string">&#x27;DEBUG&#x27;</span>]</span><br></pre></td></tr></table></figure><p>相对于上一节内容，此次修改添加了<code>host=&#39;0.0.0.0&#39;</code>这一参数，这一参数的的含义就是实现 WSGI 服务器的外网访问，如果不添加这个 host，默认只能内网访问，这时我们再执行<code>python main.py</code>启动整个项目，出现如下效果说明服务已经启动了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-317a3872a245846c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190527191041654"></p><p>这时候我们在浏览器中输入<code>ip:8080</code>即可看到效果，例如我这的输入的是<a href="http://94.191.9.43:8080，出现的结果如下：">http://94.191.9.43:8080，出现的结果如下：</a></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-0c650a0f5bdc40a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><blockquote><p>⭐️ 需要注意的是，你需要在你购买的云服务的控制台设置安全组，以便给你的服务器开放相应的端口</p></blockquote><p>至此我们就实现了 flask 的应用在服务端的部署以及实现外网访问了。</p><h3 id="这样就结束了吗？"><a href="#这样就结束了吗？" class="headerlink" title="这样就结束了吗？"></a>这样就结束了吗？</h3><p>但是这样就结束了吗？当然不是，如果我们把连接断掉，这个服务就没办法执行。这时可能就有人会说了，那在执行<code>python main.py</code>这一命令前加一个<code>nohup</code>不就可以实现后台运行了吗？没错，这样确实可以实现后台运行，但是在实际的生产环境中是不会有人使用这样的方式部署的，原因很简单，<strong>Flask 是一个 web 框架，而非 web server，直接用 Flask 拉起的 web 服务仅限于开发环境使用，生产环境不够稳定，也无法承受大量请求的并发，在生产环境下需要使用专业的服务器软件来处理各种请求</strong>。既然 flask 自带的服务器性能很差，那我们自然要清楚专业的服务器，这里的可选项有 Gunicorn、 Nginx 或 Apache，通常情况下，我们选择 Gunicorn+Nginx 这样的组合。</p><h3 id="Gunicorn-是什么？"><a href="#Gunicorn-是什么？" class="headerlink" title="Gunicorn 是什么？"></a>Gunicorn 是什么？</h3><p>这里简单回答两个问题，Gunicorn 是什么以及为什么是 Gunicorn。</p><p>第一个问题，Gunicorn 是什么？</p><p>Gunicorn 中文名”独角兽”，一个开源 Python WSGI UNIX 的 HTTP 服务器。</p><p>第二个问题，为什么是 Gunicorn？</p><p>效率高，使用方便。</p><h3 id="为什么是-Gunicorn-Nginx？"><a href="#为什么是-Gunicorn-Nginx？" class="headerlink" title="为什么是 Gunicorn+Nginx？"></a>为什么是 Gunicorn+Nginx？</h3><p>在<a href="https://mp.weixin.qq.com/s/2Q4lp5SdLfVNoYg3J8lPRw">《AI 画家第三弹——毕业设计大杀器之 Flask》</a>这篇文章中我们曾提过<strong>web 服务器</strong>和<strong>应用服务器</strong>这两种服务器，其中应用服务器既可以解析静态资源，也可以解析动态资源，但是解析静态资源的能力不如 web 服务器。而 Nginx 就是 web 服务器，Gunicorn 是应用服务器，采用这样的组合，一方面基于 Nginx 转发 Gunicorn 服务，在生产环境下能补充 Gunicorn 服务在某些情况下的不足，另一方面，如果做一个 Web 网站，除了服务外，还有很多静态文件需要被托管，这是 Nginx 的强项，也是 Gunicorn 不适合做的事情。所以，基于 Flask 开发的网站，部署时用 Gunicorn 和 Nginx，是一个很好的选择。</p><h3 id="那为什么需要-Nginx-转发-Gunicorn-服务？"><a href="#那为什么需要-Nginx-转发-Gunicorn-服务？" class="headerlink" title="那为什么需要 Nginx 转发 Gunicorn 服务？"></a>那为什么需要 Nginx 转发 Gunicorn 服务？</h3><p>按照上面的解释，其实直接使用 Gunicorn 就完全可以实现外网访问了，为什么非要加一层 Nginx 呢？</p><p>原因其实也很简单，Nginx 功能强大，用 Nginx 转发 Gunicorn 服务，重点是解决“慢客户端行为”给服务器带来的性能降低问题；另外，在互联网上部署 HTTP 服务时，还要考虑的“快客户端响应”、SSL 处理和高并发等问题，而这些问题在 Nginx 上一并能搞定，所以在 Gunicorn 服务之上加一层 Nginx 反向代理，是个一举多得的部署方案。</p><blockquote><p>如果想深入了解 Nginx/Gunnicorn 在项目中扮演的角色，推荐阅读 👇</p><p>Nginx、Gunicorn 在服务器中分别起什么作用？ - 知乎</p><p><a href="https://www.zhihu.com/question/38528616">https://www.zhihu.com/question/38528616</a></p></blockquote><h3 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h3><h4 id="启动-Gunicorn"><a href="#启动-Gunicorn" class="headerlink" title="启动 Gunicorn"></a>启动 Gunicorn</h4><p>上面说了那么多基础知识和原理，赶紧来实际操作下吧，首先安装 Gunicorn，安装方法很简单，在 pipenv 虚拟环境中，我们直接运行以下代码就可以了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipenv install gunicorn</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -D -w 3 -b 127.0.0.1:8080 main:app</span><br></pre></td></tr></table></figure><p>这样就可以启动一个 web 服务，这里我们来解释下这些参数。</p><ol><li>gunicorn：命令的名称，不多解释</li><li>-D 表示后台运行</li><li>-w 表示线程</li><li>-b 指定 ip 和端口（建议使用本地端口，方便 nginx 进行代理。）</li><li>main 是项目的启动文件（main.py）</li><li>app 是全局变量 （<code>app = Flask(__name__)</code>）</li></ol><p>虽然说上述命令也不是很难，但是每次都输这么长的命令难免会出错，有没有什么简单的方法呢？答案自然是有的，我们可以将这些命令的参数以<strong>配置文件</strong>的形式保存到本地。</p><p>首先在项目根目录下新建一个<code>gunicorn.conf</code>，然后写入下面的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 并行工作线程数</span><br><span class="line">workers &#x3D; 4</span><br><span class="line"># 监听内网端口8080【按需要更改】</span><br><span class="line">bind &#x3D; &#39;127.0.0.1:8080&#39;</span><br><span class="line"># 设置守护进程【关闭连接时，程序仍在运行】</span><br><span class="line">daemon &#x3D; True</span><br><span class="line"># 设置超时时间120s，默认为30s。按自己的需求进行设置</span><br><span class="line">timeout &#x3D; 120</span><br><span class="line"># 设置访问日志和错误信息日志路径</span><br><span class="line">accesslog &#x3D; &#39;.&#x2F;logs&#x2F;acess.log&#39;</span><br><span class="line">errorlog &#x3D; &#39;.&#x2F;logs&#x2F;error.log&#39;</span><br></pre></td></tr></table></figure><p>作用就如注释所言。这时我们再启动项目只需要执行下面的命令即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -c gunicorn.conf main:app</span><br></pre></td></tr></table></figure><blockquote><p>记得提前创建好 logs 这个文件夹哦 😊</p></blockquote><h4 id="关闭-Gunicorn"><a href="#关闭-Gunicorn" class="headerlink" title="关闭 Gunicorn"></a>关闭 Gunicorn</h4><p>经历过上述操作后我们就可以启动一个项目了，那该如何关闭呢？</p><p>很简单，分两步</p><p><strong>step1：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pstree -ap|grep gunicorn</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(stylize) ubuntu@VM-0-10-ubuntu:~/dev/python/stylize$ pstree -ap|grep gunicorn</span><br><span class="line">  |-gunicorn,9349/home/ubuntu/.<span class="built_in">local</span>/share/virtualenvs/stylize-rKP1K2<span class="_">-f</span>/bin/gun</span><br><span class="line">  |   |-gunicorn,9352/home/ubuntu/.<span class="built_in">local</span>/share/virtualenvs/stylize-rKP1K2<span class="_">-f</span>/bin/gun</span><br><span class="line">  |   |-gunicorn,9353/home/ubuntu/.<span class="built_in">local</span>/share/virtualenvs/stylize-rKP1K2<span class="_">-f</span>/bin/gun</span><br><span class="line">  |   `-gunicorn,9354/home/ubuntu/.<span class="built_in">local</span>/share/virtualenvs/stylize-rKP1K2<span class="_">-f</span>/bin/gun</span><br><span class="line">  |                       |-grep,9365 --color=auto gunicorn</span><br></pre></td></tr></table></figure><p><strong>step2：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 9349</span><br></pre></td></tr></table></figure><p>-9 表示强制关闭，9349 表示运行的进程号（根据你自己的服务器情况来定）</p><h3 id="安装配置-Nginx"><a href="#安装配置-Nginx" class="headerlink" title="安装配置 Nginx"></a>安装配置 Nginx</h3><p>在 Ubuntu 上安装 Nginx 很简单，一条命令就可以了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p>接下来就是配置了，nginx 的默认配置文件在<code>/etc/nginx/sites-enabled/default</code>中，执行<code>sudo vim default</code>，修改下面部分的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们解释下，修改上述内容的作用是：将外部通过<strong>80 端口</strong>发来的请求，代理给 127.0.0.1:8080 端口。还记得我们在<code>gunicorn.conf</code>中设置了 flask 的启动地址为<code>127.0.0.1:8080</code>，到这里终于派上了用场。</p><p>然后执行以下命令重启 nginx</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>这时我们再访问<a href="http://94.191.9.43,就不用添加端口号了./">http://94.191.9.43，就不用添加端口号了。</a></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ad104e0a39d7b20d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190528014523423"></p><p>如果你有域名的话，在后台把域名解析到这个 ip 上就可以实现域名访问了，是不是很有趣呢？</p><p>当然在 Gunicorn 上再加一层 Nginx 服务，除了实现反向代理，另一个原因就是用它配置 HTTPS 非常方便，这里我就不多说了，如果读者有兴趣的话可以查阅相关资料，或者在评论区/后台留言我，如果想了解的人数多的话我就找个机会挑出来单独写下。</p><h3 id="日志！日志！日志！"><a href="#日志！日志！日志！" class="headerlink" title="日志！日志！日志！"></a>日志！日志！日志！</h3><p>除了上述 HTTPS 的问题，不知道你们有没有发觉还少了点东西。没错，就是日志！重要的事情说三遍！作为一个后台程序，怎么可以少了日志呢？既然我们已经使用 Gunicorn 接管了 Flask 项目，那怎么才能获得 Flask 的日志信息呢？别急，Gunicorn 早就帮你想好了，很简单，只需要在启动文件也就是<code>main.py</code>中添加一段代码即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">if</span> __name__ != <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gunicorn_logger = logging.getLogger(<span class="string">&#x27;gunicorn.error&#x27;</span>)</span><br><span class="line">    app.logger.handlers = gunicorn_logger.handlers</span><br><span class="line">    app.logger.setLevel(gunicorn_logger.level)</span><br></pre></td></tr></table></figure><p>这样的写法主要做了 4 件事：</p><ol><li><code>if __name__ != &#39;__main__&#39; </code>这种写法很少见，意思是仅当该文件作为模块被导入时内部的代码才会被执行，有个好处，避免了硬编码，当执行<code>gunicorn main:app</code>跑的时候<code>main.py</code>会被当成模块导入到 gunicorn 内部, 因为 gunicorn 实际上就是纯 pyhton 写的</li><li>获取 gunicorn 的 logger</li><li>将 gunicorn 的 logger 和 flask app 的 logger 绑定在一起</li><li>将绑定的 logger 的 level 设置成 gunicorn logger 的 level, 因为最终输出的 log level 是在 gunicorn 中配置的</li></ol><p>然后重新启动 gunicorn 就可以了，日志存放的路径我们之前也已经在 gunicorn.conf 中定义过了，用 cat 命令查看就 OK 了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不知不觉已经码了将近 4000 字，这次写这么多一方面是因为最近用这东西的时候发现可以扩展的东西太多了，另一方面也是希望可以和其他博客的内容有所区别，不仅仅把实现过程表现出来，还可以把自己使用过程中的一些习惯、心得体会分享出来和大家交流。当然部署这里能挖的还有很多，比如如何获取来访者的 IP 地址并加以分析，如何用 Nginx 配置 HTTPS 等等等等，有兴趣的可以相关资料，或者在留言区/后台和我讨论，你们的支持才是我前进的最大动力！</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9b321b63b8a8ea6d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI画家 </tag>
            
            <tag> TensorFlow </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI画家第三弹——毕业设计大杀器之Flask</title>
      <link href="p/3d71.html"/>
      <url>p/3d71.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5666077-d57fa69ae73bf8c4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上一篇介绍了图像风格迁移的一个<a href="https://mp.weixin.qq.com/s/q0KxclMm3egPfc4U4_p23g">最基本实现</a>，虽然在控制台实现了功能，但是想要实际使用，应用到一个app或者网页上光靠上一节的内容肯定是不行的。那怎么样才可以将风格迁移这个功能变成一个可以实际使用的小程序呢？不着急，在实现上述功能前，我们先来介绍一个小东西，也就是这篇文章的主角，我把他称为”毕业设计大杀器“的<strong>Flask框架</strong>。</p><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>在介绍Flask之前，我们先介绍下什么是前后端分离。因为如果不介绍前后端分离就不会理解为啥要选择Flask了。前后端分离是目前互联网项目开发的标准使用方式，其核心思想简单理解为是前端页面（或者app等多端）通过ajax（或者其他请求方式）调用后端的restuful api接口并使用json数据进行交互。其目的是为了将项目解耦合，达到**”术业有专攻”**的效果。因为在以往的web项目中，后端人员的工作量非常大，用过jsp的人都知道，那真的是又当爹又当妈，既要会写后台逻辑还要会弄样式。但是采用了前后端分离的架构之后，前后端人员就可以各司其职了。</p><h3 id="前端人的追求"><a href="#前端人的追求" class="headerlink" title="前端人的追求"></a>前端人的追求</h3><p><strong>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</strong></p><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，设计模式，浏览器兼容性，性能优化等等。</p><h3 id="后端人的追求"><a href="#后端人的追求" class="headerlink" title="后端人的追求"></a>后端人的追求</h3><p><strong>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</strong></p><p>把精力放在语言基础，设计模式，底层原理，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，性能优化，以及相关的项目管理等等。</p><h3 id="应用服务器、Web服务器、Restful"><a href="#应用服务器、Web服务器、Restful" class="headerlink" title="应用服务器、Web服务器、Restful"></a>应用服务器、Web服务器、Restful</h3><p><strong>应用服务器</strong>：一般指像tomcat，jetty这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。</p><p><strong>Web服务器</strong>：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。</p><blockquote><p>静态资源就是类似于html、js、图片这些多次访问也不会变化的资源</p><p>一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。</p></blockquote><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>REST的全称是representational state transfer，即表征状态转移。在理解这个名词之前我们先来看几个名词（感觉需要知道的前置知识好多啊）。</p><h4 id="资源-resources"><a href="#资源-resources" class="headerlink" title="资源(resources)"></a>资源(resources)</h4><p>所谓的资源就是网络上的一个实体，它可以使一个图片，一个文本，一个服务，你可以用一个URI指向它，每种资源对应一个特定的URI，要获取这个资源访问它的URI就行了，所谓的上网，其实就是与网络上的资源进行一系列的互动就是了。</p><h4 id="表征-representation"><a href="#表征-representation" class="headerlink" title="表征(representation)"></a>表征(representation)</h4><p>怎么把资源表现出来就是表征的意义，比如一段文本是txt、html还是json，图片是jpg还是png，以http协议为例，就是Accept和content-type中的内容，说明了资源的类型。</p><h4 id="状态转移-state-tranfer"><a href="#状态转移-state-tranfer" class="headerlink" title="状态转移(state tranfer)"></a>状态转移(state tranfer)</h4><p>访问一个网站，就是客户端和服务端的一个交互过程，客户端想要操作服务端，就必须通过某种手段让服务端的状态发生变化，具体到http协议中就是http的几种方法：GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。</p><h4 id="理解RESTful"><a href="#理解RESTful" class="headerlink" title="理解RESTful"></a>理解RESTful</h4><ol><li>使用URI来表示每一个资源</li><li>为每一个资源确定它的表现形式</li><li>使用4个方法来操作这些资源</li></ol><h2 id="什么是Flask？"><a href="#什么是Flask？" class="headerlink" title="什么是Flask？"></a>什么是Flask？</h2><p>介绍完前后端分离后，我们就开始介绍下Flask是什么吧。</p><p>Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2。Flask也被称为 “microframework” ，即**”微框架”**，因为它使用简单的核心，用 extension 增加其他功能。Flask没有默认使用的数据库、窗体验证工具。</p><h3 id="理解下”微”"><a href="#理解下”微”" class="headerlink" title="理解下”微”"></a>理解下”微”</h3><p>“微”框架中的“微”(micro) 并不表示你需要把整个 Web 应用塞进单个 Python 文件（虽然确实可以 ），也不意味着 Flask 在功能上有所欠缺。微框架中的“微”意味着 Flask 旨在保持核心简单而易于扩展。Flask 不会替你做出太多决策——比如使用何种数据库。而那些 Flask 所选择的——比如使用何种模板引擎——则很容易替换。除此之外的一切都由可由你掌握。默认情况下，Flask 不包含数据库抽象层、表单验证，或是其它任何已有多种库可以胜任的功能。然而，Flask 支持用扩展来给应用添加这些功能，如同是 Flask 本身实现的一样。众多的扩展提供了数据库集成、表单验证、上传处理、各种各样的开放认证技术等功能。Flask 也许是“微小”的，但它已准备好在需求繁杂的生产环境中投入使用。</p><h3 id="什么是wsgi？"><a href="#什么是wsgi？" class="headerlink" title="什么是wsgi？"></a>什么是wsgi？</h3><p>全名Web Server Gateway Interface，即服务器网关接口，是应用程序和Web服务器之间的一种接口。可以理解为是服务器程序和应用程序的一个约定，规定了各自使用的接口和功能，以便二和互相配合。</p><blockquote><p>这里因为篇幅原因就不给出详细解释了，推荐两片文章，讲的挺详细的。</p><ol><li><a href="https://www.jianshu.com/p/29f66eb4e55a">https://www.jianshu.com/p/29f66eb4e55a</a></li><li><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057027806560">https://www.liaoxuefeng.com/wiki/897692888725344/923057027806560</a></li></ol></blockquote><h2 id="为什么选Flask？"><a href="#为什么选Flask？" class="headerlink" title="为什么选Flask？"></a>为什么选Flask？</h2><p>我把Flask称为毕业设计大杀器自然是有他的道理的，接下来我们看看他的几大优点：</p><ol><li>插件多。查找资料方便</li><li>没有太多繁琐的配置步骤</li><li>各种中文资料、网友的受虐后的心得文章，查询方便</li><li>部署也非常方便</li><li>社区非常活跃</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>上面说了那么多，你们肯定还是不会理解为啥要使用Flask，别急，我们用例子说话。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里就不多说了，直接<code>pip install flask</code>即可。（官方文档是推荐创建一个虚拟环境的，这里为了方便起见，省略了这一步）。</p><h3 id="最小的应用"><a href="#最小的应用" class="headerlink" title="最小的应用"></a>最小的应用</h3><p>一个最小的 Flask 应用看起来会是这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>把它保存为 hello.py （或是类似的），然后启动terminal（powershell）来运行这个文件。 确保你的应用文件名不是 flask.py ，因为这将与 Flask对象本身冲突。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python hello.py</span><br></pre></td></tr></table></figure><p>现在访问 <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a> ，你会看见 Hello World 早已等候多时。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-3c5ce67cbb914a45?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>一旦部署到远程服务器上之后，这就是一个可以用GET请求访问的接口了，是不是很方便呢？如果想更改请求方法也很简单，只需要在@app.route()装饰器第二个参数填入想要支持的请求方法就可以了，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span></span><br></pre></td></tr></table></figure><p>这样，login这个路由就可以支持get和post两种请求方式了。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>所谓 路由，即<strong>URL 绑定</strong><br>Flask 使用 <code>route()</code>装饰器把一个函数绑于一个URL上， 如下：</p><p>这里是一些基本的例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/hello&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure><p>我们便可以在本地通过<code>localhost:xxxx/hello</code>，来获取到hello函数中的内容。</p><p>同时，我们还可以使用<code>add_url_rule()</code>方法来实现路由的注册</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)   </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello ,world!&#x27;</span></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/hello&#x27;</span>, viewfunc=hello)</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>其实<code>add_url_rule</code>是<code>@app.route()</code>装饰器内部封装的一个方法，两者的本质是相同的。不信咱们看源码：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-febf274a7a179bb4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Carbonize 2019-05-09 at 3.10.23 PM"></p><h3 id="蓝图（blueprint）"><a href="#蓝图（blueprint）" class="headerlink" title="蓝图（blueprint）"></a>蓝图（blueprint）</h3><p>虽然说flask想实现一个路由非常简单，但是在实际的项目中我们肯定是不能把所有的路由都放在初始文件中啊，文件变大不说，还不方便管理，完全不符合模块化开发的思想。不过不用担心，flask早就帮我们想好了应对的办法了。这就是蓝图。</p><p>为了在一个或多个应用中，使应用模块化并且支持常用方案，Flask 引入了蓝图概念。<strong>蓝图可以极大地简化大型应用并为扩展提供集中的注册入口。</strong></p><p>接下来则是蓝图的使用（一般位于API级的<code>__init__.py</code>文件中）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">    register_blueprint(app)   <span class="comment"># 完成蓝图注册</span></span><br><span class="line">    init_db(app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_blueprint</span>(<span class="params">app</span>):</span>  <span class="comment"># 注册蓝图</span></span><br><span class="line">    <span class="keyword">from</span> app.api.v1 <span class="keyword">import</span> v1</span><br><span class="line">    <span class="keyword">from</span> app.api.v1.img <span class="keyword">import</span> img</span><br><span class="line"></span><br><span class="line">    app.register_blueprint(v1, url_prefix=<span class="string">&#x27;/api/v1&#x27;</span>)  </span><br><span class="line">    <span class="comment"># url_prefix添加了这个参数后，所有蓝图路由前面机会自动添加这个参数</span></span><br><span class="line">    <span class="comment"># PS:这个参数必须是一个字符串,而且要以&#x27; / &#x27;开头</span></span><br><span class="line">    app.register_blueprint(img, url_prefix=<span class="string">&#x27;/api/v1/img&#x27;</span>)</span><br></pre></td></tr></table></figure><p>之后我们就可以在另一个文件（需要使用app对象的文件，也就是存放路由函数的文件）中将它初始化</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint  <span class="comment"># 蓝图引入</span></span><br><span class="line"> </span><br><span class="line">img = Blueprint(<span class="string">&#x27;img&#x27;</span>, __name__)  <span class="comment"># 蓝图初始化</span></span><br></pre></td></tr></table></figure><p>其实我们可以理解为就是把主页面的app对象传递到了不同的路由文件中了，方便了模块化的开发。</p><blockquote><p>这里如果没有实例展示的话可能不是很容易理解，下一篇文章我们将会延续上一篇，讲一下如何利用Flask将图像风格迁移的功能变成一个可用的restful api，实例我已经上传了，大家可以先在微信公众号「01二进制」后台回复「风格迁移API」把代码下载下来，体验下flask项目如何分层才不会导致混乱。</p></blockquote><h3 id="flask与数据库"><a href="#flask与数据库" class="headerlink" title="flask与数据库"></a>flask与数据库</h3><p>作为一个后台框架，不可缺少的就是如何与数据库打交道，flask_sqlalchemy很好的帮我们解决了这个问题。</p><p>在了解flask_sqlalchemy是什么之前先看下sqlalchemy是什么，我这里直接引用下廖雪峰大神的介绍：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-cb8d70898d3c198e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>直接我们也提过，flask是一个微框架，通过插件来增加功能的，flask_sqlalchemy就是sqlalchemy的一个flask框架，目的就是为了更加方便的使用ORM技术操作数据库。</p><p>接下来简单介绍下他的使用方法。</p><p>先安装：<code>pip install flask_sqlalchemy</code></p><p>然后在初始文件中添加如下代码以配置数据库连接：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">db &#x3D; SQLAlchemy() # 实例化</span><br></pre></td></tr></table></figure><p>然后在启动文件中添加如下代码将flask_sqlalchemy配置到flask对象中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_db</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="comment"># 注册db</span></span><br><span class="line">    db.init_app(app)</span><br><span class="line">    <span class="comment"># 将代码映射到数据库中</span></span><br><span class="line">    <span class="keyword">with</span> app.app_context():</span><br><span class="line">        db.create_all(app=app)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候别忘了两件事：数据库的连接配置信息和数据表的定义</p><ul><li>数据库的连接配置信息</li></ul><p>我们在项目中新建一个secure.py文件（专门用于记录敏感信息），并在其中添加如下字段</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIALECT = <span class="string">&#x27;mysql&#x27;</span>  <span class="comment"># 要用的什么数据库</span></span><br><span class="line">DRIVER = <span class="string">&#x27;pymysql&#x27;</span>  <span class="comment"># 连接数据库驱动</span></span><br><span class="line">USERNAME = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment"># 用户名</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment"># 密码</span></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span>  <span class="comment"># 服务器</span></span><br><span class="line">PORT = <span class="string">&#x27;3306&#x27;</span>  <span class="comment"># 端口</span></span><br><span class="line">DATABASE = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment"># 数据库名</span></span><br><span class="line"></span><br><span class="line">SQLALCHEMY_DATABASE_URI = <span class="string">&quot;&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8&quot;</span>.format(DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT,</span><br><span class="line">                                                                       DATABASE)</span><br><span class="line">SQLALCHEMY_TRACK_MODIFICATIONS = <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建flask对象的时候别忘了添加下这个配置文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(<span class="string">&#x27;app.secure&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>数据表的定义</li></ul><p>以反馈（feedback）为例，如下代码就构建了一个非常简单的数据库模型了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app.model <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> app.utils <span class="keyword">import</span> common_utils</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedBack</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="comment"># 反馈记录的id</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 反馈人的uid</span></span><br><span class="line">    uid = Column(String(<span class="number">50</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 反馈的内容</span></span><br><span class="line">    content = Column(String(<span class="number">50</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 反馈人的联系方式</span></span><br><span class="line">    contact = Column(String(<span class="number">50</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 反馈的来源</span></span><br><span class="line">    origin = Column(Integer, nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 反馈的时间</span></span><br><span class="line">    created_time = Column(String(<span class="number">50</span>), nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, uid, content, contact, origin</span>):</span></span><br><span class="line">        self.uid = uid</span><br><span class="line">        self.content = content</span><br><span class="line">        self.contact = contact</span><br><span class="line">        self.origin = origin</span><br><span class="line">        self.created_time = common_utils.get_date_now()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后打开数据库服务，启动flask项目，没有报错就说明成功了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们总结下，这篇文章的主角是flask，但是想要理解为啥要使用flask的话我们必须要有前后端分离的概念，不然我们是不会体会到flask的便捷之处的。然后紧接着介绍了我认为刚开始使用flask时的几个比较重要的东西：<strong>路由、蓝图和ORM插件</strong>。因为篇幅原因，没有非常详细的介绍使用方法，但是事实上只要会了这三个应付毕业设计是绰绰有余的，这也就是我将其称为毕业设计大杀器的原因。那么在哪可以学到flask呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-b0fc5982f39b13b2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>在微信公众号「01二进制」后台回复「flask视频」即可获得一份非常非常优质的flask视频</strong></p><p>下一篇将会介绍如何用flask结合风格迁移模型给你的应用程序提供一个可用的RESTful API，喜欢的小伙伴可以关注转发和支持，谢谢🙏</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-1baa0e86138f5b33?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI画家 </tag>
            
            <tag> TensorFlow </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI绘画第二弹——图像风格迁移</title>
      <link href="p/66c6.html"/>
      <url>p/66c6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是我的《AI 绘画系列》的第三篇，点击<a href="http://mp.weixin.qq.com/mp/homepage?__biz=Mzg2ODAyNTgyMQ==&hid=4&sn=f69a637fac6b21c980f20fdd9af6753a&scene=18#wechat_redirect">此处</a>可以查看整个系列的文章<br>本篇文章的源码可以在微信公众号「01 二进制」后台回复「图像风格迁移」获得</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>所谓图像风格迁移，是指将一幅内容图 A 的内容，和一幅风格图 B 的风格融合在一起，从而生成一张具有 A 图风格和 B 图内容的图片 C 的技术。目前这个技术已经得到了比较广泛的应用，这里安利一个 app——“大画家”，这个软件可以将用户的照片自动变换为具有艺术家的风格的图片。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-687333c4c96b4bcd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>其实刚开始写这篇文章的时候我是准备详细介绍下原理的，但是后来发现公式实在是太多了，就算写了估计也没什么人看，而且这篇文章本来定位的用户就是只需要实现功能的新人。此外，有关风格迁移的原理解析的博客实在是太多了，所以这里我就把重点放在如何使用 TensorFlow 实现一个快速风格迁移的应用上，原理的解析就一带而过了。如果只想实现这个效果的可以跳到**”运行”**一节。</p><p>第一步我们需要提前安装好 TensorFlow，如果有 GPU 的小伙伴可以参考我的这篇文章搭建一个 GPU 环境：<a href="https://mp.weixin.qq.com/s/6qi9rnEhPdAqB_PNQh2EBw">《AI 绘画第一弹——用 GPU 为你的训练过程加速》</a>，如果打算直接用 CPU 运行的话，执行下面一行话就可以了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install numpy tensorflow scipy</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>本篇文章是基于<a href="https://link.juejin.im/?target=https://arxiv.org/abs/1508.06576">A Neural Algorithm of Artistic Style</a>一文提出的方法实现的，如果嫌看英文论文太麻烦的也可以查看我对这篇文章的翻译<a href="https://juejin.im/post/5cb49a8af265da03a00fc535">【译】一种有关艺术风格迁移的神经网络算法</a>。</p><p>为了将风格图的风格和内容图的内容进行融合，所生成的图片，在内容上应当尽可能接近内容图，在风格上应当尽可能接近风格图，因此需要定义<strong>内容损失函数</strong>和<strong>风格损失函数</strong>，经过加权后作为总的损失函数。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-dc3b7db48a9ef3f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h3><p>CNN 具有抽象和理解图像的能力，因此可以考虑将各个卷积层的输出作为图像的内容，这里我们采用了利用 VGG19 训练好的模型来进行迁移学习，一般认为，卷积神经网络的训练是对数据集特征的一步步抽取的过程，从简单的特征，到复杂的特征。训练好的模型学习到的是对图像特征的抽取方法，而该模型就是在 imagenet 数据集上预训练的模型，所以理论上来说，也可以直接用于抽取其他图像的特征，虽然效果可能没有在原有数据集上训练出的模型好，但是能够节省大量的训练时间，在特定情况下非常有用。</p><h4 id="加载预训练模型"><a href="#加载预训练模型" class="headerlink" title="加载预训练模型"></a>加载预训练模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vggnet</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="comment"># 读取预训练的vgg模型</span></span><br><span class="line">    vgg = scipy.io.loadmat(settings.VGG_MODEL_PATH)</span><br><span class="line">    vgg_layers = vgg[<span class="string">&#x27;layers&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">    net = &#123;&#125;</span><br><span class="line">    <span class="comment"># 使用预训练的模型参数构建vgg网络的卷积层和池化层</span></span><br><span class="line">    <span class="comment"># 全连接层不需要</span></span><br><span class="line">    <span class="comment"># 注意，除了input之外，这里参数都为constant，即常量</span></span><br><span class="line">    <span class="comment"># 和平时不同，我们并不训练vgg的参数，它们保持不变</span></span><br><span class="line">    <span class="comment"># 需要进行训练的是input，它即是我们最终生成的图像</span></span><br><span class="line">    net[<span class="string">&#x27;input&#x27;</span>] = tf.Variable(np.zeros([<span class="number">1</span>, settings.IMAGE_HEIGHT, settings.IMAGE_WIDTH, <span class="number">3</span>]), dtype=tf.float32)</span><br><span class="line">    <span class="comment"># 参数对应的层数可以参考vgg模型图</span></span><br><span class="line">    net[<span class="string">&#x27;conv1_1&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;input&#x27;</span>], self.get_wb(vgg_layers, <span class="number">0</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv1_2&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv1_1&#x27;</span>], self.get_wb(vgg_layers, <span class="number">2</span>))</span><br><span class="line">    net[<span class="string">&#x27;pool1&#x27;</span>] = self.pool(net[<span class="string">&#x27;conv1_2&#x27;</span>])</span><br><span class="line">    net[<span class="string">&#x27;conv2_1&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;pool1&#x27;</span>], self.get_wb(vgg_layers, <span class="number">5</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv2_2&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv2_1&#x27;</span>], self.get_wb(vgg_layers, <span class="number">7</span>))</span><br><span class="line">    net[<span class="string">&#x27;pool2&#x27;</span>] = self.pool(net[<span class="string">&#x27;conv2_2&#x27;</span>])</span><br><span class="line">    net[<span class="string">&#x27;conv3_1&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;pool2&#x27;</span>], self.get_wb(vgg_layers, <span class="number">10</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv3_2&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv3_1&#x27;</span>], self.get_wb(vgg_layers, <span class="number">12</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv3_3&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv3_2&#x27;</span>], self.get_wb(vgg_layers, <span class="number">14</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv3_4&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv3_3&#x27;</span>], self.get_wb(vgg_layers, <span class="number">16</span>))</span><br><span class="line">    net[<span class="string">&#x27;pool3&#x27;</span>] = self.pool(net[<span class="string">&#x27;conv3_4&#x27;</span>])</span><br><span class="line">    net[<span class="string">&#x27;conv4_1&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;pool3&#x27;</span>], self.get_wb(vgg_layers, <span class="number">19</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv4_2&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv4_1&#x27;</span>], self.get_wb(vgg_layers, <span class="number">21</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv4_3&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv4_2&#x27;</span>], self.get_wb(vgg_layers, <span class="number">23</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv4_4&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv4_3&#x27;</span>], self.get_wb(vgg_layers, <span class="number">25</span>))</span><br><span class="line">    net[<span class="string">&#x27;pool4&#x27;</span>] = self.pool(net[<span class="string">&#x27;conv4_4&#x27;</span>])</span><br><span class="line">    net[<span class="string">&#x27;conv5_1&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;pool4&#x27;</span>], self.get_wb(vgg_layers, <span class="number">28</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv5_2&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv5_1&#x27;</span>], self.get_wb(vgg_layers, <span class="number">30</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv5_3&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv5_2&#x27;</span>], self.get_wb(vgg_layers, <span class="number">32</span>))</span><br><span class="line">    net[<span class="string">&#x27;conv5_4&#x27;</span>] = self.conv_relu(net[<span class="string">&#x27;conv5_3&#x27;</span>], self.get_wb(vgg_layers, <span class="number">34</span>))</span><br><span class="line">    net[<span class="string">&#x27;pool5&#x27;</span>] = self.pool(net[<span class="string">&#x27;conv5_4&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><h3 id="训练思路"><a href="#训练思路" class="headerlink" title="训练思路"></a>训练思路</h3><p>我们使用 VGG 中的一些层的输出来表示图片的内容特征和风格特征。比如，我使用<code>[‘conv4_2’,’conv5_2’]</code>表示内容特征，使用<code>[‘conv1_1’,’conv2_1’,’conv3_1’,’conv4_1’]</code>表示风格特征。在<code>settings.py</code>中进行配置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义计算内容损失的vgg层名称及对应权重的列表</span></span><br><span class="line">CONTENT_LOSS_LAYERS = [(<span class="string">&#x27;conv4_2&#x27;</span>, <span class="number">0.5</span>),(<span class="string">&#x27;conv5_2&#x27;</span>,<span class="number">0.5</span>)]</span><br><span class="line"><span class="comment"># 定义计算风格损失的vgg层名称及对应权重的列表</span></span><br><span class="line">STYLE_LOSS_LAYERS = [(<span class="string">&#x27;conv1_1&#x27;</span>, <span class="number">0.2</span>), (<span class="string">&#x27;conv2_1&#x27;</span>, <span class="number">0.2</span>), (<span class="string">&#x27;conv3_1&#x27;</span>, <span class="number">0.2</span>), (<span class="string">&#x27;conv4_1&#x27;</span>, <span class="number">0.2</span>), (<span class="string">&#x27;conv5_1&#x27;</span>, <span class="number">0.2</span>)]</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ce8bc18588bfd81a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="内容损失函数"><a href="#内容损失函数" class="headerlink" title="内容损失函数"></a>内容损失函数</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ba26b2cfd7085d7c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190429151634583"></p><p>其中，X 是噪声图片的特征矩阵，P 是内容图片的特征矩阵。M 是 P 的长*宽，N 是信道数。最终的内容损失为，每一层的内容损失加权和，再对层数取平均。</p><p>我知道很多人一看到数学公式就会头疼，简单理解就是这个公式可以让模型在训练过程中不断的抽取图片的内容。</p><h3 id="风格损失函数"><a href="#风格损失函数" class="headerlink" title="风格损失函数"></a>风格损失函数</h3><p>计算风格损失。我们使用风格图像在指定层上的特征矩阵的 GRAM 矩阵来衡量其风格，风格损失可以定义为风格图像和噪音图像特征矩阵的格莱姆矩阵的差值的 L2 范数。</p><p>对于每一层的风格损失函数，我们有：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-02d023bc371abd56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中 M 是特征矩阵的长*宽，N 是特征矩阵的信道数。G 为噪音图像特征的 Gram 矩阵，A 为风格图片特征的 GRAM 矩阵。最终的风格损失为，每一层的风格损失加权和，再对层数取平均。</p><p>同样的，看不懂公式没关系，你就把它理解为这个公式可以在训练过程中获取图片的风格。</p><h3 id="计算总损失函数并训练模型"><a href="#计算总损失函数并训练模型" class="headerlink" title="计算总损失函数并训练模型"></a>计算总损失函数并训练模型</h3><p>最后我们只需要将内容损失函数和风格损失函数带入刚开始的公式中即可，要做的就是控制一些风格的权重和内容的权重：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内容损失权重</span></span><br><span class="line">ALPHA = <span class="number">1</span></span><br><span class="line"><span class="comment"># 风格损失权重</span></span><br><span class="line">BETA = <span class="number">500</span></span><br></pre></td></tr></table></figure><p>ALPHA 越大，则最后生成的图片内容信息越大；同理，BETA 越大，则最后生成的图片风格化更严重。</p><p>当训练开始时，我们根据内容图片和噪声，生成一张噪声图片。并将噪声图片喂给网络，计算 loss，再根据 loss 调整噪声图片。将调整后的图片喂给网络，重新计算 loss，再调整，再计算…直到达到指定迭代次数，此时，噪声图片已兼具内容图片的内容和风格图片的风格，进行保存即可。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>如果对上述原理不感兴趣的，想直接运行代码的可以去微信公众号「01 二进制」后台回复「图像风格迁移」获得源码。接下来我们来说说如何使用这个代码跑出自己的绘画。</p><p>首先看下项目结构：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-85ad0639285e8eba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>images 下有两张图片，分别是内容图和风格图，output 下是训练过程中产生的文件，.mat 文件就是预训练模型，models.py 是我们实现的用于读取预训练模型的文件，settings.py 是配置文件，train.py 是最终的训练文件。</p><p>想要运行该项目，我们只需要执行<code>python train.py</code>即可，想更改风格和内容的的话只要在 images 文件中更换原先的图片即可。当然你也可以在<code>settings.py</code>中修改路径：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内容图片路径</span></span><br><span class="line">CONTENT_IMAGE = <span class="string">&#x27;images/content.jpg&#x27;</span></span><br><span class="line"><span class="comment"># 风格图片路径</span></span><br><span class="line">STYLE_IMAGE = <span class="string">&#x27;images/style.jpg&#x27;</span></span><br><span class="line"><span class="comment"># 输出图片路径</span></span><br><span class="line">OUTPUT_IMAGE = <span class="string">&#x27;output/output&#x27;</span></span><br><span class="line"><span class="comment"># 预训练的vgg模型路径</span></span><br><span class="line">VGG_MODEL_PATH = <span class="string">&#x27;imagenet-vgg-verydeep-19.mat&#x27;</span></span><br></pre></td></tr></table></figure><p>我们来看看训练后的图片：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ce3f700cb326a49d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然通过上述代码我们可以实现图像的风格迁移，但是他有一个最大的缺点，就是无法保存训练好的模型，每次转换风格都要重新跑一遍，如果使用 CPU 跑 1000 轮的话大约是在 30 分钟左右，因此推荐大家使用 GPU 进行训练。</p><p>但是即使使用上了 GPU，训练时间也无法满足商业使用的，那有没有什么办法可以保存训练好的风格模型，然后直接快速生成目标图片呢？当然是有的，斯坦福的李飞飞发表过一篇《Perceptual Losses for Real-Time Style Transfer and Super-Resolution》，通过使用 perceptual loss 来替代 per-pixels loss 使用 pre-trained 的 vgg model 来简化原先的 loss 计算，增加一个 transform Network，直接生成 Content image 的 style。这里就不再多说了，感兴趣的可以参考我下面给出的两个链接：</p><ol><li><a href="https://juejin.im/post/5ba4e029e51d450e9874eaf3">《深度有趣 | 30 快速图像风格迁移》</a></li><li><a href="https://blog.csdn.net/qq_25737169/article/details/79192211">《风格迁移背后原理及 tensorflow 实现》</a></li></ol><p>以上就是本篇文章的全部内容，个人做下来感觉还是挺有意思的，因个人能力有限，文中如有纰漏错误之处，还请各位大佬指正，万分感谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://arxiv.org/pdf/1508.06576v1.pdf">A Neural Algorithm of Artistic Style</a></li><li><a href="https://blog.csdn.net/a595130080/article/details/79182843">深度学习实战（一）快速理解实现风格迁移</a></li><li><a href="https://juejin.im/post/5ba255fd6fb9a05d3c7ff06d">深度有趣 | 04 图像风格迁移</a></li><li><a href="https://blog.csdn.net/czp_374/article/details/81185603">学习笔记：图像风格迁移</a></li></ol><hr><p>欢迎关注我的微信公众号：「01 二进制」，关注后即可获得博主认真收集的计算机资料</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-68889db7a454e503?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI画家 </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI换脸——汝怎饰品如面</title>
      <link href="p/28be.html"/>
      <url>p/28be.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>事先说明，该篇文章中的代码是我无意中发现的，这里仅做一个分享，文末会给出参考文章，不喜勿喷。</p><p>完整源码和预训练模型可在公众号：「01 二进制」后台回复：「AI 换脸」获取</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个经常逛 b 站的肥宅，前段时间无意中看到了一个名为”换脸哥”做的换脸视频，让杨幂“穿越”到了 1994 年版的《射雕英雄传》里，“代替”了朱茵，“出演”了黄蓉这个角色。视频如下（b 站视频已经被删了，只能转载知乎的视频了，原地址是<a href="https://zhuanlan.zhihu.com/p/57863071">杨幂“换脸”，AI 换脸究竟有多可怕 - 科技富能量的文章 - 知乎</a>）：</p><p><video src="http://mpvideo.qpic.cn/tjg_3868025821_50000_4374234d39244a4d8a5825488ed395c3.f10002.mp4?dis_k=9bb8c446acafa3fff362e83e380299dd&dis_t=1554306632"></video></p><p>看完我便虎躯一震，这也太厉害了吧，这种技术一旦流行起来，ab 不用去片场就能拍戏了啊，真的是躺着赚钱啊。这要是运用到 H 片上，岂不是 😅😅😅</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-118e397b50981cd6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>言归正传，作为一个 coder，在看到这个视频之后我就很想知道这究竟是怎么做出来的，在查阅了一些资料后，我才发现最悲伤的事情莫过于，好不容易把源码找到了，数据集下载好了，结果显卡带不起来…</p><blockquote><p>Tips：这里给出我之前找到的两个有关视频换脸的仓库，有兴趣的自己去了解下：</p><ul><li><p><a href="https://github.com/joshua-wu/deepfakes_faceswap">deepfakes_faceswap</a></p></li><li><p><a href="https://github.com/goberoi/faceit">FaceIt</a></p></li></ul></blockquote><p>既然条件不允许，那我们只能降低成本，既然视频里的脸不好换，那就退而求其次，换一下图片里面的脸，果然在我的苦苦寻觅后，我找到了一个低配版的 Python 换脸大法：</p><p><a href="https://matthewearl.github.io/2015/07/28/switching-eds-with-python/">《Switching Eds: Face swapping with Python, dlib, and OpenCV》</a></p><blockquote><p>以下内容均参考上述所标注的文章，在这感谢原作者。</p></blockquote><p>接下来我将会介绍如何通过一段简短的 Python 脚本（200 行左右）将一张图片中面部特征自动替换为另外一张图片中的面部特征。</p><p>具体过程分为四个步骤：</p><ul><li>检测面部标志；</li><li>旋转、缩放和平移图 2 以适应图 1；</li><li>调整图 2 的白平衡以匹配图 1；</li><li>将图 2 的特征融合到图 1 中；</li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>MacOS 10.14.3</li><li>Python 3.7</li><li>PyCharm</li><li>用到的库有：<ul><li>numpy</li><li>dlib</li><li>opencv-python</li></ul></li></ul><h2 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h2><p>numpy 大家应该都很熟悉了，这里我简单介绍下 dlib 和 opencv。</p><h3 id="dlib"><a href="#dlib" class="headerlink" title="dlib"></a>dlib</h3><p>官网介绍其为：A toolkit for making real world machine learning and data analysis applications，简单来说他就是一个开源的机器学习库，包含了很多机器学习的算法。同时对外提供了 C++和 Python 的接口。使用 dlib 可以大大简化开发，比如人脸识别，特征点检测之类的工作都可以很轻松实现。同时也有很多基于 dlib 开发的应用和开源库，比如 face_recogintion 库（据说识别率高达 93%，有兴趣的可以查阅相关资料）。python 下的安装也很简单，执行<code>pip install dlib</code>即可。</p><h3 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h3><p>OpenCV 是 Intel® 开源计算机视觉库。它由一系列 C 函数和少量 C++ 类构成，实现了图像处理和计算机视觉方面的很多通用算法。是计算机视觉领域非常重要的一个开源库。官网地址：<a href="https://opencv.org/">https://opencv.org/</a></p><h2 id="开始换脸"><a href="#开始换脸" class="headerlink" title="开始换脸"></a>开始换脸</h2><h3 id="提取面部特征"><a href="#提取面部特征" class="headerlink" title="提取面部特征"></a>提取面部特征</h3><p>既然要换脸，我们肯定要先在图片中找到人脸，dlib 中有一个函数<code>get_frontal_face_detector()</code>实现了面部特征提取，核心算法来自于 Vahid Kazemi 和 Josephine Sullivan 的论文《One Millisecond Face Alignment with an Ensemble of Regression Tree》，我也没有读过这篇论文就不解释了。提取面部特征的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 面部检测器</span></span><br><span class="line">detector = dlib.get_frontal_face_detector()</span><br><span class="line"><span class="comment"># 特征提取器</span></span><br><span class="line">predictor = dlib.shape_predictor(<span class="string">&#x27;shape_predictor_68_face_landmarks.dat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLandmarks</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    img = cv2.imread(img_path, cv2.IMREAD_COLOR)</span><br><span class="line">    rects = detector(img, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> len(rects) &gt; <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">&#x27;[Warning]: More than one face in picture, only choose one randomly...&#x27;</span>)</span><br><span class="line">        rects = rects[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> len(rects) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&#x27;[Error]: No face detected...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> img, np.matrix([[p.x, p.y] <span class="keyword">for</span> p <span class="keyword">in</span> predictor(img, rects[<span class="number">0</span>]).parts()])</span><br></pre></td></tr></table></figure><p>get_landmarks() 函数接受一个图片，经过处理后以 numpy 数组的形式进行处理，并返回一个 68x2 的元素矩阵。矩阵的每一行与输入图像中特定特征点的 x，y 坐标相对应。</p><p>特征提取器（predictor）需要一个大概的边界框作为算法的输入。这将由传统的面部检测器（detector）提供。该面部检测器会返回一个矩形列表，其中每一个矩形与图像中的一张人脸相对应。</p><blockquote><p>生成 predictor 需要预先训练好的模型。该模型可在微信公众号「01 二进制」后台回复”AI 换脸”获得。</p></blockquote><h3 id="人脸对齐"><a href="#人脸对齐" class="headerlink" title="人脸对齐"></a>人脸对齐</h3><p>有了上述方法，我们就可以提取出图片中的人脸了，但是两张照片中的人脸方向肯定都是不一致的（毕竟你不能保证每张都是证件照啊），就像下面这两张图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-e8eae9769ff5da48?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190403222900051"></p><p>这两个人脸的方向明显不一致啊，所以我们还需要对人脸进行对齐。我们现在已经获取到每张图片中人脸矩形的坐标了，剩下的就是弄明白如何旋转、平移和缩放第一个向量的所有点，使其尽可能匹配第二个向量中的点就可以了。这里运用到了一个名为<strong>普氏分析法（Ordinary Procrustes Analysis）</strong>的方法解决这个问题的，数学能力有限，数学依据参考注释中的链接，这里就直接放出代码吧：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># refer:</span></span><br><span class="line"><span class="comment"># https://en.wikipedia.org/wiki/Procrustes_analysis#Ordinary_Procrustes_analysis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TransferPoints</span>(<span class="params">points1, points2</span>):</span></span><br><span class="line">    points1 = points1.astype(np.float64)</span><br><span class="line">    points2 = points2.astype(np.float64)</span><br><span class="line">    c1 = np.mean(points1, axis=<span class="number">0</span>)</span><br><span class="line">    c2 = np.mean(points2, axis=<span class="number">0</span>)</span><br><span class="line">    points1 -= c1</span><br><span class="line">    points2 -= c2</span><br><span class="line">    s1 = np.std(points1)</span><br><span class="line">    s2 = np.std(points2)</span><br><span class="line">    points1 /= s1</span><br><span class="line">    points2 /= s2</span><br><span class="line">    <span class="comment"># 奇异值分解</span></span><br><span class="line">    U, S, Vt = np.linalg.svd(points1.T * points2)</span><br><span class="line">    R = (U * Vt).T</span><br><span class="line">    <span class="keyword">return</span> np.vstack([np.hstack(((s2 / s1) * R, c2.T - (s2 / s1) * R * c1.T)), np.matrix([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>])])</span><br></pre></td></tr></table></figure><p>之后我们再把对齐的结果利用 OpenCV 的 cv2.warpAffine 函数，将第二个图片映射到第一个图片上：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WarpImg</span>(<span class="params">img, M, dshape</span>):</span></span><br><span class="line">    output_img = np.zeros(dshape, dtype=img.dtype)</span><br><span class="line">    cv2.warpAffine(img,</span><br><span class="line">                   M[:<span class="number">2</span>],</span><br><span class="line">                   (dshape[<span class="number">1</span>], dshape[<span class="number">0</span>]),</span><br><span class="line">                   dst=output_img,</span><br><span class="line">                   borderMode=cv2.BORDER_TRANSPARENT,</span><br><span class="line">                   flags=cv2.WARP_INVERSE_MAP)</span><br><span class="line">    <span class="keyword">return</span> output_img</span><br></pre></td></tr></table></figure><h3 id="校正图片颜色"><a href="#校正图片颜色" class="headerlink" title="校正图片颜色"></a>校正图片颜色</h3><p>两张图片由于不同的<strong>肤色</strong>和<strong>光线</strong>造成了覆盖区域边缘的不连续。所以我们需要修正它：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ModifyColor</span>(<span class="params">img1, img2, landmarks1</span>):</span></span><br><span class="line">    blur_amount = <span class="number">0.6</span> * np.linalg.norm(</span><br><span class="line">        np.mean(landmarks1[LEFT_EYE_POINTS], axis=<span class="number">0</span>) - np.mean(landmarks1[RIGHT_EYE_POINTS], axis=<span class="number">0</span>))</span><br><span class="line">    blur_amount = int(blur_amount)</span><br><span class="line">    <span class="keyword">if</span> blur_amount % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        blur_amount += <span class="number">1</span></span><br><span class="line">    img1_blur = cv2.GaussianBlur(img1, (blur_amount, blur_amount), <span class="number">0</span>)</span><br><span class="line">    img2_blur = cv2.GaussianBlur(img2, (blur_amount, blur_amount), <span class="number">0</span>)</span><br><span class="line">    img2_blur += (<span class="number">128</span> * (img2_blur &lt;= <span class="number">1.0</span>)).astype(img2_blur.dtype)</span><br><span class="line">    <span class="keyword">return</span> (img2.astype(np.float64) * img1_blur.astype(np.float64) / img2_blur.astype(np.float64))</span><br></pre></td></tr></table></figure><h3 id="图片融合"><a href="#图片融合" class="headerlink" title="图片融合"></a>图片融合</h3><p>用一个蒙版（mask）来选择图 2 和图 1 应被最终显示的部分：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-063a559211d46243?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>值为 1 (白色)的地方为图 2 应显示的区域，值为 0 (黑色)的地方为图 1 应显示的区域。值在 0 和 1 之间的地方为图 1 图 2 的混合区域。</p><p>这是生成上述内容的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFaceMask</span>(<span class="params">img, landmarks</span>):</span></span><br><span class="line">    img = np.zeros(img.shape[:<span class="number">2</span>], dtype=np.float64)</span><br><span class="line">    groups = [</span><br><span class="line">        LEFT_EYE_POINTS + RIGHT_EYE_POINTS + LEFT_BROW_POINTS + RIGHT_BROW_POINTS,</span><br><span class="line">        NOSE_POINTS + MOUTH_POINTS,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> groups:</span><br><span class="line">        DrawConvexHull(img, landmarks[group], color=<span class="number">1</span>)</span><br><span class="line">    img = np.array([img, img, img]).transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">    img = (cv2.GaussianBlur(img, (<span class="number">11</span>, <span class="number">11</span>), <span class="number">0</span>) &gt; <span class="number">0</span>) * <span class="number">1.0</span></span><br><span class="line">    img = cv2.GaussianBlur(img, (<span class="number">11</span>, <span class="number">11</span>), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DrawConvexHull</span>(<span class="params">img, points, color</span>):</span></span><br><span class="line">    points = cv2.convexHull(points)</span><br><span class="line">    cv2.fillConvexPoly(img, points, color=color)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ModifyColor</span>(<span class="params">img1, img2, landmarks1</span>):</span></span><br><span class="line">    blur_amount = <span class="number">0.6</span> * np.linalg.norm(</span><br><span class="line">        np.mean(landmarks1[LEFT_EYE_POINTS], axis=<span class="number">0</span>) - np.mean(landmarks1[RIGHT_EYE_POINTS], axis=<span class="number">0</span>))</span><br><span class="line">    blur_amount = int(blur_amount)</span><br><span class="line">    <span class="keyword">if</span> blur_amount % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        blur_amount += <span class="number">1</span></span><br><span class="line">    img1_blur = cv2.GaussianBlur(img1, (blur_amount, blur_amount), <span class="number">0</span>)</span><br><span class="line">    img2_blur = cv2.GaussianBlur(img2, (blur_amount, blur_amount), <span class="number">0</span>)</span><br><span class="line">    img2_blur += (<span class="number">128</span> * (img2_blur &lt;= <span class="number">1.0</span>)).astype(img2_blur.dtype)</span><br><span class="line">    <span class="keyword">return</span> (img2.astype(np.float64) * img1_blur.astype(np.float64) / img2_blur.astype(np.float64))</span><br></pre></td></tr></table></figure><p><code>GetFaceMask()</code>函数定义是：为一张图像和一个标志矩阵生成一个蒙版。蒙版会画出两个白色的凸多边形：一个是眼睛周围的区域，一个是鼻子和嘴部周围的区域。之后，蒙版的边缘区域向外羽化 11 个像素，这可以帮助消除剩下的不连续部分。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文参考了下述文章：</p><ol><li><a href="https://link.juejin.im/?target=https://matthewearl.github.io/2015/07/28/switching-eds-with-python/">《Switching Eds: Face swapping with Python, dlib, and OpenCV》</a></li><li><a href="https://juejin.im/post/5ad60e19f265da239707600d">《萌新如何用 Python 实现人脸替换？》</a></li></ol><blockquote><p>完整源码和预训练模型可在公众号：「01 二进制」后台回复：「AI 换脸」获取</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，一个低配版的 AI 换脸就完成了，结果就如开头那样。此次实验虽然已有换脸的雏形，但是精度还远远不够，而且这种换脸如果用到视频中肯定是不堪入目的，毕竟做得好的已经是下面这样了：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-62297fd4a6b1ad8a?imageMogr2/auto-orient/strip"></p><blockquote><p>方法教给大家了，图片素材大家可以自己找，玩一玩，要是能转发到朋友圈让更多人看到就更好了！</p></blockquote><hr><p>下篇更新”美国校队蔡徐坤”打篮球视频的 txt 版，这里先放个预览的 GIF 图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-ed6773e4585cead7?imageMogr2/auto-orient/strip"></p><p>喜欢的小伙伴可以长按下方二维码关注哦～。👇</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-117f041185d9be17?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 实战教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中链表与数组间的相互转换</title>
      <link href="p/afc.html"/>
      <url>p/afc.html</url>
      
        <content type="html"><![CDATA[<h2 id="自定义链表-ListNode-类"><a href="#自定义链表-ListNode-类" class="headerlink" title="自定义链表 ListNode 类"></a>自定义链表 ListNode 类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将链表转换成数组"><a href="#将链表转换成数组" class="headerlink" title="将链表转换成数组"></a>将链表转换成数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将链表转换成数组</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test1 test1 &#x3D; new Test1();</span><br><span class="line">        int[] a &#x3D; &#123;1, 9, 9, 9, 9, 9, 9, 9, 9, 9&#125;;</span><br><span class="line">        ListNode l1 &#x3D; test1.arrayToListNode(a);</span><br><span class="line">        test1.printListNode(l1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数组转换成链表</span><br><span class="line">    public ListNode arrayToListNode(int[] s) &#123;</span><br><span class="line">        ListNode root &#x3D; new ListNode(s[0]);&#x2F;&#x2F;生成链表的根节点，并将数组的第一个元素的值赋给链表的根节点</span><br><span class="line">        ListNode other &#x3D; root;&#x2F;&#x2F;生成另一个节点，并让other指向root节点，other在此作为一个临时变量，相当于指针</span><br><span class="line">        for (int i &#x3D; 1; i &lt; s.length; i++) &#123;&#x2F;&#x2F;由于已给root赋值，所以i从1开始</span><br><span class="line">            ListNode temp &#x3D; new ListNode(s[i]);&#x2F;&#x2F;每循环一次生成一个新的节点,并给当前节点赋值</span><br><span class="line">            other.next &#x3D; temp;&#x2F;&#x2F;将other的下一个节点指向生成的新的节点</span><br><span class="line">            other &#x3D; temp;&#x2F;&#x2F;将other指向最后一个节点(other的下一个节点)  other&#x3D;other.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历一个链表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void printListNode(ListNode l) &#123;</span><br><span class="line">        while (l !&#x3D; null) &#123;</span><br><span class="line">            System.out.print(l.val + &quot; &quot;);</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="将数组转换成链表"><a href="#将数组转换成链表" class="headerlink" title="将数组转换成链表"></a>将数组转换成链表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将链表转换成数组</span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test2 test2 &#x3D; new Test2();</span><br><span class="line">        ListNode l1 &#x3D; new ListNode(0);</span><br><span class="line">        l1.next &#x3D; new ListNode(1);</span><br><span class="line">        l1.next.next &#x3D; new ListNode(2);</span><br><span class="line">        l1.next.next.next &#x3D; new ListNode(3);</span><br><span class="line">        l1.next.next.next.next &#x3D; new ListNode(4);</span><br><span class="line"></span><br><span class="line">        test2.printArrays(test2.listNodeToArray(l1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;输出数组</span><br><span class="line">    public void printArrays(int[] ints) &#123;</span><br><span class="line">        for (int x : ints) &#123;</span><br><span class="line">            System.out.print(x + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将链表转换成数组</span><br><span class="line">    public int[] listNodeToArray(ListNode l) &#123;</span><br><span class="line">        int size &#x3D; listNodeSize(l);</span><br><span class="line">        int[] ints &#x3D; new int[size];</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (l !&#x3D; null) &#123;</span><br><span class="line">            ints[index] &#x3D; l.val;</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;求链表的长度</span><br><span class="line">    public int listNodeSize(ListNode l) &#123;</span><br><span class="line">        int size &#x3D; 0;</span><br><span class="line">        while (l !&#x3D; null) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历一个链表</span><br><span class="line">    public void printListNode(ListNode l) &#123;</span><br><span class="line">        while (l !&#x3D; null) &#123;</span><br><span class="line">            System.out.print(l.val + &quot; &quot;);</span><br><span class="line">            l &#x3D; l.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的进制转换</title>
      <link href="p/8486.html"/>
      <url>p/8486.html</url>
      
        <content type="html"><![CDATA[<p>近期刷题时遇到了进制转换，在这整理一波</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十进制转其他进制 </span><br><span class="line">Integer.toHexString(int i);&#x2F;&#x2F;转成16进制</span><br><span class="line">Integer.toBinaryString(int i);&#x2F;&#x2F;转成二进制</span><br><span class="line">Integer.toOctalString(int i);&#x2F;&#x2F;转成8进制</span><br><span class="line">Integer.toString(int i,  int radix);&#x2F;&#x2F;转成任意进制，radix不在【2,36】区间内radix&#x3D;10</span><br><span class="line"></span><br><span class="line">Long.toHexString(long i);&#x2F;&#x2F;转成16进制</span><br><span class="line">Long.toBinaryString(long i);&#x2F;&#x2F;转成二进制</span><br><span class="line">Long.toOctalString(long i);&#x2F;&#x2F;转成8进制</span><br><span class="line">Long.toString(long i,  int radix);&#x2F;&#x2F;转成任意进制，radix不在【2,36】区间内radix&#x3D;10 </span><br><span class="line"></span><br><span class="line">其他进制转十进制</span><br><span class="line">Integer.valueOf(String s, int radix); 返回值类型为Integer，radix不在【2,36】区间内，抛出NumberFormatException异常  </span><br><span class="line">parseInt(String s, int radix); 返回值类型为：int，radix不在【2,36】区间内，抛出NumberFormatException异常    </span><br><span class="line"></span><br><span class="line">各进制间的转换</span><br><span class="line">Integer.toString(parseInt(String s, int srcRadix), int destRadix);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 表单组件</title>
      <link href="p/7c99.html"/>
      <url>p/7c99.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在利用flutter制作校园软件，需要制作一个登录界面，所以要用到Flutter中的一些表单控件，今天就来总结下flutter中的一些表单控件。<br>本文参考：</p><ul><li><a href="https://gru.tsecloud.club/dart/flutter-widget-form/">《Flutter 基础组件-表单》</a></li><li><a href="https://docs.flutter.io/flutter/widgets/FormState-class.html">FormState class</a></li><li><a href="https://docs.flutter.io/flutter/widgets/Form-class.html">Form Class</a></li><li><a href="https://docs.flutter.io/flutter/material/TextField-class.html">TextField class</a></li><li><a href="https://docs.flutter.io/flutter/material/TextFormField-class.html">TextFormField</a></li></ul><a id="more"></a><h3 id="TextField-FormField"><a href="#TextField-FormField" class="headerlink" title="TextField, FormField"></a>TextField, FormField</h3><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><p>先从最基础的讲起，对于<code>TextField</code>就是android中的<code>edittext</code>，就是一个输入框（ <a href="https://docs.flutter.io/flutter/material/TextField-class.html">TextField class</a>），这个输入框常用的属性如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child: new TextField(</span><br><span class="line">autocorrect: false, &#x2F;&#x2F; 是否自动校正</span><br><span class="line">autofocus: false, &#x2F;&#x2F;自动获取焦点</span><br><span class="line">enabled: true, &#x2F;&#x2F; 是否启用</span><br><span class="line">inputFormatters: [], &#x2F;&#x2F;对输入的文字进行限制和校验</span><br><span class="line">keyboardType: TextInputType.text, &#x2F;&#x2F;获取焦点时,启用的键盘类型</span><br><span class="line">maxLines: 2, &#x2F;&#x2F; 输入框最大的显示行数</span><br><span class="line">maxLength: 3, &#x2F;&#x2F;允许输入的字符长度&#x2F;</span><br><span class="line">maxLengthEnforced: false, &#x2F;&#x2F;是否允许输入的字符长度超过限定的字符长度</span><br><span class="line">obscureText: true, &#x2F;&#x2F; 是否隐藏输入的内容</span><br><span class="line">onChanged: (newValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; print(newValue); &#x2F;&#x2F; 当输入内容变更时,如何处理</span><br><span class="line">&#125;,</span><br><span class="line">onSubmitted: (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; print(&quot;whar&quot;); &#x2F;&#x2F; 当用户确定已经完成编辑时触发</span><br><span class="line">&#125;,</span><br><span class="line">style: new TextStyle(</span><br><span class="line">    color: new Color(Colors.amberAccent.green)), &#x2F;&#x2F; 设置字体样式</span><br><span class="line">textAlign: TextAlign.center, &#x2F;&#x2F;输入的内容在水平方向如何显示</span><br><span class="line">decoration: new InputDecoration(</span><br><span class="line">    labelText: &quot;城市&quot;,</span><br><span class="line">    icon: new Icon(Icons.location_city),</span><br><span class="line">    border: new OutlineInputBorder(), &#x2F;&#x2F; 边框样式</span><br><span class="line">    helperText: &#39;required&#39;,</span><br><span class="line">    hintText: &#39;请选择你要投保的城市&#39;,</span><br><span class="line">    prefixIcon: new Icon(Icons.android),</span><br><span class="line">    prefixText: &#39;Hello&#39;),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h4 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h4><p>其实对于一个输入框，我们最关心的无非就是监听输入的内容，然后输入完成后，输入框中的内容是什么，文档中写的很清楚，textfiled控件有三个回调函数：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-938cc9130534823f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>在这里我们只需要关注<code>onChanged</code>和<code>onSubmitted</code>即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child: new TextField(</span><br><span class="line">    controller: _controller,</span><br><span class="line">    decoration: new InputDecoration(labelText: &#39;Your Name&#39;),</span><br><span class="line">    onChanged: (val) &#123;</span><br><span class="line">        print(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    onSubmitted: (String v) &#123;</span><br><span class="line">        print(v);</span><br><span class="line">    &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>顾名思义: <code>onChanged</code> 事件,在输入内容发生变化的时候触发，<code>onSubmitted</code>事件,则是在输入结束,点击完成的时候触发。<br>然而在<code>TextFormField</code>中没有这两个事件,取而代之的是<code>validator</code>,<code>onSaved</code>,<code>onFieldSubmitted</code> 他们都接受三个函数,并且将其值作为参数传递到函数里面</p><ul><li>validator,如果开启<code>autovalidate: true</code>,那么将会自动检验输入的值,如果没有则会在表单提交的时候检验 该函数只允许返回验证失败的错误信息以及验证通过时返回null。</li><li>onSaved, 当调用<code>FormState.save</code>方法的时候调用。</li><li>onFieldSubmitted, 与<code>onSubmitted</code>一样,则是在输入结束,点击完成的时候触发。<h4 id="编辑控制"><a href="#编辑控制" class="headerlink" title="编辑控制"></a>编辑控制</h4>无论是在TextField还是TextFormField中,都有一个重要的属性controller,该属性可用来对输入框内容进行控制。<br>先创建一个控制对象：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TextEditingController _controller &#x3D; new TextEditingController();</span><br><span class="line">TextEditingController _formFieldController &#x3D; new TextEditingController();</span><br></pre></td></tr></table></figure><p>为输入框初始化值以及注册一个监听事件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line"> void initState() &#123;</span><br><span class="line">   &#x2F;&#x2F; TODO: implement initState</span><br><span class="line">   super.initState();</span><br><span class="line">   _controller.value &#x3D; new TextEditingValue(text: &#39;Hello&#39;);</span><br><span class="line">   _formFieldController.addListener(() &#123;</span><br><span class="line">     print(&#39;listener&#39;);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>触发一个监听事件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _textFieldAction() &#123;</span><br><span class="line">   &#x2F;&#x2F; print(_formFieldController.selection);</span><br><span class="line">   &#x2F;&#x2F; print(_formFieldController.text); &#x2F;&#x2F;获取输入内容</span><br><span class="line">   print(_formFieldController.hasListeners); &#x2F;&#x2F;判断是否注册监听事件</span><br><span class="line">   _formFieldController.notifyListeners(); &#x2F;&#x2F;触发监听事件</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h3><p>Flutter中的<code>Form</code>组件和html中的<code>&lt;form&gt;&lt;/form&gt;</code>的作用类似，都是起到了一个容器的作用，里面包含了<code>TextFormField</code>的一个列表 下面通过一个例子说明表单的一些特性</p><ol><li>布局</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: implement build</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &#39;Flutter data&#39;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&#39;Flutter Form&#39;),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: new FloatingActionButton(</span><br><span class="line">          onPressed: _forSubmitted,</span><br><span class="line">          child: new Text(&#39;提交&#39;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Container(</span><br><span class="line">          padding: const EdgeInsets.all(16.0),</span><br><span class="line">          child: new Form(</span><br><span class="line">            key: _formKey,</span><br><span class="line">            child: new Column(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                new TextFormField(</span><br><span class="line">                  decoration: new InputDecoration(</span><br><span class="line">                    labelText: &#39;Your Name&#39;,</span><br><span class="line">                  ),</span><br><span class="line">                  onSaved: (val) &#123;</span><br><span class="line">                    _name &#x3D; val;</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">                new TextFormField(</span><br><span class="line">                  decoration: new InputDecoration(</span><br><span class="line">                    labelText: &#39;Password&#39;,</span><br><span class="line">                  ),</span><br><span class="line">                  obscureText: true,</span><br><span class="line">                  validator: (val) &#123;</span><br><span class="line">                    return val.length &lt; 4 ? &quot;密码长度错误&quot; : null;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  onSaved: (val) &#123;</span><br><span class="line">                    _password &#x3D; val;</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>以上,我们使用一个<code>Form</code>包裹着两个<code>TextFormField</code>组件,在这里为了简便,我们只设置了一些必要的元素,先暂时忽略<code>TextFormField</code>中的事件<br>为了获取表单的实例,我们需要设置一个全局类型的<code>key</code>,通过这个<code>key</code>的属性,来获取表单对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GlobalKey&lt;FormState&gt; _formKey &#x3D; new GlobalKey&lt;FormState&gt;();</span><br><span class="line">String _name;</span><br><span class="line">String _password;</span><br></pre></td></tr></table></figure><p>同时也设置了<code>_name</code>,<code>_password</code>两个变量来存储用户的输入值,在<code>TextFormField</code>组件的<code>onSaved</code>方法中,将输入框的值赋值到设定的变量中<br>我们通过<code>FloatingActionButton</code>来触发表单提交事件，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">floatingActionButton: new FloatingActionButton(</span><br><span class="line">    onPressed: _forSubmitted,</span><br><span class="line">    child: new Text(&#39;提交&#39;),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>在<code>_forSubmitted</code>中我们使用<code>key</code>的<code>currentState</code>属性来获取表单的实例对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _forSubmitted() &#123;</span><br><span class="line">   var _form &#x3D; _formKey.currentState;</span><br><span class="line"></span><br><span class="line">   if (_form.validate()) &#123;</span><br><span class="line">     _form.save();</span><br><span class="line">     print(_name);</span><br><span class="line">     print(_password);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对于表单对象来说,其有一些非常实用的方法比如: <code>reset</code> 重置表单内容 <code>validate</code>, 调用<code>TextFormField</code>的<code>validator</code>方法 <code>save</code>, 表单保存。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main() &#x3D;&gt; runApp(new HomePage());</span><br><span class="line"></span><br><span class="line">class HomePage extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _HomePageState createState() &#x3D;&gt; new _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _HomePageState extends State&lt;HomePage&gt; &#123;</span><br><span class="line">  GlobalKey&lt;FormState&gt; _formKey &#x3D; new GlobalKey&lt;FormState&gt;();</span><br><span class="line"></span><br><span class="line">  String _name;</span><br><span class="line"></span><br><span class="line">  String _password;</span><br><span class="line"></span><br><span class="line">  void _forSubmitted() &#123;</span><br><span class="line">    var _form &#x3D; _formKey.currentState;</span><br><span class="line"></span><br><span class="line">    if (_form.validate()) &#123;</span><br><span class="line">      _form.save();</span><br><span class="line">      print(_name);</span><br><span class="line">      print(_password);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: implement build</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      title: &#39;Flutter data&#39;,</span><br><span class="line">      home: new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(&#39;Flutter Form&#39;),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: new FloatingActionButton(</span><br><span class="line">          onPressed: _forSubmitted,</span><br><span class="line">          child: new Text(&#39;提交&#39;),</span><br><span class="line">        ),</span><br><span class="line">        body: new Container(</span><br><span class="line">          padding: const EdgeInsets.all(16.0),</span><br><span class="line">          child: new Form(</span><br><span class="line">            key: _formKey,</span><br><span class="line">            child: new Column(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                new TextFormField(</span><br><span class="line">                  decoration: new InputDecoration(</span><br><span class="line">                    labelText: &#39;Your Name&#39;,</span><br><span class="line">                  ),</span><br><span class="line">                  onSaved: (val) &#123;</span><br><span class="line">                    _name &#x3D; val;</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">                new TextFormField(</span><br><span class="line">                  decoration: new InputDecoration(</span><br><span class="line">                    labelText: &#39;Password&#39;,</span><br><span class="line">                  ),</span><br><span class="line">                  obscureText: true,</span><br><span class="line">                  validator: (val) &#123;</span><br><span class="line">                    return val.length &lt; 4 ? &quot;密码长度错误&quot; : null;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  onSaved: (val) &#123;</span><br><span class="line">                    _password &#x3D; val;</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中计算两个日期间隔多少天</title>
      <link href="p/ed06.html"/>
      <url>p/ed06.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String dbtime1 &#x3D; &quot;2017-02-23&quot;;  &#x2F;&#x2F;第二个日期</span><br><span class="line">String dbtime2 &#x3D; &quot;2017-02-22&quot;;  &#x2F;&#x2F;第一个日期</span><br><span class="line">&#x2F;&#x2F;算两个日期间隔多少天</span><br><span class="line">SimpleDateFormat format &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">Date date1 &#x3D; format.parse(dbtime1);</span><br><span class="line">Date date2 &#x3D; format.parse(dbtime2);</span><br><span class="line"></span><br><span class="line">int a &#x3D; (int) ((date1.getTime() - date2.getTime()) &#x2F; (1000*3600*24));</span><br></pre></td></tr></table></figure><p>直接通过计算两个日期的毫秒数，他们的差除以一天的毫秒数，即可得到想要的两个日期相差的天数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并查集的实现</title>
      <link href="p/f25e.html"/>
      <url>p/f25e.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>其实并查集顾名思义就是有“合并集合”和“查找集合中的元素”两种操作的关于数据结构的一种算法。</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><ol><li>维护无向图的连通性。支持判断两个点是否在同一连通块内。</li><li>判断增加一条边是否会产生环：用在求解最小生成树的Kruskal算法里。</li></ol><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>并查集主要就三个操作：初始化、合并、查找</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>一般来说，并查集的初始化用数组即可，例如数组Tree[i]，i表示某节点，tree[i]表示当前节点的根节点</p><h2 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h2><p>这里的查找和java集合类List中的查找函数get()并不一样，他的作用是查找该节点的根节点，如果集合的parent等于集合的编号（即还没有被合并或者没有同类），那么自然返回自身编号。如果不同那么就可以调用递归函数。<br>代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 并查集查找根节点</span><br><span class="line">static int findRoot(int x, int[] arr) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果集合i的父亲是自己，说明自己就是源头，返回自己的标号</span><br><span class="line">    if (arr[x] &#x3D;&#x3D; -1)</span><br><span class="line">        return x;</span><br><span class="line">    else &#x2F;&#x2F; 否则查找集合i的父亲的源头</span><br><span class="line">        return findRoot(arr[x], arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若需要在查找过程中添加路径压缩的优化，我们修改上面这个函数为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 并查集查找根节点（优化算法,本质是将路径压缩了）</span><br><span class="line">static int findRootUseful(int x, int[] arr) &#123;</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    if (arr[x] &#x3D;&#x3D; -1)</span><br><span class="line">        return x;</span><br><span class="line">    else &#123;</span><br><span class="line">        res &#x3D; findRoot(arr[x], arr);</span><br><span class="line">        arr[x] &#x3D; res; &#x2F;&#x2F; 将当前结点的双亲结点设置为查找返回的根结点编号</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p><img src="https://upload-images.jianshu.io/upload_images/5666077-bf7f1c732d0528bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>上面的图片就是关于合并的解法，至于怎么合并就是要看题目的要求了，详见代码示例中的注释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;set1表示x所在的集合，set2表示y所在的集合</span><br><span class="line">&#x2F;&#x2F; 合并两个集合,至于按照什么原则合并就要按照题目意思了，在这里我定义了两个变量，用以比较set1和set2的某种属性之间的差异</span><br><span class="line">&#x2F;&#x2F;如果rankX&gt;rankY,就需要把y的集合合并到x的根节点下，也就是set2[y]&#x3D;x，否则就是将x的集合放到y的根节点下，即set1[x]&#x3D;y</span><br><span class="line">static int rankX &#x3D; 0;</span><br><span class="line">static int rankY &#x3D; 1;</span><br><span class="line">static void union(int x, int y, int[] set1, int[] set2) &#123;</span><br><span class="line">    x &#x3D; findRootUseful(x, set1);</span><br><span class="line">    y &#x3D; findRootUseful(y, set2);</span><br><span class="line">    if (x &#x3D;&#x3D; y)</span><br><span class="line">        return;</span><br><span class="line">    else if (rankX &gt; rankY) &#123;</span><br><span class="line">        set2[y] &#x3D; x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (rankX &#x3D;&#x3D; rankY)</span><br><span class="line">            rankY++;</span><br><span class="line">        set1[x] &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter数据存储之shared_preferences</title>
      <link href="p/ab06.html"/>
      <url>p/ab06.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpyubj8u2j30yd0u0n2f.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做过android开发的人都知道，可以利用SharedPreferences这个轻量级的存储类来保存键值对信息，在Flutter中，我们可以使用<a href="https://pub.dartlang.org/packages/shared_preferences">shared_preferences库</a>来同时支持Android和ios平台。</p><p>参考：</p><ol><li><p><a href="http://flutter.link/2018/04/13/Flutter%E4%B8%AD%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/">《Flutter中的本地存储》</a></p></li><li><p><a href="https://www.jianshu.com/p/7795958d052d">《Flutter知识点:数据存储之SharedPreferences》</a></p></li><li><p><a href="https://pub.dartlang.org/packages/shared_preferences#-example-tab-">shared_preferences 0.4.2</a></p></li></ol><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><ol><li>在<code>pubspec.yaml</code>文件中添加依赖<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shared_preferences: &quot;^0.4.2&quot;</span><br></pre></td></tr></table></figure>添加的位置如图所示：</li></ol><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5666077-41887c5b6a9ae830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加依赖"></p><ol start="2"><li><p>安装依赖库<br>执行<code>$ flutter packages get</code>命令</p></li><li><p>在相应文件中导入该库</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;package:shared_preferences&#x2F;shared_preferences.dart&#39;;</span><br></pre></td></tr></table></figure><ol start="4"><li>增删改查<br>增：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SharedPreferences prefs &#x3D; await SharedPreferences.getInstance();</span><br><span class="line">prefs.setString(key, value)</span><br><span class="line">prefs.setBool(key, value)</span><br><span class="line">prefs.setDouble(key, value)</span><br><span class="line">prefs.setInt(key, value)</span><br><span class="line">prefs.setStringList(key, value)</span><br></pre></td></tr></table></figure>其中key就是你存贮的名称，value就是你存储的值<br>删：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SharedPreferences prefs &#x3D; await SharedPreferences.getInstance();</span><br><span class="line">prefs.remove(key); &#x2F;&#x2F;删除指定键</span><br><span class="line">prefs.clear();&#x2F;&#x2F;清空键值对</span><br></pre></td></tr></table></figure>改：<blockquote><p>改和增是一样的，只需要再执行一次setXXX()方法即可覆盖之前的数据。</p></blockquote></li></ol><p>查：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-43cacaf2da288ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询操作的几个API"></p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p><img src="https://upload-images.jianshu.io/upload_images/5666077-4dcb0da66b178643.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>首先我们创建了一个TextField用来获取用户输入，然后我们再下面定义看了连个按钮，每当当即存储按钮都会触发save() 方法，每当点击获取按钮都会触发get()方法。<br>先来看看save()方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save() async&#123;</span><br><span class="line">    SharedPreferences prefs &#x3D; await SharedPreferences.getInstance();</span><br><span class="line">    prefs.setString(mUserName, _userNameController.value.text.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面save方法中我们可以看到我们给它加上了async和await关键字，因为SharedPreferences的存贮也是一个轻量级的耗时操作，所以我们也是需要在异步中进行的。<br>我们使用SharedPreferences.getInstance()方法来实例化SharedPreferences对象，使用它的setString方法来存储用户输入的字符串。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setString(key, value)</span><br></pre></td></tr></table></figure><p>接下来来看下<code>get</code>方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Future&lt;String&gt; get() async &#123;</span><br><span class="line">  var userName;</span><br><span class="line">    SharedPreferences prefs &#x3D; await SharedPreferences.getInstance();</span><br><span class="line">    userName &#x3D; await prefs.getString(mUserName);</span><br><span class="line">  return userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>get</code>方法中我们同样实例化了一个SharedPreferences对象，并且调用SharedPreferences的getString方法来获取我们存入的对象。<br><code>getString(key)</code>中key就是我们刚才存入的值，我们通过这个值可以在本地查找到我们存入的对象并返回。<br>同样的，<code>get</code>方法也是耗时操作，同样需要异步执行，我们使用<code>async</code>和<code>await</code>来使得get方法异步并返回了一个泛型为String的<code>Future</code>对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Future&lt;String&gt; userName &#x3D; get();</span><br><span class="line">                         userName.then((String userName) &#123;</span><br><span class="line">                           Scaffold.of(context).showSnackBar(</span><br><span class="line">                                SnackBar(content: Text(&quot;数据获取成功：$userName&quot;)));</span><br><span class="line">                         &#125;);</span><br></pre></td></tr></table></figure><p>我们使用获得的<code>Future</code>对象调用<code>then()</code>方法，当get方法执行完后就会自动触发then()方法里面的操作弹出showSnackBar。<br>下面给出完整代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;dart:async&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line">import &#39;package:shared_preferences&#x2F;shared_preferences.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(new MaterialApp(home: new MyApp()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  final String mUserName &#x3D; &quot;userName&quot;;</span><br><span class="line">  final _userNameController &#x3D; new TextEditingController();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    save() async&#123;</span><br><span class="line">        SharedPreferences prefs &#x3D; await SharedPreferences.getInstance();</span><br><span class="line">        prefs.setString(mUserName, _userNameController.value.text.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Future&lt;String&gt; get() async &#123;</span><br><span class="line">      var userName;</span><br><span class="line"></span><br><span class="line">        SharedPreferences prefs &#x3D; await SharedPreferences.getInstance();</span><br><span class="line">         userName &#x3D; prefs.getString(mUserName);</span><br><span class="line">      return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new Builder(builder: (BuildContext context) &#123;</span><br><span class="line">      return new Scaffold(</span><br><span class="line">        appBar:  AppBar(</span><br><span class="line">          title:  Text(&quot;SharedPreferences&quot;),</span><br><span class="line">        ),</span><br><span class="line">        body:  Center(</span><br><span class="line">          child: new Builder(builder: (BuildContext context)&#123;</span><br><span class="line">            return</span><br><span class="line">                Column(</span><br><span class="line">                  children: &lt;Widget&gt;[</span><br><span class="line">                     TextField(</span><br><span class="line">                      controller: _userNameController,</span><br><span class="line">                      decoration:  InputDecoration(</span><br><span class="line">                          contentPadding: const EdgeInsets.only(top: 10.0),</span><br><span class="line">                          icon:  Icon(Icons.perm_identity),</span><br><span class="line">                          labelText: &quot;请输入用户名&quot;,</span><br><span class="line">                          helperText: &quot;注册时填写的名字&quot;),</span><br><span class="line">                    ),</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                        color: Colors.blueAccent,</span><br><span class="line">                        child: Text(&quot;存储&quot;),</span><br><span class="line">                        onPressed: () &#123;</span><br><span class="line">                          save();</span><br><span class="line">                          Scaffold.of(context).showSnackBar(</span><br><span class="line">                              new SnackBar(content:  Text(&quot;数据存储成功&quot;)));</span><br><span class="line">                        &#125;),</span><br><span class="line">                    RaisedButton(</span><br><span class="line">                        color: Colors.greenAccent,</span><br><span class="line">                        child: Text(&quot;获取&quot;),</span><br><span class="line">                        onPressed: () &#123;</span><br><span class="line">                          Future&lt;String&gt; userName &#x3D; get();</span><br><span class="line">                          userName.then((String userName) &#123;</span><br><span class="line">                            Scaffold.of(context).showSnackBar(</span><br><span class="line">                                 SnackBar(content: Text(&quot;数据获取成功：$userName&quot;)));</span><br><span class="line">                          &#125;);</span><br><span class="line">                        &#125;),</span><br><span class="line">                  ],</span><br><span class="line">                );</span><br><span class="line">          &#125;),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="键值对文件存放路径"><a href="#键值对文件存放路径" class="headerlink" title="键值对文件存放路径"></a>键值对文件存放路径</h2><p><img src="https://upload-images.jianshu.io/upload_images/5666077-c633cc6b28dab58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络(CNN)的相关概念</title>
      <link href="p/6ff8.html"/>
      <url>p/6ff8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzpytupuhoj30xa0d04dz.jpg"></p><h2 id="传统神经网络存在的问题"><a href="#传统神经网络存在的问题" class="headerlink" title="传统神经网络存在的问题"></a>传统神经网络存在的问题</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fycb7xeo3hj30lz0asn4a.jpg" alt="传统神经网络"></p><p>说卷积神经网络前，我们要先说一下传统神经网络存在的一些问题，上图是一个典型的传统神经网络的示例图。设想一个场景，假设我们要训练的的样本图片是100x100（像素）的，那么整张图片总共就是有10000个像素，那么在定义一个 传统神经网络的时候，输入层(input layer)就需要有1w个神经元，那么如果我们的中间的隐藏层(hidden layer)也需要有1w个神经元，那么总共需要的参数（权值）就高达1亿个（1w*1w），试想一下，这还只是一张100x100的图片就需要这么多的参数，如果图片更大之后呢，可想而知整个神经网络的计算量有多恐怖。当然，一旦权重多了之后，则必须要有足够量的样本进行训练，否则就会出现<a href="https://yueyong.info/p/f2b.html">过拟合</a>的现象。因此我们可以知道，传统神经网络有以下两个问题：</p><ul><li>权值太多，计算量太大</li><li>权值太多，如果没有大量样本支撑则会出现过拟合现象</li></ul><a id="more"></a><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><h4 id="什么是卷积？"><a href="#什么是卷积？" class="headerlink" title="什么是卷积？"></a>什么是卷积？</h4><p>在了解卷积神经网络之前我们需要知道什么是卷积。对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做内积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。非严格意义上来讲，下图中红框框起来的部分便可以理解为一个滤波器(filter)，即带着一组固定权重的神经元。多个滤波器叠加便成了卷积层。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fycciisv4oj30co06xt9q.jpg" alt="滤波器"></p><p>举个具体的例子。比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter，图中右边是输出的新的二维数据。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyccjacwonj30g70csafb.jpg"></p><p> 分解下上图</p><blockquote><p> <img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fycckt9eo4j302602ut8u.jpg">对应位置上是数字先相乘后相加<img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyccld8qxbj302a02e0st.jpg"> = <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fycclulpizj301f017744.jpg"></p></blockquote><p>中间滤波器filter与数据窗口做内积，其具体计算过程则是：4x0 + 0x0 + 0x0 + 0x0 + 0x1 + 0x1 + 0x0 + 0x1 + -4x2 = -8</p><h4 id="图像上的卷积"><a href="#图像上的卷积" class="headerlink" title="图像上的卷积"></a>图像上的卷积</h4><p>在下图对应的计算过程中，输入是一定区域大小(width*height)的数据，和滤波器filter（带着一组固定权重的神经元）做内积后等到新的二维数据。</p><p>如下图所示:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyccslh0vpj30hv0b1wq3.jpg"></p><p>具体来说，左边是图像输入，中间部分就是滤波器filter（带着一组固定权重的神经元），不同的滤波器filter会得到不同的输出数据，比如颜色深浅、轮廓。相当于如果想提取图像的不同特征，则用不同的滤波器filter，提取想要的关于图像的特定信息：颜色深浅或轮廓。用一句话解释不同滤波器之间的差异就是：<strong>一千个读者就有一千个哈姆雷特</strong></p><h3 id="什么是卷积神经网络？"><a href="#什么是卷积神经网络？" class="headerlink" title="什么是卷积神经网络？"></a>什么是卷积神经网络？</h3><p><strong>卷积神经网络（Convolutional Neural Network, CNN）</strong>是一种<a href="https://baike.baidu.com/item/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">前馈神经网络</a>，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。卷积神经网络与普通神经网络非常相似，它们都由具有可学习的权重和偏置常量(biases)的神经元组成。每个神经元都接收一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧到这里依旧适用。但是卷积神经网络默认输入是图像，可以让我们把特定的性质编码入网络结构，使是我们的前馈函数更加有效率，并减少了大量参数。</p><p>**具有三维体积的神经元(3D volumes of neurons) **</p><p>卷积神经网络利用输入是图片的特点，把神经元设计成三个维度 ： width, height, depth(注意这个depth不是神经网络的深度，而是用来描述神经元的) 。比如输入的图片大小是 32 × 32 × 3 (rgb)，那么输入神经元就也具有 32×32×3 的维度。下面是图解：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fycc4hdvwtj30ft05mjtk.jpg" alt="卷积神经网络"></p><p><strong>一个卷积神经网络各层应用实例</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fycc6knv4qj30yv0gph1j.jpg" alt="一个卷积神经网络各层应用实例"></p><p>上图中CNN要做的事情是：给定一张图片，是车还是马未知，是什么车也未知，现在需要模型判断这张图片里具体是一个什么东西，总之输出一个结果：如果是车 那是什么车。</p><p>我们按照从左到右的方向来理一下：</p><p><strong>左边：</strong></p><ul><li>最左边是数据输入层，对数据做一些处理，比如去均值（把输入数据各个维度都中心化为0，避免数据过多偏差，影响训练效果）、归一化（把所有的数据都归一到同样的范围）、PCA/白化等等。CNN只对训练集做“去均值”这一步。</li></ul><p><strong>中间：</strong></p><ul><li>CONV：卷积计算层，线性乘积求和。</li><li>RELU：激励层，ReLU是激活函数的一种。</li><li>POOL：池化层，简言之，即取区域平均或最大。</li></ul><p><strong>右边：</strong></p><ul><li>FC：全连接层</li></ul><h3 id="卷积神经网络-CNN-中的局部感知和权重共享"><a href="#卷积神经网络-CNN-中的局部感知和权重共享" class="headerlink" title="卷积神经网络(CNN)中的局部感知和权重共享"></a>卷积神经网络(CNN)中的局部感知和权重共享</h3><h4 id="CNN中的局部感知"><a href="#CNN中的局部感知" class="headerlink" title="CNN中的局部感知"></a>CNN中的局部感知</h4><p>在CNN中，滤波器filter（带着一组固定权重的神经元）对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数： </p><ul><li>深度depth：神经元个数，决定输出的depth厚度。同时代表滤波器个数。</li><li>步长stride：决定滑动多少步可以到边缘。</li><li>填充值zero-padding：在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑倒末尾位置，通俗地讲就是为了总长能被步长整除。</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyccnqr48wj31ts0jcgw1.jpg" alt="CNN中的局部感知"></p><p>上图就是一个典型的局部感知的示例图。其中黄色部分的矩阵为滤波器，深度为1，步长为1，填充值为0。很明显我们可以看出，每次滤波器都是针对某一局部的数据窗口进行卷积，这就是所谓的CNN中的局部感知机制。</p><p>那为什么要局部感知呢？</p><blockquote><p>打个比方，滤波器就像一双眼睛，人类视角有限，一眼望去，只能看到这世界的局部。如果一眼就看到全世界，你会累死，而且一下子接受全世界所有信息，你大脑接收不过来。当然，即便是看局部，针对局部里的信息人类双眼也是有偏重、偏好的。比如看美女，对脸、胸、腿是重点关注，所以这3个输入的权重相对较大。</p></blockquote><h4 id="CNN中的权重共享"><a href="#CNN中的权重共享" class="headerlink" title="CNN中的权重共享"></a>CNN中的权重共享</h4><p>那么权重共享又是什么呢？还是拿上图举例，滤波器在滑动的过程中，输入在变化，但中间滤波器(filter)的权重（即每个神经元连接数据窗口的权重）是固定不变的，这个权重不变即所谓的CNN中的<strong>权重（参数）共享</strong>机制。</p><blockquote><p>再打个比方，某人环游全世界，所看到的信息在变，但采集信息的双眼不变。btw，不同人的双眼看同一个局部信息所感受到的不同，即一千个读者有一千个哈姆雷特，所以不同的滤波器就像不同的双眼，不同的人有着不同的反馈结果。</p></blockquote><h4 id="用一张动图诠释局部感知和权重共享"><a href="#用一张动图诠释局部感知和权重共享" class="headerlink" title="用一张动图诠释局部感知和权重共享"></a>用一张动图诠释局部感知和权重共享</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fycddeiqy0g30nw0j6dxg.gif" alt="一张动图诠释局部感知和权重共享"></p><p>我在搜集资料的过程中发现了这张图，第一感觉非常的酷，如果理解了局部感知和权重共享那这张图就不难看懂了。</p><p>相信你也会有一个疑问，上图中的输出结果1具体是怎么计算得到的呢？接下来我们来分解下上述动图，详细解释下计算过程。</p><p>首先是第一张：</p><p> <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyce0ouqozj30k00gyjsi.jpg"></p><p>其实，计算过程类似wx + b，w对应滤波器Filter w0，x对应不同的数据窗口，b对应Bias b0，相当于滤波器Filter w0与一个个数据窗口相乘再求和后，最后加上Bias b0得到输出结果1，如下过程所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyce3ib6w4j304g02m0su.jpg"></p><blockquote><p>1x0 + 1x0 + -1x0 + -1x0 + 0x0 + 1x1+-1x0 + -1x0 + 0x1</p></blockquote><p>+</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyce5s0fpxj304i02lgls.jpg"></p><blockquote><p>-1x0 + 0x0 + -1x0 + 0x0 + 0x1 + -1x1 + 1x0 + -1x0 + 0x2</p></blockquote><p>+</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyce6vor5tj304h02j3yp.jpg"></p><blockquote><p>0x0 + 1x0 + 0x0 + 1x0 + 0x2 + 1x0 + 0x0 + -1x0 + 1x0</p></blockquote><p>+</p><p>1(这里的1就是Bias b0)</p><p>=</p><p>1</p><p>然后滤波器Filter w0固定不变，数据窗口向右移动2步，继续做内积计算，得到0的输出结果</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyceb9k7udj30k00h83zk.jpg"></p><p>最后，换做另外一个不同的滤波器Filter w1、不同的偏置Bias b1，再跟图中最左边的数据窗口做卷积，可得到另外一个不同的输出。<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fycec0ulgnj30k00gyabb.jpg"></p><h3 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h3><p>池化，简言之，即取区域平均或最大，其目的是为了减少特征图。池化操作对每个深度切片独立，规模一般为 2＊2，相对于卷积层进行卷积运算，池化层进行的运算一般有以下几种： </p><ul><li>最大池化（Max Pooling）。取4个点的最大值。这是最常用的池化方法。 </li><li>均值池化（Mean Pooling）。取4个点的均值。 </li><li>高斯池化。借鉴高斯模糊的方法。不常用。 </li><li>可训练池化。训练函数 ff ，接受4个点为输入，出入1个点。不常用。</li></ul><p>最常见的池化层是规模为2*2， 步幅为2，对输入的每个深度切片进行下采样。每个MAX操作对四个数进行，如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fycee4nqg4j30lv0a80th.jpg">上图所展示的是取区域最大，即上图左边部分中 左上角2x2的矩阵中6最大，右上角2x2的矩阵中8最大，左下角2x2的矩阵中3最大，右下角2x2的矩阵中4最大，所以得到上图右边部分的结果：6 8 3 4。均值池化类似。</p><ul><li><p>池化操作将保存<strong>深度大小不变</strong>。</p></li><li><p>如果池化层的输入单元大小不是二的整数倍，一般采取边缘补零（zero-padding）的方式补成2的倍数，然后再池化。</p></li></ul><h3 id="全连接层（Fully-connected-layer）"><a href="#全连接层（Fully-connected-layer）" class="headerlink" title="全连接层（Fully-connected layer）"></a>全连接层（Fully-connected layer）</h3><p>全连接层和卷积层可以相互转换： </p><ul><li>对于任意一个卷积层，要把它变成全连接层只需要把权重变成一个巨大的矩阵，其中大部分都是0 除了一些特定区块（因为局部感知），而且好多区块的权值还相同（由于权重共享）。 </li><li>相反地，对于任何一个全连接层也可以变为卷积层。比如，一个$K＝4096$ 的全连接层，输入层大小为 $7∗7∗512$，它可以等效为一个$ F=7, P=0, S=1, K=4096$的卷积层。换言之，我们把 filter size 正好设置为整个输入层大小。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://blog.csdn.net/v_JULY_v/article/details/51812459">CNN笔记：通俗理解卷积神经网络</a></p></li><li><p><a href="http://cs231n.github.io/convolutional-networks/">CS231n: Convolutional Neural Networks for Visual Recognition</a> </p></li><li><p><a href="https://www.wikiwand.com/zh-hans/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">卷积神经网络-维基百科</a> </p></li><li><p><a href="http://deeplearning.stanford.edu/wiki/index.php/%E5%8D%B7%E7%A7%AF%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96">卷积特征提取</a> </p></li><li><p><a href="http://www.moonshile.com/post/juan-ji-shen-jing-wang-luo-quan-mian-jie-xi">卷积神经网络全面解析</a></p></li><li><p><a href="http://52opencourse.com/139/coursera%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AB%E8%AF%BE-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%A1%A8%E7%A4%BA-neural-networks-representation">斯坦福机器学习公开课</a></p></li><li><p><a href="https://www.zhihu.com/question/22298352">理解卷积</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卷积神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的排序</title>
      <link href="p/bd3d.html"/>
      <url>p/bd3d.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap 在 Java 里面是一种非常实用的工具，他清楚明白的反映了<strong>“键-值”</strong>之间的关系，HashMap 本身是无序的，但是 HashMap 的排序却是一个比较常见的问题，这里针对 HashMap 的两种排序方式做了笔记。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map1 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map1.put(3, &quot;三&quot;);</span><br><span class="line">        map1.put(6, &quot;六&quot;);</span><br><span class="line">        map1.put(1, &quot;一&quot;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map2 &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map2.put(&quot;三&quot;, 3);</span><br><span class="line">        map2.put(&quot;一&quot;, 1);</span><br><span class="line">        map2.put(&quot;六&quot;, 6);</span><br><span class="line"></span><br><span class="line">        sortByKey(map1);</span><br><span class="line">        sortByValue(map2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 按照键排序</span><br><span class="line">    static void sortByKey(Map map) &#123;</span><br><span class="line">        Object[] objects &#x3D; map.keySet().toArray();</span><br><span class="line">        Arrays.sort(objects);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; objects.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;键：&quot; + objects[i] + &quot; 值：&quot; + map.get(objects[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 按照值排序</span><br><span class="line">    static void sortByValue(Map map) &#123;</span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; list &#x3D; new ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line">        Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2) &#123;</span><br><span class="line">                return o1.getValue().compareTo(o2.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (Map.Entry&lt;String, Integer&gt; mapping : list) &#123;</span><br><span class="line">            System.out.println(&quot;键：&quot; + mapping.getKey() + &quot; 值：&quot; + mapping.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow笔记5-—优化手写数字识别模型之优化器</title>
      <link href="p/5de1.html"/>
      <url>p/5de1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzpyp94c3uj30fv08ajwt.jpg"></p><h2 id="什么是优化器（Optimizer）"><a href="#什么是优化器（Optimizer）" class="headerlink" title="什么是优化器（Optimizer）"></a>什么是优化器（Optimizer）</h2><p>神经网络越复杂 , 数据量越大 , 我们需要在训练神经网络的过程上花费的时间也就越多. 原因很简单, 就是因为计算量太大了. 可是往往有时候为了解决复杂的问题, 复杂的结构和大数据又是不能避免的, 所以我们需要寻找一些方法, 让神经网络聪明起来, 快起来。那些可以加速神经网络训练的方法就叫做优化器（Optimizer）<br>推荐阅读：<a href="https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-06-speed-up-learning/">加速神经网络训练 (Speed Up Training)</a></p><h2 id="常见的优化器"><a href="#常见的优化器" class="headerlink" title="常见的优化器"></a>常见的优化器</h2><p>这个部分的理论知识实在太多了，我简单的整理了一点点，详见<a href="https://blog.csdn.net/weixin_40170902/article/details/80092628">机器学习：各种优化器Optimizer的总结与比较</a><br>下面是TensorFlow中提供的相关优化器的API </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.train.GradientDescentOptimizer</span><br><span class="line">tf.train.AdadeltaOptimizer</span><br><span class="line">tf.train.AdagradOptimizer</span><br><span class="line">tf.train.AdagradDAOptimizer</span><br><span class="line">tf.train.MomentumOptimizer</span><br><span class="line">tf.train.AdamOptimizer</span><br><span class="line">tf.train.FtrlOptimizer</span><br><span class="line">tf.train.ProximalGradientDescentOptimizer</span><br><span class="line">tf.train.ProximalAdagradOptimizer</span><br><span class="line">tf.train.RMSPropOptimizer</span><br></pre></td></tr></table></figure><h2 id="可视化比较几个优化器"><a href="#可视化比较几个优化器" class="headerlink" title="可视化比较几个优化器"></a>可视化比较几个优化器</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><img src="http://upload-images.jianshu.io/upload_images/5666077-7cc1ac2441d86da6?imageMogr2/auto-orient/strip" alt="image"><br>上图比较了6种优化器收敛到目标点（五角星）的运行过程，从图中可以大致看出：<br>① 在运行速度方面</p><ul><li>两个动量优化器Momentum和NAG的速度最快，其次是三个自适应学习率优化器AdaGrad、AdaDelta以及RMSProp，最慢的则是SGD。</li></ul><p>② 在收敛轨迹方面</p><ul><li>两个动量优化器虽然运行速度很快，但是初中期走了很长的”岔路”。</li><li>三个自适应优化器中，Adagrad初期走了岔路，但后来迅速地调整了过来，但相比其他两个走的路最长；AdaDelta和RMSprop的运行轨迹差不多，但在快接近目标的时候，RMSProp会发生很明显的抖动。</li><li>SGD相比于其他优化器，走的路径是最短的，路子也比较正。<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><img src="http://upload-images.jianshu.io/upload_images/5666077-aa696a9244e75ab6?imageMogr2/auto-orient/strip" alt="image"><br>上图在一个存在鞍点的曲面，比较6中优化器的性能表现，从图中大致可以看出：</li><li>三个自适应学习率优化器没有进入鞍点，其中，AdaDelta下降速度最快，Adagrad和RMSprop则齐头并进。</li><li>两个动量优化器Momentum和NAG以及SGD都顺势进入了鞍点。但两个动量优化器在鞍点抖动了一会，就逃离了鞍点并迅速地下降，后来居上超过了Adagrad和RMSProp。</li><li>很遗憾，SGD进入了鞍点，却始终停留在了鞍点，没有再继续下降。<h2 id="如何挑选合适的优化器"><a href="#如何挑选合适的优化器" class="headerlink" title="如何挑选合适的优化器"></a>如何挑选合适的优化器</h2>其实从上述的两个可视化的例子中我们就可以看到SGD的速度应该是最慢的，但是这并不影响他是我们在实际使用中用到的最多的优化器。毕竟在实际使用中速度并不是唯一决定因素，准确率才是。 所以说：</li></ul><ol><li>在研究调试我们的神经网络时我们可以使用一些比较快的优化器，例如：Adagrad、RMSProp等</li><li>研究的差不多了，模型也搭建好了，此时如果你需要有准确的结果用来发论文等，这时候最好把每一个优化器都使用一遍，因为你也不知道究竟哪个优化器最终得到的结果是最好的，最适合你的网络。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow笔记4——优化手写数字识别模型之代价函数和拟合</title>
      <link href="p/f2b.html"/>
      <url>p/f2b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzpyou7yauj30fq0953yn.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇笔记我们利用MNIST数据集训练了一个手写数字识别的模型，但是准确率非常的低，维持在91%左右，我们可以尝试着将准确率提高到96%以上，在实验之前我们需要先了解一些基本的概念，本篇文章可能会有些枯燥，因为大多都是理论知识。</p><h2 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h2><ol><li>激活函数</li><li>代价函数</li><li>拟合</li></ol><h2 id="什么是激活函数？激活函数是干嘛的？"><a href="#什么是激活函数？激活函数是干嘛的？" class="headerlink" title="什么是激活函数？激活函数是干嘛的？"></a>什么是激活函数？激活函数是干嘛的？</h2><p>想了解什么是激活函数，就要先了解神经网络的基本模型，下图所示为一单一人工神经网络的基本模型图：</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5666077-65289f21d1d9dd9e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单一人工神经网络的基本模型图"></p><p>神经网络中的每个神经元节点接受上一层神经元的输出值作为本神经元的输入值，并将输入值传递给下一层，输入层神经元节点会将输入属性值直接传递给下一层（隐藏层或输出层）。在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数（又称激励函数）。</p><p>如果我们不运用激活函数的话，则输出信号将仅仅是一个简单的线性函数。线性函数一个一级多项式。现如今，线性方程是很容易解决的，但是它们的复杂性有限，并且从数据中学习复杂函数映射的能力更小。一个没有激活函数的神经网络将只不过是一个线性回归模型（Linear regression Model）罢了，它功率有限，并且大多数情况下执行得并不好。我们希望我们的神经网络不仅仅可以学习和计算线性函数，而且还要比这复杂得多。同样是因为没有激活函数，我们的神经网络将无法学习和模拟其他复杂类型的数据，例如图像、视频、音频、语音等。这就是为什么我们要使用人工神经网络技术，诸如深度学习（Deep learning），来理解一些复杂的事情，一些相互之间具有很多隐藏层的非线性问题，而这也可以帮助我们了解复杂的数据。</p><h3 id="那么为什么我们需要非线性函数？"><a href="#那么为什么我们需要非线性函数？" class="headerlink" title="那么为什么我们需要非线性函数？"></a>那么为什么我们需要非线性函数？</h3><p>非线性函数是那些一级以上的函数，而且当绘制非线性函数时它们具有曲率。现在我们需要一个可以学习和表示几乎任何东西的神经网络模型，以及可以将输入映射到输出的任意复杂函数。神经网络被认为是通用函数近似器（Universal Function Approximators）。这意味着他们可以计算和学习任何函数。几乎我们可以想到的任何过程都可以表示为神经网络中的函数计算。</p><p>而这一切都归结于这一点，我们需要应用激活函数f（x），以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。因此，使用非线性激活函数，我们便能够从输入输出之间生成非线性映射。</p><p>激活函数的另一个重要特征是：它应该是可以区分的。我们需要这样做，以便在网络中向后推进以计算相对于权重的误差（丢失）梯度时执行反向优化策略，然后相应地使用梯度下降或任何其他优化技术优化权重以减少误差。 </p><h2 id="二次代价函数"><a href="#二次代价函数" class="headerlink" title="二次代价函数"></a>二次代价函数</h2><p>二次代价函数的公式如下：<br>$$C=\frac{1}{2n}\sum_{x}^{ }\left | y(x)-{a}^L(x) \right |^2$$</p><p>其中，C表示代价，x表示样本，y表示实际值，a表示输出值，n表示样本的总数。为简单起见，以一个样本为例进行说明，此时二次代价函数为：<br>$$C=\frac{(y-a)^2}{2}$$<br>其中$a=\delta (z),z=\sum W_j*X_j+b$，$\delta (z)$是激活函数</p><p>加入我们使用梯度下降法来调整权值参数的大小，权值w和偏置b的梯度推导如下：<br>$$\frac{\partial C}{\partial w}=(a-y)\sigma’(z)x$$<br>$$\frac{\partial C}{\partial b}=(a-y)\sigma’(z)$$<br>其中，z表示神经元的输入，$\sigma $表示激活函数。从以上公式可以看出，w和b的梯度跟激活函数的梯度成正比，激活函数的梯度越大，$w$和$b$的大小调整得越快，训练收敛得就越快。而神经网络常用的激活函数为<strong>sigmoid函数</strong>，该函数的曲线如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-5691538045d5fa89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500"></p><p>所以在这种情况下，权值和偏置的变化就会出现如下异常：</p><blockquote><p>假设我们目标是收敛到 1。A 点为 0.82 离目标比较远，梯度比较大，权值调整比较大。B 点为 0.98 离目标比较近，梯度比较小，权值调整比较小。调整方案合理。<br>假如我们目标是收敛到 0. A 点为 0.82 离目标比较近，梯度比较大，权值调整比较大。B 点为 0.98 离目标比较远，梯度比较小，权值调整比较小。调整方案不合理。</p></blockquote><p>那么可能有人就会说，如果我们想要解决上述问题，选择一个梯度不变化或变化不明显的激活函数不就解决问题了吗？图样图森破，那样虽然简单粗暴地解决了这个问题，但可能会引起其他更多更麻烦的问题。而且，类似sigmoid这样的函数（比如tanh函数）有很多优点，非常适合用来做激活函数，具体请自行google之。</p><p>在这里我们不改变激活函数，选择将代价函数改为交叉熵代价函数。</p><h2 id="交叉熵代价函数"><a href="#交叉熵代价函数" class="headerlink" title="交叉熵代价函数"></a>交叉熵代价函数</h2><p>先放公式：$$C=-\frac{1}{n}\sum_{x}^{ }[ylna+(1-y)ln(1-a)]$$<br>其中，C表示代价，x表示样本，y表示实际值，a表示输出值，n表示样本的总数。那么，重新计算参数w的梯度：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-32a14281188687d4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中：$${\sigma }’(z)=\sigma (z)(1-\sigma (z))$$<br>因此，w的梯度公式中原来的${\sigma }’(z)$被消掉了；另外，该梯度公式中的$\sigma (z)-y$表示输出值与实际值之间的误差。所以，当误差越大，梯度就越大，参数w调整得越快，训练速度也就越快。同理可得，b的梯度为：<br>$$\frac{\partial C}{\partial b}=\frac{1}{n}\sum_{x}^{ }(\sigma (z)-y)$$<br>实际情况证明，交叉熵代价函数带来的训练效果往往比二次代价函数要好。</p><ul><li>权值和偏置值的调整与${\sigma }’(z)$无关，另外，梯度公式中的$\sigma (z)-y$表示输出值与实际值的误差。所以当误差越大时，梯度就越大，参数 w 和 b 的调整就越快，训练的速度也就越快。</li><li>如果输出神经元是线性的，那么二次代价函数就是一种合适的选择。如果输出神经元是 S 型函数，那么比较适合用交叉熵代价函数。</li></ul><h2 id="对数释然代价函数-log-likelihood-cost"><a href="#对数释然代价函数-log-likelihood-cost" class="headerlink" title="对数释然代价函数(log-likelihood cost)"></a>对数释然代价函数(log-likelihood cost)</h2><ul><li>对数释然函数常用来作为softmax回归的代价函数，然后输出层神经元是sigmoid函数，可以采用交叉熵代价函数。而深度学习中更普遍的做法是将softmax作为最后一层，此时常用的代价函数是对数释然代价函数。</li><li>对数似然代价函数与softmax的组合和交叉熵与sigmoid函数的组合非常相似。对数释然代价函数在二分类时可以化简为交叉熵代价函数的形式。<br>在tensorflow中用：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.nn.sigmoid_cross_entropy_with_logits()来表示跟sigmoid搭配使用的交叉熵。</span><br><span class="line">tf.nn.softmax_cross_entropy_with_logits()来表示跟softmax搭配使用的交叉熵。</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用TensorFlow比较两种代价函数的效果"><a href="#使用TensorFlow比较两种代价函数的效果" class="headerlink" title="使用TensorFlow比较两种代价函数的效果"></a>使用TensorFlow比较两种代价函数的效果</h2><p>以上一篇文章手写数字识别的模型为例子，在这给出采用交叉熵函数的模型的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># 4.1 交叉熵代价函数</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"></span><br><span class="line">start &#x3D; datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"># 载入数据</span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&quot;MNIST_data&quot;, one_hot&#x3D;True)</span><br><span class="line"># 每个批次的大小</span><br><span class="line">batch_size &#x3D; 50</span><br><span class="line"># 计算一共有多少个批次</span><br><span class="line">n_batch &#x3D; mnist.train.num_examples &#x2F;&#x2F; batch_size</span><br><span class="line"></span><br><span class="line"># 定义两个placeholder</span><br><span class="line">x &#x3D; tf.placeholder(tf.float32, [None, 784])</span><br><span class="line">y &#x3D; tf.placeholder(tf.float32, [None, 10])</span><br><span class="line"></span><br><span class="line"># 创建一个简单的神经网络</span><br><span class="line">W &#x3D; tf.Variable(tf.zeros([784, 10]))</span><br><span class="line">b &#x3D; tf.Variable(tf.zeros([10]))</span><br><span class="line">prediction &#x3D; tf.nn.softmax(tf.matmul(x, W)+b)</span><br><span class="line"></span><br><span class="line"># 二次代价函数</span><br><span class="line"># loss &#x3D; tf.reduce_mean(tf.square(y-prediction))</span><br><span class="line"># 交叉熵代价函数</span><br><span class="line">loss &#x3D; tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(</span><br><span class="line">    labels&#x3D;y, logits&#x3D;prediction))</span><br><span class="line"># 使用梯度下降法</span><br><span class="line">train_step &#x3D; tf.train.GradientDescentOptimizer(0.1).minimize(loss)</span><br><span class="line"></span><br><span class="line"># 初始化变量</span><br><span class="line">init &#x3D; tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"># 结果存放在一个布尔型列表中</span><br><span class="line"># argmax返回一维张量中最大的值所在的位置</span><br><span class="line">correct_prediction &#x3D; tf.equal(tf.argmax(y, 1), tf.argmax(prediction, 1))</span><br><span class="line"># 求准确率</span><br><span class="line">accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    for epoch in range(30):</span><br><span class="line">        for batch in range(n_batch):</span><br><span class="line">            batch_xs, batch_ys &#x3D; mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(train_step, feed_dict&#x3D;&#123;x: batch_xs, y: batch_ys&#125;)</span><br><span class="line">        acc &#x3D; sess.run(accuracy, feed_dict&#x3D;&#123;</span><br><span class="line">                       x: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line">        print(&quot;Iter &quot;+str(epoch)+&quot;,Testing Accuracy &quot;+str(acc))</span><br><span class="line"></span><br><span class="line">end &#x3D; datetime.datetime.now()</span><br><span class="line">print((end-start).seconds)</span><br></pre></td></tr></table></figure><p>在这里我们将二次代价函数更改为了交叉熵代价函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 二次代价函数</span><br><span class="line"># loss &#x3D; tf.reduce_mean(tf.square(y-prediction))</span><br><span class="line"># 交叉熵代价函数</span><br><span class="line">loss &#x3D; tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(</span><br><span class="line">    labels&#x3D;y, logits&#x3D;prediction))</span><br></pre></td></tr></table></figure><p>接下来我们来对比下训练的结果：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-8ddbb70e3132fdc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用二次代价函数的训练结果"><br><img src="https://upload-images.jianshu.io/upload_images/5666077-ff6e6a2dfeb8b687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用交叉熵代价函数的训练结果"></p><p>由上图可知，使用二次代价函数训练第10次的精确度为0.9063，而使用交叉熵代价函数训练到第2次的精确度就已经超过0.9了，结果显而易见。</p><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p>拟合分为三种：1.欠拟合(underfitting)；2. 正确拟合(just right)；3. 过拟合(overfitting)；如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-8f37c3a28c8477c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拟合"><br>其中每个<code>x</code>表示的是样本，每条曲线代表的是模型。<br>下图是分类问题中的拟合情况，和上述情况类似。<br><img src="https://upload-images.jianshu.io/upload_images/5666077-9fa28070b531bf8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拟合"></p><p>在这里介绍过拟合，下面是wikipedia对于overfitting的解释。<br>在统计学和机器学习中，overfitting一般在描述统计学模型随机误差或噪音时用到。它通常发生在模型过于复杂的情况下，如参数过多等。overfitting会使得模型的预测性能变弱，并且增加数据的波动性。</p><p>发生overfitting是因为评判训练模型的标准不适用于作为评判该模型好坏的标准，模型通常会增强模型在训练模型的预测性能。但是模型的性能并不是由模型在训练集的表现好坏而决定，它是由模型在未知数据集上的表现确定的。当模型开始“memorize”训练数据而不是从训练数据中“learning”时，overfitting就出现了。比如，如果模型的parameters大于或等于观测值的个数，这种模型会显得过于简单，虽然模型在训练时的效果可以表现的很完美，基本上记住了数据的全部特点，但这种模型在未知数据的表现能力会大减折扣，因为简单的模型泛化能力通常都是很弱的。<br><img src="https://upload-images.jianshu.io/upload_images/5666077-9e9cfcb022418e6d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上面这个图，是通过线性函数和多项式函数来拟合这些数据点，显然多项式函数拟合效果很完美，包含了所有的点，而线性函数丢失了大部分点。但实际上，线性函数有一个很好的泛化能力，如果用这些点来做一个回归线，多项式函数过拟合的情况更糟糕。</p><p>过拟合不仅和参数的个数以及数据有关，也和数据形状模型结构的一致性有关。</p><p>为了避免过拟合，有必要使用一些额外的技术（如交叉验证、正则化、early stopping、贝斯信息量准则、赤池信息量准则或model comparison），以指出何时会有更多训练而没有导致更好的一般化。</p><p>Overfitting的概念在机器学习中很重要。通常一个学习算法是借由训练样本来训练的，在训练时会伴随着训练误差。当把该模型用到未知数据的测试时，就会相应的带来一个validation error。下面通过训练误差和验证误差来详细分析一下overfitting。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-b1c5fc2a61c089bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上图总，蓝色表示训练误差training error，红色表示validation error。当训练误差达到中间的那条垂直线的点时，模型应该是最优的，如果继续减少模型的训练误差，这时就会发生过拟合。 </p><p>其实你可以这样来理解overfitting：数据集中信息分为两部分，一部分是和预测未来数据有关的数据，另一部分是无关的，两者地位是平等的。用来作为预测的评判标准越不精确，表明噪声数据就越多，需要忽略掉的数据也就越多，而关键就是究竟那一部分应该忽略掉。所以我们把一个学习算法对噪声的削减能力就叫做它的鲁棒性。我们需要的就是鲁棒性很强的学习算法</p><p>举一个简单的例子，一个零售购物的数据库包括购买项、购买人、日期、和购买时间。根据这个数据可以很容易的建立一个模型，并且在训练集上的拟合效果也会很好，通过使用日期、购买时间来预测其它属性列的值，但是这个模型对于新数据的泛化能力很弱，因为这些过去的数据不会再次发生。</p><h2 id="防止过拟合的几种方式"><a href="#防止过拟合的几种方式" class="headerlink" title="防止过拟合的几种方式"></a>防止过拟合的几种方式</h2><p>这里推荐阅读<a href="https://juejin.im/post/5b441583f265da0fb01854c4">机器学习中用来防止过拟合的方法有哪些？</a>，说的比较详细。</p><ol><li>增加数据集<br>你的模型可以存储很多很多的信息，这意味着你输入模型的训练数据越多，模型就越不可能发生过拟合。原因是随着你添加更多数据，模型会无法过拟合所有的数据样本，被迫产生泛化以取得进步。 收集更多的数据样本应该是所有数据科学任务的第一步，数据越多会让模型的准确率更高，这样也就能降低发生过拟合的概率。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5666077-38bb9eb397f1521b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>2. 正则化方法 $C=C_0+\frac{\lambda }{2n}\sum_{w}^{ }w^2$<br>正则化是指约束模型的学习以减少过拟合的过程。它可以有多种形式，推荐阅读<a href="https://juejin.im/post/5b441583f265da0fb01854c4">机器学习中用来防止过拟合的方法有哪些？</a>，说的比较详细。<br>3. Dropout<br>由于深度学习依赖神经网络处理从一个层到下一个层的信息，因而从这两方面着手比较有效。其理念就是在训练中随机让神经元无效（即dropout）或让网络中的连接无效（即dropconnect）。<img src="https://upload-images.jianshu.io/upload_images/5666077-e42e8d5bd796d114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="droppout"></p><p>这样就让神经网络变得冗长和重复，因为它无法再依赖具体的神经元或连接来提取具体的特征。等完成模型训练后，所有的神经元和连接会被保存下来。试验显示这种方法能起到和神经网络集成方法一样的效果，可以帮助模型泛化，这样就能减少过拟合的问题。</p><p>我们来用代码体验下dropout：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line"># 4.2 Dropout</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"></span><br><span class="line">start &#x3D; datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"># 载入数据</span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&quot;MNIST_data&quot;, one_hot&#x3D;True)</span><br><span class="line"># 每个批次的大小</span><br><span class="line">batch_size &#x3D; 50</span><br><span class="line"># 计算一共有多少个批次</span><br><span class="line">n_batch &#x3D; mnist.train.num_examples &#x2F;&#x2F; batch_size</span><br><span class="line"></span><br><span class="line"># 定义两个placeholder</span><br><span class="line">x &#x3D; tf.placeholder(tf.float32, [None, 784])</span><br><span class="line">y &#x3D; tf.placeholder(tf.float32, [None, 10])</span><br><span class="line">keep_prob &#x3D; tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line"># 创建一个神经网络</span><br><span class="line">W1 &#x3D; tf.Variable(tf.truncated_normal([784, 2000], stddev&#x3D;0.1))</span><br><span class="line">b1 &#x3D; tf.Variable(tf.zeros([2000])+0.1)</span><br><span class="line">L1 &#x3D; tf.nn.tanh(tf.matmul(x, W1)+b1)</span><br><span class="line">L1_drop &#x3D; tf.nn.dropout(L1, keep_prob)</span><br><span class="line"></span><br><span class="line">W2 &#x3D; tf.Variable(tf.truncated_normal([2000, 2000], stddev&#x3D;0.1))</span><br><span class="line">b2 &#x3D; tf.Variable(tf.zeros([2000])+0.1)</span><br><span class="line">L2 &#x3D; tf.nn.tanh(tf.matmul(L1_drop, W2)+b2)</span><br><span class="line">L2_drop &#x3D; tf.nn.dropout(L2, keep_prob)</span><br><span class="line"></span><br><span class="line">W3 &#x3D; tf.Variable(tf.truncated_normal([2000, 1000], stddev&#x3D;0.1))</span><br><span class="line">b3 &#x3D; tf.Variable(tf.zeros([1000])+0.1)</span><br><span class="line">L3 &#x3D; tf.nn.tanh(tf.matmul(L2_drop, W3)+b3)</span><br><span class="line">L3_drop &#x3D; tf.nn.dropout(L3, keep_prob)</span><br><span class="line"></span><br><span class="line">W4 &#x3D; tf.Variable(tf.truncated_normal([1000, 10], stddev&#x3D;0.1))</span><br><span class="line">b4 &#x3D; tf.Variable(tf.zeros([10])+0.1)</span><br><span class="line"></span><br><span class="line">prediction &#x3D; tf.nn.softmax(tf.matmul(L3_drop, W4)+b4)</span><br><span class="line"></span><br><span class="line"># 二次代价函数</span><br><span class="line"># loss &#x3D; tf.reduce_mean(tf.square(y-prediction))</span><br><span class="line"># 交叉熵代价函数</span><br><span class="line">loss &#x3D; tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(</span><br><span class="line">    labels&#x3D;y, logits&#x3D;prediction))</span><br><span class="line"># 使用梯度下降法</span><br><span class="line">train_step &#x3D; tf.train.GradientDescentOptimizer(0.1).minimize(loss)</span><br><span class="line"></span><br><span class="line"># 初始化变量</span><br><span class="line">init &#x3D; tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"># 结果存放在一个布尔型列表中</span><br><span class="line"># argmax返回一维张量中最大的值所在的位置</span><br><span class="line">correct_prediction &#x3D; tf.equal(tf.argmax(y, 1), tf.argmax(prediction, 1))</span><br><span class="line"># 求准确率</span><br><span class="line">accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    for epoch in range(20):</span><br><span class="line">        for batch in range(n_batch):</span><br><span class="line">            batch_xs, batch_ys &#x3D; mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(train_step, feed_dict&#x3D;&#123;</span><br><span class="line">                     x: batch_xs, y: batch_ys, keep_prob: 1.0&#125;)</span><br><span class="line"></span><br><span class="line">        test_acc &#x3D; sess.run(accuracy, feed_dict&#x3D;&#123;</span><br><span class="line">            x: mnist.test.images, y: mnist.test.labels, keep_prob: 1.0&#125;)</span><br><span class="line"></span><br><span class="line">        train_acc &#x3D; sess.run(accuracy, feed_dict&#x3D;&#123;</span><br><span class="line">            x: mnist.train.images, y: mnist.train.labels, keep_prob: 1.0&#125;)</span><br><span class="line"></span><br><span class="line">        print(&quot;Iter &quot;+str(epoch)+&quot;,Testing Accuracy &quot; +</span><br><span class="line">              str(test_acc)+&quot;,Train Accuracy&quot;+str(train_acc))</span><br><span class="line"></span><br><span class="line">end &#x3D; datetime.datetime.now()</span><br><span class="line">print((end-start).seconds)</span><br></pre></td></tr></table></figure><p>相较于之前的代码我们更改了以下一些地方：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个神经网络</span><br><span class="line">W1 &#x3D; tf.Variable(tf.truncated_normal([784, 2000], stddev&#x3D;0.1))</span><br><span class="line">b1 &#x3D; tf.Variable(tf.zeros([2000])+0.1)</span><br><span class="line">L1 &#x3D; tf.nn.tanh(tf.matmul(x, W1)+b1)</span><br><span class="line">L1_drop &#x3D; tf.nn.dropout(L1, keep_prob)</span><br><span class="line"></span><br><span class="line">W2 &#x3D; tf.Variable(tf.truncated_normal([2000, 2000], stddev&#x3D;0.1))</span><br><span class="line">b2 &#x3D; tf.Variable(tf.zeros([2000])+0.1)</span><br><span class="line">L2 &#x3D; tf.nn.tanh(tf.matmul(L1_drop, W2)+b2)</span><br><span class="line">L2_drop &#x3D; tf.nn.dropout(L2, keep_prob)</span><br><span class="line"></span><br><span class="line">W3 &#x3D; tf.Variable(tf.truncated_normal([2000, 1000], stddev&#x3D;0.1))</span><br><span class="line">b3 &#x3D; tf.Variable(tf.zeros([1000])+0.1)</span><br><span class="line">L3 &#x3D; tf.nn.tanh(tf.matmul(L2_drop, W3)+b3)</span><br><span class="line">L3_drop &#x3D; tf.nn.dropout(L3, keep_prob)</span><br><span class="line"></span><br><span class="line">W4 &#x3D; tf.Variable(tf.truncated_normal([1000, 10], stddev&#x3D;0.1))</span><br><span class="line">b4 &#x3D; tf.Variable(tf.zeros([10])+0.1)</span><br><span class="line"></span><br><span class="line">prediction &#x3D; tf.nn.softmax(tf.matmul(L3_drop, W4)+b4)</span><br></pre></td></tr></table></figure><p>我额外的为神经网络添加了两个隐藏层，为了方便体现出差异，我将每个隐藏层的神经元数量设置的比较多。<br>然后在训练过程中，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for epoch in range(10):</span><br><span class="line">        for batch in range(n_batch):</span><br><span class="line">            batch_xs, batch_ys &#x3D; mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(train_step, feed_dict&#x3D;&#123;</span><br><span class="line">                     x: batch_xs, y: batch_ys, keep_prob: 1.0&#125;)</span><br><span class="line"></span><br><span class="line">        test_acc &#x3D; sess.run(accuracy, feed_dict&#x3D;&#123;</span><br><span class="line">            x: mnist.test.images, y: mnist.test.labels, keep_prob: 1.0&#125;)</span><br><span class="line"></span><br><span class="line">        train_acc &#x3D; sess.run(accuracy, feed_dict&#x3D;&#123;</span><br><span class="line">            x: mnist.train.images, y: mnist.train.labels, keep_prob: 1.0&#125;)</span><br><span class="line"></span><br><span class="line">        print(&quot;Iter &quot;+str(epoch)+&quot;,Testing Accuracy &quot; +</span><br><span class="line">              str(test_acc)+&quot;,Train Accuracy&quot;+str(train_acc))</span><br></pre></td></tr></table></figure><p>其中<code>keep_prob</code>表示启用神经元占神经元总数的百分比（1.0表示全部使用），<code>train_acc</code>表示用训练样本来测试训练出来的模型的精确度，<code>test_acc</code>表示用测试样本来测试训练出来的模型的精确度，用这两个数据来反映出拟合程度。训练结果如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/5666077-f5edc18dcfc8d178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>在这里我们总共就训练了10次，而且数据量并不大，此时test_acc和train_acc就已经差了两个百分点，如果应用到其他项目中，数据量变大之后就不是2个百分点的事情了，所以说如果神经元数量过多是会造成过度拟合的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中为了提高精确度，引入了代价函数这个概念，为了更好的理解代价函数因此提前介绍了什么是激活函数以及为什么需要激活函数。在只用一层神经网络的时候通过更改代价函数，我们可以使精确度达到93%左右（训练次数较多时），但这还是不够，所以我们尝试多添加几层神经元，但是这时候就会出现“过拟合”这个新的问题了，通常有三种方式解决过拟合的问题。之后的文章将会在此基础上介绍以下优化器，并且告知大家如何使用谷歌免费的GPU服务加速深度学习的模型训练。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow笔记3——利用TensorFlow和MNIST数据集训练一个最简单的手写数字识别模型</title>
      <link href="p/efd4.html"/>
      <url>p/efd4.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzpyolzjavj30yg0flwfm.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们开始学习编程的时候，第一件事往往是学习打印”Hello World”。就好比编程入门有Hello World，机器学习入门有MNIST。</p><p>MNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-4a6654c25e807636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手写数字"></p><p>它也包含每一张图片对应的标签，告诉我们这个是数字几。比如，上面这四张图片的标签分别是<code>5，0，4，1</code>。</p><p>其实训练一个简单的手写数字识别模型的代码很短，我的示例代码总共也就50行，除去注释、空格之类的估计连30行也没有，但是去理解包含在代码中的设计思想是很重要的，因此这篇笔记我会将我对每段代码的理解都记录下来。</p><p>参考：</p><blockquote><p><a href="http://www.tensorfly.cn/tfdoc/tutorials/mnist_beginners.html">MNIST机器学习入门</a></p><p><a href="http://www.csuldw.com/2016/03/26/2016-03-26-loss-function/">机器学习-损失函数</a></p></blockquote><a id="more"></a><h2 id="MNIST数据集"><a href="#MNIST数据集" class="headerlink" title="MNIST数据集"></a>MNIST数据集</h2><p>MNIST数据集的官网是<a href="http://yann.lecun.com/exdb/mnist/">Yann LeCun’s website</a>。<br>虽然python提供了直接下载这个数据集的代码，但是考虑到国内网络的原因，建议<a href="https://pan.baidu.com/s/11i2ddnxPwR7CFEvN8qmuYg">点这下载数据集</a>，然后导入到项目根目录下就可以了。<br><img src="https://upload-images.jianshu.io/upload_images/5666077-aa298c973df86d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据集"><br>下载下来的数据集被分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）。这样的划分很重要，在机器学习模型设计时必须有一个单独的测试数据集不用于训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上（泛化）。</p><p>正如前面提到的一样，每一个MNIST数据单元有两部分组成：一张包含手写数字的图片和一个对应的标签。我们把这些图片设为<code>xs</code>，把这些标签设为<code>ys</code>。训练数据集和测试数据集都包含<code>xs</code>和<code>ys</code>，比如训练数据集的图片是 <code>mnist.train.images </code>，训练数据集的标签是 <code>mnist.train.labels</code>。</p><p>每一张图片包含28像素X28像素。我们可以用一个数字数组来表示这张图片：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-9b355b3ff43c303a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p><p>我们把这个数组展开成一个向量，长度是 28x28 = 784。如何展开这个数组（数字间的顺序）不重要，只要保持各个图片采用相同的方式展开就可以了。</p><p>因此，在MNIST训练数据集中，<code>mnist.train.images</code> 是一个形状为 <code>[60000, 784]</code> 的张量，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点。在此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于0和1之间。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-0a83e428622c1389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mnist.train.images"></p><p>相对应的MNIST数据集的标签是介于0到9的数字，用来描述给定图片里表示的数字。为了用于这个教程，我们使标签数据是”one-hot vectors”。 一个<code>one-hot</code>向量除了某一位的数字是1以外其余各维度数字都是0。所以在此教程中，数字n将表示成一个只有在第n维度（从0开始）数字为1的10维向量。比如，标签0将表示成([1,0,0,0,0,0,0,0,0,0,0])。因此， <code>mnist.train.labels</code> 是一个 <code>[60000, 10]</code> 的数字矩阵。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-33d890b038990c3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mnist.train.labels"></p><p>现在，我们准备好可以开始构建我们的模型啦！</p><h2 id="Softmax回归介绍"><a href="#Softmax回归介绍" class="headerlink" title="Softmax回归介绍"></a>Softmax回归介绍</h2><blockquote><p>（因为这段很枯燥，而且我也解释不太好，所以干脆直接从Tensorflow的网站上复制粘贴来了，如果不想看的可以直接跳过到模型实现，最后写代码的时候只要知道用softmax函数就可以了）</p></blockquote><p>我们知道MNIST的每一张图片都表示一个数字，从0到9。我们希望得到给定图片代表每个数字的概率。比如说，我们的模型可能推测一张包含9的图片代表数字9的概率是80%但是判断它是8的概率是5%（因为8和9都有上半部分的小圆），然后给予它代表其他数字的概率更小的值。</p><p>这是一个使用softmax回归（softmax regression）模型的经典案例。softmax模型可以用来给不同的对象分配概率。即使在之后，我们训练更加精细的模型时，最后一步也需要用softmax来分配概率。</p><p>softmax回归（softmax regression）分两步：第一步</p><p>为了得到一张给定图片属于某个特定数字类的证据（evidence），我们对图片像素值进行加权求和。如果这个像素具有很强的证据说明这张图片不属于该类，那么相应的权值为负数，相反如果这个像素拥有有利的证据支持这张图片属于这个类，那么权值是正数。</p><p>下面的图片显示了一个模型学习到的图片上每个像素对于特定数字类的权值。红色代表负数权值，蓝色代表正数权值。</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-7083c239f3187d37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们也需要加入一个额外的偏置量（bias），因为输入往往会带有一些无关的干扰量。因此对于给定的输入图片 <strong>x</strong> 它代表的是数字 <strong>i</strong> 的证据可以表示为</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-7cf005141e7aefd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中 <code>$W_i$</code> 代表权重，<code>$b_i$</code> 代表数字 <strong>i</strong> 类的偏置量，<strong>j</strong> 代表给定图片 <strong>x</strong> 的像素索引用于像素求和。然后用softmax函数可以把这些证据转换成概率 <strong>y</strong>：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-30ff0e52c4f8fca2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里的softmax可以看成是一个激励（activation）函数或者链接（link）函数，把我们定义的线性函数的输出转换成我们想要的格式，也就是关于10个数字类的概率分布。因此，给定一张图片，它对于每一个数字的吻合度可以被softmax函数转换成为一个概率值。softmax函数可以定义为：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-a12f5cc5a5e3a531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>展开等式右边的子式，可以得到：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-e6ab587fa09a9a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>但是更多的时候把softmax模型函数定义为前一种形式：把输入值当成幂指数求值，再正则化这些结果值。这个幂运算表示，更大的证据对应更大的假设模型（hypothesis）里面的乘数权重值。反之，拥有更少的证据意味着在假设模型里面拥有更小的乘数系数。假设模型里的权值不可以是0值或者负值。Softmax然后会正则化这些权重值，使它们的总和等于1，以此构造一个有效的概率分布。（更多的关于Softmax函数的信息，可以参考Michael Nieslen的书里面的这个<a href="http://neuralnetworksanddeeplearning.com/chap3.html#softmax">部分</a>，其中有关于softmax的可交互式的可视化解释。）</p><p>对于softmax回归模型可以用下面的图解释，对于输入的<code>xs</code>加权求和，再分别加上一个偏置量，最后再输入到softmax函数中：</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-557513ac4d2082ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果把它写成一个等式，我们可以得到：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-0520bdcf138d9bc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们也可以用向量表示这个计算过程：用矩阵乘法和向量相加。这有助于提高计算效率。（也是一种更有效的思考方式）</p><p><img src="https://upload-images.jianshu.io/upload_images/5666077-9caa41f27aaff842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>更进一步，可以写成更加紧凑的方式：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-73d3acf5e95009f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h2><p>在使用TensorFlow之前，首先导入它：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure><p>然后导入数据集并载入数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">&quot;MNIST_data&quot;</span>, one_hot=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>我们通过操作符号变量来描述这些可交互的操作单元，可以用下面的方式创建一个：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>])</span><br></pre></td></tr></table></figure><p><code>x</code>不是一个特定的值，而是一个占位符<code>placeholder</code>，我们在TensorFlow运行计算时输入这个值。我们希望能够输入任意数量的MNIST图像，每一张图展平成784维的向量。我们用2维的浮点数张量来表示这些图，这个张量的形状是<code>[None，784 ]</code>。（这里的<code>None</code>表示此张量的第一个维度可以是任何长度的。）</p><p>我们的模型也需要权重和偏量，当然我们可以把它们当做是另外的输入（使用占位符），但TensorFlow有一个更好的方法来表示它们：<code>Variable</code> 。 一个<code>Variable</code>代表一个可修改的张量，存在在TensorFlow的用于描述交互性操作的图中。它们可以用于计算输入值，也可以在计算中被修改。对于各种机器学习应用，一般都会有模型参数，可以用<code>Variable</code>表示。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W = tf.Variable(tf.zeros([<span class="number">784</span>,<span class="number">10</span>]))</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">10</span>]))</span><br></pre></td></tr></table></figure><p>我们赋予<code>tf.Variable</code>不同的初值来创建不同的<code>Variable</code>：在这里，我们都用全为零的张量来初始化<code>W</code>和<code>b</code>。因为我们要学习<code>W</code>和<code>b</code>的值，它们的初值可以随意设置。</p><p>注意，<code>W</code>的维度是[784，10]，因为我们想要用784维的图片向量乘以它以得到一个10维的证据值向量，每一位对应不同数字类。<code>b</code>的形状是[10]，所以我们可以直接把它加到输出上面。</p><p>现在，我们可以实现我们的模型啦。只需要一行代码！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prediction = tf.nn.softmax(tf.matmul(x, W)+b)</span><br></pre></td></tr></table></figure><p>首先，我们用<code>tf.matmul(X，W)</code>表示<code>x</code>乘以<code>W</code>，对应之前等式里面的Wx，这里<code>x</code>是一个2维张量拥有多个输入。然后再加上<code>b</code>，把和输入到<code>tf.nn.softmax</code>函数里面。</p><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>为了训练我们的模型，我们首先需要定义一个指标来评估这个模型是好的。其实，在机器学习，我们通常定义指标来表示一个模型是坏的，这个指标称为成本（cost）或损失（loss），然后尽量最小化这个指标。但是，这两种方式是相同的。损失函数有很多种，在这里我们采用<strong>平方损失函数</strong>，通常我们会用均方差（MSE）作为衡量指标，公式如下：$MSE=\frac{1}{n}\sum_{i=1}^{n}\ (y-prediction)^2$</p><p>为了计算损失函数，我们首先需要添加一个新的占位符用于输入正确值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>然后定义损失函数（loss）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二次代价函数</span></span><br><span class="line">loss = tf.reduce_mean(tf.square(y-prediction))</span><br></pre></td></tr></table></figure><p>这段代码的含义我在上一篇笔记中已经介绍过了，不清楚的推荐阅读<a href="https://juejin.im/post/5c014ff6f265da6149335fe9">TensorFlow笔记（2）——利用TensorFlow训练一个最简单的一元线性模型</a></p><p>然后使用优化算法来不断的修改变量来降低损失值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用梯度下降法</span><br><span class="line">train_step &#x3D; tf.train.GradientDescentOptimizer(0.1).minimize(loss)</span><br></pre></td></tr></table></figure><p>在这里，我们要求TensorFlow用梯度下降算法（gradient descent algorithm）以0.01的学习速率最小化交叉熵。梯度下降算法（gradient descent algorithm）是一个简单的学习过程，TensorFlow只需将每个变量一点点地往使成本不断降低的方向移动。当然TensorFlow也提供了<a href="http://www.tensorfly.cn/tfdoc/api_docs/python/train.html#optimizers">其他许多优化算法</a>：只要简单地调整一行代码就可以使用其他的算法。</p><p>TensorFlow在这里实际上所做的是，它会在后台给描述你的计算的那张图里面增加一系列新的计算操作单元用于实现反向传播算法和梯度下降算法。然后，它返回给你的只是一个单一的操作，当运行这个操作时，它用梯度下降算法训练你的模型，微调你的变量，不断减少成本。</p><p>现在，我们已经设置好了我们的模型。在运行计算之前，我们需要添加一个操作来初始化我们创建的变量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure><p>接下来我们就可以定义一个会话了，并在该会话中执行初始化变量的操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br></pre></td></tr></table></figure><p>然后开始训练模型，我们需要先定义一个批次<code>batch_size</code>，因为我们在训练的时候不可能每次都只放一张图片进入神经网络（因为这样太慢了），批次为100在这表示的就是我们一次放入100张图片进入神经网络，然后我们需要计算一共会有多少个批次：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每个批次的大小</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line"><span class="comment"># 计算一共有多少个批次</span></span><br><span class="line">n_batch = mnist.train.num_examples // batch_size</span><br></pre></td></tr></table></figure><p>然后我们让模型循环训练30次:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> range(n_batch):</span><br><span class="line">            batch_xs, batch_ys = mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(train_step, feed_dict=&#123;x: batch_xs, y: batch_ys&#125;)</span><br></pre></td></tr></table></figure><p>该循环的每个步骤中，我们都会随机抓取训练数据中的<code>n_batch</code>个批处理数据点，然后我们用这些数据点作为参数替换之前的占位符来运行<code>train_step</code>。</p><p>使用一小部分的随机数据来进行训练被称为随机训练（stochastic training）- 在这里更确切的说是随机梯度下降训练。在理想情况下，我们希望用我们所有的数据来进行每一步的训练，因为这能给我们更好的训练结果，但显然这需要很大的计算开销。所以，每一次训练我们可以使用不同的数据子集，这样做既可以减少计算开销，又可以最大化地学习到数据集的总体特性。</p><h2 id="评估我们的模型"><a href="#评估我们的模型" class="headerlink" title="评估我们的模型"></a>评估我们的模型</h2><p>那么我们的模型性能如何呢？</p><p>首先让我们找出那些预测正确的标签。<code>tf.argmax</code> 是一个非常有用的函数，它能给出某个tensor对象在某一维上的其数据最大值所在的索引值。由于标签向量是由0,1组成，因此最大值1所在的索引位置就是类别标签，比如<code>tf.argmax(y,1)</code>返回的是模型对于任一输入x预测到的标签值，而 <code>tf.argmax(prediction,1)</code> 代表正确的标签，我们可以用 <code>tf.equal</code> 来检测我们的预测是否真实标签匹配(索引位置一样表示匹配)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 结果存放在一个布尔型列表中</span></span><br><span class="line"><span class="comment"># argmax返回一维张量中最大的值所在的位置</span></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(prediction, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这行代码会给我们一组布尔值。为了确定正确预测项的比例，我们可以把布尔值转换成浮点数，然后取平均值。例如，<code>[True, False, True, True]</code> 会变成 <code>[1,0,1,1]</code> ，取平均值后得到 <code>0.75</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求准确率</span></span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br></pre></td></tr></table></figure><p>最后，我们计算所学习到的模型在测试数据集上面的正确率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> range(n_batch):</span><br><span class="line">            batch_xs, batch_ys = mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(train_step, feed_dict=&#123;x: batch_xs, y: batch_ys&#125;)</span><br><span class="line">        acc = sess.run(accuracy, feed_dict=&#123;</span><br><span class="line">                       x: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line">        print(<span class="string">&quot;Iter &quot;</span>+str(epoch)+<span class="string">&quot;,Testing Accuracy &quot;</span>+str(acc))</span><br></pre></td></tr></table></figure><p>最终结果如下图所示，精确度大约在90%</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxusgjtmjfj30cy0nedjr.jpg" alt="image-20181204162301761"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>我加了datetime这个包，目的是为了计算代码的执行时间，不影响阅读。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 MNIST数据集分类简单版本</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line">start = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">&quot;MNIST_data&quot;</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 每个批次的大小</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line"><span class="comment"># 计算一共有多少个批次</span></span><br><span class="line">n_batch = mnist.train.num_examples // batch_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个placeholder</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>])</span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个简单的神经网络</span></span><br><span class="line">W = tf.Variable(tf.zeros([<span class="number">784</span>, <span class="number">10</span>]))</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">10</span>]))</span><br><span class="line">prediction = tf.nn.softmax(tf.matmul(x, W)+b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二次代价函数</span></span><br><span class="line">loss = tf.reduce_mean(tf.square(y-prediction))</span><br><span class="line"><span class="comment"># 使用梯度下降法</span></span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果存放在一个布尔型列表中</span></span><br><span class="line"><span class="comment"># argmax返回一维张量中最大的值所在的位置</span></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(prediction, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 求准确率</span></span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> range(n_batch):</span><br><span class="line">            batch_xs, batch_ys = mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(train_step, feed_dict=&#123;x: batch_xs, y: batch_ys&#125;)</span><br><span class="line">        acc = sess.run(accuracy, feed_dict=&#123;</span><br><span class="line">                       x: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line">        print(<span class="string">&quot;Iter &quot;</span>+str(epoch)+<span class="string">&quot;,Testing Accuracy &quot;</span>+str(acc))</span><br><span class="line"></span><br><span class="line">end = datetime.datetime.now()</span><br><span class="line">print((end-start).seconds)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow笔记2——利用TensorFlow训练一个最简单的一元线性模型</title>
      <link href="p/4c3a.html"/>
      <url>p/4c3a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpyodqbssj30hs0f4aai.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一次使用<a href="https://yueyong.info/p/a695.html">《TensorFlow笔记（1）——TensorFlow中的相关基本概念》</a>中学习到的知识进行机器学习的实验，一来是为了理解机器学习大概是什么样的，另一方面也算是将之前学习到的一些知识活学活用。<br>本次实现的环境为：</p><ul><li>macOS Mojave 10.14.1</li><li>python 3.7.0（pyenv）</li><li>Tensorflow 1.12.0</li><li>numpy 1.15.4</li></ul><h2 id="简单介绍下机器学习是什么"><a href="#简单介绍下机器学习是什么" class="headerlink" title="简单介绍下机器学习是什么"></a>简单介绍下机器学习是什么</h2><p>机器学习和人类学习的过程：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxqdek5ieuj30dm06kmxd.jpg"></p><a id="more"></a><p>如果觉得上图不好理解的话就再举一个栗子：</p><blockquote><p>假设你有个女朋友，她特别爱美。为了互相了解，你们每周末都会一起约会吃饭；已经约会有8周了，每周吃饭你女朋友都会比约定时间晚到10分钟-30分钟，所以你每次约会也会比约定时间晚10-30分钟，并且你总结了一个规律(如果约会前打电话她说从家走了，那么基本都是晚到30分钟左右，如果她说就快到了，那么基本会晚到10分钟)，不过你女朋友后来迟到的时间从10、30分钟变成了15、45分钟，你也自己调整了约定时间后到达的时间。</p></blockquote><p>根据上述栗子🌰我们来类比下：</p><p>机器学习方法是计算机利用已有的数据(8次约会的经验)，得出了某种模型(迟到的规律)，并利用此模型预测未来(是否迟到)的一种方法。</p><h2 id="Tensorflow的基础知识"><a href="#Tensorflow的基础知识" class="headerlink" title="Tensorflow的基础知识"></a>Tensorflow的基础知识</h2><p>基础知识在这里我就不多说了，详见<a href="https://yueyong.info/p/a695.html">《TensorFlow笔记（1）——TensorFlow中的相关基本概念》</a></p><h2 id="构建一个线性模型"><a href="#构建一个线性模型" class="headerlink" title="构建一个线性模型"></a>构建一个线性模型</h2><p>先来说明下我们需要构建的这个简单的线性模型是什么东西：</p><p>假设我们有个线性模型（一元一次函数）：<code>y=0.1x+0.2</code>，我们知道这个线性模型长啥样，就是一条直线嘛，但是我现在想让机器也知道这条直线，该怎么做？还记得上面说的那个栗子吗，我们可以提供一系列类似<code>（x，y）</code>的数据，然后带入<code>y=k*x_data+b</code>，求出k和b的值之后，机器也就知道了这个线性模型长啥样了。</p><p>下面来更数学化一点的介绍：</p><p>给定一个大小为n的点集 𝑆={(𝑥1,𝑦1),(𝑥2,𝑦2),…(𝑥𝑛,𝑦𝑛)} ，</p><p>线性模型的目标就是寻找一组 <em>K</em> 和 𝑏 构成的直线 𝑦=<em>K</em>𝑥+𝑏 ，</p><p>使得所有点的损失值 <code>$𝑙𝑜𝑠𝑠=\sum_&#123;i&#125;^&#123;n&#125;(K𝑥_𝑖+𝑏−𝑦_𝑖)^2$</code> 越小越好，因为𝑙𝑜𝑠𝑠越小就表明预测值与真实值的差距越小。</p><p>因为如果我们找到了这么一组 <em>K</em> 和 𝑏 ，我们就可以预测某一个 <code>$𝑥_𝑚$</code> 的 <code>$𝑦_𝑚$</code> 值。</p><p>这里我想多说几句，线性模型在实际应用中不一定能很好的预测 $𝑦_𝑚$ 的值，这是因为实际的数据分布也许不是线性的，可能是二次、三次、圆形甚至无规则，所以判断什么时候能用线性模型很重要。只是因为我们在这里知道了这是线性模型才这么做的，真正构建模型的时候是需要相应的方法的。</p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>话不多少，分段来看代码：</p><ol><li>导入相应的python包，这里我们使用了tensorflow和numpy</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tensorflow简单示例</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><ol start="2"><li>使用numpy生成1000个随机点，关于numpy的使用，可以查看我的<a href="https://www.jianshu.com/nb/31178645">numpy系列笔记</a></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用numpy生成1000个随机点</span></span><br><span class="line">x_data = np.random.rand(<span class="number">1000</span>)</span><br><span class="line">y_data = x_data*<span class="number">0.1</span>+<span class="number">0.2</span>         <span class="comment"># 真实值</span></span><br></pre></td></tr></table></figure><ol start="3"><li>构造一个线性模型</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造一个线性模型</span></span><br><span class="line">b = tf.Variable(<span class="number">0.</span>)</span><br><span class="line">k = tf.Variable(<span class="number">0.</span>)</span><br><span class="line">y = k*x_data+b                  <span class="comment"># 预测值</span></span><br></pre></td></tr></table></figure><ol start="4"><li>定义损失函数，用于判断y<sub> 真实值</sub>和y<sub> 预测值</sub>之间的差距</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二次代价函数（损失函数）</span></span><br><span class="line">loss = tf.reduce_mean(tf.square(y_data-y))</span><br></pre></td></tr></table></figure><p>依次来解释下每个部分的含义：</p><ul><li><code>y_data-y</code>:这个地方没啥好解释的，就是真实值和预测值之间的差</li><li><code>tf.square</code>：这个函数的作用就是求平方</li><li><code>tf.reduce_mean</code>: 函数用于计算张量tensor沿着指定的数轴（tensor的某一维度）上的的平均值，主要用作降维或者计算tensor（图像）的平均值。</li></ul><p>所以上面这三个函数合在一起就是计算loss值。</p><ol start="5"><li>使用<code>GradientDescentOptimizer</code>类创建一个优化器来优化模型，减少<code>loss</code>值，这个类的原理是梯度下降，至于什么是梯度下降，可以参考其他教程，日后会介绍，目前只要知道这么写就好了。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个梯度下降法来进行训练的优化器</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>使用优化器来减少<code>loss</code>值,<code>minimize</code>是优化器的一个方法</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个最小化代价函数</span></span><br><span class="line">train = optimizer.minimize(loss)</span><br></pre></td></tr></table></figure><ol start="7"><li>初始化上面的所有变量</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure><ol start="8"><li>利用<code>Session</code>训练我们的模型</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:<span class="comment"># 定义会话上下文</span></span><br><span class="line">    sess.run(init)<span class="comment"># 执行初始化操作</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">3000</span>):  <span class="comment"># 训练3000次</span></span><br><span class="line">        sess.run(train)<span class="comment"># 执行训练操作</span></span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:<span class="comment"># 每隔20步</span></span><br><span class="line">            print(step, sess.run([k, b]))<span class="comment"># 打印出k和b的值</span></span><br></pre></td></tr></table></figure><p>至此，一个最简单的线性模型也就完成了。下面是所有代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tensorflow简单示例</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用numpy生成1000个随机点</span></span><br><span class="line">x_data = np.random.rand(<span class="number">1000</span>)</span><br><span class="line">y_data = x_data*<span class="number">0.1</span>+<span class="number">0.2</span>         <span class="comment"># 真实值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一个线性模型</span></span><br><span class="line">b = tf.Variable(<span class="number">0.</span>)</span><br><span class="line">k = tf.Variable(<span class="number">0.</span>)</span><br><span class="line">y = k*x_data+b                  <span class="comment"># 预测值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二次代价函数（损失函数）</span></span><br><span class="line">loss = tf.reduce_mean(tf.square(y_data-y))</span><br><span class="line"><span class="comment"># 定义一个梯度下降法来进行训练的优化器</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 定义一个最小化代价函数</span></span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">3000</span>):</span><br><span class="line">        sess.run(train)</span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            print(step, sess.run([k, b]))</span><br></pre></td></tr></table></figure><p>运行结果的部分截图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxqggri22oj30ci0a8dh1.jpg" alt="训练0-240次的结果"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxqghp4eutj30cm08m754.jpg" alt="训练2700-2980次的结果"></p><p>从上面两张图我们可以明显的看出来，在训练到第2980次的时候，k的结果已经非常非常接近0.1，b也非常非常接近0.2了，由此可以看出，这个模型还是较为正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow笔记（1）——TensorFlow中的相关基本概念</title>
      <link href="p/a695.html"/>
      <url>p/a695.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzpyo15gfdj30m80cogo7.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Tensorflow 是一个编程系统，使用图（graph）来表示计算任务，图（graph）中的节点称之为 op  (operation），一个 op 获得 0 个或多个 Tensor，执行计算，产生 0 个或多个 Tensor。Tensor 看作是一个 n 维的数组或列表。图必须在会话（Session）里被启动。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>使用图（Graph）来表示计算任务</li><li>在被称为会话（Session）的上下文（context）中执行图</li><li>使用tensor表示数据</li><li>通过变量（Variable）维护状态</li><li>使用feed和fetch可以为任意的操作赋值或者从中获取数据</li></ul><p>下图显示了Session、Graph、Tensor、Variable之间的关系</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxo6y63a09j30m80cogo7.jpg" alt="关系图"></p><a id="more"></a><h2 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h2><p>在TensorFlow的官方文档中，Graph 被定义为“一些 Operation 和 Tensor 的集合”。例如我们表达如下的一个计算的 python代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">b &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">c &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">d &#x3D; a*b+c</span><br><span class="line">e &#x3D; d*2</span><br></pre></td></tr></table></figure><p>就会生成相应的一张图，在Tensorboard中看到的图大概如下这样。其中每一个圆圈表示一个Operation（输入处为Placeholder），椭圆到椭圆的边为Tensor，箭头的指向表示了这张图Operation 输入输出 Tensor 的传递关系。<br><img src="https://upload-images.jianshu.io/upload_images/5666077-4aea69b69b184954.png%EF%BC%9FimageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图（Graph）"></p><h2 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h2><p><strong><code>会话（Session）</code>**是TensorFlow中的一个非常重要的概念。上面提到了，在TensorFlow中的所有计算都构建在一张计算图（Graph）中，这是一种对数学运算过程的可视化方法。而会话（Session）就是负责让这个图运算起来，</strong><code>会话（Session）</code>持有并管理TensorFlow程序运行时的所有资源**，例如CPU或者GPU的分配。</p><h3 id="使用会话（Session）的两种方式"><a href="#使用会话（Session）的两种方式" class="headerlink" title="使用会话（Session）的两种方式"></a>使用会话（Session）的两种方式</h3><p><strong>方式一：明确的调用会话的生成函数和关闭会话函数</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个会话</span><br><span class="line">sess &#x3D; tf.Session()</span><br><span class="line"></span><br><span class="line"># 使用该会话执行一个结果</span><br><span class="line">sess.run(...)</span><br><span class="line"></span><br><span class="line"># 关闭会话，释放内存</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure><p>调用这种方式时，要明确调用<code>Session.close()</code>，以释放资源。当程序异常退出时，关闭函数就不能被执行，从而导致资源泄露。</p><p><strong>方式二：上下文管理机制自动释放所有资源</strong><br>利用with结构将需要执行的代码包裹住，创建会话，并通过上下文机制管理器管理该会话</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(...)</span><br><span class="line"># 不需要再调用&quot;Session.close()&quot;</span><br><span class="line"># 在退出with statement时，会话关闭和资源释放已自动完成</span><br></pre></td></tr></table></figure><blockquote><p>Tips:一般情况下推荐使用方式二使用会话</p></blockquote><h2 id="张量（Tensor）"><a href="#张量（Tensor）" class="headerlink" title="张量（Tensor）"></a>张量（Tensor）</h2><p>TensorFlow用张量这种数据结构来表示所有的数据.你可以把一个张量想象成一个n维的数组或列表.一个张量有一个静态类型和动态类型的维数.张量可以在图中的节点之间流通</p><h3 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h3><p>在TensorFlow系统中，张量的维数来被描述为阶.但是张量的阶和矩阵的阶并不是同一个概念.张量的阶（有时是关于如顺序或度数或者是n维）是张量维数的一个数量描述.比如，下面的张量（使用Python中list定义的）就是2阶.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br></pre></td></tr></table></figure><p>你可以认为一个二阶张量就是我们平常所说的矩阵，一阶张量可以认为是一个向量.对于一个二阶张量你可以用语句t[i, j]来访问其中的任何元素.而对于三阶张量你可以用’t[i, j, k]’来访问其中的任何元素.</p><table><thead><tr><th>阶</th><th>数学实例</th><th>Python 例子</th></tr></thead><tbody><tr><td>0</td><td>纯量 (只有大小)</td><td>s = 483</td></tr><tr><td>1</td><td>向量(大小和方向)</td><td>v = [1.1, 2.2, 3.3]</td></tr><tr><td>2</td><td>矩阵(数据表)</td><td>m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</td></tr><tr><td>3</td><td>3阶张量 (数据立体)</td><td>t = [[[2], [4], [6]], [[8], [10], [12]], [[14], [16], [18]]]</td></tr><tr><td>n</td><td>n阶 (自己想想看)</td><td>….</td></tr><tr><td>张量是所有深度学习框架中最核心的组件，因为后续的所有运算和优化算法都是基于张量进行的。几何代数中定义的张量是基于向量和矩阵的推广，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。</td><td></td><td></td></tr></tbody></table><h2 id="变量（Variable）"><a href="#变量（Variable）" class="headerlink" title="变量（Variable）"></a>变量（Variable）</h2><p>本质也是一个tensor张量，但variable主要用于数据存储(可以理解为Java中的全局变量)<br>Variable 用于构建一个变量，在计算图的运算过程中，其值会一直保存到程序运行结束，而一般的tensor张量在tensorflow运行过程中只是在计算图中流过，并不会保存下来。<br>因此Varibale主要用来保存tensorflow构建的一些结构中的参数，这些参数才不会随着运算的消失而消失，才能最终得到一个模型。 </p><blockquote><p><strong>Tips:</strong> 所有和varible有关的操作在计算的时候都要使用session会话来控制，包括计算，打印等等。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 2.2变量</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 定义一个变量 X</span><br><span class="line">X&#x3D;tf.Variable([1,2])</span><br><span class="line"># 定义一个常量 a</span><br><span class="line">a&#x3D;tf.constant([3,3])</span><br><span class="line"></span><br><span class="line"># 增加一个减法op</span><br><span class="line">sub&#x3D;tf.subtract(X,a)</span><br><span class="line"># 增加一个加法op</span><br><span class="line">add&#x3D;tf.add(X,sub)</span><br><span class="line"></span><br><span class="line"># 初始化所有变量</span><br><span class="line">init&#x3D;tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"># 定义一段会话</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    # 在会话中执行</span><br><span class="line">    sess.run(init)</span><br><span class="line">    print(sess.run(sub))</span><br><span class="line">    print(sess.run(add))</span><br><span class="line"></span><br><span class="line"># 创建一个变量，初始化为0</span><br><span class="line">state&#x3D;tf.Variable(0,name&#x3D;&#39;counter&#39;)</span><br><span class="line"># 创建一个op，作用是使state加1</span><br><span class="line">new_value&#x3D;tf.add(state,1)</span><br><span class="line"># 赋值op</span><br><span class="line">update&#x3D;tf.assign(state,new_value)</span><br><span class="line"># 变量初始化</span><br><span class="line">init&#x3D;tf.global_variables_initializer()</span><br><span class="line"># 创建一个会话</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    # 利用会话执行初始化操作</span><br><span class="line">    sess.run(init)</span><br><span class="line">    print(sess.run(state))</span><br><span class="line">    for _ in range(5):</span><br><span class="line">        sess.run(update)</span><br><span class="line">        print(sess.run(state))</span><br></pre></td></tr></table></figure><h2 id="feed和fetch"><a href="#feed和fetch" class="headerlink" title="feed和fetch"></a>feed和fetch</h2><h3 id="1-fetch"><a href="#1-fetch" class="headerlink" title="1.fetch"></a>1.fetch</h3><p>会话运行完成之后，如果我们想查看会话运行的结果，可以使用fetch来实现</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># Fetch</span><br><span class="line"># 创建三个常量</span><br><span class="line">input1 &#x3D; tf.constant(3.0)</span><br><span class="line">input2 &#x3D; tf.constant(2.0)</span><br><span class="line">input3 &#x3D; tf.constant(5.0)</span><br><span class="line"></span><br><span class="line"># 执行加法和乘法操作</span><br><span class="line">add&#x3D;tf.add(input2,input3)</span><br><span class="line">mul&#x3D;tf.multiply(input1,add)</span><br><span class="line"></span><br><span class="line"># 创建会话执行</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    result&#x3D;sess.run([mul,add])</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[21.0, 7.0]</span><br></pre></td></tr></table></figure><h3 id="2-feed与占位符-placeholder"><a href="#2-feed与占位符-placeholder" class="headerlink" title="2.feed与占位符(placeholder)"></a>2.feed与占位符(placeholder)</h3><p>当我们构建一个模型的时候，有时候我们需要在运行时候输入一些初始数据，这个时候定义模型数据输入在tensorflow中就是用placeholder（占位符）来完成。它的定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def placeholder(dtype, shape&#x3D;None, name&#x3D;None):</span><br></pre></td></tr></table></figure><p>其中dtype表示数据类型，shape表示维度，name表示名称。它支持单个数值与任意维度的数组输入。<br><strong>1. 单个数值占位符定义</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">b &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">c &#x3D; tf.add(a, b)</span><br></pre></td></tr></table></figure><p>当我们需要执行得到c的运行结果时候我们就需要在会话运行时候，通过feed来插入a与b对应的值，代码演示如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.Session() as sess:</span><br><span class="line">    result &#x3D; sess.run(c, feed_dict&#x3D;&#123;a:3, b:4&#125;)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>其中 feed_dict就是完成了feed数据功能，feed中文有喂饭的意思，这里还是很形象的，对定义的模型来说，数据就是最好的食物，所以就通过feed_dict来实现。</p><p><strong>2. 多维数据</strong><br>同样对于模型需要多维数据的情况下通过feed一样可以完成，定义二维数据的占位符，然后相加，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_x &#x3D; tf.placeholder(shape&#x3D;[None, 2], dtype&#x3D;tf.float32, name&#x3D;&quot;x&quot;)</span><br><span class="line">_y &#x3D; tf.placeholder(shape&#x3D;[None, 2], dtype&#x3D;tf.float32, name&#x3D;&quot;y&quot;)</span><br><span class="line">z &#x3D; tf.add(_x, _y);</span><br></pre></td></tr></table></figure><p>运行时候需要feed二维数组，实现如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.Session() as sess:</span><br><span class="line">    result &#x3D; sess.run(z, feed_dict&#x3D;&#123;_x:[[3, 4], [1, 2]], _y:[[8, 8],[9, 9]]&#125;)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>下面给出示例代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># Feed</span><br><span class="line"># 常见占位符</span><br><span class="line">input4&#x3D;tf.placeholder(tf.float32)</span><br><span class="line">input5&#x3D;tf.placeholder(tf.float32)</span><br><span class="line">output&#x3D;tf.multiply(input4,input5)</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    # feed的数据以字典的形式传入</span><br><span class="line">    print(sess.run(output,feed_dict&#x3D;&#123;input4:2.0,input5:45.2&#125;))</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">90.4</span><br></pre></td></tr></table></figure><h3 id="3-feed和fetch"><a href="#3-feed和fetch" class="headerlink" title="3. feed和fetch"></a>3. feed和fetch</h3><p>总结下，feed和fetch的作用就和他的意思是一样的，fetch用于从session中获取结果数据，feed是用于将数据喂给operation，然后用session执行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow笔记0——在Ubuntu 18.04安装tensorflow 1.12 GPU版本</title>
      <link href="p/4ab8.html"/>
      <url>p/4ab8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy4y2sir85j30t00eedig.jpg"></p><p>在之前的深度学习中，我是在MAC上跑CPU版本的tensorflow程序，当数据量变大后，tensorflow跑的非常慢，在内存不足情况下，又容易造成系统崩溃，这个时候我觉得不应该浪费我的限制的微星游戏本，便想着拿来跑深度学习的代码。</p><h3 id="1-配置信息"><a href="#1-配置信息" class="headerlink" title="1. 配置信息"></a>1. 配置信息</h3><p>我的老电脑配置如下：</p><ul><li>CPU i5-4210M</li><li>16G内存</li><li>GPU GTX 950M 显存2G</li><li>128G SSD</li><li>Ubuntu 18.04</li></ul><p>这个配置一般，但是为了不让我的mac发光发热，同时体验下GPU给深度学习的加速效果（虽然可能加不了多少速度）以及不想让老电脑荒废的心，我最终决定还是在上面安装Ubuntu18.04跑TensorFlow了。</p><h3 id="2-选择安装所需软件"><a href="#2-选择安装所需软件" class="headerlink" title="2. 选择安装所需软件"></a>2. 选择安装所需软件</h3><a id="more"></a><p>TensorFlow官网中提到了需要安装以下软件才可以使用TensorFlow的GPU版本：  <img src="http://upload-images.jianshu.io/upload_images/5666077-5b13e74d2776d0b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>简单来说就是我们需要在Ubuntu18.04的环境下安装以下软件：</p><ol><li><p>NVIDIA的GPU驱动（nvidia drive-390）</p></li><li><p>CUDA 9.0（不要下载CUDA 10.0，因为TensorFlow 1.12.0目前只支持到CUDA 9.0）</p></li><li><p>cuDNN v7.3.1 for CUDA 9.0 （选当前最新的）</p></li></ol><p>至于CUDA和cuDNN是什么自行谷歌，对应的下载页面和地址如下：</p><ul><li><p>CUDA 9.0 <a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a></p></li><li><p>cuDNN 7.3.1 <a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a> 注意cuDNN下载前需要注册登录</p></li></ul><h3 id="3-安装NVIDIA驱动并降低gcc版本"><a href="#3-安装NVIDIA驱动并降低gcc版本" class="headerlink" title="3. 安装NVIDIA驱动并降低gcc版本"></a>3. 安装NVIDIA驱动并降低gcc版本</h3><p>cuda的官网 <a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/#choose-installation-method">https://docs.nvidia.com/cuda/cuda-installation-guide-linux/#choose-installation-method</a> 安装说明中已经列出了检查步骤。如果你的GPU在支持列表中，则我们只需要做如下操作：</p><h4 id="3-1-安装GPU驱动程序。"><a href="#3-1-安装GPU驱动程序。" class="headerlink" title="3.1 安装GPU驱动程序。"></a>3.1 安装GPU驱动程序。</h4><p>Ubuntu在安装后，是给了一个叫Nouveau默认内建的驱动程序。我们需要安装GPU针对性的驱动程序，有篇文章教怎么在Ubuntu上安装合适的驱动：<a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux">https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux</a> 。</p><p>简单来说，执行 <code>ubuntu-drivers devices</code> 命令得到推荐的nvidia驱动程序，</p><p>然后执行 <code>sudo apt-get install nvidia-driver-390</code> （根据提示的驱动程序而定）即可安装完成。</p><p>注意安装完成后需要重启。</p><p>重启完成后执行<code>nvidia-smi</code>，如果出现类似于下图所示的信息则说明驱动安装成功：</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-5293d0d930344587.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><h4 id="3-2-安装gcc-4-8和g-4-8"><a href="#3-2-安装gcc-4-8和g-4-8" class="headerlink" title="3.2 安装gcc-4.8和g++4.8"></a>3.2 安装gcc-4.8和g++4.8</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-4.8</span><br><span class="line">ll &#x2F;usr&#x2F;bin |grep gcc #若存在高版本的gcc，则继续</span><br><span class="line">cd &#x2F;usr&#x2F;bin</span><br><span class="line">sudo mv gcc gcc.bak #备份</span><br><span class="line">sudo ln -s gcc-4.8 gcc  #重新指向</span><br></pre></td></tr></table></figure><p>执行<code>gcc --version</code> 可检查是否为4.8版本，g++可执行同样的操作。</p><h3 id="4-安装CUDA和cuDNN"><a href="#4-安装CUDA和cuDNN" class="headerlink" title="4. 安装CUDA和cuDNN"></a>4. 安装CUDA和cuDNN</h3><p>进入CUDA9.0的下载页，选择安装类型为runfile(local)，可发现有一个基础安装包，和三个补丁包，都下载下来，然后依次执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sh cuda_9.0.176_384.81_linux.run</span><br></pre></td></tr></table></figure><p>　　安装时会以提问的方式，一路默认即可，当第二个询问是否安装新驱动程序时，选择否，其余均是yes。然后再以同样的方式安装以下补丁包。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sh cuda_9.0.176.1_linux.run</span><br><span class="line">sudo sh cuda_9.0.176.2_linux.run</span><br><span class="line">sudo sh cuda_9.0.176.3_linux.run　</span><br></pre></td></tr></table></figure><p>　　结束后，可以在/usr/local/cuda-9.0 发现有安装文件，执行<code>sudo gedit /etc/profile</code>或者<code>sudo gedit ~/.bashrc</code>在<code>/etc/profile</code>或<code>~/.bashrc</code>的文件后面添加环境变量：　</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-9.0&#x2F;bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-9.0&#x2F;lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;　　</span><br></pre></td></tr></table></figure><p>　　然后执行<code>source ~/.bashrc</code>或者<code>source /etc/profile</code>让刚刚修改的环境变量生效。然后执行<code>nvcc -V</code>来验证CUDA是否完成安装。</p><p>安装好CUDA9.0后，接下来就安装cuDNN，进入cuDNN下载页选择 cuDNN v7.3.1 Library for Linux 下载。</p><p> 执行如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzvf cudnn-9.0-linux-x64-v7.tgz</span><br></pre></td></tr></table></figure><p>　　进入解压目录，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include</span><br><span class="line">sudo cp cuda&#x2F;lib64&#x2F;libcudnn* &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64</span><br><span class="line">sudo chmod a+r &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;libcudnn*</span><br></pre></td></tr></table></figure><p>　　这样就安装完成了。</p><h3 id="5-安装pyenv"><a href="#5-安装pyenv" class="headerlink" title="5. 安装pyenv"></a>5. 安装pyenv</h3><p>这里我采用了pyenv的方式来隔离不同环境下的python。</p><p>首先安装curl，它一个命令行式的下载工具</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><p>然后下载pyenv的安装包，pyenv的GitHub链接：<a href="https://github.com/pyenv/pyenv">pyenv</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;yyuu&#x2F;pyenv-installer&#x2F;master&#x2F;bin&#x2F;pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>编辑<code>~/.bashrc</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>在该文件中添加以下内容（直接复制即可）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PYENV_ROOT&#x3D;&quot;$HOME&#x2F;.pyenv&quot;</span><br><span class="line">export PATH&#x3D;&quot;$PYENV_ROOT&#x2F;bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure><p>终端执行以下命令安装python的依赖包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install make build-essential libssl-dev zlib1g-dev</span><br><span class="line">sudo apt-get install libbz2-dev libreadline-dev libsqlite3-dev wget curl</span><br><span class="line">sudo apt-get install llvm libncurses5-dev libncursesw5-dev</span><br></pre></td></tr></table></figure><p>安装python 3.6.5</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.6.5</span><br></pre></td></tr></table></figure><p>安装过程可能很缓慢，一个简便方法，只需要在python的官网(此处给出python3.6.5的<a href="https://www.python.org/downloads/release/python-365/">下载地址</a>)下载你需要的python版本的<code>tar.xz</code>文件然后放到 <code>~/.pyenv/cache</code>中然后再执行<code>pyenv install [version]</code>就可以了，cache文件夹可能不存在，请自行新建。</p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-47daf439f84abf29.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p><strong>pyenv的常用命令</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/5666077-8931e1c3c7a746aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装第二个"> </p><p>上图是官方文档中的例子，如果想要查看完整命令列表，可以点击查看<a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#command-reference">pyenv命令列表</a></p><p>在终端执行<code>pyenv global 3.6.5</code>即可将3.6.5设置为系统默认的python环境</p><h3 id="6-安装tensorflow-gpu"><a href="#6-安装tensorflow-gpu" class="headerlink" title="6. 安装tensorflow-gpu"></a>6. 安装tensorflow-gpu</h3><p>终端中输入以下命令即可安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --index-url http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple --trusted-host pypi.douban.com --upgrade tensorflow-gpu</span><br></pre></td></tr></table></figure><h3 id="7-验证结果"><a href="#7-验证结果" class="headerlink" title="7. 验证结果"></a>7. 验证结果</h3><p>利用终端新建一个.py文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch test.py</span><br></pre></td></tr></table></figure><p>然后利用Visual Studio Code打开该文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code test.py</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">hello &#x3D; tf.constant(&#39;Hello, TensorFlow!&#39;)</span><br><span class="line">sess &#x3D; tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure><p>然后执行该脚本<code>python test.py</code>即可得到包含有GPU输出信息的正确结果</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】防止 Git 泄漏的 5 种最佳做法</title>
      <link href="p/94b4.html"/>
      <url>p/94b4.html</url>
      
        <content type="html"><![CDATA[<p>之前看过几个新闻，说是因为程序员的疏忽，将公司服务器的密钥上传到 GitHub 上，导致公司数据丢失，造成了很严重的影响，恰巧最近看到一篇英文博客有介绍如何防止 Git 泄露，下面是我的翻译内容，原文来自于 <a href="https://levelup.gitconnected.com/5-best-practices-to-prevent-git-leaks-4997b96c1cbe">5 Best Practices To Prevent Git Leaks</a>，如果有翻译不当的地方欢迎指正，希望能对你有所帮助。</p><hr><p>无数的开发人员正在使用 Git 进行版本控制，但是许多开发人员对 Git 的工作方式并没有足够的了解。有些人甚至将 Git 和 Github 用作备份文件的工具。这些做法导致 Git 仓库中的信息遭到泄露。<a href="https://www.zdnet.com/article/over-100000-github-repos-have-leaked-api-or-cryptographic-keys/">每天都有数千个新的 API 或加密密钥从 GitHub 泄漏出去。</a></p><p>我在信息安全领域工作了三年。 大约在两年前，我们公司发生了一起非常严重的安全问题，是由于 Git 仓库发生了信息泄露导致的。</p><p>一名员工意外地在 Github 上泄露了 AWS 的密钥。攻击者使用此密钥从我们的服务器下载很多敏感的数据。我们花了很多时间来解决这个问题，我们试图统计出泄漏了多少数据，并分析了受影响的系统和相关用户，最后替换了系统中所有泄漏的密钥。</p><p>这是一个任何公司和开发人员都不愿经历的悲惨故事。</p><p>关于整件事情的细节我就不多写了。事实上，我希望更多的人知道如何去避免 Git 的信息泄露。以下是我提出的一些建议。</p><h2 id="建立安全意识"><a href="#建立安全意识" class="headerlink" title="建立安全意识"></a>建立安全意识</h2><p>大多数新人开发者没有足够的安全意识。有些公司会培训新员工，但有些公司没有系统的培训。</p><p>作为开发人员，我们需要知道哪些数据可能会带来安全问题。千万记住，下面这些数据不要上传到 Git 仓库中：</p><ol><li>任何配置数据，包括密码，API 密钥，AWS 密钥和私钥等。</li><li><a href="https://en.wikipedia.org/wiki/Personal_data">个人身份信息</a>（PII）。根据 GDPR 的说法，如果公司泄露了用户的 PII，则该公司需要通知用户和有关部门，否则会带来更多的法律麻烦。</li></ol><p>如果你在公司工作，未经允许，请勿共享任何与公司相关的源代码或数据。</p><p>攻击者可以在 GitHub 上轻松地找到某些具有公司版权的代码，而这些代码都是被员工无意中泄露到 Github 上的。</p><p>我的建议是，应该将公司项目和个人项目严格区分。</p><h2 id="使用-Git-忽略（Git-ignore）"><a href="#使用-Git-忽略（Git-ignore）" class="headerlink" title="使用 Git 忽略（Git ignore）"></a>使用 Git 忽略（Git ignore）</h2><p>当我们使用 Git 创建一个新项目时，我们必须正确地设置一个 <strong>.gitignore</strong> 文件。**.gitignore** 是一个 Git 配置文件，它列出了不会被存入 Git 仓库的文件或目录。</p><p><a href="https://github.com/github/gitignore">这个 gitignore 项目</a> 是一个实际使用着的 .gitignore 模板集合，其中包含对应各种编程语言、框架、工具或环境的配置文件。</p><p>我们需要了解 <strong>gitignore</strong> 的模式匹配规则，并根据模板添加我们自己的规则。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz54rdlcej30ig09a3z4.jpg"></p><h2 id="使用-Git-钩子（Git-hooks）和-CI-检查提交"><a href="#使用-Git-钩子（Git-hooks）和-CI-检查提交" class="headerlink" title="使用 Git 钩子（Git hooks）和 CI 检查提交"></a>使用 Git 钩子（Git hooks）和 CI 检查提交</h2><p>没有工具可以从 Git 仓库中找出所有敏感数据，但是有一些工具可以为我们提供帮助。</p><p><a href="https://github.com/awslabs/git-secrets">git-secrets</a> 和 <a href="https://github.com/thoughtworks/talisman">talisman</a> 是类似的工具，它们应作为<a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">预提交的钩子</a>（pre-commit hooks）安装在本地代码库中。每次都会在提交之前对更改的内容进行检查，如果钩子检测到预期的提交内容可能包含敏感信息，那它们将会拒绝提交。</p><p><a href="https://github.com/zricethezav/gitleaks">gitleaks</a> 提供了另一种在 git 仓库中查找未加密的密钥和其他一些不需要的数据类型的方法。我们可以将其集成到自动化工作流程中，例如 CICD。</p><h2 id="代码审查（Code-review）"><a href="#代码审查（Code-review）" class="headerlink" title="代码审查（Code review）"></a>代码审查（Code review）</h2><p>代码审查是团队合作的最佳实践。所有队友都将从彼此的源代码中学习。初级开发人员的代码应由具有更多经验的开发人员进行审查。</p><p>在代码检查阶段可以发现大多数不符合预期的更改。</p><p><a href="https://help.github.com/en/github/administering-a-repository/enabling-branch-restrictions">启用分支限制</a> 可以强制执行分支限制，以便只有部分用户才能推送到代码库中受保护的分支。 Gitlab 也有类似的选择。</p><p>将 master 设置为受限制的分支有助于我们执行代码审查的工作。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz54uo36wj30uo0kkwhm.jpg"></p><h2 id="快速并且正确地修复它"><a href="#快速并且正确地修复它" class="headerlink" title="快速并且正确地修复它"></a>快速并且正确地修复它</h2><p>即使使用了上面提到的工具和方法，却仍然可能会发生错误。但如果我们快速且正确地修复它，则代码泄漏可能就不会引起实际的安全问题。</p><p>如果我们在 Git 仓库中发现了一些敏感数据泄漏，我们就不能仅仅通过提交另一个提交覆盖的方式来进行清理。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz54whw08j30nr09640d.jpg"></p><p>我们需要做的是从整个 Git 历史记录中删除所有敏感数据。</p><p><strong>在进行任何清理之前请记得进行备份，然后在确认一切正常后再删除备份文件。</strong></p><p>使用 <code>--mirror</code> 参数克隆一个仓库；这是 Git 数据库的完整副本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror git://example.com/need-clean-repo.git</span><br></pre></td></tr></table></figure><p>我们需要执行 <strong>git filter-branch</strong> 命令来从所有分支中删除数据并提交历史记录。</p><p>下面举个例子，假设我们要从 Git 中删除 <code>./config /passwd</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git filter-branch --force --index-filter \</span><br><span class="line">  <span class="string">&#x27;git rm --cached --ignore-unmatch ./config/password&#x27;</span> \</span><br><span class="line">  --prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure><p>请记住将敏感文件添加到 .gitignore 中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;./config/password&quot;</span> &gt;&gt; .gitignore</span><br><span class="line">$ git add .gitignore</span><br><span class="line">$ git commit -m <span class="string">&quot;Add password to .gitignore&quot;</span></span><br></pre></td></tr></table></figure><p>然后我们将所有分支推送到远端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push --force --all</span><br><span class="line">$ git push --force --tags</span><br></pre></td></tr></table></figure><p>告诉我们的小伙伴进行变基（rebase）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br></pre></td></tr></table></figure><p><a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG</a> 是一种比 <strong>git filter-branch</strong> 更快、更简单的用于删除敏感数据的替代方法。通常比 <strong>git filter-branch</strong> 快 10–720 倍。除删除文件外，BFG 还可以用于替换文件中的机密信息。</p><p>BFG 保留最新的提交记录。它是用来防止我们犯错误的。我们应该显式地删除文件，提交删除，然后清除历史记录以此删除它。</p><p>如果泄漏的 Git 代码库被其他人 fork 了，我们需要遵循 <a href="https://help.github.com/en/github/site-policy/dmca-takedown-policy#c-what-if-i-inadvertently-missed-the-window-to-make-changes">DMCA</a> 的删除策略，请求 Github 删除创建的代码库。</p><p>整个过程需要一些时间才能完成，但这是删除所有副本的唯一方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要犯无数人犯过的错误。尽力避免发生安全事故。</p><p>使用上面提到的这些工具和策略将有助于避免 Git 泄漏。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz5j3b96tj30go0goabc.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】模型优化</title>
      <link href="p/a92c.html"/>
      <url>p/a92c.html</url>
      
        <content type="html"><![CDATA[<p>在将机器学习模型部署到移动设备时， 推理效率是一个关键问题。 当训练的计算需求随着在不同体系结构上训练的模型的数量而增长时， 推理的计算需求与用户的数量正比增长。 Tensorflow模型优化工具包最大限度地降低了推理的复杂性 - 模型大小， 延迟和功耗。 </p><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>模型优化适用于：</p><ul><li><p>将模型部署到算力， 内存和功耗受限的边缘设备上。 例如， 移动设备和物联网（IoT）设备。 </p></li><li><p>减少无线模型更新的有效负载大小。</p></li><li><p>在由定点操作约束的硬件上执行。</p></li><li><p>优化专用硬件加速器的模型。</p></li></ul><a id="more"></a><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>模型优化使用的多种技术：</p><ul><li>减少参数的数量， 例如剪枝和结构化剪枝。</li><li>降低表示精度， 例如量化。</li><li>通过减少参数或快速执行将原始模型拓扑更新为更有效的拓扑， 例如， 张量分解方法和蒸馏。 </li></ul><h2 id="模型量化"><a href="#模型量化" class="headerlink" title="模型量化"></a>模型量化</h2><p>使用允许降低权重的精确表示并且可选地， 存储和计算的激活方式来量化深度神经网络。 量化有以下几个好处： </p><ul><li>支持在已有的 CPU 平台上运行。 </li><li>量化激活降低了读取和存储中间激活器的存储器访问成本。 </li><li>许多 CPU 和硬件加速器实现提供 SIMD 指令功能， 这对量化特别有帮助。 </li></ul><p><a href="../lite">TensorFlow Lite</a>  为量化提供了几个级别的支持。 </p><p><a href="post_training_quantization.md">Post-training 量化</a> 将权重和激活量化为训练后， 且使用简单。 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/quantize/README.md">Quantization-aware training</a>{:. 额外的} 考虑到训练网络可以以最小的准确率下降来量化， 而且只是对卷积神经网络结构的一个子集有用。 </p><h3 id="延迟和准确率结果"><a href="#延迟和准确率结果" class="headerlink" title="延迟和准确率结果"></a><strong>延迟和准确率结果</strong></h3><p>下边是在几个模型上进行了 post-training quantization 和 quantization-aware training 的延迟和准确率的结果。 所有的延迟在单核处理器的 Pixel 2 上测得。 随着不同的组合配置， 数据结果展示如下： </p><figure>  <table><pre><code>&lt; tr &gt;    &lt;    th &gt; Model &lt; /th&gt; &lt;th &gt; Top - 1 Accuracy(Original) &lt; /th&gt; &lt;th &gt; Top - 1 Accuracy(Post Training Quantized) &lt; /th&gt; &lt;th &gt; Top - 1 Accuracy(Quantization Aware Training) &lt; /th&gt; &lt;th &gt; Latency(Original)(ms) &lt; /th&gt; &lt;th &gt; Latency(Post Training Quantized)(ms) &lt; /th&gt; &lt;th &gt; Latency(Quantization Aware Training)(ms) &lt; /th&gt; &lt;th &gt; Size(Original)(MB) &lt; /th&gt; &lt;th &gt; Size(Optimized)(MB) &lt; /th&gt; &lt; /    tr &gt; &lt;    tr &gt; &lt; td &gt; Mobilenet - v1 - 1 - 224 &lt; /td&gt;&lt;td&gt;0.709&lt;/td &gt; &lt; td &gt; 0.657 &lt; /td&gt;&lt;td&gt;0.70&lt;/td &gt;    &lt;    td &gt; 180 &lt; /td&gt;&lt;td&gt;145&lt;/td &gt; &lt; td &gt; 80.2 &lt; /td&gt;&lt;td&gt;16.9&lt;/td &gt; &lt; td &gt; 4.3 &lt; /td&gt;&lt;/tr &gt;    &lt;    tr &gt; &lt; td &gt; Mobilenet - v2 - 1 - 224 &lt; /td&gt;&lt;td&gt;0.719&lt;/td &gt; &lt; td &gt; 0.637 &lt; /td&gt;&lt;td&gt;0.709&lt;/td &gt;    &lt;    td &gt; 117 &lt; /td&gt;&lt;td&gt;121&lt;/td &gt; &lt; td &gt; 80.3 &lt; /td&gt;&lt;td&gt;14&lt;/td &gt; &lt; td &gt; 3.6 &lt; /td&gt;&lt;/tr &gt;</code></pre>   <tr><td>Inception_v3</td><td>0.78</td><td>0.772</td><td>0.775</td><pre><code>  &lt; td &gt; 1585 &lt; /td&gt;&lt;td&gt;1187&lt;/td &gt; &lt; td &gt; 637 &lt; /td&gt;&lt;td&gt;95.7&lt;/td &gt; &lt; td &gt; 23.9 &lt; /td&gt;&lt;/tr &gt;</code></pre>   <tr><td>Resnet_v2_101</td><td>0.770</td><td>0.768</td><td>N/A</td><pre><code>  &lt; td &gt; 3973 &lt; /td&gt;&lt;td&gt;2868&lt;/td &gt; &lt; td &gt; N / A &lt; /td&gt;&lt;td&gt;178.3&lt;/td &gt; &lt; td &gt; 44.9 &lt; /td&gt;&lt;/tr &gt;</code></pre> </table>  <figcaption><pre><code>&lt; b &gt; 表格 1 &lt; /b&gt; 选择 CNN 模型的模型量化的好处</code></pre>  </figcaption></figure><h2 id="量化工具的选择"><a href="#量化工具的选择" class="headerlink" title="量化工具的选择"></a>量化工具的选择</h2><p>当你开始时， 请检查 tensorflow lite 模型存储库中的模型是否适用于你的应用。 如果不适用， 我们建议用户从 post-training 量化工具开始， 因为它适用性强且无需训练数据。 对于那些不满足准确率和延迟要求的， 或硬件加速器支持很重要的情况下， quantization-aware training 是一个更好的选择。 </p><p>注意： Quantization-aware training 支持卷积神经网络架构的子集。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Flutter 挑战之 WhatsApp</title>
      <link href="p/349f.html"/>
      <url>p/349f.html</url>
      
        <content type="html"><![CDATA[<p>Flutter Challenges 是一项尝试利用 Flutter 重新创建特定的应用程序 UI 或设计的挑战。<br>此次挑战将尝试 Whatsapp Android 应用程序的主界面。 请注意将重点放在 UI 上而不是实际获取消息。</p><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>WhatsApp 的主界面包括：</p><ol><li>一个带有搜索操作和菜单的 AppBar</li><li>在 AppBar 的底部有四个标签</li><li>一个用于拍照的相机标签</li><li>一个用于多种用途的 FloatingActionButton</li><li>一个“聊天”标签可查看所有对话</li><li>一个“状态”选项卡可查看所有状态</li><li>一个“打电话”选项卡可查看所有的通话记录</li></ol><a id="more"></a><h4 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h4><p>让我们创建一个名为 whatsapp_ui 的 Flutter 项目并删除所有默认代码， 只留下一个带有默认应用栏的空白屏幕。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main() &#x3D;&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        return new MaterialApp(</span><br><span class="line">            title: &#39;Flutter Demo&#39;,</span><br><span class="line">            theme: new ThemeData(</span><br><span class="line">                primarySwatch: Colors.blue,</span><br><span class="line">            ),</span><br><span class="line">            home: new MyHomePage(),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line"></span><br><span class="line">    @override</span><br><span class="line">    _MyHomePageState createState() &#x3D;&gt; new _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyHomePageState extends State &lt; MyHomePage &gt; &#123;</span><br><span class="line"></span><br><span class="line">    @override</span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        return new Scaffold(</span><br><span class="line">            appBar: new AppBar(</span><br><span class="line">                title: new Text(&quot;WhatsApp&quot;),</span><br><span class="line">            ),</span><br><span class="line">            body: new Center(</span><br><span class="line">                child: new Column(</span><br><span class="line">                    mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                    children: &lt; Widget &gt; [</span><br><span class="line"></span><br><span class="line">                    ],</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="The-AppBar"><a href="#The-AppBar" class="headerlink" title="The AppBar"></a>The AppBar</h4><p>AppBar 具有应用程序的标题， 以及两个操作： 搜索和菜单。</p><p>将其添加到 AppBar 中，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appBar: new AppBar(</span><br><span class="line">    title: new Text(&quot;WhatsApp&quot;, style: TextStyle(color: Colors.white, fontSize: 22.0, fontWeight: FontWeight.w600), ),</span><br><span class="line">    actions: &lt; Widget &gt; [</span><br><span class="line">        Padding(</span><br><span class="line">            padding: const EdgeInsets.only(right: 20.0),</span><br><span class="line">                child: Icon(Icons.search),</span><br><span class="line">        ),</span><br><span class="line">        Padding(</span><br><span class="line">            padding: const EdgeInsets.only(right: 16.0),</span><br><span class="line">                child: Icon(Icons.more_vert),</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">    backgroundColor: whatsAppGreen,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>代码结果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/1653139964ee8954?w=1073&h=142&f=png&s=9468"></p><p>现在继续</p><h4 id="The-Tabs"><a href="#The-Tabs" class="headerlink" title="The Tabs"></a>The Tabs</h4><p>tabs（选项卡）是 AppBar 的简单扩展， Flutter 使它们非常容易实现。</p><p>AppBar 有一个“底部”字段， 用于保存我们的标签：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bottom: TabBar(</span><br><span class="line">    tabs: [</span><br><span class="line">        Tab(icon: Icon(Icons.camera_alt), ),</span><br><span class="line">        Tab(child: Text(&quot;CHATS&quot;), ),</span><br><span class="line">        Tab(child: Text(&quot;STATUS&quot;, )),</span><br><span class="line">        Tab(child: Text(&quot;CALLS&quot;, )),</span><br><span class="line">    ], indicatorColor: Colors.white,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>此外， 我们需要一个 TabController 来实现这一点。</p><p>创建一个新的 TabController。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TabController tabController;</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: implement initState</span><br><span class="line">    super.initState();</span><br><span class="line"></span><br><span class="line">    tabController &#x3D; TabController(vsync: this, length: 4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在将该控制器添加到 TabBar 的 “controller” 字段中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bottom: TabBar(</span><br><span class="line">    tabs: [</span><br><span class="line">        Tab(icon: Icon(Icons.camera_alt), ),</span><br><span class="line">        Tab(child: Text(&quot;CHATS&quot;), ),</span><br><span class="line">        Tab(child: Text(&quot;STATUS&quot;, )),</span><br><span class="line">        Tab(child: Text(&quot;CALLS&quot;, )),</span><br><span class="line">    ], indicatorColor: Colors.white,</span><br><span class="line">    controller: tabController,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>而对于 TabBarView</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: TabBarView(</span><br><span class="line">    controller: tabController,</span><br><span class="line">    children: [</span><br><span class="line">        Icon(Icons.camera_alt),</span><br><span class="line">        Text(&quot;Chat Screen&quot;),</span><br><span class="line">        Text(&quot;Status Screen&quot;),</span><br><span class="line">        Text(&quot;Call Screen&quot;),</span><br><span class="line">    ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/165313996933669e?w=1076&h=280&f=png&s=17766"></p><p>现在， 在转到各个页面之前， 我们将添加选项卡所代表的页面。 用以下方法切换脚手架的现有“正文”代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: TabBarView(</span><br><span class="line">    children: [</span><br><span class="line">        Icon(Icons.camera_alt),</span><br><span class="line">        Text(&quot;Chat Screen&quot;),</span><br><span class="line">        Text(&quot;Status Screen&quot;),</span><br><span class="line">        Text(&quot;Call Screen&quot;),</span><br><span class="line">    ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>子项代表选项卡所用的页面。 现在整个页面都是一个 Text 小部件。</p><h4 id="悬浮按钮"><a href="#悬浮按钮" class="headerlink" title="悬浮按钮"></a>悬浮按钮</h4><p>Floating Action Button 根据屏幕上的页面而变化。</p><p>首先在脚手架中添加一个 FloatingActionButton。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">    onPressed: () &#123;&#125;,</span><br><span class="line">    child: fabIcon,</span><br><span class="line">    backgroundColor: whatsAppGreenLight,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>“fabIcon” 字段只存储要显示的图标， 因为我们需要根据显示的屏幕更改显示的图标。</p><p>要监听选项卡选定的更改， 需要给 TabController 添加一个监听器。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tabController &#x3D; TabController(vsync: this, length: 4)..addListener(() &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在， 当标签控制器实现页面已更改时， 请更改 FAB 图标。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tabController &#x3D; TabController(vsync: this, length: 4)..addListener(() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">        switch (tabController.index) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                fabIcon &#x3D; Icons.message;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                fabIcon &#x3D; Icons.camera_enhance;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                fabIcon &#x3D; Icons.call;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/165313a02db535b4?w=1080&h=1920&f=png&s=60991"></p><p>继续，</p><h4 id="聊天界面"><a href="#聊天界面" class="headerlink" title="聊天界面"></a>聊天界面</h4><p>聊天屏幕有一个我们需要显示的消息列表。 要创建消息列表， 我们使用 ListView.builder() 并构造我们的项目。</p><p>让我们来看看聊天界面的列表项。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/165313996a8bae05?w=656&h=160&f=png&s=30988"></p><p>最外面的小部件是一行图标和另一行</p><p>第二行内部是一列， 包含一行和一个文本小部件。</p><p>该行具有标题和消息日期。</p><p>让我们构建一个聊天项模型作为用于存储列表项详细信息的类。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ChatItemModel &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    String mostRecentMessage;</span><br><span class="line">    String messageDate;</span><br><span class="line"></span><br><span class="line">    ChatItemModel(this.name, this.mostRecentMessage, this.messageDate);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在， 为简洁起见， 我省略了添加个人资料图片。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">itemBuilder: (context, position) &#123;</span><br><span class="line">    ChatItemModel chatItem &#x3D; ChatHelper.getChatItem(position);</span><br><span class="line"></span><br><span class="line">    return Column(</span><br><span class="line">        children: &lt; Widget &gt; [</span><br><span class="line">            Padding(</span><br><span class="line">                padding: const EdgeInsets.all(8.0),</span><br><span class="line">                    child: Row(</span><br><span class="line">                        children: &lt; Widget &gt; [</span><br><span class="line">                            Icon(</span><br><span class="line">                                Icons.account_circle,</span><br><span class="line">                                size: 64.0,</span><br><span class="line">                            ),</span><br><span class="line">                            Expanded(</span><br><span class="line">                                child: Padding(</span><br><span class="line">                                    padding: const EdgeInsets.all(8.0),</span><br><span class="line">                                        child: Column(</span><br><span class="line">                                            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                                            children: &lt; Widget &gt; [</span><br><span class="line">                                                Row(</span><br><span class="line">                                                    mainAxisAlignment:</span><br><span class="line">                                                    MainAxisAlignment.spaceBetween,</span><br><span class="line">                                                    children: &lt; Widget &gt; [</span><br><span class="line">                                                        Text(</span><br><span class="line">                                                            chatItem.name,</span><br><span class="line">                                                            style: TextStyle(</span><br><span class="line">                                                                fontWeight: FontWeight.w500,</span><br><span class="line">                                                                fontSize: 20.0),</span><br><span class="line">                                                        ),</span><br><span class="line">                                                        Text(</span><br><span class="line">                                                            chatItem.messageDate,</span><br><span class="line">                                                            style: TextStyle(color: Colors.black45),</span><br><span class="line">                                                        ),</span><br><span class="line">                                                    ],</span><br><span class="line">                                                ),</span><br><span class="line">                                                Padding(</span><br><span class="line">                                                    padding: const EdgeInsets.only(top: 2.0),</span><br><span class="line">                                                        child: Text(</span><br><span class="line">                                                            chatItem.mostRecentMessage,</span><br><span class="line">                                                            style: TextStyle(</span><br><span class="line">                                                                color: Colors.black45, fontSize: 16.0),</span><br><span class="line">                                                        ),</span><br><span class="line">                                                )</span><br><span class="line">                                            ],</span><br><span class="line">                                        ),</span><br><span class="line">                                ),</span><br><span class="line">                            )</span><br><span class="line">                        ],</span><br><span class="line">                    ),</span><br><span class="line">            ),</span><br><span class="line">            Divider(),</span><br><span class="line">        ],</span><br><span class="line">    );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>创建第一个列表后， 结果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/165313996c68741b?w=1080&h=1920&f=png&s=139052"></p><p>我们可以类似地在其他屏幕上的屏幕上创建其他选项卡。 完整的示例托管在 GitHub 上。</p><p>GitHub 链接 : <a href="https://github.com/deven98/WhatsappFlutter">https://github.com/deven98/WhatsappFlutter</a></p><p>感谢您阅读此 Flutter 挑战。 随意提及您可能想要在 Flutter 中重新创建的任何应用程序。 如果你喜欢它， 一定要留下掌声， 再见。</p><p>不要忘了： <a href="https://blog.usejournal.com/flutter-challenge-the-medium-app-5f64a0f3c764">The Medium App in Flutter</a></p><blockquote><p>如果发现译文存在错误或其他需要改进的地方， 欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR， 也可获得相应奖励积分。 文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区， 文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。 内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、 <a href="https://github.com/xitu/gold-miner#ios">iOS</a>、 <a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、 <a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域， 想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、 <a href="http://weibo.com/juejinfanyi">官方微博</a>、 <a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】在Android上实现Google Inbox样式的动画</title>
      <link href="p/e593.html"/>
      <url>p/e593.html</url>
      
        <content type="html"><![CDATA[<p>作为一个 Android 用户和开发人员， 我总是被精美的应用程序所吸引， 这些应用程序具有漂亮而有意义的动画。 对我来说， 这样的应用程序不仅拥有了强大的功能， 使用户的生活更便捷， 同时还表现出他们背后的团队为了将用户体验提升一个层次所投入的精力和热情。 我经常享受体验这些动画， 然后花费数小时时间去试图复制它们。 其中一个应用程序是 Google Inbox， 它提供了一个漂亮的电子邮件打开/关闭动画， 如下所示（如果你不熟悉它）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gibby6y3a7g30b40jrqv8.gif"></p><p>在本文中， 我将带您体验在 Android 上复制动画的旅程。</p><hr><a id="more"></a><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>为了复制动画， 我构建了一个简单的带有 2 个 fragment 的应用程序 ， 如下所示分别是 Email List fragment 和 Email Details fragment。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a93505715c57?w=800&h=462&f=png&s=18116"></p><p>电子邮件列表 InProgress 状态（左）- 电子邮件列表 Success 状态（中）- 电子邮件详细信息（右）</p><p>为了模拟电子邮件获取网络请求， 我为 Email List fragment 创建了一个 <code>[ViewModel](https://developer.android.com/reference/android/arch/lifecycle/ViewModel)</code> ， 它生成了 2 个状态， <code>InProgress</code> 表示正在获取电子邮件， <code>Success</code> 表示电子邮件数据已成功获取并准备好呈现（网络请求被模拟为 2 秒）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sealed class State &#123;</span><br><span class="line">    object InProgress: State()</span><br><span class="line">    data class Success(val data: List &lt; String &gt; ): State()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Email List fragment 有一种方法来呈现这些状态， 如下所示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private fun render(state: State) &#123;</span><br><span class="line">        when(state) &#123;</span><br><span class="line">            is InProgress - &gt; &#123;</span><br><span class="line">                emailList.visibility &#x3D; GONE</span><br><span class="line">                progressBar.visibility &#x3D; VISIBLE</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            is Success - &gt; &#123;</span><br><span class="line">                emailList.visibility &#x3D; VISIBLE</span><br><span class="line">                progressBar.visibility &#x3D; GONE</span><br><span class="line">                emailAdapter.setData(state.data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>每当 Email List fragment 被新加载时， 都会获取电子邮件数据并呈现 <code>InProgress</code> 状态， 直到电子邮件数据可用（ <code>Success</code> 状态）。 点击电子邮件列表中的任何电子邮件项目将使用户进入 Email Details fragment， 并将用户从电子邮件详细信息中带回电子邮件列表。</p><p>现在开始我们的旅程吧…</p><h3 id="第一站-那是什么样的动画？"><a href="#第一站-那是什么样的动画？" class="headerlink" title="第一站 - 那是什么样的动画？"></a>第一站 - 那是什么样的动画？</h3><p>有一点是可以立刻确定的就是他是一种 <code>[Explode](https://developer.android.com/reference/android/transition/Explode)</code> 过渡动画， 因为在被点击的 item 上下的 item 有过度。 但是等一下， 电子邮件详细信息 view 也会从点击的电子邮件项目进行转换和扩展。 这意味着还有一个共享元素转换。 结合我说的， 下面是我做出的第一次尝试。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: EmailViewHolder, position: Int) &#123;</span><br><span class="line">    fun onViewClick() &#123;</span><br><span class="line">        val viewRect &#x3D; Rect()</span><br><span class="line">        holder.itemView.getGlobalVisibleRect(viewRect)</span><br><span class="line"></span><br><span class="line">        exitTransition &#x3D; Explode().apply &#123;</span><br><span class="line">            duration &#x3D; TRANSITION_DURATION</span><br><span class="line">            interpolator &#x3D; transitionInterpolator</span><br><span class="line">            epicenterCallback &#x3D; object: Transition.EpicenterCallback() &#123;</span><br><span class="line">                override fun onGetEpicenter(transition: Transition) &#x3D; viewRect</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val sharedElementTransition &#x3D; TransitionSet()</span><br><span class="line">            .addTransition(ChangeBounds())</span><br><span class="line">            .addTransition(ChangeTransform())</span><br><span class="line">            .addTransition(ChangeImageTransform()).apply &#123;</span><br><span class="line">                duration &#x3D; TRANSITION_DURATION</span><br><span class="line">                interpolator &#x3D; transitionInterpolator</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        val fragment &#x3D; EmailDetailsFragment().apply &#123;</span><br><span class="line">            sharedElementEnterTransition &#x3D; sharedElementTransition</span><br><span class="line">            sharedElementReturnTransition &#x3D; sharedElementTransition</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        activity!!.supportFragmentManager</span><br><span class="line">            .beginTransaction()</span><br><span class="line">            .setReorderingAllowed(true)</span><br><span class="line">            .replace(R.id.container, fragment)</span><br><span class="line">            .addToBackStack(null)</span><br><span class="line">            .addSharedElement(holder.itemView, getString(R.string.transition_name))</span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder.bindData(emails[position], ::onViewClick)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我得到的（电子邮件详细信息视图的背景设置为蓝色， 以便清楚地演示过渡效果）…</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a935b12d9548?w=400&h=710&f=gif&s=518370"></p><p>当然这不是我想要的。 这里有两个问题。</p><ol><li>电子邮件项目不会同时开始转换。 远离被点击条目的 items 过度的更快。</li><li>被点击的电子邮件项目上的共享元素转换与其他项目的转换不同步， 即， 当分别展开时， <code>Email 4</code> 和 <code>Email 6</code> 应始终粘贴在蓝色矩形的顶部和底部边缘。 但他们没有！</li></ol><p>所以究竟哪里出了问题？</p><h3 id="第二站：-开箱即用的-Explode-效果不是我想要的。"><a href="#第二站：-开箱即用的-Explode-效果不是我想要的。" class="headerlink" title="第二站： 开箱即用的 Explode 效果不是我想要的。"></a>第二站： 开箱即用的 Explode 效果不是我想要的。</h3><p>在深入研究 <code>Explode</code> 源代码后， 我发现了两个有趣的事实：</p><ul><li>它使用 <code>CircularPropagation</code> 来强制执行这样一条规则， 即， 当它们从屏幕上消失时， 离中心远的视图过渡速度会地比离中心近的视图快。 <code>Explode</code> 过渡的中心被设置为覆盖被点击的电子邮件项目的矩形。 这解释了为什么未打开的电子邮件项目视图不会如上所述一起转换。</li><li>电子邮件条目的上下距离和被点击的条目的上下距离是不一样的。 在这种特定情况下， 该距离被确定为从被点击项目的中心点到屏幕的每个角落的距离中最长的。</li></ul><p>所以我决定编写自己的 <code>Explode</code> 过渡。 我将它命名为 <code>SlideExplode</code> ， 因为它与 <code>Slide</code> 过渡非常相似， 只是有 2 个部分在 2 个相反的方向上移动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import android.animation.Animator</span><br><span class="line">import android.animation.ObjectAnimator</span><br><span class="line">import android.graphics.Rect</span><br><span class="line">import android.transition.TransitionValues</span><br><span class="line">import android.transition.Visibility</span><br><span class="line">import android.view.View</span><br><span class="line">import android.view.ViewGroup</span><br><span class="line"></span><br><span class="line">private</span><br><span class="line">const val KEY_SCREEN_BOUNDS &#x3D; &quot;screenBounds&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * A simple Transition which allows the views above the epic centre to transition upwards and views</span><br><span class="line"> * below the epic centre to transition downwards.</span><br><span class="line"> *&#x2F;</span><br><span class="line">class SlideExplode: Visibility() &#123;</span><br><span class="line">    private val mTempLoc &#x3D; IntArray(2)</span><br><span class="line"></span><br><span class="line">    private fun captureValues(transitionValues: TransitionValues) &#123;</span><br><span class="line">        val view &#x3D; transitionValues.view</span><br><span class="line">        view.getLocationOnScreen(mTempLoc)</span><br><span class="line">        val left &#x3D; mTempLoc[0]</span><br><span class="line">        val top &#x3D; mTempLoc[1]</span><br><span class="line">        val right &#x3D; left + view.width</span><br><span class="line">        val bottom &#x3D; top + view.height</span><br><span class="line">        transitionValues.values[KEY_SCREEN_BOUNDS] &#x3D; Rect(left, top, right, bottom)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun captureStartValues(transitionValues: TransitionValues) &#123;</span><br><span class="line">        super.captureStartValues(transitionValues)</span><br><span class="line">        captureValues(transitionValues)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun captureEndValues(transitionValues: TransitionValues) &#123;</span><br><span class="line">        super.captureEndValues(transitionValues)</span><br><span class="line">        captureValues(transitionValues)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onAppear(sceneRoot: ViewGroup, view: View,</span><br><span class="line">        startValues: TransitionValues ? , endValues : TransitionValues ? ): Animator ? &#123;</span><br><span class="line">        if (endValues &#x3D;&#x3D; null) return null</span><br><span class="line"></span><br><span class="line">        val bounds &#x3D; endValues.values[KEY_SCREEN_BOUNDS] as Rect</span><br><span class="line">        val endY &#x3D; view.translationY</span><br><span class="line">        val startY &#x3D; endY + calculateDistance(sceneRoot, bounds)</span><br><span class="line">        return ObjectAnimator.ofFloat(view, View.TRANSLATION_Y, startY, endY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDisappear(sceneRoot: ViewGroup, view: View,</span><br><span class="line">        startValues: TransitionValues ? , endValues : TransitionValues ? ): Animator ? &#123;</span><br><span class="line">        if (startValues &#x3D;&#x3D; null) return null</span><br><span class="line"></span><br><span class="line">        val bounds &#x3D; startValues.values[KEY_SCREEN_BOUNDS] as Rect</span><br><span class="line">        val startY &#x3D; view.translationY</span><br><span class="line">        val endY &#x3D; startY + calculateDistance(sceneRoot, bounds)</span><br><span class="line">        return ObjectAnimator.ofFloat(view, View.TRANSLATION_Y, startY, endY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun calculateDistance(sceneRoot: View, viewBounds: Rect): Int &#123;</span><br><span class="line">        sceneRoot.getLocationOnScreen(mTempLoc)</span><br><span class="line">        val sceneRootY &#x3D; mTempLoc[1]</span><br><span class="line">        return when &#123;</span><br><span class="line">            epicenter &#x3D;&#x3D; null - &gt; -sceneRoot.height</span><br><span class="line">            viewBounds.top &lt;&#x3D; epicenter.top - &gt; sceneRootY - epicenter.top</span><br><span class="line">            else - &gt; sceneRootY + sceneRoot.height - epicenter.bottom</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我已经为 <code>SlideExplode</code> 交换了 <code>Explode</code> ， 让我们再试一次。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a935b474510f?w=400&h=710&f=gif&s=689896"></p><p>这样就好多了！ 上面和下面的项目现在开始同时转换。 请注意， 由于插值器设置为 <code>FastOutSlowIn</code> ， 因此当 <code>Email 4</code> 和 <code>Email 6</code> 分别靠近顶部和底部边缘时， 它们会减慢速度。 这表明 <code>SlideExplode</code> 过渡正常。</p><p>但是， <code>Explode</code> 转换和共享元素转换仍未同步。 我们可以看到他们正在以不同的模式移动， 这表明他们的插值器可能不同。 前一个过渡开始非常快， 最后减速， 而后者一开始很慢， 一段时间后加速。</p><p>但是怎么样？ 我确实在代码中将插值器设置相同了！</p><h3 id="第三站：-原来是-TransitionSet-的锅！"><a href="#第三站：-原来是-TransitionSet-的锅！" class="headerlink" title="第三站： 原来是 TransitionSet 的锅！"></a>第三站： 原来是 TransitionSet 的锅！</h3><p>我再次深入研究源代码。 这次我发现每当我将插值器设置为 <code>TransitionSet</code> 时， 它都不会在过渡的时候将插值器分配给它。 这仅在标准 <code>TransitionSet中</code> 发生。 它的支持版本（ <code>android.support.transition.TransitionSet</code> ）正常工作。 要解决此问题， 我们可以切换到支持版本， 或者使用下面的扩展函数将插值器明确地传递给包含的转换。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun TransitionSet.setCommonInterpolator(interpolator: Interpolator): TransitionSet &#123;</span><br><span class="line">    (0 until transitionCount)</span><br><span class="line">    .map &#123;</span><br><span class="line">        index - &gt; getTransitionAt(index)</span><br><span class="line">    &#125;</span><br><span class="line">    .forEach &#123;</span><br><span class="line">        transition - &gt; transition.interpolator &#x3D; interpolator</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们在更新插值器的设置后再试一次。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a93760065403?w=400&h=710&f=gif&s=551485"></p><p>YAYYYY！ 现在看起来很正确。 但反向过渡怎么样？</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a935bc91825b?w=400&h=710&f=gif&s=599740"></p><p>没有达到我想要的结果！ Explode 过渡似乎有效。 但是， 共享元素过渡没有。</p><h3 id="第四站：-推迟进入转换"><a href="#第四站：-推迟进入转换" class="headerlink" title="第四站： 推迟进入转换"></a>第四站： 推迟进入转换</h3><p>反向过渡动画不起作用的原因是它发挥得太早。 对于任何过渡的工作， 它需要捕获目标视图的开始和结束状态（大小， 位置， 范围）， 在这种情况下， 它们是 <code>Email Details</code> 视图和 <code>Email 5 item</code> 项。 如果在 <code>Email 5 item</code> 的状态可用之前启动了反向转换， 则它将无法像我们所看到的那样正常运行。</p><p>这里的解决方案是推迟反向转换， 直到 items 都被绘制完。 幸运的是， transition 框架提供了一对 <code>postponeEnterTransition</code> 方法， 它向系统标记输入过渡应该被推迟， <code>startPostponedEnterTransition</code> 表示它可以启动。 请注意， 必须在调用 <code>startPostponedEnterTransition</code> 后的某个时间调用 <code>postponeEnterTransition</code> 。 否则， 将永远不会执行过渡动画， 并且 fragment 也不会弹出。</p><p>根据我们的设置， 每当从 Email Details fragment 重新进入 Email List fragment 时， 它会从 view model 中获取最新状态并立即呈现电子邮件列表。 因此， 如果我们推迟过渡动画， 直到呈现电子邮件列表， 等待时间不会太长（从死进程中恢复并弹出是一个不同的情况。 这将在后面的帖子中介绍）。</p><p>更新后的代码如下所示。 我们推迟了 <code>onViewCreated</code> 中的 enter 转换。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onViewCreated(view: View, savedState: Bundle ? ) &#123;</span><br><span class="line">    super.onViewCreated(view, savedInstanceState)</span><br><span class="line">    postponeEnterTransition()</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在渲染状态后开始推迟过渡。 这是使用 <a href="https://android.github.io/android-ktx/core-ktx/androidx.view/android.view.-view/do-on-pre-draw.html">doOnPreDraw</a> 完成的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is Success - &gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    (view ? .parent as ? ViewGroup) ? .doOnPreDraw &#123;</span><br><span class="line">        startPostponedEnterTransition()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a937545005dd?w=400&h=710&f=gif&s=588609"></p><p>现在它成功了！ 但当方向变换时这个过度效果还会存在吗？</p><h3 id="第五站：-位置方向改变"><a href="#第五站：-位置方向改变" class="headerlink" title="第五站： 位置方向改变"></a>第五站： 位置方向改变</h3><p>转换后， Email List fragment 并没有发生反转过渡动画。 经过一些调试后， 我发现当 fragment 的方向发生改变时， 过渡动画也被销毁了。 因此， 应在 fragment 被销毁后重新创建过渡动画。 此外， 由于屏幕尺寸和 UI 差异， <code>Explode</code> 的过渡中心在纵向和横向模式下通常是不相同的。 因此我们也需要更新中心区域。</p><p>这要求我们跟踪点击项目的位置并在方向更改时重新记录， 这将导致更新的代码如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onViewCreated(view: View, savedState: Bundle ? ) &#123;</span><br><span class="line">        super.onViewCreated(view, savedState)</span><br><span class="line">        tapPosition &#x3D; savedState ? .getInt(TAP_POSITION, NO_POSITION) ? : NO_POSITION</span><br><span class="line">        postponeEnterTransition()</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    private fun render(state: State) &#123;</span><br><span class="line">        when(state) &#123;</span><br><span class="line">            ...</span><br><span class="line">            is Success - &gt; &#123;</span><br><span class="line">                ...</span><br><span class="line">                (view ? .parent as ? ViewGroup) ? .doOnPreDraw &#123;</span><br><span class="line">                    if (exitTransition &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        exitTransition &#x3D; SlideExplode().apply &#123;</span><br><span class="line">                            duration &#x3D; TRANSITION_DURATION</span><br><span class="line">                            interpolator &#x3D; transitionInterpolator</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    val layoutManager &#x3D; emailList.layoutManager as LinearLayoutManager</span><br><span class="line">                    layoutManager.findViewByPosition(tapPosition) ? .let &#123;</span><br><span class="line">                        view - &gt;</span><br><span class="line">                            view.getGlobalVisibleRect(viewRect)</span><br><span class="line">                            (exitTransition as Transition).epicenterCallback &#x3D;</span><br><span class="line">                            object: Transition.EpicenterCallback() &#123;</span><br><span class="line">                                override fun onGetEpicenter(transition: Transition) &#x3D; viewRect</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    startPostponedEnterTransition()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    override fun onSaveInstanceState(outState: Bundle) &#123;</span><br><span class="line">        super.onSaveInstanceState(outState)</span><br><span class="line">        outState.putInt(TAP_POSITION, tapPosition)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="第六站：-处理-Activity-被销毁和进程被杀死的情况"><a href="#第六站：-处理-Activity-被销毁和进程被杀死的情况" class="headerlink" title="第六站： 处理 Activity 被销毁和进程被杀死的情况"></a>第六站： 处理 Activity 被销毁和进程被杀死的情况</h3><p>过渡动画现在可以在方向变化中存活， 但在 activity 被销毁或者进程被杀死时又会有什么样的效果呢？ 在我们的特定方案中， 电子邮件列表 viewModel 在任何一种情况下都不存活， 因此电子邮件数据也不存在。 我们的转换取决于所点击的电子邮件项目的位置， 因此如果数据丢失则无法使用。</p><p>奇怪的是， 我查看了几个著名的应用程序， 看看它们在这种情况下如何处理转换：</p><ul><li>Google Inbox： 有趣的是， 它不需要处理这种情况， 因为它会在活动被销毁后重新加载电子邮件列表（而不是电子邮件详细信息）。</li><li>Google Play： 活动销毁或处理死亡后没有反向共享元素转换。</li><li>Plaid (不是一个真正的应用程序， 但却是 Android 上的一个优秀的 material design 的 demo）： 即使在方向改变之后（截至编写时）， 也没有反向共享元素过渡。</li></ul><p>虽然上面的列表没有足够的结论来处理 Android 应用程序在这种情况下处理转换的模式， 但它至少显示了一些观点。</p><p>回到我们的具体问题， 通常有两种可能性取决于每个应用程序处理此类情况的方法： （1）忽略丢失的数据并重新获取数据， 以及（2）保留数据并恢复数据。 由于这篇文章主要是关于过渡动画， 所以我不打算讨论在什么情况下哪种方法更好以及为什么等。 如果采用方法（1）， 则不应该进行反向转换， 因为我们不知道先前被点击的电子邮件项目是否会被取回， 即使知道， 我们不知道它在列表中的位置。 如果采用方法（2）， 我们可以像定向改变方案那样进行转换。</p><p>方法（1）是我在这种特定情况下的偏好， 因为新的电子邮件可能每分钟都会出现， 因此在活动销毁或处理死亡之后重新加载过时的电子邮件列表是没有用的， 这通常发生在用户离开应用程序一段时间之后。 在我们的设置中， 当 activity 被销毁或进程被杀死后后重新创建电子邮件列表片段时， 将自动获取电子邮件数据， 因此不需要做太多工作。 我们只需要确保在呈现 <code>InProgress</code> 状态时调用 <code>startPostponedEnterTransition</code> ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is InProgress - &gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    (view ? .parent as ? ViewGroup) ? .doOnPreDraw &#123;</span><br><span class="line">        startPostponedEnterTransition()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第七站：-让过渡动画更加平滑"><a href="#第七站：-让过渡动画更加平滑" class="headerlink" title="第七站： 让过渡动画更加平滑"></a>第七站： 让过渡动画更加平滑</h3><p>到目前为止, 我们已经有了一个基本的 “Inbox style” 过渡。 有很多方法实现平滑。 一个例子是在展开细节时呈现淡入效果， 类似于收件箱应用程序的功能。 这可以通过以下方式实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class EmailDetailsFragment: Fragment() &#123;</span><br><span class="line">    ...</span><br><span class="line">    override fun onViewCreated(view: View, savedState: Bundle ? ) &#123;</span><br><span class="line">        super.onViewCreated(view, savedState)</span><br><span class="line"></span><br><span class="line">        val content &#x3D; view.findViewById &lt; View &gt; (R.id.content).also &#123;</span><br><span class="line">            it.alpha &#x3D; 0 f</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectAnimator.ofFloat(content, View.ALPHA, 0 f, 1 f).apply &#123;</span><br><span class="line">            startDelay &#x3D; 50</span><br><span class="line">            duration &#x3D; 150</span><br><span class="line">            start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过渡动画现在看起来如下。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a9377323f0a1?w=400&h=711&f=gif&s=456214"></p><h3 id="他已经被完全复制了吗？"><a href="#他已经被完全复制了吗？" class="headerlink" title="他已经被完全复制了吗？"></a>他已经被完全复制了吗？</h3><p>基本上是。 唯一缺少的是能够垂直滑动电子邮件详细信息视图以显示电子邮件列表中的其他电子邮件， 并通过释放手指触发反向过渡， 就和下面的 GIF 图所展示的效果一样。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a937bb74b158?w=400&h=711&f=gif&s=5773760"></p><p>这样的动画对我来说很有意义， 因为如果用户可以点击电子邮件项目来打开/展开它， 他自然会拖下电子邮件详细信息来隐藏/折叠它。 目前我正在探索实现这种效果的几个选项， 它们将在下一篇文章中讨论。</p><hr><p>那就这样吧。 实现动画是 Android 开发中一个具有挑战性但又有趣的部分。 我希望你喜欢和我一样喜欢动画。 源代码可以在<a href="https://github.com/huan-nguyen/InboxStyleAnimation">这里</a>找到。 欢迎提出反馈/意见/讨论！</p><ul><li><a href="https://proandroiddev.com/tagged/android?source=post">Android</a></li><li><a href="https://proandroiddev.com/tagged/transitions?source=post">Transitions</a></li><li><a href="https://proandroiddev.com/tagged/animation?source=post">Animation</a></li><li><a href="https://proandroiddev.com/tagged/material-design?source=post">Material</a></li></ul><blockquote><p>如果发现译文存在错误或其他需要改进的地方， 欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR， 也可获得相应奖励积分。 文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区， 文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。 内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、 <a href="https://github.com/xitu/gold-miner#ios">iOS</a>、 <a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、 <a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域， 想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、 <a href="http://weibo.com/juejinfanyi">官方微博</a>、 <a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】在 Android 应用中使用矢量资源</title>
      <link href="p/6804.html"/>
      <url>p/6804.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a30ca76e5ad48?w=4000&h=1190&f=png&s=66173" alt="Illustration by [Virginia Poltrack](https://twitter.com/VPoltrack)"></p><p>在之前的文章中， 我们研究了 Android 的 <code>VectorDrawable</code> 图像格式以及它能够实现的功能：</p><ul><li><p><a href="https://medium.com/androiddevelopers/understanding-androids-vector-image-format-vectordrawable-ab09e41d5c68"><strong>Understanding Android’s vector image format: VectorDrawable</strong>: Android devices come in all sizes, shapes and screen densities. That’s why I’m a huge fan of using resolution…</a></p></li><li><p><a href="https://medium.com/androiddevelopers/draw-a-path-rendering-android-vectordrawables-89a33b5e5ebf"><strong>Draw a Path: Rendering Android VectorDrawables</strong>: In the previous article, we looked at Android’s VectorDrawable format, going into its benefits and capabilities.</a></p></li></ul><p>在这篇文章中， 我们将会深入研究如何在你的 app 中应用这些矢量资源。 <code>VectorDrawable</code> 是在 Lollipop（API 21）中引入的， 也可以在 AndroidX 中使用（作为 <code>VectorDrawableCompat</code> ）， 可以向下兼容到 API 14（这使其可以覆盖超过 <a href="https://developer.android.com/about/dashboards/">99％ 的设备</a>）。 本文将概述一些能真正在你的应用中使用 <code>VectorDrawables</code> 的建议。</p><h2 id="首先是-AndroidX"><a href="#首先是-AndroidX" class="headerlink" title="首先是 AndroidX"></a>首先是 AndroidX</h2><p>从 Lollipop 开始， 你可以在任何需要使用其他可绘制类型的地方使用 <code>VectorDrawables</code> （使用标准的 <code>@drawable/foo</code> 语法引用它们）， 但是我建议<strong>始终</strong>使用 AndroidX 实现。</p><p>这会显著增加其使用平台的范围， 不仅如此， 它还支持将特性和 bug 修复程序向后移植到旧平台。 例如， 使用 AndroidX 中的 <code>VectorDrawableCompat</code> 可以：</p><ul><li><code>nonZero</code> 和 <code>evenOdd</code> 路径 <code>fillTypes</code> —— <a href="https://www.sitepoint.com/understanding-svg-fill-rule-property/">定义形状“内部”</a>的两种常见方法， 通常用于 SVGs（ <code>evenOdd</code> 在 API 24 中得以实现）</li><li>渐变（Gradient）&amp; <code>ColorStateList</code> 填充 / 画笔（在 API 24 中被添加实现）</li><li>Bug 修复</li></ul><p>事实上， AndroidX 将使用 compat 实现， 甚至在一些存在本地实现的平台上（<a href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/appcompat/src/main/java/androidx/appcompat/widget/AppCompatDrawableManager.java#100">当前是 api 21-23</a>）也可以实现上述优点。 否则， 它将委托给平台实现， 因此仍然可以接收对新版本的任何改进（例如， 为了提高性能， <code>VectorDrawable</code> 在 API 24 的 C 中重新实现)。</p><p>基于这些原因， 你应该<strong>始终</strong>使用 AndroidX， 即使你很幸运地将你的 <code>minSdkVersion</code> 设置成 24。 这没什么不好的， 如果/当 <code>VectorDrawable</code> 在未来扩展了新的功能， 并且它们也被添加到 AndroidX 中， 那么它们就可以直接使用， 而不需要重新检查代码。</p><p><a href="undefined">Alex Lockwood</a> <strong>是这么说的</strong>：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a30ca4b5aa12d?w=1100&h=714&f=png&s=110251"></p><h2 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h2><p>为了使用 AndroidX 矢量支持（AndroidX vector support）， 你需要做 2 件事情：</p><h3 id="1-开启支持"><a href="#1-开启支持" class="headerlink" title="1. 开启支持"></a>1. 开启支持</h3><p>您需要在应用的 <code>build.gradle</code> 中选择加入 <code>AndroidX</code> 矢量支持：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        vectorDrawables.useSupportLibrary &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>minSdkVersion</code> &lt; 21， 这意味着 Android Gradle 插件无法<a href="https://developer.android.com/studio/write/vector-asset-studio#apilevel">生成矢量资源的 PNG 版本</a> —— 如果我们使用 AndroidX 库的话就不用担心这个问题。</p><p>通过默认的 <a href="https://developer.android.com/studio/command-line/aapt2">AAPT</a>（Android 资产包装工具）版本资源。 它也被传递给构建工具链。 这意味着， 如果你在 <code>res/drawable/</code> 中声明一个 <code>VectorDrawable</code> ， 它会为你将其自动移动到 <code>res/drawable-v21/</code> ， 因为系统知道这就是 <code>VectorDrawable</code> 类被引入的时候。</p><blockquote><p>这可以防止属性 ID 冲突 —— 在 <code>VectorDrawables</code> 中使用的属性（ <code>android:pathData</code> ， <code>android:fillColor</code> 等)都有一个整数 ID， 这些 ID 是在 API 21 中添加的。 在老版本的 Android 上， 没有任何东西可以阻止 OEM 使用任何”无人认领”的 ID， 因此在较老的平台上使用较新的属性是不安全的。</p></blockquote><p>这种版本控制将阻止在较老的平台上访问这些资源， 使反编译成为不可能的事情 —— gradle 标志禁用了可绘制对象资源（vector drawables）的版本控制。 这就是为什么你使用 <code>android:pathData</code> 引入你的向量而不是必须切换到 <code>app:pathData</code> 等其他后移功能。</p><h3 id="2-使用-AndroidX-加载"><a href="#2-使用-AndroidX-加载" class="headerlink" title="2. 使用 AndroidX 加载"></a>2. 使用 AndroidX 加载</h3><p>当加载 drawables 时， 你需要使用 AndroidX 的方法， 因为它已经提供了对矢量资源的支持。 这个的切入点是始终利用 [ <code>AppCompatResources.getDrawable</code> ](<a href="https://developer.android.com/reference/androidx/appcompat/content/res/AppCompatResources.html#getDrawable">https://developer.android.com/reference/androidx/appcompat/content/res/AppCompatResources.html#getDrawable</a>(android.content. Context, %20int)) 加载 drawables。 虽然有许多方法可以加载 drawables（因为某些原因）， 但是如果你想使用 compat 向量， 就必须使用 AppCompatResources。 如果你做不到这一点， 那么你就不能连接到 AndroidX 代码路径， 当你尝试使用任何你运行的平台不支持的功能时， 你的应用程序可能会崩溃。</p><blockquote><p><code>VectorDrawableCompat</code> 还提供了一个 <code>create</code> 方法。 我总是会建议使用 <code>AppCompatResources</code> ， 因为这会增加一层缓存。</p></blockquote><p>如果你想以声明的方式设置 drawables（即在你的布局中）， <code>appcompat</code> 提供了一些 <code>Compat</code> 属性， 你应该使用这些属性而不是标准的平台属性：</p><p><code>ImageView</code> ， <code>ImageButton</code> ：</p><ul><li>不要使用： <code>android:src</code></li><li>应该使用： <code>app:srcCompat</code></li></ul><p><code>CheckBox</code> ， <code>RadioButton</code> ：</p><ul><li>不要使用： <code>android:button</code></li><li>应该使用： <code>app:buttonCompat</code></li></ul><p><code>TextView</code> （<a href="https://developer.android.com/jetpack/androidx/androidx-rn#2018-dec-03-appcompat">as of <code>appcompat:1.1.0</code> </a>）：</p><ul><li>不要使用： <code>android:drawableStart</code> 和 <code>android:drawableTop</code> 等</li><li>应该使用： <code>app:drawableStartCompat</code> 和 <code>app:drawableTopCompat</code> 等</li></ul><p>由于这些属性是 <code>appcompat</code> 库的一部分， 请确保使用 app: namespace。 在内部， 这些 <code>AppCompat</code> 视图使用 <code>AppCompatResources</code> 来支持加载矢量的加载。</p><blockquote><p>如果你想了解 <code>appcompat</code> 如何交换出 <code>TextView</code> ， 或者声明了一个启用此功能的 <code>AppCompatTextView</code> 等， 你可以查看这篇文章： <a href="https://helw.net/2018/08/06/appcompat-view-inflation/">https://helw.net/2018/08/06/appcompat-view-inflation/</a></p></blockquote><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>这些要求会影响你创建布局或访问资源所使用的方式。 以下是一些考虑到的实际因素。</p><h3 id="没有-compat-属性的视图"><a href="#没有-compat-属性的视图" class="headerlink" title="没有 compat 属性的视图"></a>没有 compat 属性的视图</h3><p>不幸的是， 有很多地方你可能想要在不提供 compat 属性的视图上指定 drawables（例如， 对于 <code>progressbar</code> 来说没有 <code>indeterminateDrawableCompat</code> 属性）。 你仍然可以使用 AndroidX vectors， 但你需要对代码作如下更改:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Copyright 2018 Google LLC.</span><br><span class="line">   SPDX-License-Identifier: Apache-2.0 *&#x2F;</span><br><span class="line">val progressBar &#x3D; findViewById &lt; ProgressBar &gt; (R.id.loading)</span><br><span class="line">val drawable &#x3D; AppCompatResources.getDrawable(context, R.drawable.loading_indeterminate)</span><br><span class="line">progressBar.indeterminateDrawable &#x3D; drawable</span><br></pre></td></tr></table></figure><p>如果您正在使用<a href="https://developer.android.com/topic/libraries/data-binding/">数据绑定</a>， 那么可以使用自定义绑定适配器来完成此操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Copyright 2018 Google LLC.</span><br><span class="line">   SPDX-License-Identifier: Apache-2.0 *&#x2F;</span><br><span class="line">@BindingAdapter(&quot;indeterminateDrawableCompat&quot;)</span><br><span class="line">fun bindIndeterminateProgress(progressBar: ProgressBar, @DrawableRes id: Int) &#123;</span><br><span class="line">    val drawable &#x3D; AppCompatResources.getDrawable(progressBar.context, id)</span><br><span class="line">    progressBar.indeterminateDrawable &#x3D; drawable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意， 我们不希望数据绑定为我们加载 drawable（因为它<strong>目前</strong>不使用 <code>AppCompatResources</code> 来加载 drawables）， 所以不能像 <code>@ &#123;@ drawable / foo&#125;</code> 那样直接引用 drawable。 相反， 如果我们想将 drawable <strong>id</strong> 传递给绑定适配器， 因此需要导入 <code>R</code> 来引用它：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Copyright 2018 Google LLC.</span><br><span class="line">SPDX - License - Identifier: Apache - 2.0 --&gt;</span><br><span class="line">    &lt;</span><br><span class="line">    layout... &gt;</span><br><span class="line">    &lt;</span><br><span class="line">    data &gt;</span><br><span class="line">    &lt;</span><br><span class="line">    import type &#x3D; &quot;your.package.R&quot;</span><br><span class="line">alias &#x3D; &quot;R&quot; &#x2F; &gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;</span><br><span class="line">    &#x2F;data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;</span><br><span class="line">    ProgressBar...</span><br><span class="line">    app: indeterminateDrawableCompat &#x3D; &quot;@&#123;R.drawable.foo&#125;&quot; &#x2F; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;</span><br><span class="line">    &#x2F;layout&gt;</span><br></pre></td></tr></table></figure><h3 id="嵌套的-drawables"><a href="#嵌套的-drawables" class="headerlink" title="嵌套的 drawables"></a>嵌套的 drawables</h3><p>有些 <code>drawable</code> 是可嵌套的， 例如 <code>StateListDrawables</code> ， <code>InsetDrawables</code> 或 <code>LayerDrawables</code> 均包含其他子 drawable。 AndroidX 支持显式渲染 <code>&lt;vector&gt;</code> 元素（也包括动画向量（ <code>animated-vector</code> ）和动画选择器（ <code>animated-selectors</code> ）， 但我们今天主要讨论静态 vectors）。 当你调用 <code>AppCompatResources.getDrawable</code> ， 它用给定的 <code>id</code> 查看资源， 如果它是一个向量（即根元素是 <code>&lt;vector&gt;</code> ）， 它就会手动地为你加载它。 否则， 它就会把它交给系统加载——这样做的时候， AndroidX 就无法将自己重新插入到进程中。 这意味着， 如果你有一个包含向量的 <code>InsetDrawable</code> ， 并利用 <code>AppCompatResources</code> 加载它， 它将根据 <code>&lt;inset&gt;</code> 标记， 然后将它交给平台来加载。 因此， 它将没有机会加载嵌套的 <code>&lt;vector&gt;</code> ， 因此要么加载失败（在 API &lt;21 上）， 要么返回到平台支持。</p><p>要解决这个问题， 可以在代码中创建 <code>drawables</code> ； 也就是说， 使用 <code>AppCompatResources</code> 加载矢量资源， 然后手动创建 <code>InsetDrawable</code> 格式的 drawable。</p><p>有一个例外是 AndroidX 最近添加了一个新功能（从 <a href="https://developer.android.com/jetpack/androidx/androidx-rn#1.0.0-new"> <code>appcompat:1.0.0</code> </a> 开始）—— <a href="https://developer.android.com/reference/androidx/appcompat/graphics/drawable/AnimatedStateListDrawableCompat"> <code>AnimatedStateListDrawables</code> </a> 向后移植（译者注： 原文是 back-ported ， Wikipedia 上解释是 <code>把新版本上的东西移植到老版本上去</code> ， 这里翻译成向后移植）。 这是 <code>StateListDrawable</code> 的一个版本， 具有状态之间的动画转换(以 <code>AnimatedVectorDrawables</code> 的形式)。 你不需要申明一个过渡。 因此， 如果你只需要一个可以使用 AndroidX 来扩充子向量的 <code>StateListDrawable</code> ， 那么你可以使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Copyright 2018 Google LLC.</span><br><span class="line">SPDX - License - Identifier: Apache - 2.0 --&gt;</span><br><span class="line">    &lt;</span><br><span class="line">    animated - selector... &gt;</span><br><span class="line">    &lt;</span><br><span class="line">    item android: state_foo &#x3D; &quot;true&quot;</span><br><span class="line">android: drawable &#x3D; &quot;@drawable&#x2F;some_vector&quot; &#x2F; &gt;</span><br><span class="line">    &lt;</span><br><span class="line">    item android: drawable &#x3D; &quot;@drawable&#x2F;some_other_vector&quot; &#x2F; &gt;</span><br><span class="line">    &lt;!-- no transitions specified --&gt;</span><br><span class="line">    &lt;</span><br><span class="line">    &#x2F;animated-selector&gt;</span><br></pre></td></tr></table></figure><p>一切都归功于这个天才黑客： <a href="https://twitter.com/alexjlockwood/status/1029088247131996160">https://twitter.com/alexjlockwood/status/1029088247131996160</a></p><blockquote><p>有一种方法可以在嵌套的 drawable 中启用矢量， 通过使用 <a href="https://developer.android.com/reference/android/support/v7/app/AppCompatDelegate.html#setCompatVectorFromResourcesEnable">AppCompatDelegate#setCompatVectorFromResourcesEnabled</a>， 但它有许多缺点。 务必仔细阅读 javadoc。</p></blockquote><h3 id="进程外加载"><a href="#进程外加载" class="headerlink" title="进程外加载"></a>进程外加载</h3><p>有时你需要在无法控制何时或如何加载的地方使用 drawable。 例如： 通知， 主屏幕小部件或主题中指定的某些资源（例如， 在创建预览窗口时设置由平台加载的 <code>android：windowBackground</code> ）。 在这些情况下， 你不负责加载 drawable， 因此没有机会集成 AndroidX 支持， 你也就无法在 API 21 之前使用这些矢量资源了 😞。</p><p>你当然可以在 API 21+ 上使用 vectors， 但请注意， 你可能不喜欢 AndroidX 提供的功能/错误修正。 例如， 虽然 AndroidX 对 <code>fillType=&quot;evenOdd&quot;</code> 支持的很好， 但是在 API 21-23 设备上不使用 AndroidX 支持向量是无法理解这个属性的。 对于这个具体的例子， 我将在下一篇文章中介绍如何在设计时转换 fillType。 否则， 你可能需要为不同的 API 准备不同的资源了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res &#x2F;</span><br><span class="line">    drawable - xxhdpi &#x2F;</span><br><span class="line">    foo.png &lt; --raster</span><br><span class="line">drawable - anydpi - v21 &#x2F;</span><br><span class="line">    foo.xml &lt; --vector</span><br><span class="line">drawable - anydpi - v24 &#x2F;</span><br><span class="line">    foo.xml &lt; --vector with fancy features</span><br></pre></td></tr></table></figure><p>请注意， 除了 api 级别限定符之外， 我们还需要在此处包含 <code>anydpi</code> 资源限定符。 这是由于<a href="https://developer.android.com/guide/topics/resources/providing-resources#BestMatch">资源限定符优先级</a>的工作方式导致的。 任何在 <code>drawable- &lt;whatever&gt; dpi</code> 中的资源都被认为是比在 <code>drawable-v21</code> 更好的选择。</p><h2 id="X-标记点"><a href="#X-标记点" class="headerlink" title="X 标记点"></a>X 标记点</h2><p>本文旨在强调使用 AndroidX 矢量支持（AndroidX vector support）的好处以及一些你需要注意的限制。 使用 AndroidX 支持既可以在更多平台版本和后端功能上使用矢量资源， 也可以让你接收任何未来的更新。</p><p>现在我们已经理解了为什么以及如何使用向量， 下一篇文章将深入探讨如何创建它们。</p><p>即将推出： 为 Android 创建矢量资源</p><p>即将推出： <code> Android VectorDrawables</code> 分析</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方， 欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR， 也可获得相应奖励积分。 文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区， 文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。 内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、 <a href="https://github.com/xitu/gold-miner#ios">iOS</a>、 <a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、 <a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域， 想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、 <a href="http://weibo.com/juejinfanyi">官方微博</a>、 <a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】回答有关Flutter APP开发的问题</title>
      <link href="p/2d8c.html"/>
      <url>p/2d8c.html</url>
      
        <content type="html"><![CDATA[<p>通过我的讲座和研讨会在与很多学生和开发人员亲自交流后， 我意识到他们中很多人都对 Flutter 和应用程序开发有共同的问题， 甚至还有误解。 因此我决定去写一篇文章来解释这些普遍的疑惑。 注意， 这篇文章旨在解释一些问题， 而不是对每个方面的详细表述。 为简洁起见， 我可能没有涉及到一些例外情况。 请注意， Flutter 本身也有一个针对各种背景下的常问问题页面 <a href="https://flutter.io/">flutter.io</a>， 在这里我将更多地关注我经常看到的问题。 虽然其中一些也包含在 Flutter 常见问题解答中， 但是我还是尝试着去给出我的观点。 </p><h4 id="布局文件在哪里？-为什么-Flutter-没有布局文件？"><a href="#布局文件在哪里？-为什么-Flutter-没有布局文件？" class="headerlink" title="布局文件在哪里？ / 为什么 Flutter 没有布局文件？"></a>布局文件在哪里？ / 为什么 Flutter 没有布局文件？</h4><p>在 Android 框架中， 我们将 Activity 分为布局和代码。 因此， 我们需要引用视图以在 Java 中使用它们。 （当然 Kotlin 可以避免这种情况。 ）布局文件本身用 XML 编写， 包含 Views 和 ViewGroups。 </p><p>Flutter 使用一种全新的方法， 而不是视图， <strong>使用 Widget</strong>。 在 Android 中， View 就是布局的一个组件， 但在 Flutter 中， Widget 几乎就是一切。 从按钮到布局结构， 所有的这些都是一个 Widget。 他在这里的优势是<strong>可定制性</strong>。 想象一下 Android 中的一个按钮。 它具有文本等属性， 可让你向按钮添加文本。 但 Flutter 中的按钮不会将标题作为字符串， 而是另一个 widget。 这意味着， <strong>在按钮内部， 您可以拥有文本， 图像， 图标以及您可以想象的任何内容</strong>， 并且不会破坏布局约束。 这也让你可以很容易地制作自定义 Widget， 而在 Android 中制作自定义 view 是一件相当困难的事情。 </p><a id="more"></a><h4 id="拖放不比在代码中进行布局更容易吗？"><a href="#拖放不比在代码中进行布局更容易吗？" class="headerlink" title="拖放不比在代码中进行布局更容易吗？"></a>拖放不比在代码中进行布局更容易吗？</h4><p>在某些方面， 这是事实。 但 Flutter 社区中的很多人都更喜欢代码方式， 但这并不意味着拖放无法实现。 如果你完全喜欢拖放， 那么 Flutter Studio 是我推荐的一个很棒的资源， 它可以通过拖放帮助你生成布局。 这是一个让我印象深刻的工具， 很想知道它将来会如何发展。 </p><p>链接:  <a href="https://flutterstudio.app/">https://flutterstudio.app</a></p><h4 id="Flutter-是否像浏览器一样工作？-它与基于-WebView-的应用程序有何不同？"><a href="#Flutter-是否像浏览器一样工作？-它与基于-WebView-的应用程序有何不同？" class="headerlink" title="Flutter 是否像浏览器一样工作？ / 它与基于 WebView 的应用程序有何不同？"></a>Flutter 是否像浏览器一样工作？ / 它与基于 WebView 的应用程序有何不同？</h4><p>简单地回答这个问题： <strong>为 WebView 编写的代码或类似运行的应用程序必须经过多个层才能最终执行。 **从本质上讲， Flutter 通过</strong>编译到原生 ARM** 代码来实现这两个平台上的执行。 “混合”应用程序缓慢， 缓慢， 与它们运行的平台看起来不同。 Flutter 应用程序的运行速度远远超过混合应用程序。 此外， 使用插件访问本机组件和传感器要比使用无法充分利用其平台的 WebView 更容易。 </p><h4 id="为什么-Flutter-项目中有-Android-和-iOS-文件夹？"><a href="#为什么-Flutter-项目中有-Android-和-iOS-文件夹？" class="headerlink" title="为什么 Flutter 项目中有 Android 和 iOS 文件夹？"></a>为什么 Flutter 项目中有 Android 和 iOS 文件夹？</h4><p>Flutter项目中有三个主要文件夹： lib、 android 和 ios 。 ‘lib’ 负责处理你的 Dart 文件。 Android 和 iOS 文件夹用于在各自的平台上实际构建应用程序， 并在其上运行 Dart 文件。 它们还可以帮助您为项目添加权限和特定于平台的功能。 当您运行 Flutter 项目时， 它会根据运行的模拟器或设备进行构建， 使用其中的文件夹执行 Gradle 或 XCode 构建。 **简而言之， 这些文件夹为 Flutter 代码的运行成为一个完整的 APP 奠定了基础。 **</p><h4 id="为什么我的-Flutter-这么大？"><a href="#为什么我的-Flutter-这么大？" class="headerlink" title="为什么我的 Flutter 这么大？"></a>为什么我的 Flutter 这么大？</h4><p>如果你运行 Flutter 应用程序， 你知道它很快。 非常<strong>快</strong>。 它是如何做到的？ 在构建应用程序时， 它<strong>实际上用到了所有资源文件</strong>， 而不是仅使用特定的资源文件。 为什么这有帮助？ 因为如果我将图标从一个更改为另一个， 则不必完全重建应用程序。 这就是 Flutter 调试版本如此之大的原因。 创建发布版本时， 只会获取所需的资源文件， 并且我们会获得更多习惯的大小。 Flutter 应用程序仍然比 Android 应用程序略大， 但它相当小， 加上 Flutter 团队一直在寻找减少应用程序大小的方法。 </p><h4 id="如果我是编程新手并且我想从移动开发开始，-我应该从-Flutter-开始吗？"><a href="#如果我是编程新手并且我想从移动开发开始，-我应该从-Flutter-开始吗？" class="headerlink" title="**如果我是编程新手并且我想从移动开发开始， 我应该从 Flutter 开始吗？ **"></a>**如果我是编程新手并且我想从移动开发开始， 我应该从 Flutter 开始吗？ **</h4><p>这有两部分答案。 </p><ol><li>对于相同的页面， Flutter 非常适合编码并且代码比 Android 或 iOS 应用程序少得多。 因此对于大多数应用程序， 我认为不会出现重大问题。 </li><li>您需要记住的一件事是 Flutter 还依赖于 Android 和 iOS 项目， 你至少需要熟悉那些项目结构。 如果您想编写任何原生代码， 你肯定需要在任一平台或两个平台上都有经验。 </li></ol><p>我的个人意见是学习 Android / iOS 一两个月， 然后再开始学习 Flutter。 </p><h4 id="Packages-和-plugins-是什么？"><a href="#Packages-和-plugins-是什么？" class="headerlink" title="Packages 和 plugins 是什么？"></a>Packages 和 plugins 是什么？</h4><p>Packages 允许您将新的工具或功能导入你的应用程序。 Packages 和 plugins 之间有一点区别。 Packages 通常是新的组件或纯粹在 Dart 中编写的代码， 而 plugins 允许更多功能在设备上使用原生代码。 通常在 DartPub 上， Packages 和 plugins 都被称为包， 并且只有在创建新包时才明确提到区别。 </p><h4 id="什么是-pubspec-yaml-文件，-它有什么作用？"><a href="#什么是-pubspec-yaml-文件，-它有什么作用？" class="headerlink" title="什么是 pubspec.yaml 文件， 它有什么作用？"></a>什么是 pubspec.yaml 文件， 它有什么作用？</h4><p>Pubspec.yaml 允许你定义应用依赖的包， 声明你的资源文件， 如图片， 音频， 视频等。 它还允许你为你的应用设置约束。 对于 Android 开发人员来说， 这大致类似于 build.gradle 文件， 但两者之间的差异也很明显。 </p><h4 id="为什么第一个-Flutter-应用程序构建需要这么长时间？"><a href="#为什么第一个-Flutter-应用程序构建需要这么长时间？" class="headerlink" title="为什么第一个 Flutter 应用程序构建需要这么长时间？"></a>为什么第一个 Flutter 应用程序构建需要这么长时间？</h4><p>首次构建 Flutter 应用程序时， 会<strong>构建特定于设备的 APK 或 IPA文件</strong>。 因为要用到 Gradle 和 XCode 用于构建文件， 需要时间。 下次重新启动或热重新加载应用程序时， Flutter 实际上会在现有应用程序之上修补更改， 从而实现快速刷新。 </p><p>**注意： **热重载或重启所做的更改不会设备 APK 或 IPA 文件中保存。 要确保你的应用在设备上完成所有更改， 请考虑停止并重新运行该应用。 </p><h4 id="State-是什么意思？-什么是-setState-？"><a href="#State-是什么意思？-什么是-setState-？" class="headerlink" title="State 是什么意思？ 什么是 setState()？"></a>State 是什么意思？ 什么是 setState()？</h4><p>**简单来说， “State” 是 widget 变量值的集合。 ** 任何像计数器， 文本等一样可以改变的东西都可以成为 State 的一部分。 **想象一个柜台应用程序， 主要的动态是计数器计数。 计数更改时， 需要刷新屏幕以显示新值。 ** setState() 本质上是一种告诉应用程序使用新值刷新和重建屏幕的方法。 </p><h4 id="什么是有状态和无状态小部件？"><a href="#什么是有状态和无状态小部件？" class="headerlink" title="什么是有状态和无状态小部件？"></a>什么是有状态和无状态小部件？</h4><p>太长了， 简单的说： 允许你刷新屏幕的 Widget是一个有状态小部件。 反之则是无状态的。 </p><p>详细地说， 具有可以更改的内容的动态窗口小部件应该是有状态的 Widget。 无状态 Widget 只能在参数更改时更改内容， 因此需要在窗口小部件层次结构中的位置点之上完成。 包含静态内容的屏幕或窗口小部件应该是无状态窗口小部件， 但要更改内容， 需要是有状态的。 </p><h4 id="如何处理-Flutter-代码中的缩进和结构？"><a href="#如何处理-Flutter-代码中的缩进和结构？" class="headerlink" title="如何处理 Flutter 代码中的缩进和结构？"></a>如何处理 Flutter 代码中的缩进和结构？</h4><p>Android Studio 提供了一些工具， 可以更轻松地构建 Flutter 代码。 两个主要的方法是： </p><ol><li><strong>Alt + Enter/ Command + Enter</strong>： 这使你可以轻松地在复杂的层次结构中包装和删除窗口小部件以及交换窗口小部件。 要使用此功能， 只需将光标指向小部件声明， 然后按键即可为您提供一些选项。 这种智能的感觉有时像天赐之物。 </li><li><strong>DartFMT</strong>： dartfmt 格式化您的代码以保持干净的层次结构和缩进。 在你不小心移动几个括号后， 它使您的代码更漂亮。 </li></ol><h4 id="为什么我们将函数传递给小部件？"><a href="#为什么我们将函数传递给小部件？" class="headerlink" title="为什么我们将函数传递给小部件？"></a>为什么我们将函数传递给小部件？</h4><p>我们将一个函数传递给一个小部件， 主要是说“当事情发生时调用这个函数”。 函数是 Dart 中的第一类对象， 可以作为参数传递给其他函数。 使用 Android（&lt;Java 8） 等接口的回调有太多的样板代码用于简单的回调。 </p><p>**Java 回调： **</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        &#x2F;&#x2F; Do something here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（请注意， 这只是用于设置侦听器的代码。 定义按钮需要单独的 XML 代码。 ）</p><p>**Dart equivalent： **</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">    onPressed: () &#123;</span><br><span class="line">        &#x2F;&#x2F; Do something here</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（Dart同时进行声明以及设置回调。 ）</p><p>这变得更加整洁， 并帮助我们避免不必要的复杂化。 </p><h4 id="什么是-ScopedModel-BLoC-模式？"><a href="#什么是-ScopedModel-BLoC-模式？" class="headerlink" title="什么是 ScopedModel / BLoC 模式？"></a>什么是 ScopedModel / BLoC 模式？</h4><p>ScopedModel 和 BLoC（业务逻辑组件）是常见的 Flutter 应用程序架构模式， 可帮助**将业务逻辑与 UI 代码分离， 并使用更少的有状态 widget。 ** 有<a href="https://medium.com/flutter-community/let-me-help-you-to-understand-and-choose-a-state-management-solution-for-your-app-9ffeac834ee3">更好的资源</a>来学习这些， 我不认为有理由在几行中解释它们。 </p><p>我希望这篇文章能够消除一些疑问， 并且我将尽力更新我遇到的常见问题。 如果你喜欢这篇文章， 请给我一些鼓励， 如果你希望我添加其他问题， 请务必发表评论。 </p><blockquote><p>如果发现译文存在错误或其他需要改进的地方， 欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR， 也可获得相应奖励积分。 文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。 </p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区， 文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。 内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、 <a href="https://github.com/xitu/gold-miner#ios">iOS</a>、 <a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、 <a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域， 想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、 <a href="http://weibo.com/juejinfanyi">官方微博</a>、 <a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】前端 vs 后端：哪一个适合你？</title>
      <link href="p/ff05.html"/>
      <url>p/ff05.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文翻译自<a href="https://dev.to/molly_struve/frontend-vs-backend-which-one-is-right-for-you-5gjg">Frontend vs Backend: Which One Is Right For You?</a>，如有疑问可在公众号「01二进制」后台回复「微信」和我联系</p></blockquote><p>经常会有初学者来问我刚开始学习编程的时候应该学些什么？问这个问题就跟一个医学生询问应该专注研究哪个领域一样。根本没有一个标准答案。但我还是想提供一些指导，并就这个问题提出一些自己的看法。希望这篇文章可以给刚开始职业生涯的你一些值得思考的东西。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在刚开始学习软件开发的时候，首先要经历的心理斗争就是我应该把关注点放在哪，前端还是后端？在我们深入了解两个领域的特征之前，我们先来看看它们的定义。</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>指的是网站的表示层以及它与后端数据的交互方式。例如 HTML、CSS、JavaScript 和 Angular 等。</p></blockquote><p><a href="https://user-gold-cdn.xitu.io/2019/7/23/16c1db6769c1652e?w=880&h=1245&f=png&s=60425"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1db6769c1652e?w=880&h=1245&f=png&s=60425"></a></p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>指的是应用程序的数据处理层。这一层负责与数据库通信，并确定将哪些信息发送到要显示的前端。例如 Ruby、Rails、Python、Java 等。</p></blockquote><p><a href="https://user-gold-cdn.xitu.io/2019/7/23/16c1db6769fa8d81?w=880&h=1231&f=jpeg&s=56280"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1db6769fa8d81?w=880&h=1231&f=jpeg&s=56280"></a></p><p>好的，现在我们知道它们是什么了，但是你又该如何选择哪一个作为职业的方向呢？老实说，它取决于你的个人喜好以及你选择成为一个开发者的初衷。</p><h2 id="职业满足感"><a href="#职业满足感" class="headerlink" title="职业满足感"></a>职业满足感</h2><p>如果你选择成为一名开发人员是因为你想获得职业满足感，并做一些你喜欢的事情，那么我的建议是，当你开始时，前后端都要做。同时涉猎前端和后端，这样你就能感受到你更喜欢的是什么。这么做会很辛苦吗？当然会，但是这也会极大地增加你找到喜欢做的事情的机会。</p><p>在前端和后端生态系统中，仍然有许多你可以选择并且能做得非常出色的专业。当你开始的时候，试着去了解一些基本的东西，不要太担心会沉迷其中。试一试水，看看当你用它的时候，其中一个方向是否真的能吸引到你。同时，你要意识到，无论你选择哪个，一开始都会很困难。我想说的是，在你决定要把重点放在哪里之前，给自己一年或两年的时间来研究整个流程。这将给你足够的时间来解决最初的“哇，这太糟糕了，因为它很难”的问题，同时还能让你真正评估它是否是你喜欢使用的技术。</p><p>虽然每个人都有不同的品味，但是看看其他开发人员喜欢使用哪些语言和技术也是很有趣的。2019 年 StackOverflow 调查了<a href="https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-languages">最受欢迎的语言</a>。</p><p><a href="https://user-gold-cdn.xitu.io/2019/7/23/16c1db676a078c6b?w=880&h=677&f=png&s=18013"><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1db676a078c6b?w=880&h=677&f=png&s=18013"></a></p><p>前后端通吃的另一个好处是，你可以了解它们之间是如何协同工作的。无论你决定在未来关注哪个方面，这都非常有用。如果你了解另一半的工作原理，那么你就可以在项目中创建更好的代码和接口。</p><p>最后，当你在工作时横跨前后端，你可能会决定不进行选择了！你可能希望通吃前后端，并成为一个全栈工程师。这也是完全可以的！</p><h2 id="工资-稳定性"><a href="#工资-稳定性" class="headerlink" title="工资/稳定性"></a>工资/稳定性</h2><p>如果你从事开发的职业动机是为了工资和稳定，那么同时学习这两个方向可能是在浪费你的时间。如果你想尽快从事一行职业，那么就对你想从事的领域做一些调查。找出前端和后端的工资趋势。此外，尝试找出市场上最需要哪种类型的开发人员。</p><p>我不知道前端和后端哪个工资更高，但有一些调查试图回答这个问题。我们可以看看 2019 年 StackOverflow 的调查，该调查将开发者的<a href="https://insights.stackoverflow.com/survey/2019#work-_-salary-by-developer-type">薪资按类型</a>进行了细分。</p><h3 id="全球"><a href="#全球" class="headerlink" title="全球"></a>全球</h3><ol><li>全栈工程师 $57k  </li><li>后端工程师 $56k  </li><li>前端工程师 $52k</li></ol><h3 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h3><ol><li>后端工程师 $116k  </li><li>全栈工程师 $110k  </li><li>前端工程师 $103k</li></ol><p>此外，它还<a href="https://insights.stackoverflow.com/survey/2019#top-paying-technologies">根据技术</a>细分了薪资。下面是每项调查的样本。</p><h3 id="全球-1"><a href="#全球-1" class="headerlink" title="全球"></a>全球</h3><ul><li>Clojure $90k</li><li>Go $80k</li><li>Python $63k</li><li>Swift $59k</li><li>JavaScript $56k</li><li>HTML/CSS $55k</li></ul><h3 id="美国-1"><a href="#美国-1" class="headerlink" title="美国"></a>美国</h3><ul><li>Scala $143k</li><li>Clojure $139k</li><li>Go $136k</li><li>Swift $120k</li><li>Python $116k</li><li>JavaScript $110k</li><li>HTML/CSS $105k</li></ul><p>需要注意的是，这些工资和趋势可能会因你的工作地点和是否在寻找远程工作而有所不同。因此，你需要自己做好调查。这很简单，只需要查看求职公告板并搜索后端和前端技术，看看都有哪些。</p><h2 id="我为什么选择后端"><a href="#我为什么选择后端" class="headerlink" title="我为什么选择后端"></a>我为什么选择后端</h2><p>我想我应该在这里加上一段为什么我最终选择了后端，希望它可以在其他人做决定时帮助他们。当我转行成为一名开发人员时，我寻求工作满足感，并决定开始跨整个工作栈。在真正转向后端之前，我做了 3 年的全栈开发。吸引我来到后台的是 Ruby 的简洁。JavaScript 和前端语言对我来说总是缺乏组织性。我还热衷于优化代码性能。我喜欢想办法让事情运行得更好更快。后端似乎给了我更多的机会。</p><p>最后，我不是一个非常注重视觉或艺术的人。有些人可以看看网页，然后想办法把它放在什么地方。我从来都不擅长这个，所以后端让我更自然、更舒服。</p><p>如果你想深入了解其他人的观点，请查看这个讨论前端和后端 Web 开发的 <a href="https://wakelet.com/wake/7d71f467-89ba-49cb-a196-4e32657369ac">CodeNewbie Chat</a>。你还可以查看周二开始的 dev.to thread，我将会询问人们如何选择在前端还是后端工作以及其原因。</p><p><a href="https://dev.to/molly_struve/frontend-vs-backend-which-do-you-prefer-and-why-5a9e">Frontend vs Backend, which do you prefer and why?</a></p><h2 id="没有什么是永恒的"><a href="#没有什么是永恒的" class="headerlink" title="没有什么是永恒的"></a>没有什么是永恒的</h2><p>无论你决定专注于什么，要知道没有什么是永恒的。如果你走错了一条路，你总是可以悬崖勒马的。软件工程的一个伟大之处在于，它把所有的东西都整合在一起。了解一个领域只会帮助你的成长并在另一个领域做得更好。</p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】利用 Python中的 Bokeh 实现数据可视化， 第三部分： 制作一个完整的仪表盘</title>
      <link href="p/ba89.html"/>
      <url>p/ba89.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文翻译自<a href="https://towardsdatascience.com/data-visualization-with-bokeh-in-python-part-iii-a-complete-dashboard-dc6a86aa6e23">Data Visualization with Bokeh in Python, Part III: Making a Complete Dashboard</a></p></blockquote><p>有时我会利用数据科学来解决特定问题。 其他时候， 我会尝试一种新工具， 比如说 Bokeh ， 因为我在 Twitter 上看到一些很酷的项目， 就会想： “那看起来很棒。 虽然我不确定什么时候会用到， 但迟早会有用的。 ”几乎每次我都这么说， 但是我最终都会找到这个工具的用途。 数据科学需要你掌握许多不同方面的知识， 你永远不会知道下一个你将使用的想法将来自哪里!</p><p>作为一名数据科学研究人员， 在试用了几个星期之后， 我终于在 Bokeh 的例子中找到了一个完美的用例。 我的<a href="https://arpa-e.energy.gov/?q=slick-sheet-project/virtual-building-energy-audits">研究项目</a> 涉及利用数据科学提高商业建筑的能源效率。 <a href="http://www.arpae-summit.com/about/about-the-summit">在最近的一次会议</a>上， 我们需要用一种方法来展示我们使用的众多技术的成果。 通常情况下都建议使用 powerpoint 来完成这项任务， 但是效果并不明显。 大多数在会议中的人在看到第三张幻灯片时， 就已经失去耐心了。 尽管我对 Bokeh 还不是很熟悉， 但我仍然自愿尝试利用这个库做一个交互式应用程序， 我认为这会扩展我的技能， 创造一个吸引人的方式来展示我们的项目。 安全起见， 我们团队准备了一个演示的备份， 但在我向他们展示了一部分初稿之后， 他们便给予了全部支持。 最终的交互式仪表板在会议中脱颖而出， 未来我们的团队也将会使用：</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/168460c02dcca318?w=800&h=479&f=gif&s=2954078"></p><p>为<a href="https://arpa-e.energy.gov/?q=slick-sheet-project/virtual-building-energy-audits">我的研究</a>构建的 Bokeh 仪表盘的例子</p><p>虽然说并不是每一个你在 Twitter 上看到的想法都可能对你的职业生涯产生帮助， 但我可以负责的说， 了解更多的数据科学技术不会有什么坏处。 沿着这些思路， 我开始了本系列文章， 以展示 Bokeh 的功能， <a href="https://bokeh.pydata.org/en/latest/">Bokeh</a> 是 Python 中一个强大的绘图库， 他可以让你制作交互式绘图和仪表盘。 尽管我不能向你展示有关我研究的仪表盘， 但是我可以使用一个公开的数据集展示在 Bokeh 中构建可视化的基础知识。 第三篇文章是我的 Bokeh 系列文章的延续， <a href="https://towardsdatascience.com/data-visualization-with-bokeh-in-python-part-one-getting-started-a11655a467d4">第一部分着重于构建一个简单的图</a> ， <a href="https://towardsdatascience.com/data-visualization-with-bokeh-in-python-part-ii-interactions-a4cf994e2512">第二部分展示如何向 Bokeh 图中添加交互</a>。 在这篇文章中， 我们将看到如何设置一个完整的 Bokeh 应用程序， 并在您的浏览器中运行可访问的本地 Bokeh 服务器!</p><p>本文将重点介绍 Bokeh 应用程序的结构， 而不是具体的细节， 但是你可以在 <a href="https://github.com/WillKoehrsen/Bokeh-Python-Visualization">GitHub</a> 上找到所有内容的完整代码。 我们将会使用 <a href="https://cran.r-project.org/web/packages/nycflights13/nycflights13.pdf">NYCFlights13 数据集</a>， 这是一个 2013 年从纽约 3 个机场起飞的航班的真实信息数据集。 这个数据集中有超过 300, 000 个航班信息， 对于我们的仪表盘， 我们将主要关注于到达延迟信息的统计。</p><p>为了能完整运行整个应用程序， 你需要先确保你已经安装了 Bokeh（使用 <code>pip install bokeh</code> ）, 从 GitHub 上 <a href="https://github.com/WillKoehrsen/Bokeh-Python-Visualization/blob/master/bokeh_app.zip">下载</a> <code>[bokeh_app.zip](https://github.com/WillKoehrsen/Bokeh-Python-Visualization/blob/master/bokeh_app.zip)</code> <a href="https://github.com/WillKoehrsen/Bokeh-Python-Visualization/blob/master/bokeh_app.zip">文件夹</a>, 解压， 并在当前目录打开一个命令窗口， 并输入 <code>bokeh serve --show bokeh_app</code> 。 这会设置一个 <a href="https://bokeh.pydata.org/en/latest/docs/user_guide/server.html">Bokeh 的本地服务</a> 同时还会在你的浏览器中打开一个应用（当然你也可以使用 Bokeh 的在线服务， 但是目前对我们来说本地主机足矣）。</p><h3 id="最终产品"><a href="#最终产品" class="headerlink" title="最终产品"></a>最终产品</h3><p>在我们深入讨论细节之前， 让我们先来看看我们的最终产品， 这样我们就可以看到各个部分是如何组合在一起的。 下面是一个短片， 展示了我们如何与完整的仪表盘互动：</p><ul><li>YouTube 视频链接： <a href="https://youtu.be/VWi3HAlKOUQ">https://youtu.be/VWi3HAlKOUQ</a></li></ul><p>Bokeh 航班应用最终版</p><p>我在本地服务器上运行的浏览器(在 Chrome 的全屏模式下)中使用 Bokeh 应用程序。 在顶部我们看到许多选项卡， 每个选项卡包含不同部分的应用程序。 仪表盘的想法是， 虽然每个选项卡可以独立存在， 但是我们可以将其中许多选项卡连接在一起， 以支持对数据的完整探索。 这段视频展示了我们可以用 Bokeh 制作的图表的范围， 从直方图和密度图， 到可以按列排序的数据表， 再到完全交互式的地图。 使用 Bokeh 这个库除了可以创建丰富的图形外， 另一个好处是交互。 每个标签都有一个交互元素可以让用户参与到数据中， 并自己探索。 从经验来看， 当探索一个数据集时， 人们喜欢自己去洞察， 我们可以让他们通过各种控件来选择和过滤数据。</p><p>现在我们对目标仪表盘已经有一个概念了， 接下来让我们看看如何创建 Bokeh 应用程序。 我强烈建议你<a href="https://github.com/WillKoehrsen/Bokeh-Python-Visualization/tree/master/bokeh_app">下载这些代码</a>， 以供参考！</p><hr><h3 id="Bokeh-应用的结构"><a href="#Bokeh-应用的结构" class="headerlink" title="Bokeh 应用的结构"></a>Bokeh 应用的结构</h3><p>在编写任何代码之前， 为我们的应用程序建立一个框架是很重要的。 在任何项目中， 很容易被编码冲昏头脑， 很快就会迷失在一堆尚未完成的脚本和错位的数据文件中， 因此我们想要在编写代码和插入数据前先创建一个框架。 这个组织将帮助我们跟踪应用程序中的所有元素， 并在不可避免地出错时帮助我们进行调试。 此外， 我们可以在未来的项目中复用这个框架， 这样我们在规划阶段的初始投资将在未来得到回报。</p><p>为了设置一个 Boken 应用， 我创建了一个名为 <code>bokeh_app</code> 的根目录来保存所有内容。 在这个目录中， 我们创建了一个子目录用来存档数据（命名为 <code>data</code> ）， 另一个子目录用来存放脚本文件（命名为 <code>script</code> ）并通过一个 <code>main.py</code> 文件将所有的东西组合在一起.。 通常， 为了管理所有代码， 我发现最好将每个选项卡的代码保存在单独的 Python 脚本中， 并从单个主脚本调用它们。 下面是我为 Bokeh 应用程序所创建的文件结构， 它改编自<a href="https://bokeh.pydata.org/en/latest/docs/user_guide/server.html">官方文档</a>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bokeh_app</span><br><span class="line">    |</span><br><span class="line"></span><br><span class="line">    + -- - data |</span><br><span class="line">    + -- - info.csv |</span><br><span class="line">    + -- - info2.csv |</span><br><span class="line">    + -- - scripts |</span><br><span class="line">    + -- - plot.py |</span><br><span class="line">    + -- - plot2.py |</span><br><span class="line">    + -- - main.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 flight 应用程序， 其结构大致如下:</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/168460c0272eb29d?w=170&h=330&f=png&s=20754"></p><p>航班仪表盘的文件夹结构</p><p>在 <code>bokeh_app</code> 目录下有三个主要部分： <code>data</code> , <code>scripts</code> , 和 <code>main.py</code> 。 当需要运行服务器时， 我们在 <code>bokeh_app</code> 目录运行 Bokeh ， 它会自动搜索并运行 <code>main.py</code> 脚本。 有了总体结构之后， 让我们来看看 <code>main.py</code> 文件， 我把它称为 Bokeh 应用程序的启动程序（并不是专业术语）！</p><h3 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a><code>main.py</code></h3><p><code>main.py</code> 脚本是 Bokeh 应用程序的启动脚本。 它加载数据， 并把传递给其他脚本， 获取结果图， 并将它们组织好后单个显示出来。 这将是我展示的唯一一个完整的脚本， 因为它对应用程序非常重要：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">Pandas</span><br><span class="line">for data management</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># os methods</span><br><span class="line">for manipulating paths</span><br><span class="line">from os.path</span><br><span class="line">import dirname, join</span><br><span class="line"></span><br><span class="line"># Bokeh basics</span><br><span class="line">from bokeh.io</span><br><span class="line">import curdoc</span><br><span class="line">from bokeh.models.widgets</span><br><span class="line">import Tabs</span><br><span class="line"></span><br><span class="line"># Each tab is drawn by one script</span><br><span class="line">from scripts.histogram</span><br><span class="line">import histogram_tab</span><br><span class="line">from scripts.density</span><br><span class="line">import density_tab</span><br><span class="line">from scripts.table</span><br><span class="line">import table_tab</span><br><span class="line">from scripts.draw_map</span><br><span class="line">import map_tab</span><br><span class="line">from scripts.routes</span><br><span class="line">import route_tab</span><br><span class="line"></span><br><span class="line"># Using included state data from Bokeh</span><br><span class="line">for map</span><br><span class="line">from bokeh.sampledata.us_states</span><br><span class="line">import data as states</span><br><span class="line"></span><br><span class="line"># Read data into dataframes</span><br><span class="line">flights &#x3D; pd.read_csv(join(dirname(__file__), &#39;data&#39;, &#39;flights.csv&#39;),</span><br><span class="line">    index_col &#x3D; 0).dropna()</span><br><span class="line"></span><br><span class="line"># Formatted Flight Delay Data</span><br><span class="line">for map</span><br><span class="line">map_data &#x3D; pd.read_csv(join(dirname(__file__), &#39;data&#39;, &#39;flights_map.csv&#39;),</span><br><span class="line">    header &#x3D; [0, 1], index_col &#x3D; 0)</span><br><span class="line"></span><br><span class="line"># Create each of the tabs</span><br><span class="line">tab1 &#x3D; histogram_tab(flights)</span><br><span class="line">tab2 &#x3D; density_tab(flights)</span><br><span class="line">tab3 &#x3D; table_tab(flights)</span><br><span class="line">tab4 &#x3D; map_tab(map_data, states)</span><br><span class="line">tab5 &#x3D; route_tb(flights)</span><br><span class="line"></span><br><span class="line"># Put all the tabs into one application</span><br><span class="line">tabs &#x3D; Tabs(tabs &#x3D; [tab1, tab2, tab3, tab4, tab5])</span><br><span class="line"></span><br><span class="line"># Put the tabs in the current document</span><br><span class="line">for display</span><br><span class="line">curdoc().add_root(tabs)</span><br></pre></td></tr></table></figure><p>我们从必要的导包开始， 包括创建选项卡的函数， 每个选项卡都存储在 <code>scripts</code> 目录中的单独脚本中。 如果你看下文件结构， 注意这里有一个 <code>__init__.py</code> 文件在 <code>scripts</code> 目录中。 这是一个完全空白的文件， 需要放在目录中， 以允许我们使用相对语句导入适当的函数 (例如 <code>from scripts.histogram import histogram_tab</code> ). 我不太清楚为什么需要这样做， 但它确实有效（我曾经解决过这个问题， 这里是 <a href="https://stackoverflow.com/a/48468292/5755357">Stack Overflow 的答案</a>）.</p><p>在导入库和脚本后， 我们利用 <a href="https://stackoverflow.com/questions/9271464/what-does-the-file-variable-mean-do/9271617">Python</a> <code>[__file__](https://stackoverflow.com/questions/9271464/what-does-the-file-variable-mean-do/9271617)</code> <a href="https://stackoverflow.com/questions/9271464/what-does-the-file-variable-mean-do/9271617">属性</a>读取必要的数据。 在本例中， 我们使用了两个 pandas 数据框( <code>flights</code> 和 <code>map_data</code> )以及包含在 Bokeh 中的美国各州的数据。 读取数据之后， 脚本继续进行执行： 它将适当的数据传递给每个函数， 每个函数绘制并返回一个选项卡， 主脚本将所有这些选项卡组织在一个称为 <code>tabs</code> 的布局中。 作为这些独立选项卡函数的示例， 让我们来看看绘制 <code>map_tab</code> 的函数。</p><p>该函数接收 <code>map_data</code> (航班数据的格式化版本)和美国各州数据， 并为选定的航空公司生成航线图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/168460c02cdb9651?w=1000&h=479&f=png&s=201356"></p><p>地图选项卡</p><p>我们在本系列的第 2 部分中介绍了交互式情节， 而这个情节只是该思想的一个实现。 功能整体结构为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def map_tab(map_data, states):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def make_dataset(airline_list):</span><br><span class="line">    ...</span><br><span class="line">    return new_src</span><br><span class="line">def make_plot(src):</span><br><span class="line">    ...</span><br><span class="line">    return p</span><br><span class="line"></span><br><span class="line">def update(attr, old, new):</span><br><span class="line">    ...</span><br><span class="line">    new_src &#x3D; make_dataset(airline_list)</span><br><span class="line">src.data.update(new_src.data)</span><br><span class="line"></span><br><span class="line">controls &#x3D; ...</span><br><span class="line">    tab &#x3D; Panel(child &#x3D; layout, title &#x3D; &#39;Flight Map&#39;)</span><br><span class="line"></span><br><span class="line">return tab</span><br></pre></td></tr></table></figure><p>我们看到了熟悉的 <code>make_dataset</code> , <code>make_plot</code> , 和 <code>update</code> 函数， 这些函数用于[使用交互式控件绘制绘图](<a href="https://towardsdatascience.com/data-">https://towardsdatascience.com/data-</a> visualiz-with - bokehin - pythonpart -ii-interactions-a4cf994e2512)。 一旦我们设置好了图， 最后一行将整个图返回给主脚本。 每个单独的脚本(5 个选项卡对应 5 个选项卡)都遵循相同的模式。</p><p>回到主脚本， 最后一步是收集选项卡并将它们添加到一个单独的文档中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">Put all the tabs into one application</span><br><span class="line">tabs &#x3D; Tabs(tabs &#x3D; [tab1, tab2, tab3, tab4, tab5])</span><br><span class="line"></span><br><span class="line"># Put the tabs in the current document</span><br><span class="line">for display</span><br><span class="line">curdoc().add_root(tabs)</span><br></pre></td></tr></table></figure><p>选项卡显示在应用程序的顶部， 就像任何浏览器中的选项卡一样， 我们可以轻松地在它们之间切换以查看数据。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/168460c0455f170c?w=1000&h=723&f=png&s=162946"></p><h3 id="运行-Bokeh-服务"><a href="#运行-Bokeh-服务" class="headerlink" title="运行 Bokeh 服务"></a>运行 Bokeh 服务</h3><p>在完成所有的设置和编码之后， 在本地运行 Bokeh 服务器非常简单。 我们打开一个命令行界面(我更喜欢 Git Bash， 但任何一个都可以)， 切换到包含 <code>bokeh_app</code> 的目录， 并运行 <code>bokeh serve --show bokeh_app</code> 。 假设所有代码都正确， 应用程序将自动在浏览器中打开地址 <code>http://localhost:5006/bokeh_app</code> 。 然后， 我们就可以访问应用程序并查看我们的仪表盘了!</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/168460c02fec6c38?w=800&h=450&f=gif&s=2206336"></p><p>Bokeh 航班应用最终版</p><h4 id="在-Jupyter-Notebook-中调试"><a href="#在-Jupyter-Notebook-中调试" class="headerlink" title="在 Jupyter Notebook 中调试"></a>在 Jupyter Notebook 中调试</h4><p>如果出了什么问题(在我们刚开始编写仪表盘的时候， 肯定会出现这种情况)， 令人沮丧的是， 我们必须停止服务器、 对文件进行更改并重新启动服务器， 以查看我们的更改是否达到了预期的效果。 为了快速迭代和解决问题， 我通常在 Jupyter Notebook 中开发图。 Jupyter Notebook 对 Bokeh 来说是一个很好的开发环境， 因为你可以在笔记本中创建和测试完全交互式的绘图。 语法略有不同， 但一旦你有了一个完整的图， 代码只需稍加修改， 就可以复制粘贴到一个独立的 <code>.py</code> 脚本。 要了解这一点的实际应用， 请查看 [Jupyter Notebook](<a href="https://github.com/willkoehrsen/bokeh">https://github.com/willkoehrsen/bokeh</a> - pyth-visualization/blob/master/application/app_development .ipynb)。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个完全可交互式的 Bokeh 仪表盘可以使任何数据科学项目脱颖而出。 我经常看到我的同事们做了很多非常棒的统计工作， 但却不能清楚地表达其结果， 这意味着所有这些工作都没有得到应有的认可。 从个人经验来看， 我认为 Bokeh 应用程序在交流结果方面非常么有效。 虽然制作一个完整的仪表板需要做很多工作(超过 600 行代码)， 但其结果是值得的。 此外， 一旦我们有了一个应用程序， 我们就可以使用 GitHub 快速地共享它， 如果我们对我们的结构很了解， 我们就可以在其他项目中重用这个框架。</p><p>从这个项目中得出的关键点适用于许多常规数据科学项目：</p><ol><li>在开始一项数据科学任务之前， 拥有适当的框架/结构( Bokeh 或其他的框架)是至关重要的。 这样， 您就不会发现自己迷失在试图查找错误的代码森林中。 而且， 一旦我们开发了一个有效的框架， 它就可以以最小的工作量被复用， 从而在未来带来收益。</li><li>找到一个调试周期， 使你能够快速进行想法迭代是至关重要的。 Jupyter Notebook 支持编写代码—查看结果—修复错误的循环， 这有助于提高开发周期的效率(至少对于小型项目来说是这样)。</li><li>Bokeh 中的交互式应用程序将提升您的项目并鼓励用户参与。 仪表盘可以是独立的探索性项目， 也可以突出显示你已经完成的所有艰难的分析工作!</li><li>你永远不知道在哪里可以找到下一个你在工作中能用到的或有帮助的工具。 所以睁大你的眼睛， 不要害怕尝试新的软件和技术!</li></ol><p>这就是本文和本系列的全部内容， 尽管我计划在未来在额外发布有关 Bokeh 的独立教程。 以一种令人信服的方式展示数据科学成果是至关重要的， 有了像 Bokeh 和 plot.ly 这样的库， 制作交互式图形变得越来越容易。 你可以在 <a href="https://github.com/WillKoehrsen/Bokeh-Python-Visualization">Bokeh GitHub repo</a> 查看我所有的工作， 免费 fork 它并开始你自己的项目。 现在， 我渴望看到其他人能创造出什么!</p><p>一如既往地， 我欢迎反馈和建设性的批评。 你可以通过 Twitter <a href="https://twitter.com/koehrsen_will">@koehrsen_will</a>联系到我。</p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> Python </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】使用 SVG 和 Vue.Js 构建动态树图</title>
      <link href="p/dfc1.html"/>
      <url>p/dfc1.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用-SVG-和-Vue-Js-构建动态树图"><a href="#使用-SVG-和-Vue-Js-构建动态树图" class="headerlink" title="使用 SVG 和 Vue.Js 构建动态树图"></a>使用 SVG 和 Vue.Js 构建动态树图</h1><p>本文将会带你了解到我是如何创建一个动态树图的，该图使用 SVG（可缩放矢量图形）绘制三次贝塞尔曲线（Cubic Bezier）路径并通过 Vue.js 以实现数据响应。</p><p>在开始前，<a href="http://svg-tree-diagram.surge.sh/">先让我们来看一个 demo</a>。</p><p><img src="https://cdn-images-1.medium.com/max/2242/1*i9yyyuT1hxMj1K7ZGP4vDg.png"></p><p>基于 SVG 和 Vue.js 框架的强大功能，我们可以轻松创建基于数据驱动、可交互和可配置的图表与信息图。</p><p>该图是一个三次贝塞尔曲线的集合，它基于用户提供的数据，从单点出发，并在不同的点结束，且点和点之间的距离相同。 因此，该图会响应用户输入的内容。</p><p>我们将首先学习如何制作三次贝塞尔曲线，然后通过剪切蒙版在坐标系中尝试找到 <code>&lt;svg&gt;</code> 元素可用的 <code>x</code> 和 <code>y</code> 点。</p><p>我在这个案例中使用了很多视觉动画以保证趣味性。本文的主要思想是帮助你为类似的项目设计出自己的图表。</p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><h4 id="Cubic-Bezier-曲线是如何形成的？"><a href="#Cubic-Bezier-曲线是如何形成的？" class="headerlink" title="Cubic Bezier 曲线是如何形成的？"></a>Cubic Bezier 曲线是如何形成的？</h4><p>你在上面的 demo 中看到的曲线被称为三次贝塞尔曲线。我已在下面高亮显示了此曲线结构的每个部分。</p><p><img src="https://cdn-images-1.medium.com/max/3960/1*GPp1gpDRFC-Xx9z7Tg85iQ.png"></p><p>它总共有 4 对坐标。第一对坐标 —— <code>(x0, y0)</code> —— 是起始锚点，最后一对坐标 —— <code>(x3, y3)</code> —— 是结束锚点，指示完成路径的位置。</p><p>中间的两对坐标是：</p><ul><li>贝塞尔控制点 #1 <code>(x1, y1)</code> 和</li><li>贝塞尔控制点 #2 <code>(x2, y2)</code></li></ul><p>基于这些点实现的路径是一条平滑曲线。如果没有这些控制点，这条路径就是一条笔直的线！</p><p>让我们把这四个坐标放入 SVG 语法的 <code>&lt;path&gt;</code> 元素中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 三次贝塞尔曲线的路径语法</span><br><span class="line"></span><br><span class="line">&lt;path D&#x3D;&quot;M x0,y0  C x1,y1  x2,y2  x3,y3&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>语法中的字母 <code>c</code> 代表三次贝塞尔曲线。小 <code>c</code> 表示相对值，而大写 <code>C</code> 表示绝对值。我用绝对值 <code>C</code> 来创建这个图。</p><p><strong>实现对称性</strong></p><p>对称性是实现该图的关键点。为了实现这一点，我只使用一个变量来派生出类似于高度，宽度和中点等值。</p><p>就让我们把这个变量命名为 <code>size</code> 吧。由于此树形图的方向是水平的，因此可以将变量 <code>size</code> 视为整张图的<strong>水平</strong>空间。</p><p>让我们为这个变量赋予实际值。这样，你还可以计算路径的坐标。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size &#x3D; 1000</span><br></pre></td></tr></table></figure><h2 id="寻找坐标"><a href="#寻找坐标" class="headerlink" title="寻找坐标"></a>寻找坐标</h2><p>在我们寻找坐标前，我们需要新建一个坐标系！</p><h4 id="坐标系和-viewBox"><a href="#坐标系和-viewBox" class="headerlink" title="坐标系和 viewBox"></a>坐标系和 viewBox</h4><p><code>&lt;svg&gt;</code> 元素的 <code>viewBox</code> 属性非常重要，因为它定义了 SVG 的用户坐标系。简而言之，<code>viewBox</code> 定义了用户空间的位置和维度以便于绘制 SVG。</p><p><code>viewBox</code> 由四个数字组成，顺序需要保持一致 —— <code>min-x, min-y, width, height</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;svg viewBox&#x3D;&quot;min-x min-y width height&quot;&gt;...&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><p>我们之前定义的 <code>size</code> 变量将控制此坐标系的 <code>width</code> 和 <code>height</code>。</p><p>稍后在 Vue.js 部分，<code>viewBox</code> 将绑定到计算属性以填充 <code>width</code> 和 <code>height</code>，而 <code>min-x</code> 和 <code>min-y</code> 在此实例中始终为零。</p><p>请注意，我们没有使用 <strong>SVG 元素</strong>本身的 <code>width</code> 和 <code>height</code> 属性。因为，我们稍后会通过 CSS 设置 <code>&lt;svg&gt;</code> 的 <code>width: 100%</code> 和 <code>height: 100%</code>，以便自适应填满整个 viewport。</p><p>现在整张图的用户空间 / 坐标系已准备好，让我们看看 <code>size</code> 变量如何通过使用不同的 <code>%</code> 值来帮助计算坐标。</p><h4 id="恒定和动态坐标"><a href="#恒定和动态坐标" class="headerlink" title="恒定和动态坐标"></a>恒定和动态坐标</h4><p><img src="https://cdn-images-1.medium.com/max/5184/1*2CRePTNtiym2q7eJKxEUWQ.png" alt="Diagram Concept"></p><p>圆是图的一部分。这就是为什么从一开始就把它包含在计算中是很重要的。如上图所示，让我们开始导出一个<strong>圆</strong>和<strong>一个样本路径</strong>的坐标值。</p><p>**垂直高度分为两部分：<code>topHeight</code>（<code>size</code> 的 20%）和 <code>bottomHeight</code>（<code>size</code> 剩余的 80%）。水平宽度分为两部分 —— 分别是 <code>size</code> 的 50%**。</p><p>这样圆坐标（<code>halfSize, topHeight</code>）就显而易见了。圆的 <code>radius</code> 属性设置为 <code>topHeight</code> 的一半，这样的可用空间非常合适。</p><p>现在，让我们看一下路径坐标……</p><ul><li><strong><code>x0, y0</code></strong> —— 第一对锚点<strong>始终保持不变</strong>。这里，<code>x0</code> 是图表 <code>size</code> 的中心，<code>y0</code> 是圆圈停止的垂直点（<strong>因此增加了一个 radius</strong>）并且是路径的起点。<br>=<code>（50% 的 size, 20% 的 size + radius）</code></li><li><strong><code>x1, y1</code></strong> —— 贝塞尔控制点 1，对于所有路径<strong>也保持不变</strong>。考虑到对称性，<code>x1</code> 和 <code>y1</code> 总是图表 <code>size</code> 的一半。<br>= <code>(50% 的 size, 50% 的 size)</code></li><li><strong><code>x2, y2</code></strong> —— 贝塞尔控制点 2，其中 <code>x2</code> 指示哪一侧形成曲线并且为每条路径<strong>动态计算</strong>。同样，<code>y2</code> 是图表 <code>size</code> 的一半。<br>= <code>(x2, 50% 的 size)</code></li><li><strong><code>x3, y3</code></strong> —— 最后一对锚点，指示路径绘制结束的位置。这里，<code>x3</code> 模仿 <code>x2</code> 的值，这是动态计算的。<code>y3</code> 占据了 <code>size</code> 的 80%。<br>= <code>(x3, 80% 的 size)</code></li></ul><p>在合并上述计算结果后，请参阅下面的通用路径语法。为了表示 <code>%</code>，我只是简单的将 <code>%</code> 值除以 100。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;path d&#x3D;&quot;M size*0.5, (size*0.2) + radius  </span><br><span class="line">         C size*0.5,  size*0.5</span><br><span class="line">           x2,        size*0.5</span><br><span class="line">           x3,        size*0.8&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：整个代码逻辑中 <code>%</code> 的选择最初看起来似乎全是主观推断，但它是为了实现对称而选择的正确比例。一旦你了解了构建此图表的目的，你就可以尝试自己的 <code>%</code> 值并检查不同的结果。</strong></p><p>下一部分重点是找到剩余坐标 <code>x2</code> 和 <code>x3</code> 的值 —— 这使得能够根据它们的数组索引动态地形成多个弯曲路径。</p><p>根据数组中的多个元素，可用的水平空间应分配到相等的部分，以便每个路径在 <code>x-axis</code> 上获得相同的空间量。</p><p>公式最终应适用于任意数量的项目，但出于本文的目的，我已经使用了 5 个数组项 —— <code>[0,1,2,3,4]</code>。意思是，我将绘制 5 条贝塞尔曲线。</p><h4 id="寻找动态坐标（x2-和-x3）"><a href="#寻找动态坐标（x2-和-x3）" class="headerlink" title="寻找动态坐标（x2 和 x3）"></a>寻找动态坐标（x2 和 x3）</h4><p>首先，我将 <code>size</code> 除以元素数，即数组长度，并命名为 <code>distance</code> —— 作为两个元素之间的距离。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distance &#x3D; size&#x2F;arrayLength</span><br><span class="line">&#x2F;&#x2F; distance &#x3D; 1000&#x2F;5 &#x3D; 200</span><br></pre></td></tr></table></figure><p>然后，我循环遍历数组中的每个元素，并将其 <code>index</code> 值乘以 <code>distance</code>。 为了描述简单，我用 <code>x</code> 表示 <code>x2</code> 和 <code>x3</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; value of x2 and x3</span><br><span class="line">x &#x3D; index * distance</span><br></pre></td></tr></table></figure><p>当我使用 <code>x</code> 的值来表示 <code>x2</code> 和 <code>x3</code> 时，这张图看起来有点奇怪。</p><p><img src="https://cdn-images-1.medium.com/max/6068/1*0whAEEtgKwVpeNf1uZY5ug.png"></p><p>如你所见，坐标的位置是正确的，但不是很对称。左侧的元素看起来比右侧的元素多。</p><p>此时因为一些原因，我需要将 <code>x3</code> 坐标放在 <code>distance</code> 的中心，而不是在一开始的地方。</p><p>为了解决这个问题，让我们重新审视下变量 <code>distance</code> —— 对于给定的场景，它的值是 200。我只是给 <code>x</code> 又加了 <strong>distance 的一半</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; index * distance + (distance * 0.5)</span><br></pre></td></tr></table></figure><p>上式意思是，我找到了 <code>distance</code> 的中点并将最终的 <code>x3</code> 坐标放在那里，并调整了贝塞尔曲线 #2 的 <code>x2</code>。</p><p><img src="https://cdn-images-1.medium.com/max/6334/1*i2-TArj3Jol77m5f2fxgZA.png"></p><p>在 <code>x2</code> 和 <code>x3</code> 坐标中添加 <strong>distance 的一半</strong>，适用于数组的奇数项和偶数项元素。</p><h4 id="图层蒙版"><a href="#图层蒙版" class="headerlink" title="图层蒙版"></a>图层蒙版</h4><p>为了使蒙版形状为圆形，我已经在 <strong>mask</strong> 元素中<strong>定义</strong>了一个 <strong>circle</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  &lt;mask id&#x3D;&quot;svg-mask&quot;&gt;</span><br><span class="line">     &lt;circle :r&#x3D;&quot;radius&quot; </span><br><span class="line">             :cx&#x3D;&quot;halfSize&quot; </span><br><span class="line">             :cy&#x3D;&quot;topHeight&quot; </span><br><span class="line">             fill&#x3D;&quot;white&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;mask&gt;</span><br><span class="line">&lt;&#x2F;defs&gt;</span><br></pre></td></tr></table></figure><p>接下来，使用 <code>&lt;svg&gt;</code> 元素中的 <code>&lt;image&gt;</code> 标签作为内容，我使用 <code>mask</code> 属性将图像绑定到 <code>&lt;mask&gt;</code> 元素里（已在上述代码中创建）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;image mask&#x3D;&quot;url(#svg-mask)&quot; </span><br><span class="line">      :x&#x3D;&quot;(halfSize-radius)&quot; </span><br><span class="line">      :y&#x3D;&quot;(topHeight-radius)&quot;</span><br><span class="line">...</span><br><span class="line">&gt; </span><br><span class="line">&lt;&#x2F;image&gt;</span><br></pre></td></tr></table></figure><p>由于我们试图将方形图像拟合成圆形，我通过减小圆的 <code>radius</code> 来调整图像位置，以通过圆形蒙版实现图像的完全可见性。</p><p>让我们将所有的值都放入图表中，以帮助我们看到完整的图像。</p><p><img src="https://cdn-images-1.medium.com/max/3752/1*kWPi7xIsu6PF9drIwOKo4Q.png"></p><h2 id="使用-Vue-js-的动态-SVG"><a href="#使用-Vue-js-的动态-SVG" class="headerlink" title="使用 Vue.js 的动态 SVG"></a>使用 Vue.js 的动态 SVG</h2><p>到目前为止，我们已经了解了贝塞尔曲线的本质，以及它的工作原理。因此，我们有了静态 SVG 图的概念。使用 Vue.js 和 SVG，我们现在将用数据驱动图表，并将其从静态转换为动态。</p><p>在本节中，我们将把 SVG 图分解为 Vue 组件，并将 SVG 属性绑定到计算属性，并使其响应数据更改。</p><p>最后，我们还将查看配置面板组件，该组件用于向动态 SVG 图提供数据。</p><p>我们将在本节中了解以下关键主题。</p><ul><li>绑定 SVG viewBox</li><li>计算 SVG 路径坐标</li><li>实现贝塞尔曲线路径的两个选项</li><li>配置面板</li><li>家庭作业 ❤</li></ul><p><strong>绑定 SVG viewBox</strong></p><p>首先，我们需要一个坐标系统才能在 SVG 内部绘制。 计算属性 <code>viewbox</code> 将使用 <code>size</code> 变量。它包含由空格分隔的四个值 —— 它被送入 <code>&lt;svg&gt;</code> 元素的 <strong><code>viewBox</code></strong> 属性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">viewbox() </span><br><span class="line">&#123;</span><br><span class="line">   return &quot;0 0 &quot; + this.size + &quot; &quot; + this.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SVG 中，<code>viewBox</code> 属性<strong>已经</strong>使用驼峰命名法（camelCase）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;svg viewBox&#x3D;&quot;0 0 1000 1000&quot;&gt;</span><br><span class="line">&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><p>因此为了正确绑定上计算属性，我在 <code>.camel</code> 修饰符后对该变量使用了短横线命名（kebab-case）的方式（如下所示）。通过这种方式，HTML 才得以正确绑定此属性。</p><p>现在，每次我们更改 <code>size</code> 时，图表都会自行调整，而无需手动更改标记。</p><p><strong>计算 SVG 路径坐标</strong></p><p>由于大多数值都是从单个变量 <code>size</code> 派生的，所以我已经为所有常量坐标使用了计算属性。不要被这里的常量混淆。这些值是从 <code>size</code> 中派生出来的，但在<strong>此</strong>之后，无论创建多少曲线路径，它们都保持不变。</p><p>如果你改变 SVG 的大小，这些值会再次被计算出来。考虑到这一点，这里列出了绘制贝塞尔曲线所需的五个值。</p><ul><li>topHeight — <code>size * 0.2</code></li><li>bottomHeight — <code>size * 0.8</code></li><li>width — <code>size</code></li><li>halfSize — <code>size * 0.5</code></li><li>distance — <code>size/arrayLength</code></li></ul><p>此时，我们只剩下两个未知值，即 <code>x2</code> 和 <code>x3</code>，我们有一个公式可以确定它们的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; index * distance + (distance * 0.5)</span><br></pre></td></tr></table></figure><p>为了找到上面的 <code>x</code>，我们需要一次将 <code>index</code> 输入到每个路径的公式中。所以……</p><p>在这使用计算属性合适吗？肯定不合适。</p><p>我们不能将参数传递给计算属性 —— 因为它是一个属性，而不是函数。另外，需要一个参数来计算意味着——使用计算属性对缓存也没什么好处。</p><p><strong>注意：上面有一个例外，Vuex。如果我们正在使用 Vuex Getters，那么，我们可以通过返回一个函数将参数传递给 getter。</strong></p><p>在本文所述的情况下，我们不使用 Vuex。可即便如此，我们仍有两个选择。</p><h4 id="选择一"><a href="#选择一" class="headerlink" title="选择一"></a>选择一</h4><p>我们可以定义一个函数，在这里我们将数组 <code>index</code> 作为参数传递并返回结果。如果要在模板中的多个位置使用此值，选择 <code>Bit cleaner</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;g v-for&#x3D;&quot;(item, i) in itemArray&quot;&gt;</span><br><span class="line">  &lt;path :d&#x3D;&quot;&#39;M&#39; + halfSize + &#39;,&#39;         + (topHeight+r) +&#39; &#39;+</span><br><span class="line">            &#39;C&#39; + halfSize + &#39;,&#39;         + halfSize +&#39; &#39;+    </span><br><span class="line">                  calculateXPos(i) + &#39;,&#39; + halfSize +&#39; &#39;+ </span><br><span class="line">                  calculateXPos(i) + &#39;,&#39; + bottomHeight&quot; </span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;g&gt;</span><br></pre></td></tr></table></figure><p>calculateXPos() 方法将在每次调用时进行评估。并且此方法接受索引 —— <code>i</code> —— 作为参数（代码如下）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    calculateXPos (i)</span><br><span class="line">    &#123;</span><br><span class="line">      return distance * i + (distance * 0.5)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>下面是运行在 CodePen 上 Option 1 的结果。</p><p><a href="https://codepen.io/krutie/pen/eoRXWP">Option 1 - Bezier Curve Tree Diagram with Vue Js</a></p><h4 id="选择二"><a href="#选择二" class="headerlink" title="选择二"></a>选择二</h4><p>更好的是，我们可以将这个小的 SVG 路径标记提取到它自己的子组件中，并将 <code>index</code> 作为一个属性传递给它 —— 当然，还有其他必需的属性。</p><p>在这个例子中，我们甚至可以使用计算属性来查找 <code>x2</code> 和 <code>x3</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;g v-for&#x3D;&quot;(item, i) in items&quot;&gt; </span><br><span class="line">    &lt;cubic-bezier  :index&#x3D;&quot;i&quot; </span><br><span class="line">                   :half-size&#x3D;&quot;halfSize&quot; </span><br><span class="line">                   :top-height&#x3D;&quot;topHeight&quot; </span><br><span class="line">                   :bottom-height&#x3D;&quot;bottomHeight&quot; </span><br><span class="line">                   :r&#x3D;&quot;radius&quot;</span><br><span class="line">                   :d&#x3D;&quot;distance&quot;</span><br><span class="line">     &gt;</span><br><span class="line">     &lt;&#x2F;cubic-bezier&gt;</span><br><span class="line">&lt;&#x2F;g&gt;</span><br></pre></td></tr></table></figure><p>这种方法可以让我们的代码更具条理，例如，我们可以为一个圆形剪切蒙版创建一个或多个子组件，如下所示。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;clip-mask :title&#x3D;&quot;title&quot;</span><br><span class="line">           :half-size&#x3D;&quot;halfSize&quot; </span><br><span class="line">           :top-height&#x3D;&quot;topHeight&quot;                     </span><br><span class="line">           :r&#x3D;&quot;radius&quot;&gt; </span><br><span class="line">&lt;&#x2F;clip-mask&gt;</span><br></pre></td></tr></table></figure><h4 id="配置面板"><a href="#配置面板" class="headerlink" title="配置面板"></a>配置面板</h4><p><img src="https://cdn-images-1.medium.com/max/2000/1*zI1UlqRzNrxoGQdgl9nCSA.png" alt="Config Panel"></p><p>您可能已经在 CodePen 左上角看到了 <strong>控制面板</strong>。它可以添加和删除数组中的元素。在 Option 2 中，我创建了一个子组件来容纳 Config Panel，使顶级 Vue 组件清晰可读。我们的 Vue 组件树看起来就像下面这样。</p><p><img src="https://cdn-images-1.medium.com/max/2942/1*ztoHw3dN6o_0VvwI1UOpxw.png"></p><p>想知道 Option 2 的代码是什么样子的？下面的链接是在 CodePen 上使用了 Option 2 的代码。</p><p><a href="https://codepen.io/krutie/pen/Bexoez">Option 2 - Bezier Curve Tree Diagram with Vue Js</a></p><h2 id="GitHub-仓库"><a href="#GitHub-仓库" class="headerlink" title="GitHub 仓库"></a>GitHub 仓库</h2><p>最后，这里有一个为你准备的 <a href="https://github.com/Krutie/svg-tree-diagram">GitHub Repo</a>，你可以在进入下一部分之前查看该项目（使用选项 2）。</p><h2 id="家庭作业"><a href="#家庭作业" class="headerlink" title="家庭作业"></a>家庭作业</h2><p>尝试基于本文中介绍的逻辑在垂直模式下创建相同的图表。</p><p>如果你认为，它是交换坐标系中的 <code>x</code> 值和 <code>y</code> 值一样简单的话，那么你是对的！因为最艰难的部分已经完成，在交换了<strong>所需</strong>的坐标后，再用适当的变量和方法更新代码。</p><p>在 Vue.js 的帮助下，该图可以通过更多功能进一步扩展，例如，</p><ul><li>创建一个开关以便于在水平和垂直模式之间切换</li><li>可以使用 GSAP 为路径设置动画</li><li>从配置面板控制路径属性（例如颜色和笔触宽度）</li><li>使用第三方工具库将图表保存并下载为图像/PDF</li></ul><p>现在试一试，如果需要的话，下面是家庭作业的答案链接。</p><p>祝你好运！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>&lt;path&gt;</code> 是 SVG 中众多强大的元素之一，因为它允许你精确地创建图形和图表。在本文中，我们了解了贝塞尔曲线的工作原理以及如何创建一个自定义图表应用。</p><p>利用现代 JavaScript 框架所使用的数据驱动方法进行调整总是令人生畏的，但 Vue.js 使它变得非常简单，并且还可以处理诸如 DOM 操作之类的简单任务。因此，作为一名开发人员，即使在处理具有明显视觉效果的项目时，你也可以用数据的方式进行思考。</p><p>我已经意识到创建这个看起来很复杂的图表需要 Vue.js 和 SVG 的一些简单概念。如果你还没有准备好，我建议您阅读有关<a href="https://www.smashingmagazine.com/2018/11/interactive-infographic-vue-js/">使用 Vue.js 构建交互式信息图</a>的内容。读完那篇文章后再回过头阅读本文就会容易很多。❤这是家庭作业的<a href="https://codepen.io/krutie/pen/QRrNKz">答案</a>。</p><p>我希望你从这篇文章中学到了一些东西，并在阅读本文时能够感受到我当时创作时的乐趣。</p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】人工智能何以留存</title>
      <link href="p/cbb1.html"/>
      <url>p/cbb1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://medium.com/hackernoon/why-ai-is-here-to-stay-9c75b1868b9b">https://medium.com/hackernoon/why-ai-is-here-to-stay-9c75b1868b9b</a> ，本文的主旨是从人人交互过度到人际交互，帮助我们更好的理解什么是人工智能。但是不得不说，这篇文章是真的很难翻译，原文读起来大致可以理解，但是真想重新组织语言将文章翻译的有条有理真的好难啊，英语好的朋友可以自行阅读原文，之后我会努力提高自己的姿势水平，争取为大家带来更多优质的译文。</p></blockquote><h2 id="人机之间的沟通革命"><a href="#人机之间的沟通革命" class="headerlink" title="人机之间的沟通革命"></a>人机之间的沟通革命</h2><p>如果你曾经参加过<a href="http://bit.ly/quaesita_ai">人工智能</a>会议，我敢打赌你一定会遇到一个目光十分平静的镀铬机器人，这张图片是从一堆<a href="https://twitter.com/hmason/status/1123750831587827713">令人毛骨悚然的机器人图库</a>中精心挑选的，以至于现如今，任何一个营销团队都无法拒绝在广告牌上贴出这张图。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c7123a0e654fc8?w=1280&h=720&f=png&s=1025371"></p><p>很明显，我使用了玲珑蓝（<a href="http://bit.ly/octarineai">octarine-blue</a>）的科幻艺术配色来吸引疲惫的读者阅读我的<a href="https://medium.com/@kozyrkov">博客</a>，对此我感到十分抱歉。虽然这种方法十分奏效，不过遗憾的是，这些图像几乎与<a href="http://bit.ly/quaesita_ai">人工智能无关</a>。</p><h2 id="机器人技术令人振奋，但大多没有用处；"><a href="#机器人技术令人振奋，但大多没有用处；" class="headerlink" title="机器人技术令人振奋，但大多没有用处；"></a>机器人技术令人振奋，但大多没有用处；</h2><h2 id="如今的人工智能大多无聊，但却非常有用。"><a href="#如今的人工智能大多无聊，但却非常有用。" class="headerlink" title="如今的人工智能大多无聊，但却非常有用。"></a>如今的人工智能大多无聊，但却非常有用。</h2><p>也许你认为我们都应该为自己感到羞耻，但是不用担心，<a href="http://bit.ly/quaesita_ai">人工智能</a><a href="http://bit.ly/quaesita_island">太有用了</a>，以至于无论我们怎么喊“狼来了”，它都不会消失。理由如下。</p><h2 id="人工智能为程序员提供了另一种方法，来告诉计算机要做什么事。"><a href="#人工智能为程序员提供了另一种方法，来告诉计算机要做什么事。" class="headerlink" title="人工智能为程序员提供了另一种方法，来告诉计算机要做什么事。"></a>人工智能为程序员提供了另一种方法，来告诉计算机要做什么事。</h2><p>营销人员四处奔走，试图用科幻噱头来吸引你的注意力，但你长期在<a href="http://bit.ly/quaesita_ai">人工智能</a>上消费的原因并不是因为这些噱头。真正的原因是与机器进行交流。</p><p><a href="http://bit.ly/quaesita_simplest">人工智能为程序员提供了另一种方法，来告诉计算机要做什么事。</a>这种与机器交谈的新方式为何如此有用？为什么它会是一场技术革命？为了理解这些，让我们先暂时忘记计算机，然后把关注点放到人上面。我会摊开所有底牌，然后帮你揭开人工智能用途的层层迷雾。</p><h2 id="人与人之间如何交谈"><a href="#人与人之间如何交谈" class="headerlink" title="人与人之间如何交谈"></a>人与人之间如何交谈</h2><p>我们通过两种方式向别人表达我们的意愿。一个是通过明确的指令，另一个是通过举例。</p><p>如果你想学习如何预测我要点的星巴克订单，你可以在我的旅行中跟随我。你可能会注意到，我在美国机场会点一杯四盎司的浓缩咖啡，但是到了台北、孟买和内罗毕就变成了一杯拿铁。这是怎么回事？再举几个例子，你可能就能自己找出规律了。这就是人工智所要做的 —— <a href="http://bit.ly/quaesita_emperor">将实例转化为指令</a>。如果你只看到我点了一两次星巴克（没有足够的<a href="http://bit.ly/quaesita_hist">数据</a>），或者你只观察到 50 次我在街上同一个地方订购我常喝的卡布奇诺咖啡（<a href="http://bit.ly/quaesita_biasdef">无关紧要的数据</a>，因为地点不是星巴克），那你将不可能把这些弄清楚。人工智能也是如此。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c7123a0c5bc7b8?w=960&h=639&f=jpeg&s=106879"></p><p>当然，我也可以把我的星巴克规则告诉你，因为表达起来非常容易：<strong>“如果他们有 B 奶（ half and half），点一中杯四盎司的浓缩咖啡，然后加满 B 奶</strong>（别批判我的喜好）<strong>。如果没有，那就点一份中杯拿铁。”</strong></p><blockquote><p>Tips：星巴克的 B 奶是一半牛奶一半奶油的混合物，配方：是<strong>1份浓缩咖啡+0.75份热牛奶和0.75份鲜奶油混合+0.5份奶泡</strong></p></blockquote><p>这里的重点是，如果我教一个人类驴友，让他能够使用两种交流方式自然是非常好的。当明确的指令易于提出和表达时，我就可以像人们几十年来一直与电脑交谈一样为朋友编写程序：<strong>如果是这样的话，就那样做。</strong></p><p>但如果我甚至不知道为什么我在纽约的某些日子点一杯卡布奇诺，而在其他日子点馥芮白呢？我不能给你公式，因为<strong>即使是我也不知道</strong>。但我想请你试试看，看你能不能找出规律。也许会有一个规律，也许没有，但你至少可以<strong>尝试</strong>着算出来，这很棒。没有<a href="http://bit.ly/quaesita_emperor">机器学习或者人工智能</a>，计算机就无法<strong>尝试</strong><a href="http://bit.ly/quaesita_emperor">找到一个模式</a>。那样的话要么是明确的指示，要么就是失败。</p><h2 id="人工智能是关于人类的自我表达。"><a href="#人工智能是关于人类的自我表达。" class="headerlink" title="人工智能是关于人类的自我表达。"></a>人工智能是关于人类的自我表达。</h2><p>也许你会发现在有些地凭方气味就能做到这些。你可能不知道为什么这样会有效（也许这种气味会引发一种与我父亲在去完剧院后喝卡布奇诺相关的感觉，但是你无法获得这些信息）但你会意识到，你能够准确预测我要做什么。最终，你会自信满满的说：<strong>“这次是白咖啡？我知道了。”</strong> 我会目瞪口呆地站在那里，因为我不知道你是怎么知道的。过一段时间我就不会担心了，我会<a href="http://bit.ly/quaesita_donttrust">相信你</a>。只要我的偏好不变，你就会一直做对，<a href="http://bit.ly/quaesita_xai">即使我们</a>都不知道为什么。</p><h2 id="我给出明确指令这一过程是传统编程。我要求你学会从相关例子中学习-这才是机器学习和人工智能的本质。"><a href="#我给出明确指令这一过程是传统编程。我要求你学会从相关例子中学习-这才是机器学习和人工智能的本质。" class="headerlink" title="我给出明确指令这一过程是传统编程。我要求你学会从相关例子中学习,这才是机器学习和人工智能的本质。"></a>我给出明确指令这一过程是<a href="http://bit.ly/quaesita_simplest">传统编程</a>。我要求你学会从相关例子中学习,这才是<a href="http://bit.ly/quaesita_emperor">机器学习和人工智能的本质</a>。</h2><p>所以这就是为什么<a href="http://bit.ly/quaesita_fad">人工智能并不是昙花一现</a>：在现实生活中，如果我不能够聪明地提出指示，我就无法放弃依靠举例教学的能力。我很确定，当我在现实世界中磕磕绊绊时，我更多地是用例子而不是指令来与他人交流。</p><p>人工智能意味着我可以用第二种方式与电脑交流——通过例子——而不仅仅是指令，你是认真地要求我突然把自己的嘴塞住吗？请记住，在过去，我们必须主要依赖指令，只是因为我们不能用另一种方法来做，部分原因是，处理所有这些示例将<a href="http://bit.ly/forbes_ai">使上世纪可怜的台式机的 CPU 不堪重负</a>。</p><p>但是现在人类已经通过实例解锁了向机器表达自己的能力，为什么我们会突然完全放弃这个选择呢？这第二种与计算机交谈的方式太重要了，不能像昨日的垫肩那样抛弃掉。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c7123a184b9c3f?w=600&h=284&f=jpeg&s=37046"></p><p>我们应该放弃的是期望有一种通用的方式与计算机就每个问题进行通信。说出你的意愿，并以最佳方式说出来。有时你想要提供指令，有时你想要提供大量示例。</p><h2 id="有些任务太复杂了，你无法记住它们的指令"><a href="#有些任务太复杂了，你无法记住它们的指令" class="headerlink" title="有些任务太复杂了，你无法记住它们的指令"></a>有些任务太复杂了，你无法记住它们的指令</h2><p>因为人工智能允许你自动化处理那些无法言说的东西，就是在某些情况下我们只会做出唯一的选择，但我们却无法细化成特定的指令。你还不够聪明去弄清楚这些模式是什么意思，或者这些指令是如此的复杂以至于当你读到第七千行时你忘记了第一行。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c7123a1aa3a4df?w=600&h=400&f=jpeg&s=81118" alt="Want to memorize all this? Me neither. Computers don’t mind, though."></p><p>计算机不介意记忆冗长乏味的<a href="http://bit.ly/quaesita_hist">示例集</a>或指令手册。他们可以快速地浏览这些例子，即使这是一项你根本不想碰的任务。<a href="http://bit.ly/quaesita_fad">有些任务太复杂了，你无法记住它们的指令</a>。当所有<a href="http://bit.ly/quaesita_fad">容易实现的任务</a>都通过直接而明确的指令自动完成时，就需要处理复杂的任务。在那个领域，除了人工智能谁都做不了。</p><p>如果这些任务非常复杂，你可能无法完美地自动化它们，但是使用人工智能你仍然可以做得比什么都没做好（不要忘记建立<a href="http://bit.ly/quaesita_policy">安全网</a>）。如果你确实获得了完美的表现，我的第一直觉就是想知道你的任务<a href="http://bit.ly/quaesita_fad">是否如此简单，以至于你真的应该以传统方式解决它</a>。不要用人工智能转换美元和美分……说真的，你在做什么？！这就是你可能在面对复杂问题而求助于人工智能的老套路。这也是为什么<a href="http://bit.ly/quaesita_first">人工智能的第一步</a>是从任务开始，并反复检查没有人工智能你是否就不能解决它。这也是为什么<a href="http://bit.ly/quaesita_first">人工智能的第一步</a>是从任务开始，并反复检查没有人工智能你是否就不能解决它。</p><p><strong>如果你渴望开始让 AI 对你有用，那么这里有<a href="http://bit.ly/quaesita_dmguide">一个指南</a>，决策者应该在所有人甚至思考数据或技术细节之前阅读。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】为用户提供安全可靠的体验</title>
      <link href="p/8245.html"/>
      <url>p/8245.html</url>
      
        <content type="html"><![CDATA[<p><em>发表自 Google Play 的产品经理总监， <em>Paul Bankhead</em></em></p><p>我们不遗余力地关注 Google Play Store 的安全性和隐私， 以确保 Android 用户拥有发现和安装他们喜欢的应用程序和游戏的积极体验。 我们定期更新我们的 <a href="https://play.google.com/about/developer-content-policy/">Google Play 开发者条款</a> ， 今天引入了更强的控制和<a href="https://play.google.com/about/updates-resources/">新的策略</a>来保持用户数据的安全。 以下是一些更新：</p><a id="more"></a><h2 id="安全性和性能升级"><a href="#安全性和性能升级" class="headerlink" title="安全性和性能升级"></a>安全性和性能升级</h2><p>如前<a href="https://android-developers.googleblog.com/2017/12/improving-app-security-and-performance.html">所述</a>， 截至 2018 年 11 月 1 日， Google Play 将<a href="https://developer.android.com/distribute/best-practices/develop/target-sdk">要求</a>对现有应用程序进行更新， 使其达到 API 级别 26（ Android 8.0 ）或更高（对于所有新应用程序来说， 这已经是必需的）。 我们的目标是确保 Google Play 上的所有应用程序都是使用优化了安全性和性能的最新的 API 来构建的。</p><h2 id="保护用户"><a href="#保护用户" class="headerlink" title="保护用户"></a>保护用户</h2><p>我们的 Google Play 开发者策略旨在为用户提供安全可靠的体验， 同时为开发人员提供获得成功所需的工具。 例如， 我们一直要求开发人员将权限请求限制为应用程序运行所需的权限， 并使用户清楚 APP 访问了他们的哪些数据。</p><p>作为今天的 Google Play 开发者策略<a href="https://play.google.com/about/updates-resources/">更新</a>的一部分， 我们公布了与 SMS 和呼叫日志权限相关的更改。 一些 Android 应用程序请求访问用户的电话（包括通话记录）和 SMS 数据。 将来， Google Play 将限制哪些应用程序可以请求这些权限。 只有被选为用户默认通话或短信的应用程序才能分别访问通话记录和 SMS 。</p><p>请访问我们的 <a href="https://play.google.com/about/developer-content-policy/#!?modal_active=none">Google Play Developer 策略中心</a>和这篇<a href="https://support.google.com/googleplay/android-developer/answer/9047303">帮助中心文章</a> ， 以获得关于 SMS 和呼叫日志权限的产品替代方案的详细信息。 例如， <a href="https://developers.google.com/identity/sms-retriever/overview">SMS Retriever API</a> 使您能够执行基于 SMS 的用户验证， <a href="https://developer.android.com/guide/components/intents-common#SendMessage">SMS Intent</a> 使你能够发起 SMS 或 MMS 文本消息来共享内容或邀请。 我们将与我们的开发伙伴合作， 给他们适当的时间来调整和更新他们的应用程序， 并将从此策略更新开始实施 90 天。</p><p>在未来几个月中， 我们将在各个产品和平台上推出额外的控制和策略， 并将继续与你（我们的开发人员）合作， 以帮助你完成过渡。</p><p>我们的用户信任是至关重要的， 我们将继续建立一个安全和可靠的 Android 生态系统。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方， 欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR， 也可获得相应奖励积分。 文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区， 文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。 内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、 <a href="https://github.com/xitu/gold-miner#ios">iOS</a>、 <a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、 <a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域， 想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、 <a href="http://weibo.com/juejinfanyi">官方微博</a>、 <a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Slidable： 一个有关 Flutter 的故事</title>
      <link href="p/31dd.html"/>
      <url>p/31dd.html</url>
      
        <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>这是创建 <strong>Slidable</strong> 小部件背后的故事（点击<a href="https://pub.dartlang.org/packages/flutter_slidable">这里</a>）。 他是一个当您向左侧或右侧滑动时， 可以在列表项上添加上下文操作的小部件。 </p><h3 id="这一切是如何开始的呢"><a href="#这一切是如何开始的呢" class="headerlink" title="这一切是如何开始的呢"></a>这一切是如何开始的呢</h3><a id="more"></a><p>我是一个充满激情的开发者。 编码是我维持生活的来源， 但它同时也是我的主要爱好 ❤️。 有些人通过文字， 图画， 音乐表达自己， 我通过代码表达自己。 变量和函数比打球更能让我感到舒服。 这就是我。 </p><p>2018 年 7 月我们在法国的布列塔尼， 这里阳光充足☀️， 有点热， 但我不想享受阳光或者去海滩， 我渴望学习新东西和编码。 </p><p>我是 Flutter 的忠实粉丝， 我已经发布了一些软件包（<a href="https://github.com/letsar/flutter_staggered_grid_view">flutter_staggered_grid_view</a>, <a href="https://github.com/letsar/flutter_parallax">flutter_parallax</a>, <a href="https://github.com/letsar/flutter_sticky_header">flutter_sticky_header</a>）。 所有这些都有一些共同之处： <strong>Slivers</strong>。<br>还记得吗？ 我想学习新的东西。 所以我选了一个新主题： 动画！ </p><p>既然我有东西要学， 我就需要一个想法， 那就是用这些知识创造一些东西。 我记得当我发现 Flutter 的时候， 我考虑了 3 个当时不存在的小部件： 交错的网格视图， 粘性标题和一个允许用户在左右滑动时显示在列表项两侧的上下文菜单。 我没有尝试过最后一个， 所以就诞生了这个想法💡。 </p><h3 id="从哪里开始呢"><a href="#从哪里开始呢" class="headerlink" title="从哪里开始呢"></a>从哪里开始呢</h3><p>在一个已有的例子上创造总是更容易。 这就是为什么每次我想要创造一些东西时， 我首先要研究是否有类似的我可以改进的东西。 </p><p>我开始在 Pub Dart 上搜索， 看看是否有人还没有发布过那个， 如果是这样的话， 我会停下来去寻找一个新的想法。 </p><p>在那里我找不到我想要的东西， 所以我搜索了 StackOverflow 并找到了这个<a href="https://stackoverflow.com/questions/46651974/swipe-list-item-for-more-options-flutter/46662914">问题</a>。 用户 Remi Rousselet 给出了一个非常好的<a href="https://stackoverflow.com/a/46662914/3241871">答案</a>。<br>我阅读并理解了他的代码， 这对我构建第一个原型有很大的帮助。 所以 Remi 先生， 如果您正在读着我的这篇文章， 那么我在此非常感谢您当初的帮助 👏。 </p><h3 id="从原型到第一次发布"><a href="#从原型到第一次发布" class="headerlink" title="从原型到第一次发布"></a>从原型到第一次发布</h3><p>在我开发了使用一个动画的原型后， 我立刻想到让开发人员创建自己的动画。 我想起一个让开发人员在网格中控制布局的工具 <a href="https://docs.flutter.io/flutter/rendering/SliverGridDelegate-class.html">SliverDelegate</a>， 并决定创建类似的东西。 </p><p>让开发人员自定义动画很棒， 但我必须提供一些内置动画， 以便任何开发人员都可以使用它们， 或调整我的动画来创建他们的动画。 </p><p>这就是为什么我首先创建了 3 个代表： </p><h4 id="SlidableBehindDelegate"><a href="#SlidableBehindDelegate" class="headerlink" title="SlidableBehindDelegate"></a>SlidableBehindDelegate</h4><p>使用这个对象， 滑动操作在列表项后。 </p><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164e93651d8445f1?w=324&h=75&f=gif&s=260891"></p><p>SlidableBehindDelegate 的例子</p><h4 id="SlidableScrollDelegate"><a href="#SlidableScrollDelegate" class="headerlink" title="SlidableScrollDelegate"></a>SlidableScrollDelegate</h4><p>使用此对象， 幻灯片操作将以与列表项相同的方向滚动。 </p><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164e93654143651b?w=324&h=75&f=gif&s=462626"></p><p> SlidableScrollDelegate 的例子</p><h4 id="SlidableStrechDelegate"><a href="#SlidableStrechDelegate" class="headerlink" title="SlidableStrechDelegate"></a>SlidableStrechDelegate</h4><p>使用此对象， 当列表项滑动时， 幻灯片操作正在增长。 </p><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164e936543565f81?w=324&h=75&f=gif&s=350910"></p><p>SlidableStrechDelegate 的例子</p><h4 id="SlidableDrawerDelegate"><a href="#SlidableDrawerDelegate" class="headerlink" title="SlidableDrawerDelegate"></a>SlidableDrawerDelegate</h4><p>有了这个， 滑动动作显示出一种视差效果， 就像在 iOS 中一样。 </p><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164e93659d3e090c?w=324&h=75&f=gif&s=374223"></p><p>SlidableDrawerDelegate 的例子</p><p>对于这个故事， 当我向我的同事 <a href="https://github.com/clovisnicolas">Clovis Nicolas</a> 展示前 3 位代表时， 他告诉我， 在 iOS 中拥有这样效果的应用会很棒。 由于我不是 iOS 用户， 我认为它更像是 SlidableStrechDelegate， 但没有。<br>这就是 SlidableDrawerDelegate 如何诞生的过程。 </p><h3 id="Flutter-中的动画"><a href="#Flutter-中的动画" class="headerlink" title="Flutter 中的动画"></a>Flutter 中的动画</h3><p>我没有写过我在 Flutter 中学到的关于动画的内容， 因为还有其他内容可以很好的解释它， 就像<a href="https://proandroiddev.com/animations-in-flutter-6e02ee91a0b2">这个</a>。 </p><p>但我可以分享我对 Flutter 中动画的感受： 它们非常棒且易于处理 😍！ </p><p>我很后悔之前没有使用过他们😃。 </p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>完成这些内置对象后， 我认为这将是一个很好的初始版本。 所以我公开了我的 <a href="https://github.com/letsar/flutter_slidable">GitHub 代码库</a>， 并在 <a href="https://pub.dartlang.org/packages/flutter_slidable">Dart Pub</a> 上发布了它。 </p><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164e93651f42101c?w=324&h=627&f=gif&s=1159747"></p><p>Slidable 部件预览</p><p>这就是 <strong>Slidable</strong> 部件如何诞生的过程。 现在它需要一些发展。 如果您想要一些新功能， 欢迎您在 GitHub 上创建一个 <a href="https://github.com/letsar/flutter_slidable/issues">issue</a>并解释您想要的内容。 如果它与我对这个包的看法一致， 我将很乐意实现它！ </p><p>您可以在<a href="https://github.com/letsar/flutter_slidable">代码库</a>中找到一些文档， 以及上面的<a href="https://github.com/letsar/flutter_slidable/blob/master/example/lib/main.dart">示例</a>。 </p><p>如果这个软件包对你有所帮助， 你可以通过⭐️这个 <a href="https://github.com/letsar/flutter_slidable">repo</a>， 或者👏这个故事。 你也可以在 <a href="https://twitter.com/lets4r">Twitter</a> 上关注我。 </p><p>如果您使用此软件包构建应用程序， 请告诉我😃。 </p><blockquote><p>如果发现译文存在错误或其他需要改进的地方， 欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR， 也可获得相应奖励积分。 文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。 </p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区， 文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。 内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、 <a href="https://github.com/xitu/gold-miner#ios">iOS</a>、 <a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、 <a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域， 想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、 <a href="http://weibo.com/juejinfanyi">官方微博</a>、 <a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】写一款小众的 flutter 图标包</title>
      <link href="p/d67.html"/>
      <url>p/d67.html</url>
      
        <content type="html"><![CDATA[<p>当所有的 flutter 开发人员都在制作可以在日常生活中被<strong>成千上万</strong>人使用的移动应用程序时，我<strong>呆坐</strong>在房间里，不禁陷入沉思，<strong>为何不做一款 flutter 的图标包呢</strong> 🤔</p><p>和平常一样，<strong>凌晨 3 点</strong>。我在网上搜索高质量的黑色主题包，想分享给一部分人，让他们觉得“<strong>嗯，你真厉害</strong>”。鉴于 GitHub 是新的社交媒体，我偶然发现了一个 <strong>“CSS”</strong> 库，我们学校最棒的一个程序员都曾给它点过赞（starred）。心想 <strong>“不妨深入地研究一下，看看这些字体是如何制作的。”</strong></p><p>在浏览了几分钟资源文件夹中的文件后，我回想起有一次，我使用了一个名为 <a href="https://pub.dev/packages/eva_icons_flutter"><strong>EvaIcons</strong></a> 的开源图标包。我访问了该包的 GitHub 地址，并开始阅读它的源码。和其他复杂的 flutter 包不同的是，这个 package 的结构相当简单。问题是，我应该看一个关于如何从 CSS 创建<strong>字体/图标</strong>并将其移植到 flutter 的教程吗？还是说我应该直接使用它，然后移植一小段代码看看是否有效?</p><h2 id="开始-🏁"><a href="#开始-🏁" class="headerlink" title="开始 🏁"></a>开始 🏁</h2><p>你需要做的第一件事就是找到一个包含 <strong>“.ttf”</strong> 文件的开源图标库。<strong>那 “.ttf” 是什么文件？</strong></p><blockquote><p><strong>TTF</strong> 文件是由苹果公司创建的一种字体文件格式，但可以同时运行在 Macintosh 和 Windows 平台上。它可以调整到任何大小并且不会失真，而且打印出来的效果和在屏幕上显示的看起来是一样的。<strong>TrueType</strong> 字体是 Mac OS X 和 Windows 上最常用的字体格式。我不知道其他类似的格式如 <strong>“.svg”, “.eot” 或者 “.woff”</strong> 是否都可以使用。</p></blockquote><p>我在 GitHub 上发现了一个名为 <a href="https://github.com/erikflowers/weather-icons">weather-icons</a> 开源 CSS 图标库。这是一个包含了 <strong>222 个精美天气主题的图标库</strong>。</p><h2 id="Flutter-包-📦"><a href="#Flutter-包-📦" class="headerlink" title="Flutter 包 📦"></a>Flutter 包 📦</h2><p>是时候来创建一个 flutter package 了。我们可以通过使用 Android Studio 这种<strong>老套</strong>而又略显<strong>笨拙</strong>的方法来创建一个 package，或者执行下面这个非常酷的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flutter create --template=package your_awesome_package_name</span><br></pre></td></tr></table></figure><p>砰! 💥💥 我们已经完成了一半。这些没什么好讲的。</p><h2 id="下一步-🤔"><a href="#下一步-🤔" class="headerlink" title="下一步 🤔"></a>下一步 🤔</h2><p>创建一个 <strong>assets/</strong> 文件夹，并将 <strong>&lt;font_name&gt;.ttf</strong> 文件放在其中。接下来我们来配置 <strong>pubspec.yaml</strong> 文件。这样我们就可以在我们的 dart 文件中使用图标了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dedc3eb122f9f2?w=1340&h=784&f=png&s=77093" alt="Add the fonts like this, replacing WeatherIcons with MyAwesomeIcons or whatever suits :)"></p><p>终于迈出了伟大的一步！<strong>现在我们来关注一下 dart 代码。</strong></p><h2 id="难点-😓"><a href="#难点-😓" class="headerlink" title="难点 😓"></a>难点 😓</h2><p>在 <strong>lib/</strong> 目录中创建一个 <strong>src/</strong> 文件夹。并在其中创建一个名为 <strong>icon_data.dart</strong> 的文件。文件里面该写些什么？<strong>猜的不错！</strong> 我们需要在里面放入图标的数据。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dedc3eb61a03e1?w=1292&h=820&f=png&s=101506" alt="Your custom IconData class extending the one which is available in the widgets library."></p><p>我们编写了一个构造函数，它接受一个值 <strong>“codePoint”</strong>，这个值是图标的十六进制代码。我们很快就会看到一些关于它的东西。</p><p>到目前为止都很容易？那接下来是什么呢？</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dedc3eb3a0d32d?w=1388&h=896&f=png&s=107858" alt="Huff! We can’t write this all by ourselves. 222 codePoints!!"></p><h2 id="容易的一步-🤩"><a href="#容易的一步-🤩" class="headerlink" title="容易的一步 🤩"></a>容易的一步 🤩</h2><p>我们首先找到一个合适的 JSON 文件，他包含所有十六进制代码和名称。找到它，或者使用 web 抓取一个。这部分不是我做的，是 <a href="https://github.com/muj-programmer"><strong>Nikhil</strong></a> 做的。这是一个简单的 JS web 爬虫。我们利用它生成了一个类似的文件。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dedc3eb0c62304?w=1324&h=820&f=png&s=92803" alt="Yupp! Cool as hell!"></p><p>接下来我们需要在 lib/ 文件夹下创建一个 <strong>flutter_weather_icons.dart</strong> 来编写 dart 代码来解析这个 JSON 了。</p><p>我们需要使用到 <strong>dart:convert</strong>、<strong>dart:io</strong>（标准库的一部分）和 <strong>recase</strong> 包。所有的这些都是为 JSON 解码、文件 I/O 和将 <strong>“wi-day-sunny”</strong> 转换为 <strong>“wiDaySunny”</strong> 所准备的，以便于这些都可以在 flutter 代码中正常使用。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dedc3eb7212613?w=2012&h=970&f=png&s=132980" alt="Not the complete code for font generation"></p><p>你可以在<a href="https://github.com/rshrc/flutter_weather_icons/blob/master/tool/generate_fonts.dart">这里</a>找到 <strong>font_generation</strong> 的完整代码</p><p>和我想的一样。这将生成一个看起来像下面这样的文件。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dedc3fad4fcc8c?w=1644&h=1342&f=png&s=286748" alt="Find the complete code [here](https://github.com/rshrc/flutter_weather_icons/blob/master/lib/flutter_weather_icons.dart)"></p><p>发现这一点后，我和 Nikhil 都做了一堆字体图标包。</p><p>在以下链接找到并测试我们的字体 <a href="https://github.com/rshrc/flutter_weather_icons">weather icons</a>, <a href="https://github.com/muj-programmer/flutter_brand_icons">brand icons</a>, <a href="https://github.com/rshrc/flutter_icomoon_icons">icomoon icons</a> 和 <a href="https://github.com/muj-programmer/flutter_feather_icons">feather icons</a> 🎉</p><p>如果你喜欢我们的代码和文章，可以<strong>点赞 🌟、收藏 👏</strong>，或者在 GitHub 上<strong>关注</strong>我们。</p><p>我们下次再见！<a href="https://www.twitter.com/FlutterComm">Flutter Community (@FlutterComm) | Twitter*<strong>*The latest Tweets from Flutter Community (@FlutterComm). Follow to get notifications of new articles and packages from…</strong>www.twitter.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】 如何创建一个可复用的网页爬虫</title>
      <link href="p/8915.html"/>
      <url>p/8915.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://medium.com/better-programming/how-to-create-a-reusable-web-scraper-5a5aa9af62d9">How to Create a Reusable Web Scraper</a></li></ul></blockquote><p>网页爬虫是个非常有趣的玩具。不过不好玩的是，我们需要根据不同网页上的元素不断的调整自己的代码。这就是为什么我要着手实现一个更好的网页爬虫项目——通过该项目可以以最少的更改实现对新网页的爬取。</p><p>第一步是将网页爬虫按照逻辑分成每个独立的部分：</p><ol><li>页面请求器</li><li>页面验证器</li><li>模板页面处理器</li></ol><h2 id="页面请求器"><a href="#页面请求器" class="headerlink" title="页面请求器"></a>页面请求器</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghp6jl53qfj30hs0dc0u7.jpg"></p><p>页面请求器的实现有一些技巧。下载网页时要考虑很多因素。你需要确保你可以随机的使用用户代理，并且不要过于频繁地从同一域中请求。</p><p>此外，停下手头的工作去分析为什么网页无法下载是一件出力不讨好的事。尤其是当你的爬虫已经在多个站点运行了好几个小时的情况下。因此，我们会处理一些请求，并将它们保存为文件。</p><p>将请求保存到文件中还有另外一个好处。你不必担心一个标签的消失会影响到你的爬虫。如果页面处理器是独立的，并且你已经完成了页面的下载，你还可以根据需要快速且频繁的对其进行处理。如果发现有另一个要抓取的数据元素怎么办？别担心。只需添加一个标签，然后在你已下载的页面上重新运行处理器即可。</p><p>以下是一些实际情况下的示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_random_ua</span>():</span></span><br><span class="line">    ua_list = [<span class="string">&quot;user agent1, user agent2&quot;</span>, <span class="string">&quot;user agent3&quot;</span>]</span><br><span class="line">    random_num = randint(<span class="number">0</span>, len(ua_list))</span><br><span class="line">    <span class="keyword">return</span> ua_list[random_num]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_headers</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="string">&#x27;user-agent&#x27;</span>: _random_ua() &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_save_page</span>(<span class="params">response</span>):</span></span><br><span class="line">    uri = urlparse(response.url)</span><br><span class="line">    filename = uri.netloc + <span class="string">&quot;.pickle&quot;</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> pickle_file:</span><br><span class="line">        pickle.dump(response, pickle_file)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    _save_page(request)</span><br></pre></td></tr></table></figure><h2 id="页面验证器"><a href="#页面验证器" class="headerlink" title="页面验证器"></a>页面验证器</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghp6jzqb8xj32bp0u077q.jpg" alt="照片来自 Medium."></p><p>页面验证器浏览文件并释放请求。它将读取请求的状态码，如果请求代码类似于 408（超时），你可以让它重新排队下载网页。否则，验证器会将文件移动到实际的 web 抓取模块中进行处理。</p><p>你还可以收集为什么页面没有下载的数据。也许你请求页面的速度太快而被禁止了。此数据可用于调整你的页面下载器，以便它可以运行尽可能快且错误量最小。</p><h2 id="模板页面处理器"><a href="#模板页面处理器" class="headerlink" title="模板页面处理器"></a>模板页面处理器</h2><p>终于到这里了。我们要做的第一步是创建数据模型。让我们从 URL 开始，对于每个不同的站点/路径，可能都有不同的提取数据的方法。我们从一个字典开始，就像这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models = &#123;</span><br><span class="line">  <span class="string">&#x27;finance.yahoo.com&#x27;</span>:&#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;news.yahoo.com&#x27;</span>&#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;bloomberg.com&#x27;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的用例中，我们想要提取这些网站的 article 内容。要做到这一点，我们需要创建一个选择器，用于包含所有数据的最小外部元素。举个例子，下面是 finance.yahoo.com 的示例页面:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Webpage Sample</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span>some link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>some content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;canvas-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>article paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;ad&quot;</span>&gt;</span>Ad Link<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>article paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>list element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span>&gt;</span>unrelated link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码段中，我们希望定位 article 元素。因此，我们将使用 article 标签和 class 作为标识符，因为这是包含 article 内容的最小元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models = &#123;</span><br><span class="line">  <span class="string">&#x27;finance.yahoo.com&#x27;</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;root-element&#x27;</span>:[</span><br><span class="line">            <span class="string">&#x27;article&#x27;</span>,</span><br><span class="line">            &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;canvas-body&quot;</span>&#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;news.yahoo.com&#x27;</span>&#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;bloomberg.com&#x27;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将确定本文中的哪些元素是无用的。我们可以看到一个有 <code>ad</code> 类（值得注意的是，在真实场景中它永远不会这么简单）。因此，为了删除指定的元素，我们将在配置模型中创建一个 <code>unwanted_elements</code> 元素：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models = &#123;</span><br><span class="line">  <span class="string">&#x27;finance.yahoo.com&#x27;</span>:&#123;</span><br><span class="line">       <span class="string">&#x27;root-element&#x27;</span>:[</span><br><span class="line">            <span class="string">&#x27;article&#x27;</span>,</span><br><span class="line">            &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;canvas-body&quot;</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;unwanted_elements&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">            &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;ad&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;news.yahoo.com&#x27;</span>&#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;bloomberg.com&#x27;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经删除了一些无用元素，我们还要注意哪些元素需要保留。因为我们只寻找 article 元素，所以我们只需要指定保留 <code>p</code> 和 <code>h1</code> 元素即可:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models = &#123;</span><br><span class="line">  <span class="string">&#x27;finance.yahoo.com&#x27;</span>:&#123;</span><br><span class="line">       <span class="string">&#x27;root-element&#x27;</span>:[</span><br><span class="line">            <span class="string">&#x27;article&#x27;</span>,</span><br><span class="line">            &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;canvas-body&quot;</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;unwanted_elements&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">            &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;ad&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">        <span class="string">&#x27;text_elements&#x27;</span>: [</span><br><span class="line">            [<span class="string">&#x27;p&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;li&#x27;</span>]</span><br><span class="line">        ]  &#125;,</span><br><span class="line">  <span class="string">&#x27;news.yahoo.com&#x27;</span>&#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;bloomberg.com&#x27;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在是最后一部分——主聚合器！这里我将不关注配置文件的解析和加载。如果我把所有代码都放上来，这一篇文章不足以全部介绍完。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取外部元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer_element</span>(<span class="params">page, identifier</span>):</span></span><br><span class="line">    root = page.find(*identifier)</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Could not find root element&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不需要的元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trim_unwanted</span>(<span class="params">page, identifier_list</span>):</span></span><br><span class="line">    <span class="comment"># 判断 list 中是否有该元素</span></span><br><span class="line">    <span class="keyword">if</span> len(identifier_list) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> identifier <span class="keyword">in</span> identifier_list:</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> page.find_all(*identifier):</span><br><span class="line">                element.decompose()</span><br><span class="line">    <span class="keyword">return</span> page</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取文字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_text</span>(<span class="params">page, identifier_list</span>):</span></span><br><span class="line">    <span class="comment"># 判断 list 中是否有该元素</span></span><br><span class="line">    <span class="keyword">if</span> len(identifier_list) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Need text elements&quot;</span>)</span><br><span class="line">    page_text = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> identifier <span class="keyword">in</span> identifier_list:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> page.find_all(*identifier):</span><br><span class="line">            page_text.append(element.text)</span><br><span class="line">        <span class="keyword">return</span> page_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取页面配置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_scrape_config</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;加载页面爬取配置数据&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> get_scrape_config()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取站点的抓取配置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_site_config</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;获取站点的抓取配置&#x27;&#x27;&#x27;</span></span><br><span class="line">    domain = extract_domain(url)</span><br><span class="line">    config_data = load_scrape_config()</span><br><span class="line">    config = config_data.get(domain, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> config == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;Config does not exist for: <span class="subst">&#123;domain&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建返回字段</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_processer</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;返回文本&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 获取站点的抓取配置</span></span><br><span class="line">    site_config = get_site_config(request.url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析页面</span></span><br><span class="line">    soup = BeautifulSoup(request.text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取根元素</span></span><br><span class="line">    root = outer_element(soup, site_config[<span class="string">&quot;root_element&quot;</span>])</span><br><span class="line">    <span class="comment"># 移除不需要的元素</span></span><br><span class="line">    trimmed_tree = trim_unwanted(root, site_config[<span class="string">&quot;unwanted&quot;</span>])</span><br><span class="line">    <span class="comment"># 获得所需的元素</span></span><br><span class="line">    text = get_text(trimmed_tree, site_config[<span class="string">&quot;text_elements&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(text)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用此代码，你可以创建一个模板，从任何网站提取文章文本。你可以在我的 <a href="https://github.com/dtaivpp/NewsTicker/blob/master/src/scrape_page.py">GitHub</a> 上看到完整的代码并查看我是如何实现它的。</p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】从头开始到最初的 10 个客户：我是如何设计并推出一个 SaaS 产品</title>
      <link href="p/6136.html"/>
      <url>p/6136.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://codeburst.io/from-scratch-to-the-first-10-customers-how-i-designed-and-launched-a-saas-product-9176a8996b89">From scratch to the first 10 customers: How I designed and launched a SaaS product</a></li></ul></blockquote><p>对于许多具有创业精神的程序员来说，创建一个成功的软件即服务（SaaS）产品是他们追求的梦想。在推出我自己的 SaaS 产品的过程时，我发现与其他创业者分享和探讨经验是必不可少的，如果没有这一点，我可能根本就不会想着去创建它。</p><p>在本文中，我将分享我从零开始创建 SaaS 产品的思路和实践过程，以及我是如何获得第一个付费客户的。无论是正在考虑创建一个新产品，还是已经推出了这个产品，你都可以通过对比自己的策略和文章中对我而言有效的策略，来调整适合你的策略</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqbv4sryj31370bp0tf.jpg"></p><p>我每周会花 5 个小时研究其他创业者的经历。我一直在寻找新的想法以及避免错误的方法，评估新的策略可以帮助我获得具体的结果（即改进产品并增加客户满意度）。</p><p>出于这个原因，我决定以一种完全坦率和透明的方式工作，并分享我的道路上的一切 —— 包括什么已经起作用了，什么没有起作用 —— 目的是通过直接和理性的讨论互相帮助。</p><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p>这篇文章按时间顺序分为七个部分，下面是我所做的工作的每个阶段：</p><ul><li><strong>发现问题</strong></li><li><strong>量化问题</strong></li><li><strong>评估竞争对手和他们解决问题的方法</strong></li><li><strong>开发第一个原型</strong></li><li><strong>扔掉一切然后重新开始</strong></li><li><strong>获得第一个订阅</strong></li><li><strong>如何走得更远</strong></li></ul><p>我开发的 SaaS 产品是 <a href="https://www.inspector.dev/">Inspector</a>，一个实时监控工具，可以帮助软件开发人员避免因程序技术问题而失去客户和资金。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqc0224nj31400u0b29.jpg" alt="1_qWDI9beoYFfBmghh-Z6ybQ"></p><p>在过去的 10 年里，我一直与软件开发团队一起工作，在这期间，我意识到，对于开发人员来说，每天处理影响应用程序的技术问题非常复杂。开发团队与客户之间有着密切的关系，这对于生产软件的公司来说有很高的风险，因为一旦出现问题，你就会意识到这种联系是多么脆弱。</p><p>用户不喜欢出现问题！这是显而易见的，但这方面经常会被忽视。这是一个令人不安的事实。没有人喜欢遇到问题，本能的做法是把问题最小化。但如果你否认这一事实，你可能会惹恼客户，甚至会让他们重新考虑是否“应该”付钱给你。</p><p>客户是不会花时间向你报告问题和错误的。没有人会关心能否帮助我们解决 bug。它们只是退出我们的应用，可能要过好几年我们才能再见到他们。因此，我工作过的每个团队都使用最直观的方法来判断应用是否正常工作：</p><blockquote><p>“如果你的客户投诉你，就说明你的软件有问题。”</p></blockquote><p>这并不是一个技术解决方案……</p><p>紧迫、有限的预算，不断向客户、经理施压，这迫使开发人员必须顶着巨大的压力工作，采用权宜之计（暂时解决问题）这种生存策略。也许这看起来很荒谬，但只有深知项目内容的内部工作人员才会知道这些。这样的经历下工作了十年，我意识到这部分明显出现了问题。</p><h2 id="量化问题"><a href="#量化问题" class="headerlink" title="量化问题"></a>量化问题</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqc6h403j31900u0ayq.jpg" alt="1_aOZ8uDUscHo0oRipuqKPBg"></p><p>2019 年初，我刚刚完成了一些重要的项目，并希望能享受一段平静的时光。在过去的几年里，我利用这些时间寻找可以让我充分发挥自己技术才能的商机，希望以此找到合适的条件来启动我的商业想法。</p><p>作为一名开发人员，我的经验告诉我，通过简单而即时的监视工具足以帮助开发团队时刻了解应用程序最新的信息，不需要依赖客户的电话来知道软件什么时候出现了问题。另一方面，我不需要一个工具来监视每件事，因为并不是每件事都有意义。同时我也不希望它变得复杂——我不想仅仅为了这份工作而花一个月的时间学习它的工作原理，也不想为此雇佣专业的工程师。我的生活必须比以前更轻松。因此有必要准备一个随时可用的开发人员工具。</p><p>第一步是了解是否已经有尝试解决此问题的解决方案了，因此我谷歌了一下“<strong>application monitoring</strong>”，出现了 941,000,000 个结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqcd25fxj30s305n3ys.jpg" alt="1_i2ZmDlt4rYw7d90QgEWwzA"></p><p>哇。这可真是一个大问题。但究竟有多大呢?</p><p>软件开发团队效率低下是我一直面对的一个问题，但是在评估工作任务和量化问题的经济影响之间存在很大差异。从大范围来说，这就更加困难了。这条推文引起了我的注意：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqcjf327j30hn0e53zt.jpg" alt="1_TvugFYsVbZuQSD_iFwWBTw"></p><p><strong>50％的开发人员承认他们需要花费多达 50％的时间来验证应用程序是否正常运行。</strong></p><p>软件开发这个工作的报酬主要是通过技术人员在项目上所花费的时间来衡量的，如果开发人员需要花费 50%的时间来检查一切是否正常，那么一种完全自动化完成这项工作的工具可能会更有用。</p><p><strong>那么为什么它没有在这么多开发人员中流行起来呢？</strong></p><h2 id="评估竞争对手和他们解决问题的方法"><a href="#评估竞争对手和他们解决问题的方法" class="headerlink" title="评估竞争对手和他们解决问题的方法"></a>评估竞争对手和他们解决问题的方法</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqcpbbvpj31900u0npd.jpg" alt="1_N-6vdg-eP1w_5Femejg5pA"></p><p>当公司决定使用哪些工具来提高生产力时，我考虑了两个主要因素:</p><ol><li><strong>简单</strong>（易于安装和使用）</li><li><strong>功效</strong>（我花 x 去解决一个价值 x+10 的问题，所以我得到+10）</li></ol><p>使用这些参数，我花了大约一个星期的时间创建了一个知名监测工具的评估表，并且把它们放在一个图表中</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqcsc486j31f50qn0v6.jpg" alt="1_jCKXywhfbMjCF98suUklJg"></p><p>经过几天的整理收集，看一下图表就足以了解问题所在。简单的工具不能为大多数开发人员提供足够的价值。相反，更完整的工具被认为是针对大型组织的，需要熟练的员工致力于安装、配置和使用，这最终会使团队操作复杂化而不是简化。</p><p><strong>在我看来，问题不是监控本身，而是团队效率的发展。</strong></p><p>对于大规模的采用，很有必要有一种产品，其安装时间在一分钟左右且无需额外配置，同时还需要提供完整、容易的信息以供参考，甚至允许中型开发团队对问题进行修复以及实时监控。</p><p>当然，它必须很酷。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqcwsqpuj31f50qnmzu.jpg" alt="1_v3O5TbWyrm1P1zC4IeM9TQ"></p><h2 id="开发第一个原型"><a href="#开发第一个原型" class="headerlink" title="开发第一个原型"></a>开发第一个原型</h2><p>最后，我决定尝试一下。上次的工作进展顺利，我认为创建该工具并不是没有可能。因此，我立即通知我的合作伙伴，我想在接下来的两三个月内建立一个 MVP。当我向他们解释时，很难让他们理解问题，因为他们并不是和我涉及同一领域的技术人员，好在他们给了我 90％的信任许可，我对此表示感谢。</p><p>在三个月的时间里，我创造出了这个原型：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqd1sno0g30m80bre81.gif" alt="1_KgapMnraeCMY4GqmriE_fw"></p><p>在实现过程中，我逐渐明白了实现这类工具的痛点，甚至包括用户在使用过程中可能会遇到的问题。从技术角度来看，监控产品必须设计成能够处理大量数据，最好我也想让它可以实时处理这些数据。</p><p>因为我花费比预期更长的时间开发后端部分（换句话说，看不见的部分，或者云端软件的后台），导致忽视了用户可以看到和使用的图形界面（例如你在上面看到的）。</p><h2 id="扔掉一切然后重新开始"><a href="#扔掉一切然后重新开始" class="headerlink" title="扔掉一切然后重新开始"></a>扔掉一切然后重新开始</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqd8e2e3j31900u04qp.jpg"></p><p>在过去的几年里，对于产品上市的梦想促使我不断的学习并将适用于 SaaS 软件的营销策略应用于不同的项目（甚至失败的项目）。我开始为我的博客写文章，在将其发布在不同的网站和社交媒体上，以收集第一批反馈。</p><p>很抱歉，由于英语不是我的母语，我写了很多非常糟糕的内容，时不时还有些写作上的错误，不过好在我已经开始收到关于这些想法的反馈了，这些反馈有：</p><ul><li>我不知道我能用它做什么。</li><li>我如何安装它？</li><li>为什么用它而不是 XXX？</li><li>其他……</li></ul><p>要客观地看待开发人员的回应和评论并不容易。情绪反应总是会占据主导，对于我来说，真的很难理解哪里出了错，因为我不是销售代理人或卖方，而是一个技术人员。</p><h2 id="以下是我一路走来学到的经验"><a href="#以下是我一路走来学到的经验" class="headerlink" title="以下是我一路走来学到的经验"></a>以下是我一路走来学到的经验</h2><h4 id="第一课——销售很烂"><a href="#第一课——销售很烂" class="headerlink" title="第一课——销售很烂"></a>第一课——销售很烂</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqdcd5euj31930u07wh.jpg"></p><p>得益于工具的技术投入，实际上我并不需要销售。相反，我只需要学会如何交流每天遇到的问题，以及如何用我的工具解决它们。</p><p>我花了整整一个月的时间来撰写我所知道的、最重要的有关监控和应用程序可伸缩性问题，以及我决定开始启动这个项目的原因，在开发产品过程中遇到的困难，以及我如何解决这些问题并继续前进，代码示例、技术指南、我的最佳实践等等。</p><p>然后，我将一切都交给了 <a href="https://www.fiverr.com/robinoo/professionally-proofread-1000-words?context=recommendation&context_alg=recently_ordered%7Cco&context_referrer=homepage&context_type=gig&mod=rep&pckg_id=1&pos=1&source=recently_and_inspired&tier_selection=recommended&ref_ctx_id=1bf19e6d-aa27-407d-86ea-f8ca268b8131">Robin</a>，他是我在 Fiverr 上找到的一位加拿大文案撰稿人，他修改了所有的内容，包括网站上的文字，并把文章修改成英语母语水平。</p><h4 id="第-2-课——产品不足"><a href="#第-2-课——产品不足" class="headerlink" title="第 2 课——产品不足"></a>第 2 课——产品不足</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqdiityoj31900u04qq.jpg"></p><p>担心忽视用户界面是有理由的。我所做的工作还不足以创造出我心中的那种交互体验，所以我必须重新开始。这样做的好处是我解决了大部分的技术问题。对一个工程师来说，设身处地为设计师着想并不容易。</p><p>为了提高我的设计感知，我参加了两门关于图形界面开发的课程，阅读了三本关于设计和用户体验的书籍，并使用 VueJs 作为前端框架进行了直接的实验。</p><h2 id="第三课——试一试，尽管有疑虑"><a href="#第三课——试一试，尽管有疑虑" class="headerlink" title="第三课——试一试，尽管有疑虑"></a>第三课——试一试，尽管有疑虑</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqdlx515j31400u04np.jpg"></p><p>当我们花时间阅读有关商场营销的书籍和视频时，我们总是会学习一些常见的建议，而这些建议在实际情况下通常是行不通的。例如，想想这句口头禅：“如果你等到一切都准备好了，你就永远不会开始创业。” <strong>如此真实</strong>！</p><p>但初次体验会促使我们做出应激反应，会使我们处于防御状态。这是一个非常大的错误，因为创建一个因其实用性而值得购买的产品是一个过程，并不是一蹴而就的。“启动”这个词误导了我们，因此请别管它，而将注意力集中在“创造”上，与外界相比，该过程会一步步帮助你了解为实现目标而需要进行改进的内容。</p><h2 id="Inspector-诞生了！"><a href="#Inspector-诞生了！" class="headerlink" title="Inspector 诞生了！"></a>Inspector 诞生了！</h2><p>这个项目又花了我两个月的时间。在这几个月里，我决定从零开始重新创建这个品牌，尝试将原型体验不仅仅用于产品，还用于市场营销和传播。</p><p><a href="https://www.inspector.dev/">Inspector</a> —— 在不到一分钟的时间内，在用户反应之前识别出代码中的问题!</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqdsuffkj316o0kywi9.jpg" alt="1_7tXxOtkvca_518-3LPNEQA"></p><p>我们无休止地重复，其目的不是监视本身，而是帮助开发人员使他们的工作流程自动化：</p><ul><li><strong>不费吹灰之力</strong></li><li><strong>无需浪费时间进行手动操作</strong></li><li><strong>必要时保证灵活性</strong></li></ul><h2 id="获得第一个订阅"><a href="#获得第一个订阅" class="headerlink" title="获得第一个订阅"></a>获得第一个订阅</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghqqdx8bwuj31900u01kx.jpg"></p><p>2019 年 7 月 14 日，我的一份技术指南被批准在 Laravel News 上发表。Laravel News 是 Laravel 开发者社区最重要的网站之一，它使这一工具广为宣传。 在四天内，有 2,000 多人访问了 Inspector 网站，近 100 家公司注册签约，其中包括两位来自荷兰和瑞士的用户订阅了，成为了第一批用户。</p><p>当我收到 Stripe 公司的通知，告知我已经收到了我的第一笔付款时，那时已是深夜，我无法描述我当时的心情。这种感觉就像我背着大象七个月，最后它消失了，让我如释重负。</p><p>在接下来的几个月中出现了很多问题，这些问题需要时间，精力和金钱来解决。其中包括黑客攻击和基础设施超载之类的问题，这些问题迫使我即使在平安夜也要和电脑捆绑在一起。这些问题会让你重新回到现实，让你意识到事情比以前更加困难，因为你现在已经拥有了一些可以失去的东西了。</p><p>有了第一批付费用户，我知道我有了一个有趣的产品，多亏了网络和云，我才有机会让世界各地的开发人员宣传我的产品。所以这几个月来我每天都在全职工作，每天在尽可能多的渠道上创作和发表我的技术文章：</p><ul><li><a href="https://medium.com/inspector">https://medium.com/inspector</a></li><li><a href="https://dev.to/inspector">https://dev.to/inspector</a></li><li><a href="https://valerio.hashnode.dev/">https://valerio.hashnode.dev/</a></li><li><a href="https://www.facebook.com/inspector.realtime">https://www.facebook.com/inspector.realtime</a></li><li><a href="https://www.linkedin.com/company/14054676">https://www.linkedin.com/company/14054676</a></li><li><a href="https://twitter.com/Inspector_rt">https://twitter.com/Inspector_rt</a></li><li><a href="https://www.indiehackers.com/product/inspector">https://www.indiehackers.com/product/inspector</a></li><li><a href="https://www.reddit.com/r/InspectorFans/">https://www.reddit.com/r/InspectorFans/</a></li><li><a href="https://www.producthunt.com/posts/inspector">https://www.producthunt.com/posts/inspector</a></li></ul><p>现在，超过 800 家公司和商业人士已经尝试了 Inspector，我们有超过 20 个活跃订阅，来自新加坡，德国，纽约，法国，香港，荷兰等。</p><h2 id="如何走的更远"><a href="#如何走的更远" class="headerlink" title="如何走的更远"></a>如何走的更远</h2><p>与他人分享和比较是我成功的基础，所以我打算继续走下去。完全没有意识到这些问题比我们意识还有很多地方需要改进更糟糕。这就是为什么我们在最重要的意大利活动中（以创新为主题）开始讲这个故事的原因。</p><p>现在我们加入了<a href="https://www.inspector.dev/inspector-joins-nana-bianca-the-italian-startup-accelerator/"><strong>哈勃</strong></a>计划，这是一家意大利创业孵化器，三位创始人分别是 Paolo Barberis、Jacopo Marello 和 Alessandro Sordi。达达的三位创始人花了 20 年的时间合作，为 30 多家正在成长的意大利和外国公司提供资金和支持。</p><p>我们的目标是将 Inspector 介绍给其他的经理、商务人士、市场和技术专家，测试新的工具和策略，以将产品提升到一个新的水平，并使 Inspector 在全球范围内广为人知。我们希望帮助软件开发人员以一种更高效有趣的方式工作，借助智能工具可以给他们更多的空闲时间花在更有价值的活动上，而不必进行无聊的，重复的手动检查。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我分享了我从头创建和启动 SaaS 产品的思想和实践过程，以及我是如何获得第一批付费用户的。如果我之前不写文章分享我的历程，我就不会有机会创建 <a href="https://www.inspector.dev/">Inspector</a>，因此，感谢您阅读本文。我邀请您在下面发表评论，提出任何问题，或者只是告诉我您的想法。 如果你认为这篇文章可能对其他人有用，请在你的社交媒体上分享它！</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】5 分钟内从单体架构迁移到微服务架构</title>
      <link href="p/293a.html"/>
      <url>p/293a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>“微服务架构是一种将单体应用程序开发为一套小型服务的方法。”——马丁 · 福勒。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oixi4ktj318x0u0e81.jpg" alt="Monolithic Architecture vs. Microservice Architecture"></p><p>首先，我们需要明白什么是单体架构。因此，我将向你展示如何修改它的域,，以便为微服务架构做好准备。最后，我将会简要地告诉你微服务架构的基础知识，并讨论其优缺点。</p><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>每一种非垂直拆分的架构都是单体架构。软件设计中的垂直拆分意味着将应用程序划分为更多可部署的单元。这并不意味着单体架构不能<a href="https://levelup.gitconnected.com/layers-in-software-architecture-that-every-sofware-architect-should-know-76b2452b9d9a">水平划分</a>。</p><p>单体这个词指的是软件的体系结构是由一个后端单元组成。我之所以说后端，是因为我认为单体架构可以在具有多个 UI（如 Web 和移动设备）的同时，仍然可以被看作为一个整体。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oiyfcgrj309h0e7dgg.jpg" alt="Monolithic Architecture"></p><p>组件之间的通信主要通过方法的调用。 如果你的前端和后端是在物理上隔离的，但是它们仍然是一个整体，例如 API 和 Web 客户端。</p><p>除非你将后端划分为更多部署单元，否则在我看来你依旧是在使用单体架构。</p><h2 id="单域模型"><a href="#单域模型" class="headerlink" title="单域模型"></a>单域模型</h2><blockquote><p>“域是计算机程序的目标主题领域。 形式上，它代表特定编程项目的目标主题。”—— 维基百科</p></blockquote><p>用我的话说，域就是软件存在的原因和目的。我在 <a href="https://levelup.gitconnected.com/3-domain-centric-architectures-every-software-developer-should-know-a15727ada79f">3 Domain-Centric Architectures Every Software Developer should Know</a> 这篇文章中写了有关域的几个观点。</p><p>下图是一个将在线商城域可视化的结果。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oj5uhidj31kr0siwfk.jpg" alt="Single-Domain Model"></p><p>Sales 和 Catalog 子域包含单个的 <strong>Product</strong> 实体。这种做法是不可取的，因为这将导致一个地方出现更多的问题。这违反了<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">关注点分离原则</a>。</p><p>强迫一个实体承担更多的责任，显然是不合理的。实体在这两种上下文中都包含未使用的属性。Sales 不需要知道产品的类别，并且对于 Catalog 来说，知道 Product 是如何将信息传递给客户并没有任何用处。</p><p>为了避免这个问题，我们需要找到 Sales 和 Catalog 上下文的边界来将它们分开。这就引出接下来要说的限界上下文。</p><h2 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h2><blockquote><p>限界上下文是上下文的边界，参考 [Idapwiki.com](<a href="https://ldapwiki.com/wiki/Bounded">https://ldapwiki.com/wiki/Bounded</a> Context)</p></blockquote><p>要指定限界上下文，我们需要识别出一个模型仍然有效的上下文范围。</p><p>我们可以通过对域中的每个实体问一个简单的问题来验证模型，即：<strong>这个实体对于哪个上下文有效？</strong></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oj7fmupj31pf0riwgp.jpg" alt="Specifying Entities Contexts"></p><p>当一个实体对多个上下文有效时，那么它应该被划分到多个上下文中。每个实体都具有与上下文相对应的属性。这一步结束后，你的应用就准备好迁移到<strong>微服务架构</strong>了。</p><p>下图是从在线商城域中对 Product 分离的实体类的可视化结果。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3ojbxttfj31yx0sfab7.jpg" alt="Multi-Domain Model"></p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构是因为微服务从而闻名。它是不断细分的单体。微服务将大型系统划分为较小的部分。</p><p>限界上下文帮助我们找到一个微服务的最佳大小。微服务应具有足够小的模型，以最大程度减少与外部世界的通信，而出于存在的原因，则应足够大。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3ojcifbtj30y10u0gs9.jpg" alt="Microservices"></p><p>微服务架构使项目具有独立性。该架构支持分离的开发团队、不同的操作系统、不同的编程语言以及不同的业务层架构，例如 [CQRS](<a href="https://levelup.gitconnected.com/3-cqrs-architectures-that-every-software-architect-should">https://levelup.gitconnected.com/3-cqrs-architectures-that-every-software-architect-should</a> -know-a7f69aae8b6c)。</p><p>每一个微服务对外都有一个明确定义的接口，主要通过 HTTP 传输，并以 JSON 的形式实现，例如 REST API。对于微服务之间的通信，推荐的解决方案是通过 <a href="https://www.rabbitmq.com/">RabitMQ</a> 或 <a href="https://azure.microsoft.com/cs-cz/services">Azure 服务总线</a> 之类的消息平台。</p><p>如果没有适当的消息传递工具，那么微服务必须知道其他微服务的位置，并且这个位置是会被随意更改的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在大型应用程序中，微服务体系结构的开发成本曲线较好。小型应用程序无法从微服务中受益，因此应保持单体架构。</p><p>微服务会有分布式系统的成本，比如负载平衡和网络延迟。这些问题可以通过任务编排器很好的解决，例如 <a href="https://kubernetes.io/">Kubernetes </a> 和 <a href="https://azure.microsoft.com/cs-cz/services/service-fabric/">Azure Service Fabric</a>。</p><p>有了对以上这些内容的理解，接下来我推荐你去阅读 <a href="https://app.pluralsight.com/library/courses/microservices-fundamentals/table-of-contents">Pluralsight course from Mark Heath — Microservices Fundamentals</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://martinfowler.com/microservices/">Martin Fowler’s blog post about microservices.</a></li><li><a href="https://martinfowler.com/bliki/BoundedContext.html">Martin Fowler’s blog post about Bounded Context.</a></li><li><a href="https://app.pluralsight.com/library/courses/clean-architecture-patterns-practices-principles/table-of-contents">Pluralsight course Clean architecture patterns, practices, and principles</a>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Post-training 量化</title>
      <link href="p/1daa.html"/>
      <url>p/1daa.html</url>
      
        <content type="html"><![CDATA[<p>Post-training 量化是一种可以减小模型大小， 同时降低 3 倍延迟并且仍然能够保持模型精度的一般方法。 Post-training量化将权重从浮点量化为 8 位精度。 此技术在 <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/lite/toco">TensorFlow Lite model converter</a> 中作为一个功能选项被使用。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">converter &#x3D; tf.contrib.lite.TocoConverter.from_saved_model(saved_model_dir)</span><br><span class="line">converter.post_training_quantize &#x3D; True</span><br><span class="line">tflite_quantized_model &#x3D; converter.convert()</span><br><span class="line">open(&quot;quantized_model.tflite&quot;, &quot;wb&quot;).write(tflite_quantized_model)</span><br></pre></td></tr></table></figure><p>在推理时， 权重值从 8 位精度转换为浮点数， 并使用浮点内核进行计算。 此转换只执行一次并进行缓存以减少延迟。 </p><a id="more"></a><p>在推理时， 权重值从 8 位精度转换为浮点数， 并使用浮点内核进行计算。 此转换只执行一次并进行缓存以减少延迟。 </p><p>为了进一步改善延迟， 混合运算符动态地将激活量化为 8 位， 并使用 8 位权重和激活函数执行计算。 此种优化方式可以提供接近完全定点推断时的延迟。 但是， 输出仍然使用浮点存储， 因此混合运算的加速效果仍然小于完全定点计算。 混合操作可用于大多数计算密集型网络： </p><ul><li><a href="https://www.tensorflow.org/api_docs/python/tf/contrib/layers/fully_connected">tf.contrib.layers.fully_connected</a></li><li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d">tf.nn.conv2d</a></li><li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/embedding_lookup">tf.nn.embedding_lookup</a></li><li><a href="https://www.tensorflow.org/api_docs/python/tf/contrib/rnn/BasicRNNCell">BasicRNN</a></li><li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/bidirectional_dynamic_rnn">tf.nn.bidirectional_dynamic_rnn for BasicRNNCell type</a></li><li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dynamic_rnn">tf.nn.dynamic_rnn for LSTM and BasicRNN Cell types</a></li></ul><p>由于权重在训练后被量化， 因此可能存在精度损失， 特别是对于较小的网络。 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/lite/g3doc/models.md#image-classification-quantized-models">TensorFlow Lite model repository</a>提供了为特定网络提供预训练的完全量化模型。 检查量化模型的准确性以验证任何精度上的降低是否在可接受的限度内是很重要的。 这里有一个工具可以评估 <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/lite/tools/accuracy/README.md">TensorFlow Lite 模型精确度</a>。 </p><p>如果精确度下降幅度过大， 可以考虑使用<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/quantize/README.md">注重量化的训练</a>。 </p><h3 id="量化张量的表示"><a href="#量化张量的表示" class="headerlink" title="量化张量的表示"></a>量化张量的表示</h3><p>TensorFlow 将数字浮点数组转换为 8 位表示形式作为压缩问题。 由于训练的神经网络模型中的权重和激活张量倾向于分布在相对小范围内的值。 (例如， 对于权重为 -15 到 +15 ， 对于图像模型激活为 -500 到 1000 )。 并且由于神经网络在处理噪声数据时具有健壮性， 因此通过量化到一小组值引入的误差将整体结果的精度保持在可接受的阈值内。 选定的表示必须执行快速计算， 尤其是在运行模型时产生的具有大量计算的大型矩阵乘法。 </p><p>这用两个浮点表示， 它存储对应于最低和最高量化值的总体最小值和最大值。 量化阵列中的每个条目表示该范围内的浮点值， 在最小值和最大值之间线性分布。 例如， 当一个 8 位数组的最小值为 -10.0 ， 最大值为 30.0f 时， 其量化值表示如下： </p><figure>  <table><pre><code>&lt; tr &gt; &lt; th &gt; 量化值 &lt; /th&gt;&lt;th&gt;浮点值&lt;/th &gt; &lt; /tr&gt; &lt;tr &gt; &lt; td &gt; 0 &lt; /td&gt;&lt;td&gt;-10.0&lt;/td &gt; &lt; /tr&gt; &lt;tr &gt; &lt; td &gt; 128 &lt; /td&gt;&lt;td&gt;10.0&lt;/td &gt; &lt; /tr&gt; &lt;tr &gt; &lt; td &gt; 255 &lt; /td&gt;&lt;td&gt;30.0&lt;/td &gt; &lt; /tr&gt;</code></pre>  </table>  <figcaption><pre><code>&lt; b &gt; 表格 2 &lt; /b&gt;: 量化值范围示例</code></pre>  </figcaption></figure><p>这种表示方式的好处有： </p><ul><li>它有效地表示任意大小的范围。 。 </li><li>数值无需对称。 </li><li>有符号数和无符号数均可被表示。 </li><li>线性扩展使乘法变得简单。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】在几秒钟内为你的开发环境创建一个私有 PostgreSQL 数据库</title>
      <link href="p/2c7f.html"/>
      <url>p/2c7f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3owt7o15j31900u0e81.jpg"></p><p>很多开发者在开始一个新项目的时候，通常会使用 JSON，CSV 或者其他 Flat File 来模拟真实存放在数据库中的数据。这是因为他们总是在没有真实的数据库环境限制和是否需要自己创建模拟数据库之间左右为难。既然这样，为什么不使用 Docker Compose 定义一个可以在几秒钟内创建、销毁和重新创建的 PostgreSQL 数据库<strong>和监视工具</strong>？</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3owyvf4xj30sq0dmq3n.jpg" alt="Image source: Author"></p><p>正确创建配置两个容器的 Docker 命令过于冗长。而使用 Docker Compose，你只需要记住 <code>up</code> 命令和 <code>down</code> 命令！</p><p><code>Up</code> 命令将创建指定版本的 PostgreSQL 数据库和一个 GUI 管理工具。<code>Down</code> 命令会将其关闭并删除。</p><h2 id="基于私有容器的数据库的好处"><a href="#基于私有容器的数据库的好处" class="headerlink" title="基于私有容器的数据库的好处"></a>基于私有容器的数据库的好处</h2><ul><li>不同版本的 PostgreSQL 在行为和功能上存在差异，因此开发人员应针对一个数据库版本进行长期开发。你可以选择的一个版本是 9.6.12，另一个可以是 12.4。</li><li>大多数程序员都不是数据库管理员或 SQL 专家。可视化工具可以让他们直观地验证其代码的运行效果并支持手动修改数据。</li><li>项目的不同阶段需要不同类型的存储方案。在项目早期，非持久型数据库可以最大程度地减少麻烦。在项目的后期阶段，持久型数据库提供了更实际的方案。</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3ox20uwuj30r80aqjrm.jpg" alt="Create and recreate a database with simple commands"></p><h2 id="建立开发堆栈"><a href="#建立开发堆栈" class="headerlink" title="建立开发堆栈"></a>建立开发堆栈</h2><p>下面所展示的这份 <code>docker-compose.yml</code> 文件定义了一个运行特定版本 PostgreSQL 和 pgAdmin 4（Postgres 最常用的管理工具）的 PostgreSQL 容器。该文件的内容值得我们详细的探讨。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:9.6.12-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">some-postgres</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;~/Documents/docker_pgsql_init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;~/Documents/docker_pgsql_volume:/var/lib/postgresql/data&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5432</span><span class="string">:5432</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=mysecret</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pgadmin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dpage/pgadmin4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">some-pgadmin</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PWD&#125;/servers.json:/pgadmin4/servers.json</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PGADMIN_DEFAULT_EMAIL=user@domain.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PGADMIN_DEFAULT_PASSWORD=admin</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="Docker-Compose-的文件结构"><a href="#Docker-Compose-的文件结构" class="headerlink" title="Docker Compose 的文件结构"></a>Docker Compose 的文件结构</h4><p>该文件定义了两个要创建的“服务”：Postgres 和 pgAdmin。每个服务都包含一个从 Docker Hub 拉取的容器。Postgres 和 pgAdmin 将分别开放 5432 端口和 8080 端口。将你写的任何程序指向主机名“localhost”，然后用浏览器访问 <a href="http://localhost:8080/">http://localhost:8080</a> 即可访问 pgAdmin。</p><p>继续阅读有关如何将 pgAdmin 指向 Postgres 的说明。</p><h4 id="PostgreSQL-的版本"><a href="#PostgreSQL-的版本" class="headerlink" title="PostgreSQL 的版本"></a>PostgreSQL 的版本</h4><p>在定义 Postgres 容器的这一行中，你需要准确指定所需的 Postgres 版本。在这里，版本是一个标签，而 <code>9.6.12-alpine</code> 就是示例中使用的版本。点击<a href="https://hub.docker.com/_/postgres?tab=tags">这里查看其他可用的版本</a>。</p><h4 id="Postgres-的存储"><a href="#Postgres-的存储" class="headerlink" title="Postgres 的存储"></a>Postgres 的存储</h4><p>上面的 <code>docker-compose.yml</code> 文件为 Postgres 指定了两个 volume 映射。这两个映射将使 Postgres 可以访问你计算机上的目录。</p><ol><li>被映射到 <code>/docker-entrypoint-initdb.d</code> 的文件夹包含了初始化 Postgres 将会用到的 SQL 文件。将所需的 SQL 文件和 Shell 脚本放在该目录中，它们将会按字母顺序自动执行。</li><li>被映射到 <code>/var/lib/postgresql/data</code> 的文件夹存放了数据库持久化存储所需要的实际文件。</li></ol><p>当 Postgres 启动时，他的简单运行流程如下图所示。如果数据库中没有数据，那么它将执行被映射到 <code>/docker-entrypoint-initdb.d</code> 目录中的每个 SQL 文件和 Shell 脚本（按字母顺序）。如果被映射到 <code>/var/lib/postgresql/data</code> 目录的文件夹中有数据，那么它将会忽略掉这些文件。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3ox6qqebj30s40843yw.jpg"></p><p>你是否需要挂载这两个目录？这个得视情况而定。下表描述了通过 Postgres 的两个不同映射得到的一个预期结果。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3ox7u71sj31ci0dnjtw.jpg"></p><p>我的建议是对这两个文件目录都做映射。如果你不想再初始化你的数据库，你可以从 init 目录中删除文件。你也可以在你的计算机上删除任何可能已经持久化的数据（当你下一次运行 <code>docker-compose up</code> 命令时，Docker 将会在其位置重新创建一个空文件夹）。</p><p><strong>专业提示</strong>：你可以将 CSV 文件放在计算机的 init 文件夹中，然后在 init 目录中通过适当的 SQL 命令将 CSV 文件中的数据填充到数据表中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Employee(id, first_name, last_name, salary);</span><br><span class="line">COPY Employee FROM &#39;&#x2F;docker-entrypoint-initdb.d&#x2F;emp.csv&#39;</span><br><span class="line">    WITH (FORMAT CSV, HEADER);</span><br></pre></td></tr></table></figure><h4 id="pgAdmin-的存储"><a href="#pgAdmin-的存储" class="headerlink" title="pgAdmin 的存储"></a>pgAdmin 的存储</h4><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxagvaoj30dw0f70tc.jpg"></p><p>尽管 pgAdmin 只是一个用于查看和配置数据库的工具，但必须配置其与数据库的连接。这可以通过可视化工具中的 <code>add server</code>指令完成。这里需要注意的是，主机名（the hostname）是我们在 YML 文件中配置的 <code>container_name</code> 这一参数的名称，即 <code>some-postgres</code>。同样地，密码也已经在 YML 文件中指定了，即 <code>mysecret</code>。</p><p>另一种方法是通过在 JSON 文件中指定这些配置（除了密码之外的所有配置），通过这种方式可以免去大量的单击和输入操作。为了避免手动配置 pgAdmin 到 Postgres 的连接，我们需要将该 JSON 文件映射到容器 <code>/pgadmin4/servers.json</code> 上（在示例 YML 文件中的第 22 行）。</p><p>设置文件可以指定 pgAdmin 和 Postgres 之间的多个连接（以不同用户的身份连接或者连接到多个不同的数据库）。下面是只有一个数据库连接的示例。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Servers&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;1&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;my-postgres&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Group&quot;</span>: <span class="string">&quot;Servers&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Port&quot;</span>: <span class="number">5432</span>,</span><br><span class="line">            <span class="attr">&quot;Username&quot;</span>: <span class="string">&quot;postgres&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;some-postgres&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;SSLMode&quot;</span>: <span class="string">&quot;prefer&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MaintenanceDB&quot;</span>: <span class="string">&quot;postgres&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p><code>container_name</code> 参数仅仅只表示一个名字。但是 pgAdmin 将使用这个名称访问 5432 端口上的数据库。原因如下图所示。这两个容器通过私有网络相互连接，因此可以通过它们的主机名（容器名）也就是 <code>some-postgres</code> 和 <code>some-pgadmin</code> 相互访问。然而，你的主机（也就是你的计算机和 web 浏览器）只能访问容器对外暴露的 5432 端口和 8080 端口，因此你可以通过 <code>localhost:5432</code> 和 <code>localhost:8080</code> 访问它们。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxctcuoj30o30aeaac.jpg"></p><p>内部网络的名称可以在 compose 文件中指定，但是为一个从未被代码引用的网络命名没有任何价值！如果你还是好奇，可以随时查看你的私人及临时网络的名称。在下面的代码片段中，我从桌面运行了 Docker Compose，因此将该网络命名为 <code>desktop_default</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">23a6be9b8021        bridge              bridge              local</span><br><span class="line">49a120440f88        desktop_default     bridge              local</span><br><span class="line">44a949b56fa7        host                host                local</span><br><span class="line">3892b16dca2d        none                null                local</span><br></pre></td></tr></table></figure><h2 id="Docker-和-docker-compose-命令"><a href="#Docker-和-docker-compose-命令" class="headerlink" title="Docker 和 docker-compose 命令"></a>Docker 和 docker-compose 命令</h2><p>在这里，我必须承认我在前言中过于简化了命令操作，但只是稍微简化了一点。</p><p><strong>为了启动容器</strong>，可以使用 <code>docker-compose up -d</code>。<code>-d</code> 参数指定这是一个 <code>detached</code> 模式，它将会在后台运行，并且不会影响你在命令提示符中执行其他命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose up -d</span><br><span class="line">Creating network &quot;desktop_default&quot; with the default driver</span><br><span class="line">Creating some-postgres ... done</span><br><span class="line">Creating some-pgadmin  ... done</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p><strong>为了关闭并删除容器</strong>，你可以使用 <code>docker-compose down -v</code>。<code>-v</code> 参数表示删除容器在运行时使用的 volume。这个<strong>不会</strong>删除计算机映射到容器上的目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose down -v</span><br><span class="line">Stopping some-pgadmin  ... done</span><br><span class="line">Stopping some-postgres ... done</span><br><span class="line">Removing some-pgadmin  ... done</span><br><span class="line">Removing some-postgres ... done</span><br><span class="line">Removing network desktop_default</span><br></pre></td></tr></table></figure><p>随着时间的推移，如果不使用 <code>-v</code> 标志，就会累积不必要的 volume。你可以使用 <code>docker volume ls</code> 来验证这一点。</p><p>如果要调试一个没有正确启动的容器，请使用 <code>docker logs [container_name]</code>。例如，由于 init 目录中的一个 SQL 文件中出现错误，数据库可能无法正确初始化。通过执行 <code>docker logs some-postgres</code> 命令，可以生成容器启动时记录的日志，通过对该日志的查阅，我在一个特殊命名的 SQL 文件中发现一个错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-entrypoint.sh: running &#x2F;docker-entrypoint-initdb.d&#x2F;broken.sql</span><br><span class="line">ERROR:  syntax error at end of input at character 34</span><br><span class="line">STATEMENT:  CREATE TABLE Songs(id, name, year</span><br><span class="line">psql:&#x2F;docker-entrypoint-initdb.d&#x2F;broken.sql:1: ERROR:  syntax error at end of input</span><br><span class="line">LINE 1: CREATE TABLE Song(id, name, year</span><br></pre></td></tr></table></figure><p>日志告诉我在 <code>broken.sql</code> 文件的第 1 行有一个错误。该命令缺少右括号和分号。我可以修复这个错误，并使用 <code>down</code> 和 <code>up</code> 来验证。</p><hr><h2 id="使用-Python"><a href="#使用-Python" class="headerlink" title="使用 Python"></a>使用 Python</h2><p>使用 localhost 作为 YML 文件中指定的主机名和密码，连接到数据库很容易。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"></span><br><span class="line"><span class="comment"># connect to DB</span></span><br><span class="line">conn = psycopg2.connect(host=<span class="string">&quot;localhost&quot;</span>, dbname=<span class="string">&quot;postgres&quot;</span>, user=<span class="string">&quot;postgres&quot;</span>,</span><br><span class="line">    password=<span class="string">&quot;mysecret&quot;</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute SQL commands in SQL file</span></span><br><span class="line">cursor.execute(open(<span class="string">&quot;emp.sql&quot;</span>, <span class="string">&quot;r&quot;</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># retrieve data from the database</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT * FROM Employee&quot;</span>)</span><br><span class="line">print(cursor.fetchall())</span><br></pre></td></tr></table></figure><h2 id="使用-pgAdmin"><a href="#使用-pgAdmin" class="headerlink" title="使用 pgAdmin"></a>使用 pgAdmin</h2><p>简单的访问 <a href="http://localhost:8080/">http://localhost:8080</a> 即可进入登录界面，使用你在 <code>docker-compose.yml</code> 文件中定义的用户名和密码登录即可（在我们的示例中是 <code>user@domain.com</code> 和 <code>admin</code>）。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxg40e4j30v80kl41q.jpg"></p><p>如果你使用的是本文之前讨论的 <code>servers.json</code> 文件来指定连接细节，你将会在展开用户界面左侧的导航树时，收到系统要求你输入 Postgres 数据库的密码的提示。在我们示例的 <code>docker-compose.yml</code> 文件中，这个密码是 <code>mysecret</code>。如果你并没有创建 <code>servers.json</code> 文件或文件中有错误，你就必须手动添加服务器。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxjaovuj30n808k0to.jpg"></p><p>现在，你应该能够查看和操作数据库了。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxlpf60j30v80klaf3.jpg"></p><h2 id="进入-PSQL"><a href="#进入-PSQL" class="headerlink" title="进入 PSQL"></a>进入 PSQL</h2><p>有时候，开发者需要一个熟悉的命令行。Docker 使得访问 PSQL 和执行高级用户命令等操作变得更加容易。执行下面的命令进入 PSQL 命令行。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxp4146j30ty080aaa.jpg"></p><p>连接后，你就可以执行所有 PSQL 命令，例如，输入 <code>\i</code> 用于导入外部数据库，输入 <code>\dt</code> 显示数据表的描述，输入 <code>\df</code> 显示函数的描述。想要退出，可以使用 <code>\q</code> 命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -it some-postgres psql -U postgres</span><br><span class="line"></span><br><span class="line">psql (9.6.12)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# \dt</span><br><span class="line">List of relations</span><br><span class="line">Schema |     Name     | Type  |  Owner</span><br><span class="line">--------+--------------+-------+----------</span><br><span class="line">public | peak         | table | postgres</span><br><span class="line">public | climb        | table | postgres</span><br><span class="line">public | climber      | table | postgres</span><br></pre></td></tr></table></figure><h2 id="pgAdmin-的替代品"><a href="#pgAdmin-的替代品" class="headerlink" title="pgAdmin 的替代品"></a>pgAdmin 的替代品</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxr8dtwj30v80klgpx.jpg" alt="Adminer is a much simpler interface"></p><p>pgAdmin 是 PostgreSQL 最常见的 GUI 管理工具，但我们还有其他选择。Adminer 的使用更加简单，并且你可能已经拥有使用它的经验了，因为它支持多种风格的 SQL。如果你是刚开始使用 PostgreSQL 或者只有非常简单的需求，那么它可能是一个更合适你的工具。</p><p>在登录界面上，设置主机名为 <code>some-postgres</code> ，密码为 <code>mysecret</code>。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl3oxsrhp0j308a0783yl.jpg"></p><p>要在你的环境中用 Adminer 替换 pgAdmin，你需要在 <code>docker-compose.yml</code> 中替换几行有关 pgAdmin 容器的定义。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">adminer:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">adminer</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">some-adminer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">restart_policy:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">      <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>所有优秀的开发者都依赖于产品文档和其他人员的经验。这是我在创建工作流程和编写本文时引用的参考资料。</p><ul><li><a href="https://hub.docker.com/_/postgres">https://hub.docker.com/_/postgres</a></li><li><a href="https://hub.docker.com/_/adminer">https://hub.docker.com/_/adminer</a></li><li><a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></li><li><a href="https://www.pgadmin.org/docs/pgadmin4/latest/container_deployment.html">https://www.pgadmin.org/docs/pgadmin4/latest/container_deployment.html</a></li><li><a href="https://technology.amis.nl/2020/01/02/pgadmin-in-docker-provision-connections-and-passwords/">https://technology.amis.nl/2020/01/02/pgadmin-in-docker-provision-connections-and-passwords/</a></li><li><a href="https://stackoverflow.com/questions/42248198/how-to-mount-a-single-file-in-a-volume">https://stackoverflow.com/questions/42248198/how-to-mount-a-single-file-in-a-volume</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】JetPack Compose for Desktop 初体验</title>
      <link href="p/4e00.html"/>
      <url>p/4e00.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.ytools.xyz/uPic/ECk5bT1*3wOqMMXsvUfkDTWXUri_EQ.png" alt="Photo by the author."></p><p>目前为止，我们只在 Android 开发中看到 <a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a>。今天，我们将进入一个崭新的阶段，因为 JetBrains 宣布了 IntelliJ 的早期访问版本，允许你使用 Jetpack Compose 来构建 Windows 应用程序。</p><p>关于如何使用 Jetpack Compose for desktop，我计划在未来写一些文章加以阐述，本文是这个系列的第一篇文章。上个月，JetBrains 发布了 Compose for desktop Milestone 2，为开发者们带来了更好的开发体验和可操作性。</p><p>和往常一样，JetBrains 试图通过提供独家项目引导来简化开发者的开发流程。在 Compose for desktop 的早期版本中，他们为 IntelliJ 增加了一个桌面项目引导，可以在几秒内配置好项目。</p><p>在开始开发之前，你需要安装 <a href="https://www.jetbrains.com/idea/whatsnew/#section=mac">IntelliJ IDEA 2020.3</a>。</p><h2 id="使用项目模版快速开始"><a href="#使用项目模版快速开始" class="headerlink" title="使用项目模版快速开始"></a>使用项目模版快速开始</h2><p>正如我前面所说，项目模板是 IntelliJ 最好用的东西之一。安装完 IDE 后，启动应用程序。你会看到如下的界面：</p><p><img src="https://cdn.ytools.xyz/uPic/qBSy9V1*x-OrVhcmjnr0FKOlNHjNoQ.png"></p><p>然后点击顶部栏的 “New Project “按钮，这一操作将会跳转至选择应用程序类型的界面。如下所示：</p><p><img src="https://cdn.ytools.xyz/uPic/2HDuXt1*M2u_N3K-1DY9Q3WaYBnB0w.png"></p><p>首先，我们需要从左侧菜单中选择 Kotlin，然后修改项目名称和位置。之后，我们需要选择项目模板。这是配置项目的一个重要步骤。我们需要从项目模板列表中挑选桌面模板，向下滚动就能找到。然后你需要选择项目的 JDK，这里我建议使用 JDK 11。</p><p><img src="https://cdn.ytools.xyz/uPic/mGRgv21*XyyhciTuFLCVhk_hF10xCw.png"></p><p>然后点击 “Next “按钮，这将会跳转至确认 Compose 模块的界面。现在点击 “Finish “按钮，IntelliJ 将通过自动下载适当的 gradle 为你配置整个项目。</p><h2 id="运行你的第一个桌面应用"><a href="#运行你的第一个桌面应用" class="headerlink" title="运行你的第一个桌面应用"></a>运行你的第一个桌面应用</h2><p>如果进展顺利，整个桌面项目加载完成后你将会看到以下界面：</p><p><img src="https://cdn.ytools.xyz/uPic/6pOCLD1*iU2it0DXYOt0qxJQB1VgBQ.png"></p><p>此时，你可以运行该应用程序了。由于某些原因，<code>Main.kt</code>在右上角的 “运行 “按钮旁边没有被默认选中，所以它会要求你配置项目。为了解决这个问题，你需要在<code>Main.kt</code>文件内的主函数旁边点击绿色的 “运行 “按钮。</p><p>运行成功后，你会看到下面的输出结果，有一个包含 “Hello, World!”文字的按钮。如果你点击它，按钮里面的文字就会变成 “Hello, Desktop!“实际操作体验一下吧。</p><p><img src="https://cdn.ytools.xyz/uPic/hxQm5r1*AMNYP559WHhfKFvpGrmN4g.gif"></p><h2 id="探究代码"><a href="#探究代码" class="headerlink" title="探究代码"></a>探究代码</h2><p>正如你看到的，这是一个简单的 Hello World 程序——一点也不复杂。大部分的代码与 Android 里面的 Jetpack Compose UI 相似。</p><p><code>Main.kt</code>是包含与输出有关的代码 Kotlin 文件。它有一个主函数作为应用程序运行的入口。代码从<code>Window</code>函数开始，用给定的内容打开一个窗口。它需要几个参数来初步配置窗口的属性，如<code>title</code>、<code>size</code>、<code>location</code>、<code>centered</code>、<code>content</code>等。</p><figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = Window &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们只需要把值传给内容参数，其余的参数保留默认值即可。在接下来的代码中，我们声明了一个具有<code>remember</code>功能的<code>text</code>变量，其初始值为<code>Hello, World！</code>。如下所示：</p><figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = Window &#123;</span><br><span class="line">    <span class="keyword">var</span> text <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个声明式的 UI 系统中，代码本身就描述了 UI。我们需要描述任何时间点上的 UI——不仅仅是初始时间。在诸如按钮、文本字段等 UI 组件中，我们使用<code>remember</code>作为文本的状态，这样当我们在未来更新这个 <code>text</code> 变量时，与该变量相关的视图也会更新显示文本。</p><p>为了更好地理解它，我建议阅读以下文章。</p><p><a href="https://medium.com/better-programming/jetpack-compose-components-part-2-2b3eb135d294">Jetpack Compose Components (Part 2)</a></p><p>下一段代码是定义一个具有点击功能的按钮，并将整个应用窗口设置为 Material 主题。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = Window &#123;</span><br><span class="line">    <span class="keyword">var</span> text <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    MaterialTheme &#123;</span><br><span class="line">        Button(onClick = &#123;</span><br><span class="line">            text = <span class="string">&quot;Hello, Desktop!&quot;</span></span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            Text(text)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前，Jetpack Compose 在桌面和安卓上都处于非常早期的阶段，但它仍然展现出为构建 UI 所作出的巨大进步。像 Jetpack Compose 这样的框架配合上 Kotlin 的强大功能将提高开发者的开发效率，并为他们提供在不同平台上工作的方法。</p><p>像 <a href="https://twitter.com/_gurupreet">Gurupreet Singh</a> 这样的开发者非常积极地参与 Compose 的发布，并创造了宝贵的资源（如 <a href="https://github.com/Gurupreet/ComposeCookBook">ComposeCookBook</a>）来帮助其他开发者。他还从 Compose Android 应用中创建了 <a href="https://github.com/Gurupreet/ComposeSpotifyDesktop">the Spotify desktop clone</a>，这给了我很大的启发。</p><h2 id="捐赠"><a href="#捐赠" class="headerlink" title="捐赠"></a>捐赠</h2><p>如果你刚入门 Jetpack Compose ，可以从这里开始。</p><ul><li><a href="https://medium.com/better-programming/jetpack-compose-a-new-and-simple-way-to-create-material-ui-in-android-f49c6fcb448b">“Jetpack Compose — A New and Simple Way to Create Material-UI in Android”</a></li><li><a href="https://medium.com/android-dev-hacks/jetpack-compose-with-server-driven-ui-396a19f0a661">“JetPack Compose With Server Driven UI”</a></li><li><a href="https://medium.com/better-programming/jetpack-compose-how-to-build-a-messaging-app-e2cdc828c00f">“Jetpack Compose: How to Build a Messaging App”</a></li></ul><p>以上就是本文的全部内容了，希望本文能对你有所帮助，感谢你的阅读。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Javascript中的call(), apply() 和 bind()</title>
      <link href="p/3422.html"/>
      <url>p/3422.html</url>
      
        <content type="html"><![CDATA[<h3 id="回顾一下-“this”"><a href="#回顾一下-“this”" class="headerlink" title="回顾一下 “this”"></a>回顾一下 “this”</h3><p>我们了解到， 在面向对象的 JS 中， 一切都是对象。 因为一切都是对象， 我们开始明白我们可以为函数设置并访问额外的属性。 </p><p>通过原型给函数设置属性并且添加其他方法非常棒…**但是我们如何访问它们？ ！ ？ ？ ？ ！ **</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/12/16707678d3ba7fd7?w=478&h=250&f=gif&s=8801820"></p><p>当他说 “myself” 时， 他的确意味着 ‘this’</p><p>我们介绍过 <code>this</code> 关键字。 我们了解到每个函数都会自动获取此属性。 所以这时， 如果我们创建一个有关我们函数执行上下文的抽象模型（我不是唯一一个这么做的人！ … 对吗？ ！ ？ ！ ）， 它看起来就会像这样： </p><p><img src="https://user-gold-cdn.xitu.io/2018/11/12/16707687e4c0f519?w=800&h=307&f=png&s=104229"></p><a id="more"></a><p>我们花了一些时间来熟悉 <code>this</code> 关键字， 但是一旦我们这样做了， 我们就开始意识到它是多么有用了。 <code>this</code> 在函数内部使用， 并且总是引用单个对象 — <a href="http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/">这个对象会在使用 “this” 的地方调用函数</a>。 </p><p>但是生活肯定都不是完美的。 有时候我们会失去 <code>this</code> 的引用。 当这种情况发生时， 我们最终使用了令人困惑的解决方法去保存我们对于 <code>this</code> 的引用。 让我们通过<a href="https://github.com/Arieg419/ITCCodingBootcamp/blob/master/localStorage/eBay.js"> localSorage 练习</a>来看看这个方法吧： </p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a95ef01478dc?w=800&h=306&f=png&s=60306"></p><p>第 31 行 :(</p><p>那为什么我需要保存 <code>this</code> 引用呢？ 因为在 deleteBtn.addEventListener 中， <code>this</code> 指向了 <em>deleteBtn</em> 对象。 这并不太好。 有更好的解决方案吗？ </p><hr><h3 id="call-、-apply-和-bind-—-一个新的希望"><a href="#call-、-apply-和-bind-—-一个新的希望" class="headerlink" title="call()、 apply() 和 bind() — 一个新的希望"></a>call()、 apply() 和 bind() — 一个新的希望</h3><p>到目前为止， 我们已将函数视为由名称（可选， 也可以是匿名函数）及其在调用时执行的代码所组成的对象。 但这并不是全部真相。 作为一个 热爱真理的人， 我必须让你知道一个函数实际上看起来更接近下面的图像： </p><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671a95ed72896d0?w=800&h=386&f=png&s=29046"></p><p>这是什么？ ？ ？ ？ ？ ？ ？ 别担心！ 现在， 我将通过示例介绍每个函数中出现的这 3 种类似方法。 真是很让人兴奋呢！ </p><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a><strong>bind()</strong></h3><p><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">官方文档说： </a> ** <code>bind()</code> ** 方法创建一个新函数， 在调用时， 将其 <code>this</code> 关键字设置为所需的值。 （它实际上谈论了更多的东西， 但我们将把它留到下一次讲）</p><p>这非常强大。 它让我们在调用函数时明确定义 <code>this</code> 的值。 我们来看看 cooooode： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pokemon &#x3D; &#123;</span><br><span class="line">    firstname: &#39;Pika&#39;,</span><br><span class="line">    lastname: &#39;Chu &#39;,</span><br><span class="line">    getPokeName: function() &#123;</span><br><span class="line">        var fullname &#x3D; this.firstname + &#39; &#39; + this.lastname;</span><br><span class="line">        return fullname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pokemonName &#x3D; function() &#123;</span><br><span class="line">    console.log(this.getPokeName() + &#39;I choose you!&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var logPokemon &#x3D; pokemonName.bind(pokemon); &#x2F;&#x2F; creates new object and binds pokemon. &#39;this&#39; of pokemon &#x3D;&#x3D;&#x3D; pokemon now</span><br><span class="line"></span><br><span class="line">logPokemon(); &#x2F;&#x2F; &#39;Pika Chu I choose you!&#39;</span><br></pre></td></tr></table></figure><p>在第 14 行使用了 <code>bind（）方法</code> 。 </p><p>**我们来逐个分析。 ** 当我们使用了 <code>bind()</code> 方法： </p><ol><li>JS 引擎创建了一个新的 <code>pokemonName</code> 的实例， 并将 <code>pokemon</code> 绑定到 <code>this</code> 变量。 重要的是要理解**它复制了 pokemonName 函数。 **</li><li>在创建了 <code>pokemonName</code> 函数的副本之后， 它可以调用 <code>logPokemon()</code> 方法， 尽管它最初不在 <code>pokemon</code> 对象上。 它现在将识别其属性（Pika 和 Chu）及其方法。 </li></ol><p>很酷的是， 在我们 bind() 一个值后， 我们可以像使用任何其他正常函数一样使用该函数。 我们甚至可以更新函数来接受参数， 并像这样传递它们： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pokemon &#x3D; &#123;</span><br><span class="line">    firstname: &#39;Pika&#39;,</span><br><span class="line">    lastname: &#39;Chu &#39;,</span><br><span class="line">    getPokeName: function() &#123;</span><br><span class="line">        var fullname &#x3D; this.firstname + &#39; &#39; + this.lastname;</span><br><span class="line">        return fullname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pokemonName &#x3D; function(snack, hobby) &#123;</span><br><span class="line">    console.log(this.getPokeName() + &#39;I choose you!&#39;);</span><br><span class="line">    console.log(this.getPokeName() + &#39; loves &#39; + snack + &#39; and &#39; + hobby);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var logPokemon &#x3D; pokemonName.bind(pokemon); &#x2F;&#x2F; creates new object and binds pokemon. &#39;this&#39; of pokemon &#x3D;&#x3D;&#x3D; pokemon now</span><br><span class="line"></span><br><span class="line">logPokemon(&#39;sushi&#39;, &#39;algorithms&#39;); &#x2F;&#x2F; Pika Chu  loves sushi and algorithms</span><br></pre></td></tr></table></figure><h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call(), apply()"></a>call(), apply()</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call() 方法的官方文档说： </a>** <code>call()</code> ** 方法调用一个给定 <code>this</code> 值的函数， 并单独提供参数。 </p><p>这意味着， 我们可以调用任何函数， 并明确指定 <code>this</code> 应该在调用函数中引用的内容。 真的类似于 <code>bind()</code> 方法！ 这绝对可以让我们免于编写 hacky 代码（即使我们仍然是 hackerzzz）。 </p><p> <code>bind()</code> 和 <code>call()</code> 之间的主要区别在于 <code>call()</code> 方法： </p><ol><li><p>支持接受其他参数</p></li><li><p>当它被调用的时候， 立即执行函数。 </p></li><li><p><code>call()</code> 方法不会复制正在调用它的函数。 </p><p><code>call()</code> 和 <code>apply()</code> 使用于<strong>完全相同的目的。 ** **它们工作方式之间的唯一区别</strong>是 <code>call()</code> 期望所有参数都单独传递， 而 <code>apply()</code> 需要所有参数的数组。 例如： </p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pokemon &#x3D; &#123;</span><br><span class="line">    firstname: &#39;Pika&#39;,</span><br><span class="line">    lastname: &#39;Chu &#39;,</span><br><span class="line">    getPokeName: function() &#123;</span><br><span class="line">        var fullname &#x3D; this.firstname + &#39; &#39; + this.lastname;</span><br><span class="line">        return fullname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var pokemonName &#x3D; function(snack, hobby) &#123;</span><br><span class="line">    console.log(this.getPokeName() + &#39; loves &#39; + snack + &#39; and &#39; + hobby);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pokemonName.call(pokemon, &#39;sushi&#39;, &#39;algorithms&#39;); &#x2F;&#x2F; Pika Chu  loves sushi and algorithms</span><br><span class="line">pokemonName.apply(pokemon, [&#39;sushi&#39;, &#39;algorithms&#39;]); &#x2F;&#x2F; Pika Chu  loves sushi and algorithms</span><br></pre></td></tr></table></figure><p>注意， apply 接受数组， call 接受每个单独的参数。 </p><p>这些存在于每一个 JS 函数的内置方法都非常有用。 即使你最终没有在日常编程中使用它们， 你仍然会在阅读其他人的代码时经常遇到它们。 </p><p>如果您有任何疑问， 请一如既往地通过 <a href="https://www.instagram.com/omeragoldberg/">Instagram</a> 与我们联系。 ❤</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方， 欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR， 也可获得相应奖励积分。 文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。 </p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区， 文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。 内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、 <a href="https://github.com/xitu/gold-miner#ios">iOS</a>、 <a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、 <a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、 <a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、 <a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域， 想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、 <a href="http://weibo.com/juejinfanyi">官方微博</a>、 <a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】HTTP/2 常见问题解答</title>
      <link href="p/c226.html"/>
      <url>p/c226.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzudb80ogng30h808cmzi.gif"></p><blockquote><p>**本文翻译自：  <a href="https://http2.github.io/faq/">《HTTP/2 Frequently Asked Questions》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><h1 id="HTTP-2-常见问题解答"><a href="#HTTP-2-常见问题解答" class="headerlink" title="HTTP/2 常见问题解答"></a>HTTP/2 常见问题解答</h1><p>以下是有关 HTTP/2 的常见问题解答。 </p><ul><li><p><a href="#%E4%B8%80%E8%88%AC%E9%97%AE%E9%A2%98">一般问题</a></p><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%AE%E8%AE%A2-http">为什么要修订 HTTP ?</a></li><li><a href="#%E8%B0%81%E5%88%B6%E5%AE%9A%E4%BA%86-http2">谁制定了 HTTP/2??</a></li><li><a href="#http2-%E4%B8%8E-spdy-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88">HTTP/2 与 SPDY 的关系是什么？ </a></li><li><a href="#%E7%A9%B6%E7%AB%9F%E6%98%AF-http20-%E8%BF%98%E6%98%AF-http2">究竟是 HTTP/2.0 还是 HTTP/2？ </a></li><li><a href="#%E5%92%8C-http1x-%E7%9B%B8%E6%AF%94-http2-%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">和 HTTP/1.x 相比 HTTP/2 的关键区别是什么?</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-http2-%E6%98%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84">为什么 HTTP/2 是二进制的?</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-http2-%E9%9C%80%E8%A6%81%E5%A4%9A%E8%B7%AF%E4%BC%A0%E8%BE%93">为什么 HTTP/2 需要多路传输?</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA-TCP-%E8%BF%9E%E6%8E%A5">为什么只需要一个 TCP 连接?</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88">服务器推送的好处是什么？ </a></li><li><a href="#%E6%B6%88%E6%81%AF%E5%A4%B4%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%8E%8B%E7%BC%A9">消息头为何需要压缩？ </a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-HPACK">为什么选择 HPACK？ </a></li><li><a href="#http2-%E5%8F%AF%E4%BB%A5%E8%AE%A9-cookies-%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E5%A4%B4%E5%8F%98%E5%BE%97%E6%9B%B4%E5%A5%BD%E5%90%97">HTTP/2 可以让 cookies （或者其他消息头）变得更好吗？ </a></li><li><a href="#%E9%9D%9E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%A8%E6%88%B7%E7%9A%84-HTTP-%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84">非浏览器用户的 HTTP 是什么样的？ </a></li><li><a href="#http2-%E9%9C%80%E8%A6%81%E5%8A%A0%E5%AF%86%E5%90%97">HTTP/2 需要加密吗？ </a></li><li><a href="#Hhttp2-%E6%98%AF%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E5%91%A2">HTTP/2 是怎么提高安全性的呢？ </a></li><li><a href="#%E6%88%91%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-http2-%E5%90%97">我现在可以使用 HTTP/2 吗？ </a></li><li><a href="#http2-%E5%B0%86%E4%BC%9A%E5%8F%96%E4%BB%A3-http1x-%E5%90%97">HTTP/2 将会取代 HTTP/1.x 吗？ </a></li><li><a href="#http3-%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%90%97">HTTP/3 会出现吗？ </a></li></ul></li><li><p><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98">实现过程中的问题</a></p><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A7%84%E5%88%99%E4%BC%9A%E5%9B%B4%E7%BB%95%E6%B6%88%E6%81%AF%E5%A4%B4%E5%B8%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%A5%E7%BB%AD">为什么规则会围绕消息头帧的数据接续？ </a></li><li><a href="#hpack-%E7%8A%B6%E6%80%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E5%B0%BA%E5%AF%B8%E6%98%AF%E5%A4%9A%E5%B0%91">HPACK 状态的最小和最大尺寸是多少？ </a></li><li><a href="#%E6%88%91%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E9%81%BF%E5%85%8D%E4%BF%9D%E6%8C%81-hpack-%E7%8A%B6%E6%80%81">我怎样才能避免保持 HPACK 状态？ </a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8D%95%E7%8B%AC%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%B8%8B%E6%96%87">为什么会有一个单独的压缩/流程控制上下文？ </a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-hpack-%E4%B8%AD%E6%9C%89-eos-%E7%9A%84%E7%AC%A6%E5%8F%B7">为什么在 HPACK 中有 EOS 的符号？ </a></li><li><a href="#%E5%AE%9E%E7%8E%B0-http2-%E7%9A%84%E6%97%B6%E5%80%99%E6%88%91%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E5%8E%BB%E5%AE%9E%E7%8E%B0-http11-%E5%90%97">实现 HTTP/2 的时候我可以不用去实现 HTTP/1.1 吗？ </a></li><li><a href="#532%E8%8A%82%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E7%A4%BA%E4%BE%8B%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE">5.3.2节中的优先级示例是否正确？ </a></li><li><a href="#http2-%E8%BF%9E%E6%8E%A5%E4%B8%AD%E9%9C%80%E8%A6%81-tcp_nodelay-%E5%90%97">HTTP/2 连接中需要 TCP_NODELAY 吗？ </a></li></ul></li><li><p><a href="#%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98">部署问题</a></p><ul><li><a href="#%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95%E5%8A%A0%E5%AF%86%E8%BF%87%E7%9A%84-http2">我该怎么调试加密过的 HTTP/2 ？ </a></li><li><a href="#%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-http2-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81">我该怎么使用 HTTP/2 的服务端推送？ </a></li></ul></li></ul><h2 id="一般问题"><a href="#一般问题" class="headerlink" title="一般问题"></a>一般问题</h2><h3 id="为什么要修订-HTTP"><a href="#为什么要修订-HTTP" class="headerlink" title="为什么要修订 HTTP?"></a>为什么要修订 HTTP?</h3><p>HTTP/1.1 已经在 Web 上服役了十五年以上， 但其劣势也开始显现。 </p><p>加载一个网页比以往更加耗费资源（详见 <a href="http://httparchive.org/trends.php#bytesTotal&reqTotal">HTTP Archive’s page size statistics</a>）。 与此同时， 有效地加载所有这些静态资源变得非常困难， 因为事实上， HTTP 只允许每个 TCP 连接有一个未完成的请求。 </p><p>在过去， 浏览器使用多个 TCP 连接来发出并行请求。 然而这种做法是有限制的。 如果使用了太多的连接， 就会产生相反的效果（TCP 拥塞控制将被无效化， 导致的用塞事件将会损害性能和网络）。 而且从根本上讲这对其他程序来说也是不公平的(因为浏览器会占用许多本不该属于他的资源)。 </p><p>同时， 大量的请求意味着“在线上”有大量重复的数据。 </p><p>这两个因素都意味着 HTTP/1.1 请求有很多与之相关的开销; 如果请求太多， 则会影响性能。 </p><p>这使得业界在有哪些是最好的实践上达成共识， 它们包括， 比如， Spriting（图片合并）、 data: inlining（数据内嵌）、 Domain Sharding（域名分片）和 Concatenation（文件合并）等。 这些不规范的解决方案说明了协议本身存在一些潜在问题， 并且在使用的时候会出现很多问题。 </p><h3 id="谁制定了-HTTP-2"><a href="#谁制定了-HTTP-2" class="headerlink" title="谁制定了 HTTP/2?"></a>谁制定了 HTTP/2?</h3><p>HTTP/2 是由 <a href="http://www.ietf.org/">IETF</a> 的 <a href="https://httpwg.github.io/">HTTP 工作组</a>开发的， 该组织负责维护 HTTP 协议。 该组织由众多 HTTP 实现者、 用户、 网络运营商和 HTTP 专家组成。 </p><p>值得注意的是， 虽然<a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">工作组的邮件列表</a>托管在 W3C 网站上， 不过这并不是 W3C 的功劳。 但是， Tim Berners-Lee 和 W3C TAG与 WG 的进度保持一致。 </p><p>许多人为这项工作做出了自己的贡献， 尤其是一些来自“大”项目的工程师， 例如 Firefox、 Chrome、 Twitter、 Microsoft 的 HTTP stack、 Curl 和 Akamai。 以及若干 Python、 Ruby 和 NodeJS 的 HTTP 实现者。 </p><p>为了更好的了解有关 IETF 的信息， 你可以访问 <a href="http://www.ietf.org/tao.html">Tao of the IETF</a>； 你也可以在 <a href="https://github.com/http2/http2-spec/graphs/contributors">Github 的贡献者图表</a>上查看有哪些人为该项目做出了贡献， 同样的， 你也可以在 <a href="https://github.com/http2/http2-spec/wiki/Implementations">implementation list</a> 上查看谁正在参与该项目。 </p><h3 id="HTTP-2-与-SPDY-的关系是什么？"><a href="#HTTP-2-与-SPDY-的关系是什么？" class="headerlink" title="HTTP/2 与 SPDY 的关系是什么？"></a>HTTP/2 与 SPDY 的关系是什么？</h3><p>HTTP/2 第一次出现并被讨论的时候， SPDY 正得到厂商 (像 Mozilla 和 nginx)的青睐和支持， 并被看成是 HTTP/1.x 基础上的重大改善。 </p><p>在不断的征求建议以及投票选择之后， <a href="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00">SPDY/2</a> 被选为 HTTP/2 的基础。 从那时起， 根据工作组的讨论和用户的反馈， 它已经有了很多变化。 </p><p>在整个过程中， SPDY 的核心开发人员参与了 HTTP/2 的开发， 其中包括 Mike Belshe 和 Roberto Peon。 </p><p>2015 年 2 月， 谷歌<a href="https://blog.chromium.org/2015/02/hello-http2-goodbye-spdy.html">宣布计划</a>取消对 SPDY 的支持， 转而支持 HTTP/2。 </p><h3 id="究竟是-HTTP-2-0-还是-HTTP-2？"><a href="#究竟是-HTTP-2-0-还是-HTTP-2？" class="headerlink" title="究竟是 HTTP/2.0 还是 HTTP/2？"></a>究竟是 HTTP/2.0 还是 HTTP/2？</h3><p>工作组决定删除次要版本（“.0”）， 因为它在 HTTP/1.x 中造成了很多混乱。 也就是说， HTTP 的版本仅代表它的兼容性， 不表示它的特性和“亮点”。 </p><h3 id="和-HTTP-1-x-相比-HTTP-2-的关键区别是什么"><a href="#和-HTTP-1-x-相比-HTTP-2-的关键区别是什么" class="headerlink" title="和 HTTP/1.x 相比 HTTP/2 的关键区别是什么?"></a>和 HTTP/1.x 相比 HTTP/2 的关键区别是什么?</h3><p>在高版本 HTTP/2 中： </p><ul><li>是二进制的， 代替原有的文本</li><li>是多路复用的， 代替原来的序列和阻塞机制</li><li>所以可以在一个连接中并行处理</li><li>压缩头部信息减小开销</li><li>允许服务器主动推送应答到客户端的缓存中</li></ul><h3 id="为什么-HTTP-2-是二进制的"><a href="#为什么-HTTP-2-是二进制的" class="headerlink" title="为什么 HTTP/2 是二进制的?"></a>为什么 HTTP/2 是二进制的?</h3><p>和 HTTP/1.x 这样的文本协议相比， 二进制协议解析起来更高效、 “线上”更紧凑， 更重要的是错误更少。 因为它们对如空白字符的处理、 大小写、 行尾、 空链接等的处理很有帮助。 </p><p>举个栗子 🌰， HTTP/1.1 定义了<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4">四种不同的方法来解析一条消息</a>； 而在HTTP/2中， 仅需一个代码路径即可。 </p><p>HTTP/2 在 telnet 中不可用， 但是我们已经有一些工具可以提供支持， 例如 <a href="https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=9042">Wireshark plugin</a>。 </p><h3 id="为什么-HTTP-2-需要多路传输？"><a href="#为什么-HTTP-2-需要多路传输？" class="headerlink" title="为什么 HTTP/2 需要多路传输？"></a>为什么 HTTP/2 需要多路传输？</h3><p>HTTP/1.x 有个问题叫“队头阻塞（head-of-line blocking）”， 它是指在一次连接（connection）中， 只提交一个请求的效率比较高， 多了就会变慢。 </p><p>HTTP/1.1 尝试使用管线化（pipelining）来解决这个问题， 但是效果并不理想（对于数据量较大或者速度较慢的响应， 依旧会阻碍排在他后面的请求）。 此外， 由于许多网络媒介（intermediary）和服务器不能很好的支持管线化， 导致其部署起来也是困难重重。 </p><p>这也就迫使客户端使用一些启发式的方法（基本靠猜）来决定通过哪些连接提交哪些请求； 由于一个页面加载的数据量， 往往比可用连接能处理的数据量的 10 倍还多， 对性能产生极大的负面影响， 结果经常引起瀑布式阻塞（waterfall of blocked requests）。 </p><p>而多路传输（Multiplexing）能很好的解决这些问题， 因为它能同时处理多个消息的请求和响应； 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。 </p><p>所以在这种情况下， 客户端只需要一个连接就能加载一个页面。 </p><h3 id="为什么只需要一个-TCP-连接？"><a href="#为什么只需要一个-TCP-连接？" class="headerlink" title="为什么只需要一个 TCP 连接？"></a>为什么只需要一个 TCP 连接？</h3><p>如果使用 HTTP/1， 浏览器打开每个点（origin）就需要 4 到 8 个连接（Connection）。 而现在很多网站都使用多点传输（multiple origins）， 也就是说， 光加载一个网页， 打开的连接数量就超过 30 个。 </p><p>一个应用同时打开这么多连接， 已经远远超出了当初设计 TCP 时的预想； 同时， 因为每个连接都会响应大量的数据， 使其可以造成网络缓存溢出的风险， 结果可能导致网络堵塞和数据重传。 </p><p>此外， 使用这么多连接还会强占许多网络资源。 这些资源都是从那些“遵纪守法”的应用那“偷”的（VoIP 就是个很好的例子）。 </p><h3 id="服务器推送的好处是什么？"><a href="#服务器推送的好处是什么？" class="headerlink" title="服务器推送的好处是什么？"></a>服务器推送的好处是什么？</h3><p>当浏览器请求页面时， 服务器发送 HTML 作为响应， 然后需要等待浏览器解析 HTML 并发出对所有嵌入资源的请求， 然后才能开始发送 JavaScript， 图像和 CSS。 </p><p>服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中， 以此来避免往返的延迟。 </p><p>但是， 推送的响应并不是“万金油”， 如果使用不当， 可能会损害性能。 正确使用服务器推送是一个长期的实验及研究领域。 </p><h3 id="消息头为何需要压缩？"><a href="#消息头为何需要压缩？" class="headerlink" title="消息头为何需要压缩？"></a>消息头为何需要压缩？</h3><p>来自 Mozilla 的 Patrick McManus 通过计算消息头对平均页面负载的印象， 对此进行了形象且充分的说明。 </p><p>假定一个页面有 80 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的）， 而每一次请求都有 1400 字节的消息头（这同样也并不少见， 因为 Cookie 和引用等东西的存在）， 至少要 7 到 8 个来回去“在线”获得这些消息头。 这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。 </p><p>这全都由于 TCP 的<a href="http://en.wikipedia.org/wiki/Slow-start">慢启动</a>机制， 它根据可以确认的数据包数量对新连接上发送数据的进行限制 — 这有效地限制了最初的几次来回可以发送的数据包数量。 </p><p>相比之下， 即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。 </p><p>这些额外的开销是相当多的， 特别是当你考虑对移动客户端的影响的时候。 这些往返的延迟， 即使在网络状况良好的情况下， 也高达数百毫秒。 </p><h3 id="为什么选择-HPACK？"><a href="#为什么选择-HPACK？" class="headerlink" title="为什么选择 HPACK？"></a>为什么选择 HPACK？</h3><p>SPDY/2 提出在每一方都使用一个单独的 GZIP 上下文用于消息头压缩， 这实现起来很容易， 也很高效。 </p><p>从那时起， 一个重要的攻击方式 <a href="http://en.wikipedia.org/wiki/CRIME">CRIME</a> 诞生了， 这种方式可以攻击加密文件内部的所使用的压缩流（如GZIP）。 </p><p>使用 CRIME， 那些具备向加密数据流中注入数据能力的攻击者获得了“探测”明文并还原的可能性。 因为是 Web， JavaScript 使其成为了可能， 而且已经有了通过对受到 TLS 保护的 HTTP 资源的使用CRIME来还原出 cookies 和认证令牌（Toekn）的案例。 </p><p>因此， 我们不应该使用 GZIP 进行压缩。 由于找不到其它适合在这种用例下使用的安全有效的算法， 所以我们创造了一种新的， 针对消息头的， 进行粗粒度操作的压缩模式； 因为HTTP消息头并不常常需要改变， 我们仍然可以得到很好的压缩效率， 而且更加的安全。 </p><h3 id="HTTP-2-可以让-cookies（或者其他消息头）变得更好吗？"><a href="#HTTP-2-可以让-cookies（或者其他消息头）变得更好吗？" class="headerlink" title="HTTP/2 可以让 cookies（或者其他消息头）变得更好吗？"></a>HTTP/2 可以让 cookies（或者其他消息头）变得更好吗？</h3><p>这一努力被许可在网络协议的一个修订版本上运行 – 例如， HTTP 消息头、 方法等等如何才能在不改变 HTTP 语义的前提下放到“网络上”。 </p><p>这是因为 HTTP 的应用非常广泛。 如果我们使用了这个版本的 HTTP， 它就会引入一种新的状态机制（例如之前讨论过的例子）或者改变其核心方法（幸好， 这还没有发生过）， 这可能就意味着新的协议将不会兼容现有的 Web 内容。 </p><p>具体地， 我们是想要能够从 HTTP/1 转移到 HTTP/2， 并且不会有信息的丢失。 如果我们开始”清理”消息头（大多数人都认为现在的 HTTP 消息头简直是一团糟)， 我们就不得不去面对现有 Web 的诸多问题。 </p><p>这样做只会对新协议的普及造成麻烦。 </p><p>总而言之， <a href="https://httpwg.github.io/">工作组</a> 会对所有的 HTTP 负责， 而不仅仅只是 HTTP/2。 因此， 我们才可以在版本独立的新机制下运作， 只要它们也能同现有的网络向下兼容。 </p><h3 id="非浏览器用户的-HTTP-是什么样的？"><a href="#非浏览器用户的-HTTP-是什么样的？" class="headerlink" title="非浏览器用户的 HTTP 是什么样的？"></a>非浏览器用户的 HTTP 是什么样的？</h3><p>如果非浏览器应用已经使用过 HTTP 的话， 那他们也应该可以使用 HTTP/2。 </p><p>先前收到过 HTTP “APIs” 在 HTTP/2 中具有良好性能等特点这样的反馈， 那是因为 API 的设计不需要考虑类似请求开销这样一些事情。 </p><p>话虽如此， 我们正在考虑的改进重点是典型的浏览用例， 因为这是协议主要的使用场景。 </p><p>我们的章程里面是这样说的： </p><p>正在组织的规范需要满足现在已经普遍部署了的 HTTP 的功能要求； 具体来说主要包括， Web 浏览（桌面端和移动端）， 非浏览器（“HTTP APIs” 形式的）， Web 服务（大范围的）， 还有各种网络中介（借助代理， 企业防火墙， 反向代理以及内容分发网络实现的）。 同样的， 对 HTTP/1.x 当前和未来的语义扩展 (例如， 消息头， 方法， 状态码， 缓存指令) 都应该在新的协议中支持。 </p><p>值得注意的是， 这里没有包括将 HTTP 用于非特定行为所依赖的场景中（例如超时， 连接状态以及拦截代理）。 这些可能并不会被最终的产品启用。 </p><h3 id="HTTP-2-需要加密吗？"><a href="#HTTP-2-需要加密吗？" class="headerlink" title="HTTP/2 需要加密吗？"></a>HTTP/2 需要加密吗？</h3><p>不需要。 在激烈的讨论后， 工作组没有就新协议是否使用加密（如 TLS）而达成共识。 </p><p>不过， 有些观点认为只有在加密连接上使用时才会支持 HTTP/2， 而目前还没有浏览器支持未加密的 HTTP/2。 </p><h3 id="HTTP-2-是怎么提高安全性的呢？"><a href="#HTTP-2-是怎么提高安全性的呢？" class="headerlink" title="HTTP/2 是怎么提高安全性的呢？"></a>HTTP/2 是怎么提高安全性的呢？</h3><p>HTTP/2 定义了所需的 TLS 文档， 包括版本， 密码套件黑名单和使用的扩展。 </p><p>细节详见<a href="http://http2.github.io/http2-spec/#TLSUsage">相关规范</a>。 </p><p>还有对于一些额外机制的讨论， 例如对 HTTP:// URLs（所谓的“机会主义加密”）使用 TLS； 详见 <a href="https://tools.ietf.org/html/rfc8164">RFC 8164</a>。 </p><h3 id="我现在可以使用-HTTP-2-吗？"><a href="#我现在可以使用-HTTP-2-吗？" class="headerlink" title="我现在可以使用 HTTP/2 吗？"></a>我现在可以使用 HTTP/2 吗？</h3><p>浏览器中， 最新版本的 Edge、 Safari、 Firefox 和 Chrome都支持 HTTP/2。 其他基于 Blink 的浏览器也将支持HTTP/2（例如 Opera 和 Yandex 浏览器）。 详见 <a href="http://caniuse.com/#feat=http2">caniuse</a>。 </p><p>还有几个可用的服务器（包括来自 <a href="https://http2.akamai.com/">Akamai</a>， <a href="https://www.google.com/">Google</a> 和 <a href="https://twitter.com/">Twitter</a> 的主要站点的 beta 支持）， 以及许多可以部署和测试的开源实现。 </p><p>有关详细信息， 请参阅<a href="https://github.com/http2/http2-spec/wiki/Implementations">实现列表</a>。 </p><h3 id="HTTP-2-将会取代-HTTP-1-x-吗？"><a href="#HTTP-2-将会取代-HTTP-1-x-吗？" class="headerlink" title="HTTP/2 将会取代 HTTP/1.x 吗？"></a>HTTP/2 将会取代 HTTP/1.x 吗？</h3><p>工作组的目的是让那些使用 HTTP/1.x 的人也可以使用 HTTP/2， 并能获得 HTTP/2 所带来的好处。 他们说过， 由于人们部署代理和服务器的方式不同， 我们不能强迫整个世界进行迁移， 所以 HTTP/1.x 仍有可能要使用了一段时间。 </p><h3 id="HTTP-3-会出现吗？"><a href="#HTTP-3-会出现吗？" class="headerlink" title="HTTP/3 会出现吗？"></a>HTTP/3 会出现吗？</h3><p>如果通过 HTTP/2 引入的沟通协作机制运行良好， 支持新版本的 HTTP 就会比过去更加容易。 </p><h2 id="实现过程中的问题"><a href="#实现过程中的问题" class="headerlink" title="实现过程中的问题"></a>实现过程中的问题</h2><h3 id="为什么规则会围绕消息头帧的数据接续？"><a href="#为什么规则会围绕消息头帧的数据接续？" class="headerlink" title="为什么规则会围绕消息头帧的数据接续？"></a>为什么规则会围绕消息头帧的数据接续？</h3><p>数据接续的存在是由于一个值（例如 cookie）可以超过 16kb， 这意味着它不可能全部装进一个帧里面。 </p><p>所以就决定以最不容易出错的方式让所有的消息头数据以一个接一个帧的方式传递， 这样就使得对消息头的解码和缓冲区的管理变得更加容易。 </p><h3 id="HPACK-状态的最小和最大尺寸是多少？"><a href="#HPACK-状态的最小和最大尺寸是多少？" class="headerlink" title="HPACK 状态的最小和最大尺寸是多少？"></a>HPACK 状态的最小和最大尺寸是多少？</h3><p>接收一方总是会控制 HPACK 中内存的使用量, 并且最小能设置到 0， 最大则要看 SETTING 帧中能表示的最大整型数是多少， 目前是 2^32 - 1。 </p><h3 id="我怎样才能避免保持-HPACK-状态？"><a href="#我怎样才能避免保持-HPACK-状态？" class="headerlink" title="我怎样才能避免保持 HPACK 状态？"></a>我怎样才能避免保持 HPACK 状态？</h3><p>发送一个 SETTINGS 帧， 将状态尺寸（SETTINGS_HEADER_TABLE_SIZE）设置到 0， 然后 RST 所有的流， 直到一个带有 ACT 设置位的 SETTINGS 帧被接收。 </p><h3 id="为什么会有一个单独的压缩-流程控制上下文？"><a href="#为什么会有一个单独的压缩-流程控制上下文？" class="headerlink" title="为什么会有一个单独的压缩/流程控制上下文？"></a>为什么会有一个单独的压缩/流程控制上下文？</h3><p>简单说一下。 </p><p>原来的提案里面提到了流分组这个概念， 它可以共享上下文， 进行流控制等等。 尽管那样有利于代理（也有利于用户体验）， 但是这样做相应也会增加一点复杂度。 所以我们就决定先以一个简单的东西开始， 看看它会有多糟糕的问题， 并且在未来的协议版本中解决这些问题（如果有的话）。 </p><h3 id="为什么在-HPACK-中有-EOS-的符号？"><a href="#为什么在-HPACK-中有-EOS-的符号？" class="headerlink" title="为什么在 HPACK 中有 EOS 的符号？"></a>为什么在 HPACK 中有 EOS 的符号？</h3><p>由于 CPU 效率和安全的原因， HPACK 的霍夫曼编码填充了霍夫曼编码字符串的下一个字节边界。 因此对于任何特定的字符串可能需要 0-7 个比特的填充。 </p><p>如果单独考虑霍夫曼解码， 任何比所需要的填充长的符号都可以正常工作。 但是， HPACK 的设计允许按字节对比霍夫曼编码的字符串。 通过填充 EOS 符号需要的比特， 我们确保用户在做霍夫曼编码字符串字节级比较时是相等的。 反之， 许多 headers 可以在不需要霍夫曼解码的情况下被解析。 </p><h3 id="实现-HTTP-2-的时候我可以不用去实现-HTTP-1-1-吗？"><a href="#实现-HTTP-2-的时候我可以不用去实现-HTTP-1-1-吗？" class="headerlink" title="实现 HTTP/2 的时候我可以不用去实现 HTTP/1.1 吗？"></a>实现 HTTP/2 的时候我可以不用去实现 HTTP/1.1 吗？</h3><p>通常/大部分时候可以。 </p><p>对于运行在 TLS（ <code>h2</code> ）之上的 HTTP/2 而言， 如果你没有实现 <code>http1.1</code> 的 ALPN 标识， 那你就不需要支持任何 HTTP/1.1 的特性。 </p><p>对于运行在 TCP（ <code>h2c</code> ）之上的 HTTP/2 而言， 你需要实现最初始的升级（Upgrade）请求。 </p><p>只支持 <code>h2c</code> 的客户端需要生成一个针对 OPTIONS 的请求， 因为 <code>“*”</code> 或者一个针对 “/” 的 HEAD 请求， 他们相当安全， 并且也很容易构建。 仅仅只希望实现 HTTP/2 的客户端应当把没有带上 101 状态码的 HTTP/1.1 响应看做错误处理。 </p><p>只支持 <code>h2c</code> 的服务器可以使用一个固定的 101 响应来接收一个包含升级（Upgrade）消息头字段的请求。 没有 <code>h2c</code> 的升级令牌的请求可以使用一个包含了 Upgrade 消息头字段的 505（HTTP 版本不支持）状态码来拒绝。 那些不希望处理 HTTP/1.1 响应的服务器应该在发送了带有鼓励用户在升级了的 HTTP/2 连接上重试的连接序言之后立即用带有 REFUSED_STREAM 错误码拒绝该请求的第一份数据流.</p><h3 id="5-3-2节中的优先级示例是否正确？"><a href="#5-3-2节中的优先级示例是否正确？" class="headerlink" title="5.3.2节中的优先级示例是否正确？"></a>5.3.2节中的优先级示例是否正确？</h3><p>不， 那是正确的。 流 B 的权重为 4， 流 C 的权重为 12。 为了确定每个流接收的可用资源的比例， 将所有权重（16）相加并将每个流权重除以总权重。 因此， 流 B 接收四分之一的可用资源， 流 C 接收四分之三。 因此， 正如规范所述： <a href="http://http2.github.io/http2-spec/#rfc.section.5.3.2">流 B 理想地接收分配给流 C 的资源的三分之一</a>。 </p><h3 id="HTTP-2-连接中需要-TCP-NODELAY-吗？"><a href="#HTTP-2-连接中需要-TCP-NODELAY-吗？" class="headerlink" title="HTTP/2 连接中需要 TCP_NODELAY 吗？"></a>HTTP/2 连接中需要 TCP_NODELAY 吗？</h3><p>是的, 有可能。 即使对于仅使用单个流下载大量数据的客户端， 仍然需要一些数据包以相反的方向发回以实现最大传输速度。 在没有设置 TCP_NODELAY（仍然允许 Nagle 算法）的情况下， 可以传输的数据包将被延迟一段时间以允许它们与后续分组合并。 </p><p>例如， 如果这样一个数据包告诉对等端有更多可用的窗口来发送数据， 那么将其发送延迟数毫秒（或更长时间）会对高速连接造成严重影响。 </p><h2 id="部署问题"><a href="#部署问题" class="headerlink" title="部署问题"></a>部署问题</h2><h3 id="我该怎么调试加密过的-HTTP-2？"><a href="#我该怎么调试加密过的-HTTP-2？" class="headerlink" title="我该怎么调试加密过的 HTTP/2？"></a>我该怎么调试加密过的 HTTP/2？</h3><p>存取应用程序数据的方法很多， 最简单的方法是使用 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format">NSS keylogging</a> 配上 Wireshark 插件（包含在最新开发版中）。 这种方法对 Firefox 和 Chrome 都适用。 </p><h3 id="我该怎么使用-HTTP-2-的服务端推送？"><a href="#我该怎么使用-HTTP-2-的服务端推送？" class="headerlink" title="我该怎么使用 HTTP/2 的服务端推送？"></a>我该怎么使用 HTTP/2 的服务端推送？</h3><p>HTTP/2 服务器推送允许服务器向客户端提供内容而无需等待请求。 这可以提高检索资源的时间， 特别是对于具有大<a href="https://en.wikipedia.org/wiki/Bandwidth-delay_product">带宽延迟产品</a>的连接， 其中网络往返时间占了在资源上花费的大部分时间。 </p><p>推送基于请求内容而变化的资源可能是不明智的。 目前， 浏览器只会推送请求， 如果他们不这样做， 就会提出匹配的请求（详见 <a href="https://tools.ietf.org/html/rfc7234#section-4">Section 4 of RFC 7234</a>）。 </p><p>有些缓存不考虑所有请求头字段的变化， 即使它们列在 <code>Vary</code> header 字段中。 为了使推送资源被接收的可能性最大化， 内容协商是最好的选择。 基于 <code>accept-encoding</code> 报头字段的内容协商受到缓存的广泛尊重， 但是其他报头字段可能不受支持。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Flutter 系列入门教程五： 网格</title>
      <link href="p/16e3.html"/>
      <url>p/16e3.html</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Flutter</strong> <code>GridView</code> 几乎与 <code>ListView</code> 相同， 只是它提供了与 <code>ListView</code> 单向视图的 2D 视图比较。 同时它也是移动应用开发中非常受欢迎的小部件。 如果你不相信我， 那就举个例子， 打开你手机中的任何一个电子商务应用， 它肯定是依赖于 <code>ListView</code> 或 <code>GridView</code> 来显示数据的。 </p><p><strong>Amazon</strong> 移动应用程序利用网格显示数据</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165127b809aaa95f?w=350&h=622&f=png&s=67704"></p><p>另一个是 <strong>PayTM</strong>， 它是印度流行的在线钱包服务应用之一， 它广泛使用网格布局来显示不同的产品</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165127b803b6b8d3?w=350&h=622&f=png&s=46310"></p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本文的最终目的是实现类似的界面： </p><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165127b80ba17804?w=600&h=338&f=png&s=167924"></p><p>但是， 如果你注意到上面的图像， 那是横屏模式下的。 所以我将在本文中做以下的事情， 当应用程序处于竖屏模式时， 移动 APP 将在 <code>ListView</code> 中显示项目， 当它处于横屏模式时， 将会在网格中每行显示3个条目。 我还通过在单独的类中移动 gridview 来实现创建自定义窗口小部件。 </p><h3 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h3><p>我将以我之前的文章为基础 <a href="https://medium.com/@thatsalok/flutter-getting-started-tutorial-4-listview-8326c9ed5524">Flutter Getting Started: Tutorial 4 ListView</a>， 我已经创建了基于 ListView 的应用程序， 这里是初始项目结构和初始UI。 </p><p>这是我们开始构建的初始代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomePage extends StatelessWidget &#123;</span><br><span class="line">    final List &lt; City &gt; _allCities &#x3D; City.allCities();</span><br><span class="line"></span><br><span class="line">    HomePage() &#123;&#125;</span><br><span class="line">    final GlobalKey scaffoldKey &#x3D; new GlobalKey();</span><br><span class="line">    @override</span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        return new Scaffold(</span><br><span class="line">            key: scaffoldKey,</span><br><span class="line">            appBar: new AppBar(</span><br><span class="line">                title: new Text(</span><br><span class="line">                    &quot;Cites around world&quot;,</span><br><span class="line">                    style: new TextStyle(</span><br><span class="line">                        fontSize: 18.0,</span><br><span class="line">                        fontWeight: FontWeight.bold,</span><br><span class="line">                        color: Colors.black87),</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">            body: new Padding(</span><br><span class="line">                padding: EdgeInsets.fromLTRB(0.0, 10.0, 0.0, 0.0),</span><br><span class="line">                child: getHomePageBody(context)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getHomePageBody(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">        return ListView.builder(</span><br><span class="line">            itemCount: _allCities.length,</span><br><span class="line">            itemBuilder: _getListItemUI,</span><br><span class="line">            padding: EdgeInsets.all(0.0),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget _getListItemUI(BuildContext context, int index, &#123;</span><br><span class="line">        double imgwidth: 100.0</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        return new Card(</span><br><span class="line">            child: new Column(</span><br><span class="line">                children: &lt; Widget &gt; [</span><br><span class="line">                    new ListTile(</span><br><span class="line">                        leading: new Image.asset(</span><br><span class="line">                            &quot;assets&#x2F;&quot; + _allCities[index].image,</span><br><span class="line">                            fit: BoxFit.fitHeight,</span><br><span class="line">                            width: imgwidth,</span><br><span class="line">                        ),</span><br><span class="line">                        title: new Text(</span><br><span class="line">                            _allCities[index].name,</span><br><span class="line">                            style: new TextStyle(fontSize: 14.0, fontWeight: FontWeight.bold),</span><br><span class="line">                        ),</span><br><span class="line">                        subtitle: new Column(</span><br><span class="line">                            mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">                            crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                            children: &lt; Widget &gt; [</span><br><span class="line">                                new Text(_allCities[index].country,</span><br><span class="line">                                    style: new TextStyle(</span><br><span class="line">                                        fontSize: 13.0, fontWeight: FontWeight.normal)),</span><br><span class="line">                                new Text(&#39;Population: $&#123;_allCities[index].population&#125;&#39;,</span><br><span class="line">                                    style: new TextStyle(</span><br><span class="line">                                        fontSize: 11.0, fontWeight: FontWeight.normal)),</span><br><span class="line">                            ]),</span><br><span class="line">                        onTap: () &#123;</span><br><span class="line">                            _showSnackBar(context, _allCities[index]);</span><br><span class="line">                        &#125;,</span><br><span class="line">                    )</span><br><span class="line">                ],</span><br><span class="line">            ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _showSnackBar(BuildContext context, City item) &#123;</span><br><span class="line">        final SnackBar objSnackbar &#x3D; new SnackBar(</span><br><span class="line">            content: new Text(&quot;$&#123;item.name&#125; is a city in $&#123;item.country&#125;&quot;),</span><br><span class="line">            backgroundColor: Colors.amber,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Scaffold.of(context).showSnackBar(objSnackbar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始实际任务之前， 让我简要介绍一下我上面做过的事情</p><ul><li>我已经使用 <code>ListView.builder</code> 创建了简单的 <code>ListView</code> ， 它可以灵活地创建无限的 listitem 视图， 因为它只调用那些可以在屏幕上显示的项目的回调函数。 </li><li>我正在显示城市信息， 如城市地标图像， 其次是城市名称， 城市所属的国家和她的人口。 </li><li>最后点击， 它在屏幕底部显示小的会自动消失的消息， 称为 <code>SnackBar</code> 。 </li></ul><p>现在开始我们的工作， 正如我之前提到的， 我们将把新的 widget 重构为不同的类， 以保持我们的代码模块化并提高代码的可读性。 因此， 在 <code>lib</code> 文件夹下创建一个新的文件夹， 并添加新的 DART 文件 <code>mygridview.dart</code> 。 </p><p>添加文件后， 首先通过 <code>&#39;package:flutter/material.dart&#39;</code> 导入 material 组件， 然后添加 <code>MyGridView</code> 类来继承我们最喜欢的 <code>StatelessWidget</code> 并复写 <code>Build</code> 函数， 代码如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line">import &#39;package:flutter5_gridlist&#x2F;model&#x2F;city.dart&#39;;</span><br><span class="line"></span><br><span class="line">class MyGridView extends StatelessWidget &#123;</span><br><span class="line">    final List &lt; City &gt; allCities;</span><br><span class="line">    MyGridView(&#123;</span><br><span class="line">        Key key,</span><br><span class="line">        this.allCities</span><br><span class="line">    &#125;): super(key: key);</span><br><span class="line"></span><br><span class="line">    @override</span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我现在添加基本的 GridView 只显示城市名称， 所以我将在重写的 Build 函数中添加以下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    return GridView.count(</span><br><span class="line">        crossAxisCount: 3,</span><br><span class="line">        padding: EdgeInsets.all(16.0),</span><br><span class="line">        childAspectRatio: 8.0,</span><br><span class="line">        children: _getGridViewItems(context),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">_getGridViewItems(BuildContext context) &#123;</span><br><span class="line">    List &lt; Widget &gt; allWidgets &#x3D; new List &lt; Widget &gt; ();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; allCities.length; i++) &#123;</span><br><span class="line">        var widget &#x3D; new Text(allCities[i].name);</span><br><span class="line">        allWidgets.add(widget);</span><br><span class="line">    &#125;;</span><br><span class="line">    return allWidgets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述代码的解释</p><ul><li><code>GridView.count</code> 方法将为应用程序提供 GridView 小部件</li><li><code>crossAxisCount</code> 属性用于让移动应用程序知道我们想要显示每行的项目数</li><li><code>children</code> 属性将包含您希望在加载页面时显示的所有小部件</li><li><code>childAspectRatio</code> ， 它是每个子节点的横轴与主轴范围的比率， 因为我显示的是名称， 所以我统一设置为 8.0， 以便减少两个图块之间的边距 </li></ul><p>这是UI的样子</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165127b807a7dd10?w=600&h=338&f=png&s=15605"></p><p>现在我们来改变 UI 让其类似于我们看到的 ListView。 在这里我创建了一个新的函数， 它将以 Card 的形式发送 City 类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Create individual item</span><br><span class="line">_getGridItemUI(BuildContext context, City item) &#123;</span><br><span class="line">    return new InkWell(</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">            _showSnackBar(context, item);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: new Card(</span><br><span class="line">            child: new Column(</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                children: &lt; Widget &gt; [</span><br><span class="line">                    new Image.asset(</span><br><span class="line">                        &quot;assets&#x2F;&quot; + item.image,</span><br><span class="line">                        fit: BoxFit.fill,</span><br><span class="line"></span><br><span class="line">                    ),</span><br><span class="line">                    new Expanded(</span><br><span class="line">                        child: new Center(</span><br><span class="line">                            child: new Column(</span><br><span class="line">                                children: &lt; Widget &gt; [</span><br><span class="line">                                    new SizedBox(height: 8.0),</span><br><span class="line">                                    new Text(</span><br><span class="line">                                        item.name,</span><br><span class="line">                                        style: new TextStyle(</span><br><span class="line">                                            fontSize: 20.0,</span><br><span class="line">                                            fontWeight: FontWeight.bold,</span><br><span class="line">                                        ),</span><br><span class="line">                                    ),</span><br><span class="line">                                    new Text(item.country),</span><br><span class="line">                                    new Text(&#39;Population: $&#123;item.population&#125;&#39;)</span><br><span class="line">                                ],</span><br><span class="line">                            )))</span><br><span class="line">                ],</span><br><span class="line">            ),</span><br><span class="line">            elevation: 2.0,</span><br><span class="line">            margin: EdgeInsets.all(5.0),</span><br><span class="line">        ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码的解释</strong></p><ul><li>我正在使用 <code>Inkwell</code> 类， 因为 Card 类不直接支持手势， 所以我把它包装在 InkWell 类中， 利用它的 <code>onTap</code> 事件替换 SnackBar</li><li>其余代码类似于 <code>ListView</code> 的卡片， 但未指定宽度</li><li>此外， 由于我们正在显示完整的卡片， 因此我们不要忘记将 <code>childAspectRatio</code> 从 8.0 更改为 8.0/9.0， 因为我们需要更多的高度。 </li></ul><p>如果没有忘记的话， 在开始做程序时我就说过， 我将在纵向方向上显示 <code>ListView</code> ， 在横向方向上显示 <code>GridView</code> ， 为了实现它我们需要 <code>MediaQuery</code> 类来识别方向。 无论何时更改方向， 你都可以决定哪些代码应该被调用， 也就是说， 即使你倾斜移动窗口都会调用 <code>Build</code> 函数， 小部件也都会重新绘制。 所以在 <code>homepage.dart</code> 类中我们将使用以下函数来处理 Orientation 更改的问题</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getHomePageBody(BuildContext context) &#123;</span><br><span class="line">    if (MediaQuery.of(context).orientation &#x3D;&#x3D; Orientation.portrait)</span><br><span class="line">        return ListView.builder(</span><br><span class="line">            itemCount: _allCities.length,</span><br><span class="line">            itemBuilder: _getListItemUI,</span><br><span class="line">            padding: EdgeInsets.all(0.0),</span><br><span class="line">        );</span><br><span class="line">    else</span><br><span class="line">        return new MyGridView(allCities: _allCities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此， 最终的 UI 将是这样的</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165127b8151d33f6?w=350&h=622&f=gif&s=446180"></p><p>本教程结束</p><h3 id="兴趣点"><a href="#兴趣点" class="headerlink" title="兴趣点"></a>兴趣点</h3><p>请仔细阅读这些文章。 它可能会给你一个你真正需要的指引： </p><ol><li><a href="https://material.io/design/components/cards.html#">https://material.io/design/components/cards.html</a></li><li>Github : <a href="https://github.com/thatsalok/FlutterExample/tree/master/flutter5_gridlist">https://github.com/thatsalok/FlutterExample/tree/master/flutter5_gridlist</a></li></ol><h3 id="Flutter-教程"><a href="#Flutter-教程" class="headerlink" title="Flutter 教程"></a>Flutter 教程</h3><ol><li><a href="https://medium.com/@thatsalok/flutter-getting-started-tutorial-1-basics-8714e751408f">Flutter Getting Started: Tutorial 1 Basics</a></li><li><a href="https://medium.com/@thatsalok/flutter-getting-started-tutorial-4-listview-8326c9ed5524">Flutter Getting Started: Tutorial 4 ListView</a></li></ol><h3 id="Dart-教程"><a href="#Dart-教程" class="headerlink" title="Dart 教程"></a>Dart 教程</h3><ol><li><a href="https://www.codeproject.com/Articles/1251136/DART-Prima-Plus-Tutorial">DART2 Prima Plus — Tutorial 1</a></li><li><a href="https://www.codeproject.com/Articles/1251343/DART2-Prima-Plus-Tutorial-2-LIST">DART2 Prima Plus — Tutorial 2 — LIST</a></li><li><a href="https://www.codeproject.com/Articles/1252345/DART2-Prima-Plus-Tutorial-3-MAP">DART2 Prima Plus — Tutorial 3 — MAP</a></li></ol><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li>22-July-2018： 第一个版本</li></ul>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】使用 GraphQL 的 6 个月</title>
      <link href="p/3bd2.html"/>
      <url>p/3bd2.html</url>
      
        <content type="html"><![CDATA[<p>GraphQL 这个名词已经火了一段时间，但是一直没有体验过，无意中发现了一篇使用体验的文章，就想着翻译下分享给大家，如果翻译有问题的，还望批评指正。</p><blockquote><ul><li>原文地址：<a href="https://levelup.gitconnected.com/6-months-of-using-graphql-faa0fb68b4af">6 Months Of Using GraphQL</a></li></ul></blockquote><hr><p>在使用 GraphQL 进行了 6 个月的后端项目开发后，我开始考量该技术是否适合在开发工作中使用。</p><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>GraphQL 是一种实现 API 的查询语言，也是使用现有数据完成这些查询的运行时。GraphQL 为你的 API 中的数据提供了完整且易于理解的描述，并且让用户有权决定他们所需要的东西，仅此而已。</p><p>它由 Facebook 开发，作为其移动应用程序的内部解决方案，后来向社区开放了源代码。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h4 id="务实的数据交换"><a href="#务实的数据交换" class="headerlink" title="务实的数据交换"></a>务实的数据交换</h4><p>使用 GraphQL，可以为客户需要的字段指定一个查询，不多也不少。真的就是这么简单。如果<strong>前端</strong>只需要一个人的**<code>名字</code><strong>和</strong><code>年龄</code><strong>字段，直接请求相应的字段就可以了。这个人的</strong><code>姓氏</code><strong>和</strong><code>地址</code>**等其他字段不会返回在请求结果中。</p><h4 id="使用数据加载器（Dataloaders）减少网络调用"><a href="#使用数据加载器（Dataloaders）减少网络调用" class="headerlink" title="使用数据加载器（Dataloaders）减少网络调用"></a>使用数据加载器（Dataloaders）减少网络调用</h4><p>虽然 Dataloaders 不是 GraphQL 库本身的一部分，但是它的确是一个很有用的第三方库，可以用来解耦应用程序中不相关的部分，同时不会牺牲批量数据加载的性能。虽然加载器提供了一个加载各个独立值的 API，但是所有并发请求都将被合并起来才分送给你的批处理加载函数。这使你的应用程序可以安全地在整个应用程序进行数据的分发与获取。</p><p>这方面的一个例子是，从另一个称为<strong>事务服务</strong>的服务中获取人的银行信息，后端可以从<strong>事务服务</strong>中获取银行信息，然后将结果与人的**<code>姓名</code><strong>和</strong><code>年龄</code>**结合起来后作为结果返回。</p><h4 id="公开数据和数据库模型之间的解耦"><a href="#公开数据和数据库模型之间的解耦" class="headerlink" title="公开数据和数据库模型之间的解耦"></a>公开数据和数据库模型之间的解耦</h4><p>GraphQL 的一大优点是可以将数据库建模数据和给用户公开的数据解耦。这样，在设计持久层时，我们可以专注于该层的需求，然后分别考虑如何采取最好的方式将数据暴露给使用者。这与 dataloader 的使用密切相关，因为你可以在将数据发送给用户之前将它们组合在一起，从而使得公开数据的设计模型变得非常容易。</p><h4 id="忘记-API-的版本控制"><a href="#忘记-API-的版本控制" class="headerlink" title="忘记 API 的版本控制"></a>忘记 API 的版本控制</h4><p>API 的版本控制是一个常见问题，通常一个简单的解决方案是，在相同的 API 前面添加一个<strong>v2</strong>标识。但一旦有了 GraphQL，情况就不同了。虽然你仍然可以使用相同的解决方案，但这与 GraphQL 的理念不合。官方文档明确指出你应该改进你的 API，这意味着向已有端点添加更多的字段并不会破坏原有的 API。前端仍然可以使用相同的 API 进行查询，并且可以根据需要查询新字段。这种处理方式真的很巧妙。</p><p>在与前端团队协作时，这个特性非常有用。他们可以发出请求，并添加由于设计更改而需要的新字段，而后端可以轻松地添加该字段，同时不会破坏现有的 API。</p><h4 id="独立团队"><a href="#独立团队" class="headerlink" title="独立团队"></a>独立团队</h4><p>使用 GraphQL，前端和后端可以独立工作。因为 GraphQL 具有严格的类型化架构，因此两个团队可以并行工作互不影响。首先，<strong>前端</strong>无需查看后端代码即可轻松地生成数据模型，且生成的数据模型可以直接用于创建数据查询。其次，<strong>前端</strong>可以使用模拟（mock）出来的 API 来测试代码。这样便不会阻碍前后端的开发工作，大大的提升了程序员的开发体验。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gem4rmk5jrj31900u01ky.jpg"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h4 id="并非所有的-API-都能改进"><a href="#并非所有的-API-都能改进" class="headerlink" title="并非所有的 API 都能改进"></a>并非所有的 API 都能改进</h4><p>有时，会因业务或设计而产生一些变化，这需要对 API 的实现进行彻底更改。在这种情况下，你将不得不依靠旧的方式进行版本控制。</p><h4 id="不可读的代码"><a href="#不可读的代码" class="headerlink" title="不可读的代码"></a>不可读的代码</h4><p>由于经历了多次迭代，所以有时在使用 Dataloader 读取数据时代码会分散到多个位置，这可能很难维护。</p><h4 id="响应时间更长"><a href="#响应时间更长" class="headerlink" title="响应时间更长"></a>响应时间更长</h4><p>由于查询会不断发展并变得臃肿，因此有可能会延长响应时间。为避免这种情况，请确保简明扼要的响应资源。有关指导原则，请查看<a href="https://developer.github.com/v4/">Github GraphQL API。</a></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存 API 响应的目的主要是为了更快地从将来的请求中获取响应。与 GraphQL 不同，RESTful API 可以利用 HTTP 规范中内置的缓存。正如前面提到的，GraphQL 查询可以请求资源的任何字段，因此本质上是很难实现缓存的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我强烈建议使用 GraphQL 替代 REST API。GraphQL 所提供的灵活性绝对可以取代它的痛点。这里提到的优缺点可能并不总适用，但是探索如何借助 GraphQL 来帮助你完成项目是很值得思考的。</p><p>如果你有任何意见，请在下面回复。</p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】13 个你应该选择/考虑使用 Flutter 的理由</title>
      <link href="p/f628.html"/>
      <url>p/f628.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>13 个你应该<a href="https://twitter.com/scottstoll2017"><strong>转向 Dart</strong></a> 并且选择或者学习利用 Flutter 去开发你的下一个 app 的理由。 </p></blockquote><p>如今的企业需要在选择移动技术时做出关键选择。 他们不断的测试和评估技术， 以求不论用户使用什么移动设备或操作系统都能有强大的数字体验。 企业如果不能提供易于使用的产品和服务， 那么无论使用何种渠道或设备， 都有可能落后于竞争对手。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9ed0ff1692?w=360&h=240&f=gif&s=3052341"></p><p>目前面临的挑战便是跨平台应用的开发存在问题。 在某些情况下， 尽管开发人员尽了最大努力， 其用户体验仍然落后于原生 app 。 近年来， 我们看到了各种移动框架的出现， 如 React Native、 Xamarin 和 AngularJS ， 它们帮助我们更容易地产生较好地数字体验。 最近我们看到一个新玩家加入了这场游戏——谷歌的 Flutter。 </p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9ecdb3881c?w=400&h=225&f=gif&s=1010084"></p><p>从内部来看， Flutter 看起来像是谷歌各种技术和概念的大杂烩， 然而却产生一个不可思议的强大的移动框架。 它是基于 Dart (谷歌的内部编程语言)开发的， 它可以让 Flutter 访问 Skia 图形库， 而这正是 Chrome 浏览器所使用的。 除此之外， Flutter 与谷歌的 Material Design 规范紧密结合； 其中最著名的便是 Android 用户已经熟知的“卡片图案”。 </p><hr><p>让我们看看 13 个选择 Flutter 作为你的开发环境甚至可以选择它开始你的职业生涯的理由， </p><p><strong>1. Flutter 克服了传统跨平台的限制</strong></p><p>长期以来， 创建真正的跨平台方法一直是技术顾问的苦恼所在， 他们厌倦了为同一产品制作多个版本。 但是， 实际上， 跨平台应用的用户体验通常落后于原生 app， 因为你经常需要即时编译 JavaScript 来构建 UI 体验。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9ec9518e42?w=615&h=413&f=jpeg&s=30288"></p><p>使用 Flutter， 你不仅可以拥有“一次编写”的优势， 还可以创建高性能的“原生”体验， 因为 Flutter 应用程序是提前编译出机器可执行的二进制文件。 它克服了其他跨平台方法中的一些常见问题。 </p><p><strong>2. 开发人员的生产力提高了十倍</strong></p><p>这种生产力的提高来自 Flutter 的“热重载”（也就是所谓的“有状态的热重载”和“热重启”）。 这样， 开发人员可以在不到一秒的时间内看到他们对应用程序状态所做的更改； 并且在不到 10s 的时间内改变 app 的结构。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897ba0556932c1?w=200&h=356&f=gif&s=619458"></p><p>没有必要去启动另一个 Gradle 构建程序——因为你可以在保存后查看你的修改。 对于开发人员来说， 这通常很容易掌握——在使用“热重载”时几乎没有等待时间， 因为在默认情况下， 每次保存时都会实时改变。 </p><p>然而， 优势是至关重要的。 使用 Flutter 开发时间通常会减少 30-40%， 因为在 Android 开发中， 每次修改后 Gradle 都需要重新构建， 这会降低 Android 开发人员的速度。 </p><p><strong>3. 前后端只需一套代码</strong></p><p>在 Android 编程中， 前端( Views )有单独的文件， 由后端( Java )引用， 与之不同的是， flutter 使用一种语言( Dart )来完成这两项工作， 并使用一个响应式框架。 </p><p>Dart 借鉴了其他语言众多流行的特性， 同时不会让你感到陌生， 因为它和 Java 或者其他语言相似。 Dart 的构建考虑了开发人员的易用性， 从而使许多常见任务变得更加容易。 你可以在这学到更多有关 Dart 的知识： <a href="https://www.dartlang.org/guides/language/language-tour">Dart 语言之旅</a>.</p><p><strong>4. 这是一种强大的开箱即用的设计体验</strong></p><p>由于 Flutter 团队对 Material design 规范的积极适配， 使得开发者很容易就可以创建出功能强大的 UI 体验。 它可以帮助你生成通常只能在原生 app 中才能体验到的平滑、 流畅， 因为 Flutter 的发行版构建的就是一个原生 app 。 </p><p>Flutter 的小部件同时也实现了 iOS 的人机界面设计规范， 可以让你在 iPhone 和 iPad 上也能获得那种原生的“体验”。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9ecbf91aaf?w=800&h=378&f=png&s=75833"></p><p><strong>5. 有一个数量众多且开源的软件库</strong></p><p>大量可用的开源包可以帮助你更快、 更轻松地创建应用程序， 而且目前有许多可用的包可以使许多复杂的任务变得更容易。 </p><p>由于不断加入的开发人员对 Flutter 的作出的积极贡献， 所以即使这个开源库还不够成熟， 但它依然在积极壮大。 </p><p><strong>6. 与 Firebase 的紧密结合</strong></p><p>Firebase 为云存储、 云功能、 实时数据库、 托管、 身份验证等一系列服务提供开箱即用的支持。 你的基础设施完全可以是无服务器的、 冗余的和可扩展的。 这意味着你不必花费大量时间和资源来构建后端。 </p><p>它还可以直接与一个工具结合使用来自动化你的开发和发布过程以促进持续交付（例如 Fastlane）。 因此， 你不必在团队中提供专门的 DevOps 支持。 </p><p><strong>7. 大量 IDE支持 Flutter</strong></p><p>在使用 Flutter 进行编程时， 你可以从许多集成开发环境中进行选择。 一开始我使用的是 Android Studio， 但后来我看 Flutter Live 时使用的是VS Code。 这让我很疑惑， 因为我发现很多 Flutter 开发人员都在使用 Visual Studio Code。 当我尝试之后， 我明白为什么这么多人喜欢它了。 VS Code 相较于 Android Studio 和 IntelliJ 更加轻量， 速度也快得多， 并且具有两者中的大部分特性。 就我个人而言， 我已经转向 VS Code， 但是你也可以使用许多其他的 IDE ， 你无需切换就可以开始 Flutter 的工作。 </p><p><strong>8. UI遵从性——一切都是一个小部件</strong></p><p>在 flutter 中， 所有的东西都是一个小部件， 例如 Appbar, Drawer, Snackbar, Scaffold 等等。 开发者可以很容易地将一个小部件包装在另一个小部件中以实现一些效果， 例如将一个部件包装在一个 Center 小部件中， 就可以让其居中。 </p><p>以上这些都是为了确保你的用户无论使用什么平台运行你的软件都可以有相同的用户体验。 你还应该阅读下述 flutter 文档： <a href="https://flutter.io/docs/resources/technical-overview#everythings-a-widget">Everything’s a widget</a></p><p><strong>9. Android/iOS 的不同主题</strong></p><p>根据用户的平台分配正确的主题就像使用三元 if 检查用户正在运行的平台一样简单； 允许 UI 在运行时决定使用哪些 UI 组件。 </p><p>下面是一个示例代码， 它用于检查当前运行的平台， 如果是 iOS， 它返回一个以紫色作为主色调的主题。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return new MaterialApp(</span><br><span class="line">    &#x2F;&#x2F; default theme here</span><br><span class="line">    theme: new ThemeData(),</span><br><span class="line">    builder: (context, child) &#123;</span><br><span class="line">        final defaultTheme &#x3D; Theme.of(context);</span><br><span class="line">        if (defaultTheme.platform &#x3D;&#x3D; TargetPlatform.iOS) &#123;</span><br><span class="line">            return new Theme(</span><br><span class="line">                data: defaultTheme.copyWith(</span><br><span class="line">                    primaryColor: Colors.purple</span><br><span class="line">                ),</span><br><span class="line">                child: child,</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        return child;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>10. 使用 Code Magic 进行持续集成.</strong></p><p>Code magic 是 2018 年 12 月 4 日在 Flutter Live 中使用的一个开源工具。 Code magic 很容易学习， 并且完全免费！ 它是一种高度复杂的 CI 工具， 专门针对 Flutter 进行了优化。 Code magic 使构建过程无缝对接。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9f7bf47488?w=800&h=421&f=png&s=42788"></p><p>运行中的 Code Magic </p><p><strong>11.  <a href="https://www.2dimensions.com/">2Dimensions</a> 让动画制作更简单</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9f7f26235f?w=320&h=568&f=gif&s=1312542"></p><p>我第一次尝试使用 Flutter + Flare——Bouncy</p><p>同样是在 Flutter live 2018 期间推出的惊人的在线工具， 可以轻松创建非常棒的 UI 或动画。 它弥补了 UI 设计人员和开发人员之间的差距， 减少了应用 UI 或动画相关更改所需的时间。 </p><p>Flare的学习曲线很浅， 我在使用了它之后， 对创建动画的简单性感到惊讶！ 你可以看到 app 在这里工作， 我甚至在球上加了一个反射， 给它一个更逼真的外观。 </p><p><strong>12. 运行在桌面和 Web 端的 Flutter</strong></p><p>Flutter 团队现在已经有了可以在 web 浏览器中工作的 Flutter 原型 app ， 这让所有人都感到震惊。 在 Flutter Live 中， 之前的绝密项目 “Hummingbird” 向世界公开。 很快， 你就可以使用相同的代码轻松地为移动端、 桌面端和 web 端创建应用程序。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9f85928aae?w=800&h=210&f=png&s=19512"></p><p><strong>13. 来自 Flutter 团队和 Flutter 社区的持续支持</strong></p><p>在过去的三周里， 我一直在用 Flutter 工作， 并注意到来自 Flutter 团队和社区的很多支持和鼓励； 尤其是 <a href="https://twitter.com/scottstoll2017">Scott Stoll</a>, <a href="https://twitter.com/nlycskn">Nilay Yener</a> 和 <a href="https://twitter.com/devangelslondon">Simon Lightfoot</a>（仅举几个例子）。 每个星期三， Flutter 社区中许多比较知名的名字都可以在 Zoom at #HumpDayQandA 上看到， 在那里你可以实时获取来自真人的有关 Flutter 的帮助。 即便你没有任何问题， 那也是一个很好的地方， 因为你可以从他们回答别人的问题中学到很多。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/29/16897b9fd842c5f9?w=800&h=856&f=jpeg&s=132825"></p><p>这是我参加 #HumpDayQandA 的照片。 来自 Flutter Egypt 的创始人， 谷歌开发者 Amed Abu Eldahab的推文。 </p><p>使用 Flutter 的价值很明显， 也很有吸引力， 因为它减轻了初创公司试图将产品发布到多个平台所面临的许多困难； 特别是处理在有限的时间和预算内将软件产品推向市场的时候。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】用于补丁生成自动推理代码转换</title>
      <link href="p/e32c.html"/>
      <url>p/e32c.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689f44bc205ebfc?w=2622&h=962&f=jpeg&s=326163"></p><blockquote><p>这篇是导师给的论文， 因为有随手删文件的习惯， 所以把这篇文章发布到这留作备份， 原文地址为： <a href="http://www.cs.toronto.edu/~fanl/papers/genesis-fse17.pdf">Automatic Inference of Code Transforms for Patch Generation.</a>， 本人目前翻译功底较差， 如果有小伙伴觉得翻译的有问题， 希望在评论区指出， 大家共同进步😊</p></blockquote><hr><p><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689f42eb6deb83b?w=2612&h=428&f=jpeg&s=101785"></p><blockquote><p><strong>论文</strong>： Fan Long, Peter Amidon, and Martin Rinard. 2017. Automatic Inference of Code Transforms for Patch Generation. In Proceedings of 2017 11th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, Paderborn, Germany, September 4-8, 2017 (ESEC/FSE’17), 13 pages. <a href="https://doi.org/10.1145/3106237.3106253">https://doi.org/10.1145/3106237.3106253</a></p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们提出了一个新的系统Genesis， 该系统能够处理人工的补丁来自动化推理代码转换， 用于自动化补丁生成。 我们呈现的结果描述了 Genesis 推理算法和完整的 Genesis 补丁生成系统在来自372个真实的 Java 项目的补丁和缺陷上工作的有效性。 据我们所知， Genesis是第一个用于自动推理补丁生成转换或从先前成功的补丁空间中搜索候选补丁的系统。 </p><a id="more"></a><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>补丁生成， 代码转换， 搜索空间推理</p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>自动补丁生成系统有望大大减少诊断、 调试和修复软件缺陷所需的人工工作。 标准的生成和验证方法是从一组测试用例开始的， 该测试集中至少有一个测试用例揭示了缺陷。 它部署了一组转换以生成候选补丁的搜索空间， 然后在测试用例上运行生成的补丁程序， 以此找到能够为所有测试用例生成正确输出的合理补丁。 之前所有的生成和验证系统都通过一组人工转换来修补这些转换范围内的程序错误。 </p><h4 id="Genesis"><a href="#Genesis" class="headerlink" title="Genesis"></a>Genesis</h4><p>我们介绍了Genesis， 一个新颖的系统， 其推理代码转换用于自动化补丁生成系统。 给定一组从可修正历史库中提取的人工生成的正确补丁， Genesis将补丁的子集泛化， 并以此推断出可以生成高效搜索空间候选补丁的转换。 因此， Genesis可以结合众多开发人员的补丁并总结出经验并以此生成各种高效的补丁生成策略。 在过去没见过的程序中， Genesis可以很成功地将推断转换应用修复bug上。 据我们所知， Genesis是第一个自动推理补丁生成转换或根据先前成功的补丁搜索候选补丁空间的系统。 </p><p><strong>转换</strong>： 每个Genesis转换都有两个模版抽象语法树（ASTs）。 一个模板AST匹配原始程序中的代码。 另一个模板AST指定生成补丁的替换代码。 模板AST包含模板变量， 这些变量与原始代码或补丁代码中的子树或子森林匹配。 模板变量使得转换能够抽象掉特定于应用的细节， 以捕捉由从不同应用中提取的多个补丁所实现的公共模式。 </p><p><strong>生成器</strong>： 许多有用的补丁并不是简单地重新排列现有的代码和逻辑， 它们还引入了新的代码和逻辑。 因此， Genesis 转换实现了部分模式匹配（partial pattern matching）， 其中替换的模板AST包含原始代码中不匹配的自由模板变量。 每个自由模板变量都与一个生成器（generator）相关联， 这个生成器可以系统地为自由变量生成新的候选代码组件。 这种技术使Genesis能够在候选补丁中合成新的代码和逻辑， 使其可以为以前不可见的应用程序生成正确的补丁， 这点对于Genesis来说至关重要。 </p><p><strong>使用ILP搜索空间推断</strong>： 在设计补丁搜索空间时， 关键的地方是在覆盖率和可跟踪性之间进行一个固有的权衡。 一方面， 搜索空间需要足够大， 以包含针对目标缺陷类的正确补丁(覆盖率)； 另一方面， 搜索空间需要足够小， 这样补丁生成系统才能有效地探索空间， 找到正确的补丁(可跟踪性)。 </p><p>Genesis通过构造和解决整数线性程序(ILP)来解决这个问题， 该程序的解决方案最大化了被推断的搜索空间所覆盖的训练补丁的数量， 同时又在一定范围内限定了搜索空间可以生成的候选补丁的数量。 </p><h3 id="2-转换推理"><a href="#2-转换推理" class="headerlink" title="2. 转换推理"></a>2. 转换推理</h3><p>接下来， 我们将通过一个例子来概述Genesis转换推理算法。 Genesis使用一组训练成功的人工补丁来推断一组补丁生成转换。 在我们的示例中， 训练集由963个人工补丁组成， 分别从356个GitHub仓库中筛选出来。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689f44bc205ebfc?w=2622&h=962&f=jpeg&s=326163"></p><p><strong>补丁采样和泛化</strong>： Genesis推理算法使用训练集的样本子集进行训练。 对于每个子集， 它应用一个泛化算法（generalization algorithm）来推断可以用于生成候选补丁的转换。 图一展示了该例中的一个补丁子集： 第一个补丁将一个语句mapperTypeElement==null分解成一个if条件语句。 第二个补丁将一个分句subject!=null组合成一个返回一个值的语句， 第三个补丁将分句Material.getMaterials(getTypeId())!=null合并成一个if条件语句， 这些补丁来自三个不同的应用程序， 分别是mapstruct、 modelmappe和Bukki。 在图1中， Genesis将这些补丁泛化以此来推断转化P1， 在应用时， P1可以为其他应用程序生成所有采样的三个补丁以及其他补丁。 </p><p><strong>模版结构</strong>： 每种转换都有一个模版。 在我们的例子中， 模版是V0 ==&gt; ((V3)op2(null))op1(V0)（图1以图的形式显示了这个模板）。 转换有一个初始模板AST T0， 它匹配未修补程序中的布尔表达式V0。 V0必须出现在函数体中(如果所有的训练补丁都修改了if条件， 那么T0就会反映出更具体的上下文)。 该转换还有一个替换模板AST T1， 它将匹配的布尔表达式V0替换为表单((V3)op2(null))op1(V0)的一个补丁。 这里V3、 op2和op1是不匹配的模板变量。 每个这样的变量都与生成器关联， 生成器枚举变量的候选代码组件。 </p><p><strong>生成器约束</strong>： 生成器约束控制生成器将枚举的组件。 op2和op1的生成器约束 (op2 ∈ {==, ! =} and op1 ∈ {&amp;&amp;, ||}) 只指定要枚举的操作符集。 V3的生成器约束控制为V3枚举的AST子树。 V3 ∈ Expr表明V3 是一个表达式， nodes(V3) ⊆ Call∪Var表明V3只能包含方法调用或变量引用。 |V3| ≤ 2 表明V3最多可以包含2个AST节点。 </p><p>vars(V3) ⊆ M表明V3中出现的任何变量也必须出现在匹配的模板AST V0中(这里M表示原始匹配代码中的节点集)。 |vars(V3)| ≤ 1表示V3中最多只能出现一个变量。 calls(V3) ⊆ M 和 |calls(V3)| ≤ 2类似， 表明约束V3中可能出现的方法调用。 </p><p>正如这些生成器约束所说明的， Genesis 补丁泛化算法推导出生成所有采样训练补丁的最小通用Genesis变换。 这种策略对于获得在补丁搜索空间中生成可处理数量的补丁的精确目标转换至关重要。 </p><p><strong>候选转换</strong>： Genesis重复采样训练补丁以获得候选转换(Genesis将从中选择它用于生成补丁的所选转换)。 在我们的例子中， 候选转换包括前面的转换<em>P1</em>以及一个转换(<em>P2</em>)， 它添加了一个条件(三元)运算符来保护表达式的计算不受NP缺陷的影响； 一个转换(<em>P3</em>)添加一个if-return或if-continue语句来跳过触发NP缺陷的计算； 转换<em>P4</em>通过用一个新的表达式来随便更换一个表达式。 新表达式可能包含二进制运算符、 条件运算符， 以及来自封闭函数的至多六个变量和六个方法调用。 </p><p>但是并非所有这些变换都同样有用。 例如， <em>P4</em>是一个过度通用的转换， 它可以生成一个巨大的补丁搜索空间， 以至于Genesis无法有效搜索。 另一方面， <em>P1</em>、 <em>P2</em>和<em>P3</em>更有针对性——因为它们是从概念上类似的训练补丁中推断出来的， 因此每个都生成一个小得多的搜索空间， 但其中包含正确的补丁。 <em>P1</em>、 <em>P2</em>和<em>P3</em>有效地互补——它们生成的搜索空间具有相对较少的公共补丁。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689f44bc1f72d3c?w=2624&h=562&f=jpeg&s=158706"></p><p><strong>搜索空间推理</strong>： 为了得到一组有效的转换， Genesis必须抛弃例如<em>P4</em>的过度通用的转换， 而选择互补的、 有效的目标转换， 如<em>P1</em>、 <em>P2</em>和<em>P3</em>。 Genesis利用从训练补丁中选择的一组验证补丁来驱动转换选择。 Genesis首先计算每个候选转换生成的验证补丁的数量， 以及在应用于每个验证补丁的补丁前代码时， 每个候选转换生成的搜索空间的大小。 </p><p>图2中的矩阵给出了四个候选转换<em>P1</em>、 <em>P2</em>、 <em>P3</em>和<em>P4</em>的编号， 以及三个验证补丁<em>VP1</em>、 <em>VP2</em>和<em>VP3</em>。 矩阵中的每个数字都是转换应用于验证补丁的补丁前代码时生成的候选补丁的数量。 绿色粗体数字表示， 当将转换应用于补丁的预补丁代码时， 可以生成验证补丁。 这些数字突出了候选补丁提供的覆盖率与可跟踪性之间的权衡。 对于易于处理的搜索空间， <em>P1</em>、 <em>P2</em>和<em>P3</em>都生成一个验证补丁。 相反， <em>P4</em>可以生成两个验证补丁， 但代价是难以处理的大搜索空间。 </p><p>使用矩阵中的信息， Genesis制定了一个整数线性程序（ILP）， 它可以最大化所选变换可以生成的验证补丁的数量， 但要受到所有选定变换的生成候选补丁总数的约束。 覆盖验证案例小于5×10^4。 在我们的示例中， ILP选择<em>P1</em>、 <em>P2</em>和<em>P3</em>作为选定的变换并排除<em>P4</em>。 </p><p><strong>补丁生成</strong>： 对于DataflowJavaSDK修订版c06125中的NP缺陷(如图1底部所示)， Genesis首先使用了一种缺陷定位技术来生成一个要修改语句的潜在排序列表。 得到的排序列表包括图1左下角所示的if条件。 Genesis然后将所有选择的转换(包括P1)应用到if条件以生成候选补丁。 </p><p>图1显示了Genesis如何将P1应用于if条件。 在这里， 补丁将V3实例化为变量union， op2实例化为==， op3为||， 以此来分解语句unions == null使其变成一个最原始的if语句。 当union为null时， 补丁会导致封闭函数innerGetOnly()返回预定义的默认值(而不是错误地抛出空指针异常)。 这个补丁验证是正确的(为DataflowJavaSDK JUnit测试套件中的所有输入生成正确的输出)， 并且和为该缺陷开发的人工补丁一致。 </p><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><p>我们在Java程序中使用Genesis， 在此实验中， 我们利用spoon库解析Java程序， 目前我们支持任何使用maven项目管理系统和JUnit测试框架的Java应用程序。 </p><p>给定一个程序p， 一个测试集， 至少一个在p中暴露出的缺陷和一个推断搜索空间P， Genesis首先会使用一个缺陷定位算法在p中标识出与缺陷相关的可疑位置的排序列表(如AST片段)。 对于每个可疑的AST片段S， Genesis在P中应用每个转换来生成候选补丁。 它根据测试用例验证每个候选补丁， 如果通过了所有测试用例， 则将其附加到生成的补丁列表中。 Genesis旨在使用任意缺陷定位算法。 我们目前的实现基于可疑的位置， 其由触发Java异常的测试集堆栈跟踪得知。 Genesis将其推断的转换应用于排名缺陷定位列表中的每一个可疑语句。 对于每个变换， Genesis计算成本分数， 该分数是转换需要生成以覆盖验证案例的候选补丁的平均数量。 对于每一个可疑的语句， Genesis都会优先考虑由成本分数较低的转换生成的候选补丁。 </p><h3 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. 实验结果</h3><p>我们使用Genesis来推理补丁的搜索空间， 并为Java程序中的三类缺陷生成补丁:空指针(null pointer, NP)、 超界(out of bounds, OOB)和类强制转换(class cast, CC)。 Genesis使用一个包含483个NP补丁、 199个OOB补丁和287个CC补丁的训练集， 这些补丁来自356个开源应用， 并推断出一个由108个转换生成的搜索空间。 </p><p>我们的基准缺陷包括来自41个开源应用程序的20个NP、 13个OOB和16个CC缺陷。 所有的基准测试应用程序都是从GitHub收集的， 并且多达235K行代码。 通过108个推断的转换， Genesis为49个缺陷(11个NP、 6个OOB和4个CC缺陷)中的21个生成了正确的补丁。 </p><p>PAR是过去的一个使用手工定义补丁模版的Java补丁生成系统。 我们将 Genesis和其进行比较。 对于相同的基准集， PAR模板为10个缺陷(具体地说， 7个NP和4个OOB缺陷)生成正确的补丁。 </p><p>我们将这些结果归因于Genesis自动化推理算法能够在一定规模下导航导航补丁的变换权衡。 Genesis使用成百上千个候选转换来获得由数十到100多个选择转换生成的高效搜索空间——比以前生成和验证系统的转换要多得多。 通过部署这么多转换， Genesis能够捕获范围广泛的补丁模式， 并通过选择的转换来确保最终的补丁搜索空间的可追踪性和覆盖率。 </p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>以前的生成和验证补丁生成系统使用由开发人员定义的固定转换集。 通过从成功的人类补丁中自动推断转换， Genesis使得利用全世界开发人员的专业知识和补丁生成策略来自动修补新应用程序中的漏洞成为可能。 </p><h3 id="6-本文的主要贡献"><a href="#6-本文的主要贡献" class="headerlink" title="6. 本文的主要贡献"></a>6. 本文的主要贡献</h3><ul><li><p><strong>使用模板AST和生成器进行转换</strong>： 我们用模板AST 和发生器， 为自由模板变量提出了新的变量。 这些转换使创世纪能够抽象出补丁和应用程序特定的细节， 以捕获由不同应用程序绘制的多个补丁中存在的常见模式和策略。 生成器使创世纪能够合成所需的新代码和逻辑， 以获得在大规模实际应用中出现的bug 的正确补丁。 </p></li><li><p><strong>补丁泛化</strong>： 我们提出一种新的补丁泛化算法， 给定一组补丁， 自动生成捕获了补丁中常见补丁生成模式的转换。 该转换可以生成所有给定的补丁以及在相同或其他应用程序中具有相同模式的其他补丁。 </p></li><li><p><strong>搜索空间推理</strong>： 我们提出了一种新颖的搜索空间推理算法。 从一组训练补丁开始， 该算法推理出一组转换， 它们一起生成具有良好覆盖和易处理性的候选补丁的搜索空间。 推理算法包括一个新的采样算法， 它可以识别训练补丁中“有前景”的子集来进行泛化， 以及针对最终搜索空间选择问题的基于ILP的解决方案。 </p></li><li><p><strong>完整的系统和实验结果</strong>： 我们提供了一个完整的补丁生成系统， 包括bug 定位和候选补丁评估算法， 它们使用推理搜索空间自动修补大规模现实应用中的缺陷。 我们还介绍了完整系统的实验结果。 </p></li></ul><p>据我们所知， Genesis是第一个自动推理补丁生成转换或根据先前成功的补丁搜索候选补丁空间的系统。 所有实验数据（包括创世纪源代码、 推理模板和生成的补丁）可从<a href="http://groups.csail.mit.edu/pac/patchgen/">http://groups.csail.mit.edu/pac/patchgen/</a> 获得。 </p><h3 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7. 参考文献"></a>7. 参考文献</h3><p>[1]  Fan Long and Martin C. Rinard. 2016. An analysis of the search spaces for generate and validate patch generation systems. In Proceedings of the 38th International Conference on Software Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016. 702–713.</p><p>[2] Dataflow Java SDK. <a href="https://github.com/GoogleCloudPlatform/DataflowJavaSDK">https://github.com/GoogleCloudPlatform/DataflowJavaSDK</a>.</p><p>(2017).</p><p>[3] JUnit. <a href="http://junit.org/">http://junit.org/</a>. (2017).</p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他翻译 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】机器学习竞赛实际上是一场数据竞赛</title>
      <link href="p/27e7.html"/>
      <url>p/27e7.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://sloanreview.mit.edu/content/uploads/2018/11/GEN-Libert-Data-Analytics-Technology-Race-Machine-Learning-2400-300x300.jpg"></p><p>**本文翻译自： <a href="https://sloanreview.mit.edu/article/the-machine-learning-race-is-really-a-data-race/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website">《The Machine Learning Race Is Really a Data Race》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p><h3 id="那些想让AI成为差异化因素的企业需要从可选数据集中抽取——这些数据集可能是他们自己创建的。"><a href="#那些想让AI成为差异化因素的企业需要从可选数据集中抽取——这些数据集可能是他们自己创建的。" class="headerlink" title="那些想让AI成为差异化因素的企业需要从可选数据集中抽取——这些数据集可能是他们自己创建的。"></a>那些想让AI成为差异化因素的企业需要从可选数据集中抽取——这些数据集可能是他们自己创建的。</h3><hr><p>如果你愿意这么说的话， 机器学习或人工智能已经成为一种商品。 那些急于定义和实现机器学习的企业惊讶的发现， 实现用于使机器智能的处理数据集或问题的算法是比较容易的部分。 从谷歌的开源机器学习框架TensorFlow到微软的Azure和亚马逊的SageMaker， 有一大批强大的即插即用解决方案， 可以轻松地完成繁重的编程工作。 </p><p>不过， 数据不但没有被商品化， 反而正在成为机器学习竞赛中的关键差异化因素。 这是因为好的数据并不常见。 </p><a id="more"></a><p><img src="https://sloanreview.mit.edu/content/uploads/2018/11/GEN-Libert-Data-Analytics-Technology-Race-Machine-Learning-2400-300x300.jpg" alt="Rowing crew of business people race through a sea of data in a four person row boat"></p><h3 id="有用的数据：-有价值并且罕见"><a href="#有用的数据：-有价值并且罕见" class="headerlink" title="有用的数据： 有价值并且罕见"></a>有用的数据： 有价值并且罕见</h3><p>数据正在成为一种差异化因素， 因为许多公司并没有他们需要的数据。 尽管几十年来， 企业一直使用公认的会计准则以系统的方式衡量自己， 但这种衡量长期以来一直集中于实物和金融资产——即物品和货币。 2013年， <a href="https://www.nobelprize.org/prizes/economic-sciences/2013/press-release/">诺贝尔奖(Nobel Prize)甚至授予了资本资产定价领域的奖项</a>， 从而加强了这些公认的优先事项。 </p><p>但今天最有价值的公司大多是<a href="https://hbr.org/video/5231040873001/in-the-digital-age-physical-assets-are-a-burden">在软件和网络上进行交易</a>， 而不仅仅是实物和资本资产。 在过去40年中， 资产重点已完全转变， 1975年有形资产占市场的83％， 但是到了2015年无形资产却占据了市场的84％。 和过去不同的是， 如今的企业巨头不再制造咖啡壶、 销售洗衣机， 而是提供app用以连接用户。 这种转变在我们衡量的东西和真正驱动价值的东西之间造成了严重的不匹配。 </p><p>有用的数据十分罕见。 市场和账面价值之间的差距越来越大。 由于这种差距， 公司正在竞相将机器学习应用于重要的业务决策， 甚至<a href="https://hbr.org/2018/01/robo-advisers-are-coming-to-consulting-and-corporate-strategy">取代他们的一些昂贵的顾问</a>， 只是意识到他们所需的数据甚至还不存在。 从本质上说， 人工智能这个新生的系统正在被要求应用到传统的企业中。 </p><p>就像人一样， 机器学习系统在没有学习之前无论怎样都不算聪明。 为了变得智能， 机器需要比人类更多的数据。 不过他们也确实能够更快地读取数据。 因此， 尽管企业在引进机器学习人才和启动人工智能计划方面存在明显的竞争， 但对于新数据和不同数据， 也存在一场幕后竞争。 </p><p>例如， 在金融领域， 替代数据的超出了传统的证券交易委员会报告和影响投资决策的投资者报告。 社交媒体情绪或专利授予数量等另类数据之所以重要， 有两个重要原因。 首先， 传统数据侧重于传统资产， 而在无形资产时代则不够广泛。 其次， 没有必要花时间使用机器学习来研究市场上其他人正在分析的相同数据集。 所有对此感兴趣的人都已经尝试将行业趋势、 利润率、 增长率、 息税前利润、 资产周转率和资产回报率， 以及1000多个其他常见变量与股东回报联系起来。 </p><p>在所有人都拥有的相同资料之间寻找联系， 无助于企业在竞争中取胜。 相反， 那些希望将人工智能作为差异化因素的企业， 将不得不在新数据集之间寻找关联——它们可能不得不创建自己的数据集， 以衡量无形资产。 </p><h3 id="仔细考虑：-你想知道什么？"><a href="#仔细考虑：-你想知道什么？" class="headerlink" title="仔细考虑： 你想知道什么？"></a>仔细考虑： 你想知道什么？</h3><p>数据创建比简单地聚合销售点或客户信息并将其转储到数据库要复杂得多： 大多数组织错误地认为， 权宜之计包括收集所有可能的数据碎片， 并煞费苦心地梳理所有数据， 以期找到一丝见解——难以捉摸的功能， 可以预测或分类他们关心的事物。 </p><p>虽然机器学习偶尔会以一种罕见的、 尚未有人发现的闪光点给我们带来惊喜， 但该技术无法提出一致性的见解。 这并不意味着这个工具没用。 而是意味着我们必须正确的使用它。 在我们对替代数据市场的研究中， 我们发现超过一半的新数据提供商仍然专注于衡量实物和金融资产。 </p><p>许多组织省略的步骤是创建一个关于重要事项的假设。 机器学习真正擅长的地方在于， 它具有人类所拥有的洞察力——一种基于经验法则、 广泛的感知或不太理解的关系——并开发一种更快速、 更易于理解、 更易拓展（不容易出错）的方法来应用那些insight。 </p><p>为了以这种方式使用机器学习， 你不需要向系统提供任何相关领域的所有已知数据点。 你给它提供了一套精心准备的知识， 希望它能够学习， 或许就能扩展人们已经拥有的知识。 </p><h3 id="深刻的机器学习来自不同的数据"><a href="#深刻的机器学习来自不同的数据" class="headerlink" title="深刻的机器学习来自不同的数据"></a>深刻的机器学习来自不同的数据</h3><p>所有的这些对于那些希望创建有影响力和有价值的机器学习应用程序的公司都有以下三个具体的含义： </p><ul><li>**差异化数据是这场AI游戏成功的关键。 **使用竞争对手拥有的数据， 你不会发现任何新东西。 深入了解并确定你的组织所知道的独一无二的内容和观点， 并综合这些创建一个独特的数据集。 机器学习的程序确实需要大量的数据点， 但这并不意味着模型必须考虑数据的广泛性。 你需要将数据工作集中在组织已经差异化的地方。 </li><li>**有意义的数据比全面的数据好。 **你可能拥有关于某个主题非常详细的数据， 但这些数据可能并没有什么用。 如果你的公司并没有把这些信息作为基础用来帮助决策， 那么从机器学习的角度来看， 这些数据可能就没有价值。 一个专业的机器学习架构师会问你一些棘手的问题， 比如哪些领域是真正重要的， 以及这些领域对你获得的见解的应用可能有什么影响。 如果这些问题很难回答， 那就说明你还没有深入的去思考如何产生实用价值。 </li><li>**起点应该是你所知道的那些东西。 ** 那些机器学习用的比较好的公司往往都是从一个独到的见解开始的。 对他们来说， 做重要决定最重要的是什么? 这为他们了解要收集哪些数据， 以及使用哪些技术提供了方向。 一个简单的开始是扩展和增长你的团队已经拥有的知识， 这可以为组织创造更多的价值。 </li></ul><hr><p>很明显， <a href="https://www.wsj.com/articles/SB10001424053111903480904576512250915629460">软件已经吞噬了世界</a>（这是软件企业家Marc Andreessen创造的一句话）。 但这仍然不够， 软件需要新数据与新技术相结合， 这样才可以继续增加价值。 </p><p>如果你不想被这种见解、 机器和替代数据的转变所抛弃。 那就从内部开始寻找， 确定你独特的视角， 以及你能够并且应该生成的有价值的、 可选的数据。 遵循这些步骤， 你将会发现他们之间的关联， 并以此保持组织的竞争力。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他翻译 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Flutter 可能是移动应用程序开发的最佳解决方案</title>
      <link href="p/dbb1.html"/>
      <url>p/dbb1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakrzw219gj30hv09odgr.jpg"></p><blockquote><p>本文翻译自<a href="https://flutterawesome.com/flutter-could-be-the-best-solution-for-mobile-app-development/">Flutter Could Be the Best Solution for Mobile App Development</a>，如有错误，望批评指正</p></blockquote><p>众所周知，Java 和 Objective-C 是开发高质量 Android 和 iOS App 的首选。大多数开发人员通过这些编程语言制作足够健壮的 APP。</p><p>然而，自从 2017 年 5 月 Flutter 横空出世后，几乎所有移动应用开发公司和个人开发者都转向了这种先进的移动应用开发技术。</p><p>Flutter 是谷歌的用户界（UI）工具包，从官网介绍中我们可以得知，它可以通过统一的代码为移动端、web 端 和桌面端设计出漂亮的、具有原生 App 特性的应用程序。</p><p>Flutter 的引入给移动应用开发行业带来了诸多好处，其中之一就是它简化了跨平台应用的开发过程。</p><h2 id="利用-Flutter-开发应用的好处"><a href="#利用-Flutter-开发应用的好处" class="headerlink" title="利用 Flutter 开发应用的好处"></a>利用 Flutter 开发应用的好处</h2><p>许多开发者声称他们发现 Flutter 是最有前途的平台。<br>此外，你现在可以找到许多可靠的公司，他们正在利用 Flutter 为企业提供超现代化、多平台的移动应用程序。</p><p>我们无法预测未来，但 Flutter 已经成为一个强大的、可以帮助开发者为 Android 和 iOS 开发移动应用的平台。</p><p>Flutter 与一个响应式的现代框架相结合，以便允许开发者可以在 Android 和 iOS 平台上构建令人印象深刻的动画、共享代码库和视图。</p><p>上述好处已经证明 Flutter 将会在行业内存活很长时间。但这些并不足以说明 Flutter 的前景和未来是光明的。</p><p>下面这些内容你应该了解下，这些是 Flutter 的其他优秀特性。</p><ol><li><p>Flutter 基于 Dart 开发<br>谷歌开发的 Dart 语言是开发 Flutter 应用的唯一选择。Dart 是一种完全不同的编程语言；它与 Java 惟一相似的地方是语法。<br>Flutter 强大的编程语言也支持异步操作，这使得开发者可以更轻松地进行应用开发。<br>另外，在异步操作的支持下，开发人员可以执行那些需要花费时间才能完成的代码，而不会阻塞其他正在运行的代码。</p></li><li><p>编写一次，到处执行<br>分别开发 Android 和 iOS 应用程序非常耗时，这也需要很多开发人员的努力。当你使用 Flutter 时，允许开发者通过统一的代码库，为 Android 和 iOS 平台开发应用。</p><p>使用 Flutter 还可以让开发出来的应用运行在单独的平台上。</p></li><li><p>增强 UI 开发<br>Flutter 通过将不同的 UI 组件和小部件相结合，使得应用程序在功能上更加强大。 这个相对较新的 app 开发技术和框架，旨在解决所有的用户界面问题。<br>开发人员可以使用不同的 UI widgets，包括 Column、Row 和 Container，使这些应用程序看起来更有吸引力。<br>为了系统地放置 App 所需的内容，有一种名为 Text 和 RaisedButton 的小部件。<br>如果你想要制作一个功能强大并且美观的 App，合理使用 Flutter 的这些 UI 组件将会让你事半功倍。</p></li><li><p>扩展库<br>大量的第三方库可用于支持 Flutter 和 Dart 开发。<br>因此，Flutter 正努力成为最佳的构建健壮跨平台应用程序的开发框架，并通过开箱即用的第三方库促进移动应用开发行业的发展。<br>比如，如果你想在你的应用里放广告，你可以搜索到一个广告库；如果你想要新的小部件，也会搜索到一个合适的库来集成它。</p></li><li><p>快速渲染<br>许多公司认为 Flutter 是解决移动应用开发的最佳方案，它能够创造出持续渲染的超性能 App。原因是 Flutter 既不使用 WebView，也不使用设备自带的 OEM 部件。</p><p>相反，Flutter 使用自己的高性能渲染引擎来绘制小部件。 而且，由于 Flutter 拥有极其精简的 C/C++代码层，它的渲染速度非常快。</p><p>除此之外，如前所述，Flutter 使用 Dart 编程语言，它已经被证明（并推荐）可以创建高性能、安全的应用程序。</p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用 Flutter 开发应用程序的可能性是无穷无尽的，这都要归功于它具有丰富的 UI 小部件、高性能渲染引擎，最重要的是，它可以在 Dart 上运行。</p><p>Flutter 通过统一的开发语言和跨平台开发真的让开发强大的移动应用程序变得十分容易。</p><p>如果你正在考虑为 iOS、Android、Windows、Mac、Linux、谷歌 Fuchsia 和 web 开发一个应用程序，那么 Flutter 是个不错的选择。<br>专家认为，Flutter 将会成为整个应用开发行业中一颗闪亮的星。</p><hr><p>关注微信公众号「01 二进制」，获取更多 IT 资讯和技巧</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gakgye5et2j31970oxq5a.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 其他翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter13——在TensorFlow中利用learn API构建神经网络框架</title>
      <link href="p/d412.html"/>
      <url>p/d412.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#building-a-neural-network-training-framework-with-learn-api">《Building a neural network training framework with learn API》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>为了简单起见， 在之前的大多数示例中， 我们都是手动创建一个会话（session）， 并不关心保存和加载检查点， 但在实践中通常不是这样做的。 在这我推荐你使用 <code>learn API</code> 来进行会话管理和日志记录（session management and logging）。 我们使用TensorFlow提供了一个简单而实用的<a href="https://github.com/vahidk/TensorflowFramework/tree/master">框架</a>来训练神经网络。 在这一节中， 我们将解释这个框架是如何工作的。 </p><p>当利用神经网络训练模型进行实验时， 通常需要分割训练集和测试集。 你需要利用训练集训练你的模型， 并在测试集中计算一些指标来评估模型的好坏。 你还需要将模型参数存储为一个检查点（checkpoint）， 因为你需要可以随时停止并重启训练过程。 TensorFlow的learn API旨在简化这项工作， 使我们能够专注于开发实际模型。 </p><p>使用 <code>tf.learn</code> API的最简单的方式是直接使用 <code>tf.Estimator</code> 对象。 你需要定义一个模型函数， 该模型函数包含一个损失函数（loss function）、 一个训练操作（train op）、 一个或一组预测， 以及一组可选的用于评估的度量操作:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_fn</span>(<span class="params">features, labels, mode, params</span>):</span></span><br><span class="line">    predictions = ...</span><br><span class="line">    loss = ...</span><br><span class="line">    train_op = ...</span><br><span class="line">    metric_ops = ...</span><br><span class="line">    <span class="keyword">return</span> tf.estimator.EstimatorSpec(</span><br><span class="line">        mode=mode,</span><br><span class="line">        predictions=predictions,</span><br><span class="line">        loss=loss,</span><br><span class="line">        train_op=train_op,</span><br><span class="line">        eval_metric_ops=metric_ops)</span><br><span class="line"></span><br><span class="line">params = ...</span><br><span class="line">run_config = tf.contrib.learn.RunConfig(model_dir=FLAGS.output_dir)</span><br><span class="line">estimator = tf.estimator.Estimator(</span><br><span class="line">    model_fn=model_fn, config=run_config, params=params)</span><br></pre></td></tr></table></figure><p>要训练模型， 你只需调用 <code>Estimator.train()</code> 函数， 同时提供一个输入函数来读取数据即可:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_fn</span>():</span></span><br><span class="line">    features = ...</span><br><span class="line">    labels = ...</span><br><span class="line">    <span class="keyword">return</span> features, labels</span><br><span class="line"></span><br><span class="line">estimator.train(input_fn=input_fn, max_steps=...)</span><br></pre></td></tr></table></figure><p>如果想要评估模型， 只需要调用 <code>Estimator.evaluate()</code> :</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">estimator.evaluate(input_fn=input_fn)</span><br></pre></td></tr></table></figure><p>对于一些简单的情况， Estimator对象就已经足够应付了， 但是TensorFlow还提供了一个更高级别的对象， 称为** <code>Experiment</code> ** ， 它提供了一些额外的实用功能。 创建一个experiment对象非常简单:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">experiment = tf.contrib.learn.Experiment(</span><br><span class="line">    estimator=estimator,</span><br><span class="line">    train_input_fn=train_input_fn,</span><br><span class="line">    eval_input_fn=eval_input_fn)</span><br></pre></td></tr></table></figure><p>现在我们可以调用 <code>train_and_evaluate</code> 函数来计算训练时的指标:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">experiment.train_and_evaluate()</span><br></pre></td></tr></table></figure><p>运行 <code>experiment</code> 的另一种更为高级的方法是使用 <code>learn_runner.run()</code> 函数。 下面是我们在框架中提供的主要功能:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">tf.flags.DEFINE_string(<span class="string">&quot;output_dir&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Optional output dir.&quot;</span>)</span><br><span class="line">tf.flags.DEFINE_string(<span class="string">&quot;schedule&quot;</span>, <span class="string">&quot;train_and_evaluate&quot;</span>, <span class="string">&quot;Schedule.&quot;</span>)</span><br><span class="line">tf.flags.DEFINE_string(<span class="string">&quot;hparams&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Hyper parameters.&quot;</span>)</span><br><span class="line"></span><br><span class="line">FLAGS = tf.flags.FLAGS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">experiment_fn</span>(<span class="params">run_config, hparams</span>):</span></span><br><span class="line">  estimator = tf.estimator.Estimator(</span><br><span class="line">    model_fn=make_model_fn(),</span><br><span class="line">    config=run_config,</span><br><span class="line">    params=hparams)</span><br><span class="line">  <span class="keyword">return</span> tf.contrib.learn.Experiment(</span><br><span class="line">    estimator=estimator,</span><br><span class="line">    train_input_fn=make_input_fn(tf.estimator.ModeKeys.TRAIN, hparams),</span><br><span class="line">    eval_input_fn=make_input_fn(tf.estimator.ModeKeys.EVAL, hparams))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">unused_argv</span>):</span></span><br><span class="line">  run_config = tf.contrib.learn.RunConfig(model_dir=FLAGS.output_dir)</span><br><span class="line">  hparams = tf.contrib.training.HParams()</span><br><span class="line">  hparams.parse(FLAGS.hparams)</span><br><span class="line"></span><br><span class="line">  estimator = tf.contrib.learn.learn_runner.run(</span><br><span class="line">    experiment_fn=experiment_fn,</span><br><span class="line">    run_config=run_config,</span><br><span class="line">    schedule=FLAGS.schedule,</span><br><span class="line">    hparams=hparams)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  tf.app.run()</span><br></pre></td></tr></table></figure><p>调度标志（schedule flag）决定 <code>Experiment</code> 对象的哪个成员函数被调用。 因此， 如果你将schedule设置为 <code>“train_and_evaluate”</code> ， <code>experiment.train_and_evaluate()</code> 这个函数将会被调用。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_fn</span>():</span></span><br><span class="line">    features = ...</span><br><span class="line">    labels = ...</span><br><span class="line">    <span class="keyword">return</span> features, labels</span><br></pre></td></tr></table></figure><p>有关如何使用数据集API读取数据的示例， 请参见<a href="https://github.com/vahidk/TensorflowFramework/blob/master/dataset/mnist.py">mnist .py</a>。 要了解在TensorFlow中读取数据的各种方法， 可以参考<a href="https://github.com/vahidk/EffectiveTensorflow#data">这段代码</a>。 </p><p>该框架还提供了一个简单的卷积网络分类器， 详见<a href="https://github.com/vahidk/TensorflowFramework/blob/master/model/alexnet.py">alexnet.py</a>， 其中包括一个示例模型。 </p><p>这就是开始使用TensorFlow learn API所需要的全部内容。 我建议查看<a href="https://github.com/vahidk/TensorFlowFramework">框架源码</a>并查看官方python API， 以了解更多关于learn API的信息。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter12——TensorFlow中的数值稳定性</title>
      <link href="p/ec16.html"/>
      <url>p/ec16.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#stable">《Numerical stability in TensorFlow》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>当使用任何数值计算库（如NumPy或TensorFlow）时， 值得注意的是， 编写出正确的数学计算代码对于计算出正确结果并不是必须的。 你同样需要确保整个计算过程是稳定的。 </p><p>让我们从一个例子入手。 小学的时候我们就知道， 对于任意一个非0的数x， 都有 <code>x*y/y=x</code> 。 但是让我们在实践中看看是否如此： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.float32(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">y = np.float32(<span class="number">1e-50</span>)  <span class="comment"># y would be stored as zero</span></span><br><span class="line">z = x * y / y</span><br><span class="line"></span><br><span class="line">print(z)  <span class="comment"># prints nan</span></span><br></pre></td></tr></table></figure><p>错误的原因是： y是 <code>float32</code> 类型的数字， 所能表示的数值太小。 当y太大时会出现类似的问题： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = np.float32(<span class="number">1e39</span>)  <span class="comment"># y would be stored as inf</span></span><br><span class="line">z = x * y / y</span><br><span class="line"></span><br><span class="line">print(z)  <span class="comment"># prints 0</span></span><br></pre></td></tr></table></figure><p>float32类型可以表示的最小正值是1.4013e-45， 任何低于该值的数都将存储为零。 此外， 任何超过3.40282e + 38的数都将存储为inf。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(np.nextafter(np.float32(<span class="number">0</span>), np.float32(<span class="number">1</span>)))  <span class="comment"># prints 1.4013e-45</span></span><br><span class="line">print(np.finfo(np.float32).max)  <span class="comment"># print 3.40282e+38</span></span><br></pre></td></tr></table></figure><p>为了保证计算的稳定性， 你需要避免使用绝对值非常小或非常大的值。 可能听起来这种问题比较低级， 但这些问题可能会让程序变得难以调试， 尤其是在TensorFlow中进行梯度下降时。 这是因为你不仅需要确保正向传递中的所有值都在数据类型的有效范围内， 而且反向传播时同样如此（在梯度运算期间）。 </p><p>让我们看一个真实的例子。 我们想要在logits向量上计算其softmax的值。 一个too navie的实现方式就像这样： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unstable_softmax</span>(<span class="params">logits</span>):</span></span><br><span class="line">    exp = tf.exp(logits)</span><br><span class="line">    <span class="keyword">return</span> exp / tf.reduce_sum(exp)</span><br><span class="line"></span><br><span class="line">tf.Session().run(unstable_softmax([<span class="number">1000.</span>, <span class="number">0.</span>]))  <span class="comment"># prints [ nan, 0.]</span></span><br></pre></td></tr></table></figure><p>注意一下， 计算相对较小的数的对数， 将会得到一个超出float32范围的大数。 对于我们的naive softmax实现来说， 最大的有效对数是ln(3.40282e+38) = 88.7， 如果超过这个值， 就会导致nan结果。 </p><p>但是我们怎样才能使它更稳定呢? 解决办法相当简单。 很容易看到, exp (x - c) /∑exp (x - c) = exp (x) /∑exp (x)。 因此， 我们可以从逻辑中减去任何常数， 结果还是一样的。 我们选择这个常数作为逻辑的最大值。 这样， 指数函数的定义域将被限制为[-inf, 0]， 因此其范围将为[0.0, 1.0]， 这是可取的:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">logits</span>):</span></span><br><span class="line">    exp = tf.exp(logits - tf.reduce_max(logits))</span><br><span class="line">    <span class="keyword">return</span> exp / tf.reduce_sum(exp)</span><br><span class="line"></span><br><span class="line">tf.Session().run(softmax([<span class="number">1000.</span>, <span class="number">0.</span>]))  <span class="comment"># prints [ 1., 0.]</span></span><br></pre></td></tr></table></figure><p>让我们来看一个复杂点案例。 假设我们有一个分类问题， 并且使用softmax函数从我们的逻辑中产生概率。 然后我们定义一个真实值和预测值之间的交叉熵损失函数。 回想一下， 交叉熵的分类分布可以简单地定义为 <code>xe(p, q) = -∑ p_i log(q_i)</code> ， 所以一个简单的交叉熵代码是这样的： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unstable_softmax_cross_entropy</span>(<span class="params">labels, logits</span>):</span></span><br><span class="line">    logits = tf.log(softmax(logits))</span><br><span class="line">    <span class="keyword">return</span> -tf.reduce_sum(labels * logits)</span><br><span class="line"></span><br><span class="line">labels = tf.constant([<span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">logits = tf.constant([<span class="number">1000.</span>, <span class="number">0.</span>])</span><br><span class="line"></span><br><span class="line">xe = unstable_softmax_cross_entropy(labels, logits)</span><br><span class="line"></span><br><span class="line">print(tf.Session().run(xe))  <span class="comment"># prints inf</span></span><br></pre></td></tr></table></figure><p>请注意， 在这个代码中， 当softmax输出接近0时， 输出将会接近无穷， 这将导致我们的计算不稳定。 我们可以通过扩展softmax函数并做一些简化来重写它:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax_cross_entropy</span>(<span class="params">labels, logits</span>):</span></span><br><span class="line">    scaled_logits = logits - tf.reduce_max(logits)</span><br><span class="line">    normalized_logits = scaled_logits - tf.reduce_logsumexp(scaled_logits)</span><br><span class="line">    <span class="keyword">return</span> -tf.reduce_sum(labels * normalized_logits)</span><br><span class="line"></span><br><span class="line">labels = tf.constant([<span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">logits = tf.constant([<span class="number">1000.</span>, <span class="number">0.</span>])</span><br><span class="line"></span><br><span class="line">xe = softmax_cross_entropy(labels, logits)</span><br><span class="line"></span><br><span class="line">print(tf.Session().run(xe))  <span class="comment"># prints 500.0</span></span><br></pre></td></tr></table></figure><p>我们也可以验证梯度计算也是正确的:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = tf.gradients(xe, logits)</span><br><span class="line">print(tf.Session().run(g))  <span class="comment"># prints [0.5, -0.5]</span></span><br></pre></td></tr></table></figure><p>再次提醒一下， 在做梯度下降的时候务必格外小心， 以确保函数以及每一层的梯度值都在一个有效的范围内。 指数函数和对数函数在使用时也要格外的注意， 因为它们可以将小数字映射为大数字， 反之亦然。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter11——在TensorFlow中调试模型</title>
      <link href="p/ec16.html"/>
      <url>p/ec16.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#debugging-tensorflow-models">《Debugging TensorFlow models》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>与常规python代码相比， TensorFlow的符号特性使的TensorFlow的代码调试变得相对困难。 这里我介绍一些TensorFlow附带的工具， 使调试更容易。 </p><p>使用TensorFlow时最常见的错误可能是传递形状错误的张量。 许多TensorFlow操作可以在不同秩(rank)和形状(shape)的张量上操作。 这在使用API时很方便， 但在出现问题时可能会导致额外的麻烦。 </p><p>例如， 考虑下面这个 <code>tf.matmul</code> 操作， 它可以使两个矩阵相乘： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random_uniform([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = tf.random_uniform([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">c = tf.matmul(a, b)  <span class="comment"># c is a tensor of shape [2, 4]</span></span><br></pre></td></tr></table></figure><p>但是下面这个函数也可以实现矩阵乘法： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random_uniform([<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = tf.random_uniform([<span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">tf.matmul(a, b)  <span class="comment"># c is a tensor of shape [10, 2, 4]</span></span><br></pre></td></tr></table></figure><p>下面是我们之前在<a href="https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&mid=2247483775&idx=1&sn=4c45383acd0639d5756c5ee3a10e934c&chksm=ceb3d5cdf9c45cdb46639bb612a534f10136d2bb2f6cfa6b9dc7679a810ef715f412d22dd9a1&scene=0&subscene=131&clicktime=1551345932&ascene=7&devicetype=android-26&version=2700033a&nettype=cmnet&abtest_cookie=BAABAAoACwASABMABAAjlx4AWpkeAMKZHgDTmR4AAAA=&lang=zh_CN&pass_ticket=LFRQeZhcjp8CTkBbwi5u5192kHLrJlWbmRsLlTV8jeXk/QHp2ZIgzvFKrbrX+Ut3&wx_header=1">广播部分</a>谈到的一个支持广播的添加操作的例子： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.constant([</span><br><span class="line">    [1.],</span><br><span class="line">    [2.]</span><br><span class="line">])</span><br><span class="line">b &#x3D; tf.constant([1., 2.])</span><br><span class="line">c &#x3D; a + b# c is a tensor of shape[2, 2]</span><br></pre></td></tr></table></figure><p><strong>使用 <code>tf.assert *</code> 操作验证您的张量</strong></p><p>减少不必要行为可能性的一种方法是使用 <code>tf.assert * </code> 操作验证中间张量的秩(rank)或形状(shape)。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant([[<span class="number">1.</span>], [<span class="number">2.</span>]])</span><br><span class="line">b = tf.constant([<span class="number">1.</span>, <span class="number">2.</span>])</span><br><span class="line">check_a = tf.assert_rank(a, <span class="number">1</span>)  <span class="comment"># This will raise an InvalidArgumentError exception</span></span><br><span class="line">check_b = tf.assert_rank(b, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([check_a, check_b]):</span><br><span class="line">    c = a + b  <span class="comment"># c is a tensor of shape [2, 2]</span></span><br></pre></td></tr></table></figure><p>请记住， 断言节点和其他操作一样都属于TensorFlow中图（Graph）的一部分， 如果不进行评估， 则会在执行 <code>Session.run()</code> 期间进行剔除。 因此， 请确保为断言操作创建显式依赖项， 以强制TensorFlow执行它们。 </p><p>你还可以在运行时使用断言验证张量的值： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check_pos = tf.assert_positive(a)</span><br></pre></td></tr></table></figure><p>有关断言操作的<a href="https://www.tensorflow.org/api_guides/python/check_ops">详细信息</a>， 请参阅官方文档。 </p><p><strong>使用 <code>tf.Print</code> 打印张量值</strong></p><p>另一个对调试有帮助的内置函数是 <code>tf.Print</code> ， 它可以将给定的张量记录到标准错误堆栈中： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_copy = tf.Print(input, tensors_to_print_list)</span><br></pre></td></tr></table></figure><p>注意一下， <code>tf.Print</code> 函数将其第一个参数的副本作为返回值输出。 一种让 <code>tf.Print</code> 强制运行的方式是将其输出传递给另一个操作去执行。 例如， 如果我们想在添加它们之前就打印张量a和b的值， 我们可以这样做： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = ...</span><br><span class="line">b = ...</span><br><span class="line">a = tf.Print(a, [a, b])</span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure><p>或者， 我们可以手动定义控件依赖项。 </p><p><strong>利用 <code>tf.compute_gradient_error</code> 检查梯度变化的值</strong></p><p>并不是TensorFlow中的所有操作都有梯度变化， 并且很容易在无意中构建出TensorFlow无法计算梯度变化的图。 </p><p>让我们来看个例子： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_differentiable_softmax_entropy</span>(<span class="params">logits</span>):</span></span><br><span class="line">    probs = tf.nn.softmax(logits)</span><br><span class="line">    <span class="keyword">return</span> tf.nn.softmax_cross_entropy_with_logits(labels=probs, logits=logits)</span><br><span class="line"></span><br><span class="line">w = tf.get_variable(<span class="string">&quot;w&quot;</span>, shape=[<span class="number">5</span>])</span><br><span class="line">y = -non_differentiable_softmax_entropy(w)</span><br><span class="line"></span><br><span class="line">opt = tf.train.AdamOptimizer()</span><br><span class="line">train_op = opt.minimize(y)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    sess.run(train_op)</span><br><span class="line"></span><br><span class="line">print(sess.run(tf.nn.softmax(w)))</span><br></pre></td></tr></table></figure><p>我们正在使用 <code>tf.nn.softmax_cross_entropy_with_logits </code> 定义一个分类分布上的熵。 然后我们使用Adam优化器来找到具有最大熵的权重。 如果你通过了信息论的课程， 你就会知道均匀分布包含最大熵。 所以你预计他的结果应该会是 <code>[0.2, 0.2, 0.2, 0.2, 0.2]</code> 。 但是你执行这段代码的话会得到一个你意想不到的结果： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">0.34081486</span>  <span class="number">0.24287023</span>  <span class="number">0.23465775</span>  <span class="number">0.08935683</span>  <span class="number">0.09230034</span>]</span><br></pre></td></tr></table></figure><p>事实证明， <code>tf.nn.softmax_cross_entropy_with_logits</code> 对标签有未定义的梯度变化！ 但是， 如果我们不知道这个现象， 我们又怎么能发现这个问题呢？ </p><p>幸运的是， TensorFlow带有一个数值微分器， 可用于查找符号梯度误差。 让我们看看我们如何使用它： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session():</span><br><span class="line">    diff = tf.test.compute_gradient_error(w, [<span class="number">5</span>], y, [])</span><br><span class="line">    print(diff)</span><br></pre></td></tr></table></figure><p>如果你运行它， 你会发现数值和符号之间的差异非常大（我试了下大约为0.06  -  0.1）。 </p><p>现在让我们更改下我们的函数并再次执行下： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax_entropy</span>(<span class="params">logits, dim=<span class="number">-1</span></span>):</span></span><br><span class="line">    plogp = tf.nn.softmax(logits, dim) * tf.nn.log_softmax(logits, dim)</span><br><span class="line">    <span class="keyword">return</span> -tf.reduce_sum(plogp, dim)</span><br><span class="line"></span><br><span class="line">w = tf.get_variable(<span class="string">&quot;w&quot;</span>, shape=[<span class="number">5</span>])</span><br><span class="line">y = -softmax_entropy(w)</span><br><span class="line"></span><br><span class="line">print(w.get_shape())</span><br><span class="line">print(y.get_shape())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    diff = tf.test.compute_gradient_error(w, [<span class="number">5</span>], y, [])</span><br><span class="line">    print(diff)</span><br></pre></td></tr></table></figure><p>差异应该在0.0001左右， 这个结果看起来好多了。 </p><p>现在， 如果再次使用正确的版本运行优化器， 你可以看到最终权重为： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>]</span><br></pre></td></tr></table></figure><p>这就是我们想要的答案。 </p><p><a href="https://www.tensorflow.org/api_guides/python/summary">TensorFlow summaries</a>和<a href="https://www.tensorflow.org/api_guides/python/tfdbg">tfdbg(TensorFlow Debugger)</a>是另外两个用于调试的工具， 请参阅官方文档以了解更多信息。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter10——在TensorFlow中利用多GPU处理并行数据</title>
      <link href="p/1229.html"/>
      <url>p/1229.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#multi_gpu">《Multi-GPU processing with data parallelism》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>如果你使用类似C++这样的语言在单核CPU上编写你的软件， 为使其能够在多个GPU上并行运行， 你可能需要从头开始重写你的软件。 但是在TensorFlow中并非如此。 由于其符号性质， tensorflow可以隐藏所有这些复杂的过程， 使你无需在多个CPU和GPU上扩展程序。 </p><p>让我们从在CPU上添加两个向量开始： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.device(tf.DeviceSpec(device_type=<span class="string">&quot;CPU&quot;</span>, device_index=<span class="number">0</span>)):</span><br><span class="line">   a = tf.random_uniform([<span class="number">1000</span>, <span class="number">100</span>])</span><br><span class="line">   b = tf.random_uniform([<span class="number">1000</span>, <span class="number">100</span>])</span><br><span class="line">   c = a + b</span><br><span class="line"></span><br><span class="line">tf.Session().run(c)</span><br></pre></td></tr></table></figure><p>同样的事情在GPU上也可以简单地完成： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.device(tf.DeviceSpec(device_type=<span class="string">&quot;GPU&quot;</span>, device_index=<span class="number">0</span>)):</span><br><span class="line">    a = tf.random_uniform([<span class="number">1000</span>, <span class="number">100</span>])</span><br><span class="line">    b = tf.random_uniform([<span class="number">1000</span>, <span class="number">100</span>])</span><br><span class="line">    c = a + b</span><br></pre></td></tr></table></figure><p>但是， 如果我们有两个GPU并希望同时使用它们呢？ 为此， 我们可以把数据分成两份， 并让每个GPU单独处理一个部分： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">split_a = tf.split(a, <span class="number">2</span>)</span><br><span class="line">split_b = tf.split(b, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">split_c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.device(tf.DeviceSpec(device_type=<span class="string">&quot;GPU&quot;</span>, device_index=i)):</span><br><span class="line">        split_c.append(split_a[i] + split_b[i])</span><br><span class="line"></span><br><span class="line">c = tf.concat(split_c, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>让我们以更一般的形式重写它， 以便我们可以用任何其他操作集替换添加： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_parallel</span>(<span class="params">fn, num_gpus, **kwargs</span>):</span></span><br><span class="line">    in_splits = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        in_splits[k] = tf.split(v, num_gpus)</span><br><span class="line"></span><br><span class="line">    out_split = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_gpus):</span><br><span class="line">        <span class="keyword">with</span> tf.device(tf.DeviceSpec(device_type=<span class="string">&quot;GPU&quot;</span>, device_index=i)):</span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(tf.get_variable_scope(), reuse=tf.AUTO_REUSE):</span><br><span class="line">                out_split.append(fn(**&#123;k : v[i] <span class="keyword">for</span> k, v <span class="keyword">in</span> in_splits.items()&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf.concat(out_split, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">c = make_parallel(model, <span class="number">2</span>, a=a, b=b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以使用任何一个将张量作为输入并返回张量的函数来替换模型， 限定条件是输入和输出都必须在一个批次（batch）内。 值得注意的是， 我们还添加了一个变量作用域并将 <code>reuse</code> 属性设置为true。 这个操作确保我们可以使用相同的变量来处理两个部分的数据。 如此操作让我们在下一个例子中变得很方便。 </p><p>让我们看一个稍微更实际的例子。 我们想在多个GPU上训练神经网络。 在训练期间， 我们不仅需要计算前向传播， 还需要计算后向传播（梯度变化）。 但是我们如何并行化梯度计算呢？ 事实证明这很简单。 </p><p>回忆一下第一项我们想要把一个二阶多项式拟合到一组样本中。 我们对代码进行了一些重组， 以便在模型函数中进行大量的操作:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    w = tf.get_variable(<span class="string">&quot;w&quot;</span>, shape=[<span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    f = tf.stack([tf.square(x), x, tf.ones_like(x)], <span class="number">1</span>)</span><br><span class="line">    yhat = tf.squeeze(tf.matmul(f, w), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    loss = tf.square(yhat - y)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">x = tf.placeholder(tf.float32)</span><br><span class="line">y = tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line">loss = model(x, y)</span><br><span class="line"></span><br><span class="line">train_op = tf.train.AdamOptimizer(<span class="number">0.1</span>).minimize(</span><br><span class="line">    tf.reduce_mean(loss))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_data</span>():</span></span><br><span class="line">    x_val = np.random.uniform(<span class="number">-10.0</span>, <span class="number">10.0</span>, size=<span class="number">100</span>)</span><br><span class="line">    y_val = <span class="number">5</span> * np.square(x_val) + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x_val, y_val</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    x_val, y_val = generate_data()</span><br><span class="line">    _, loss_val = sess.run([train_op, loss], &#123;x: x_val, y: y_val&#125;)</span><br><span class="line"></span><br><span class="line">_, loss_val = sess.run([train_op, loss], &#123;x: x_val, y: y_val&#125;)</span><br><span class="line">print(sess.run(tf.contrib.framework.get_variables_by_name(<span class="string">&quot;w&quot;</span>)))</span><br></pre></td></tr></table></figure><p>现在让我们使用我们刚刚编写的 <code>make_parallel</code> 函数来并行化这个操作吧。 我们只需要从上面的代码中更改两行代码： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = make_parallel(model, <span class="number">2</span>, x=x, y=y)</span><br><span class="line"></span><br><span class="line">train_op = tf.train.AdamOptimizer(<span class="number">0.1</span>).minimize(</span><br><span class="line">    tf.reduce_mean(loss),</span><br><span class="line">    colocate_gradients_with_ops=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>要并行化梯度的反向传播， 唯一需要改变的是将 <code>colocate_gradients_with_ops</code> 设置为<strong>true</strong>。 这确保了梯度操作可以在与初始操作相同的设备上运行。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter9——使用Python ops进行原型内核和高级可视化</title>
      <link href="p/82ca.html"/>
      <url>p/82ca.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#python_ops">《Prototyping kernels and advanced visualization with Python ops》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>TensorFlow中的内核操作完全用C ++编写， 以提高效率。 但是用C++编写TensorFlow内核的话可能会非常痛苦。 因此， 在花费数小时实现属于自己的内核之前， 你也许需要先实现一个操作的原型， 尽管这样的效率会很低。 通过 <code>tf.py_func()</code> 你可以将任何一个python源代码转换为TensorFlow的操作。 </p><p>举个例子而言， 这里有一个用python自己实现的ReLU非线性激活函数， 通过 <code>tf.py_func()</code> 转换为TensorFlow操作的例子： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">inputs</span>):</span></span><br><span class="line">    <span class="comment"># Define the op in python</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_relu</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.maximum(x, <span class="number">0.</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define the op&#x27;s gradient in python</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_relu_grad</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.float32(x &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># An adapter that defines a gradient op compatible with TensorFlow</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_relu_grad_op</span>(<span class="params">op, grad</span>):</span></span><br><span class="line">        x = op.inputs[<span class="number">0</span>]</span><br><span class="line">        x_grad = grad * tf.py_func(_relu_grad, [x], tf.float32)</span><br><span class="line">        <span class="keyword">return</span> x_grad</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Register the gradient with a unique id</span></span><br><span class="line">    grad_name = <span class="string">&quot;MyReluGrad_&quot;</span> + str(uuid.uuid4())</span><br><span class="line">    tf.RegisterGradient(grad_name)(_relu_grad_op)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the gradient of the custom op</span></span><br><span class="line">    g = tf.get_default_graph()</span><br><span class="line">    <span class="keyword">with</span> g.gradient_override_map(&#123;<span class="string">&quot;PyFunc&quot;</span>: grad_name&#125;):</span><br><span class="line">        output = tf.py_func(_relu, [inputs], tf.float32)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>通过TensorFlow的<strong>gradient checker</strong>， 你可以确认这些梯度是否计算正确： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.random_normal([<span class="number">10</span>])</span><br><span class="line">y = relu(x * x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session():</span><br><span class="line">    diff = tf.test.compute_gradient_error(x, [<span class="number">10</span>], y, [<span class="number">10</span>])</span><br><span class="line">    print(diff)</span><br></pre></td></tr></table></figure><p> <code>compute_gradient_error()</code> 数值化地计算梯度， 返回与理论上的梯度的差别， 我们所期望的是一个非常小的差别。<br>注意到我们的这种实现是非常低效率的， 这仅仅在实现模型原型的时候起作用， 因为python代码并不能并行化而且不能在GPU上运算（导致速度很慢）。 一旦你确定了你的idea， 你就需要用C++重写其内核。<br>在实践中， 我们一般在Tensorboard中用python操作进行可视化。 如果你是在构建一个图片分类模型， 而且想要在训练过程中可视化你的模型预测， 那么TF允许你通过 <code>tf.summary.image()</code> 函数进行图片的可视化。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = tf.placeholder(tf.float32)</span><br><span class="line">tf.summary.image(<span class="string">&quot;image&quot;</span>, image)</span><br></pre></td></tr></table></figure><p>但是这仅仅是可视化了输入的图片， 为了可视化其预测结果， 你还必须找一个方法在图片上添加预测标识， 当然这在现有的tensorflow操作中是不存在的。 一个更简单的方法就是通过python将预测标志绘制到图片上， 然后再封装它。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PIL</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_labeled_images</span>(<span class="params">images, labels, max_outputs=<span class="number">3</span>, name=<span class="string">&quot;image&quot;</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_visualize_image</span>(<span class="params">image, label</span>):</span></span><br><span class="line">        <span class="comment"># Do the actual drawing in python</span></span><br><span class="line">        fig = plt.figure(figsize=(<span class="number">3</span>, <span class="number">3</span>), dpi=<span class="number">80</span>)</span><br><span class="line">        ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">        ax.imshow(image[::<span class="number">-1</span>,...])</span><br><span class="line">        ax.text(<span class="number">0</span>, <span class="number">0</span>, str(label),</span><br><span class="line">          horizontalalignment=<span class="string">&quot;left&quot;</span>,</span><br><span class="line">          verticalalignment=<span class="string">&quot;top&quot;</span>)</span><br><span class="line">        fig.canvas.draw()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write the plot as a memory file.</span></span><br><span class="line">        buf = io.BytesIO()</span><br><span class="line">        data = fig.savefig(buf, format=<span class="string">&quot;png&quot;</span>)</span><br><span class="line">        buf.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Read the image and convert to numpy array</span></span><br><span class="line">        img = PIL.Image.open(buf)</span><br><span class="line">        <span class="keyword">return</span> np.array(img.getdata()).reshape(img.size[<span class="number">0</span>], img.size[<span class="number">1</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_visualize_images</span>(<span class="params">images, labels</span>):</span></span><br><span class="line">        <span class="comment"># Only display the given number of examples in the batch</span></span><br><span class="line">        outputs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_outputs):</span><br><span class="line">            output = _visualize_image(images[i], labels[i])</span><br><span class="line">            outputs.append(output)</span><br><span class="line">        <span class="keyword">return</span> np.array(outputs, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run the python op.</span></span><br><span class="line">    figs = tf.py_func(_visualize_images, [images, labels], tf.uint8)</span><br><span class="line">    <span class="keyword">return</span> tf.summary.image(name, figs)</span><br></pre></td></tr></table></figure><p>请注意， 因为 <code>summary</code> 通常只评估一次（并不是每步都执行）， 因此可以在实践中可以使用而不必担心效率。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter8——控制流操作： 条件和循环</title>
      <link href="p/af09.html"/>
      <url>p/af09.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#control_flow">《Control flow operations: conditionals and loops》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>当我们在构建一个复杂模型如RNN（循环神经网络）的时候， 你可能需要通过条件和循环来控制操作流程。 在这一节， 我们介绍一些在TensorFlow中常用的控制流。 </p><p>假设我们现在需要通过一个条件判断来决定我们是否<strong>相加</strong>还是<strong>相乘</strong>两个变量。 这个可以通过调用 <code>tf.cond()</code> 简单实现， 它表现出像python中 <code>if...else...</code> 相似的功能。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant(<span class="number">1</span>)</span><br><span class="line">b = tf.constant(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p = tf.constant(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">x = tf.cond(p, <span class="keyword">lambda</span>: a + b, <span class="keyword">lambda</span>: a * b)</span><br><span class="line"></span><br><span class="line">print(tf.Session().run(x))</span><br></pre></td></tr></table></figure><p>因为这个条件判断为True， 所以这个输出应该是加法输出， 也就是输出3。 </p><p>在使用TensorFlow的过程中， 大部分时间你都会使用大型的张量， 并且在一个批次（a batch）中进行操作。 一个与之相关的条件操作符是 <code>tf.where()</code> ， 它需要提供一个条件判断， 就和 <code>tf.cond()</code> 一样， 但是 <code>tf.where()</code> 将会根据这个条件判断， 在一个批次中选择输出， 如： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">b = tf.constant([<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">p = tf.constant([<span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">x = tf.where(p, a + b, a * b)</span><br><span class="line"></span><br><span class="line">print(tf.Session().run(x))</span><br></pre></td></tr></table></figure><p>返回的结果是 <code>[3, 2]</code> 。 </p><p>另一个广泛使用的控制流操作是 <code>tf.while_loop()</code> 。 它允许在TensorFlow中构建动态的循环， 这个可以实现对一个序列的变量进行操作。 让我们看看我们如何通过 <code> tf.while_loops</code> 函数生成一个斐波那契数列吧： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = tf.constant(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cond</span>(<span class="params">i, a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i &lt; n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">body</span>(<span class="params">i, a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>, b, a + b</span><br><span class="line"></span><br><span class="line">i, a, b = tf.while_loop(cond, body, (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(tf.Session().run(b))</span><br></pre></td></tr></table></figure><p>这段代码将会返回5。 <code>tf.while_loop()</code> 需要一个条件函数和一个循环体函数， 除此之外还需初始化循环变量。 这些循环变量在每一次循环体函数调用完之后都会被更新一次， 直到这个条件返回False为止。 </p><p>现在想象我们想要保存这个斐波那契序列， 我们可能更新我们的循环体函数以纪录当前值的历史记录： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = tf.constant(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cond</span>(<span class="params">i, a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i &lt; n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">body</span>(<span class="params">i, a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>, b, a + b, tf.concat([c, [a + b]], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">i, a, b, c = tf.while_loop(cond, body, (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, tf.constant([<span class="number">1</span>, <span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">print(tf.Session().run(c))</span><br></pre></td></tr></table></figure><p>当你尝试运行这个程序的时候， TensorFlow将会“抱怨”说<strong>第四个循环变量的形状正在改变</strong>。 所以你必须指明这件事后有意为之的： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i, a, b, c = tf.while_loop(</span><br><span class="line">    cond, body, (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, tf.constant([<span class="number">1</span>, <span class="number">1</span>])),</span><br><span class="line">    shape_invariants=(tf.TensorShape([]),</span><br><span class="line">                      tf.TensorShape([]),</span><br><span class="line">                      tf.TensorShape([]),</span><br><span class="line">                      tf.TensorShape([<span class="literal">None</span>])))</span><br></pre></td></tr></table></figure><p>这使得代码变得丑陋不堪， 而且效率极低。 请注意， 我们正在构建许多我们不使用的中间张量。 TensorFlow对这种增长式的数组， 其实有一个更好的解决方案： <code>tf.TensorArray</code> 。 让我们用张量数组做同样的事情： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = tf.constant(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">c = tf.TensorArray(tf.int32, n)</span><br><span class="line">c = c.write(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">c = c.write(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cond</span>(<span class="params">i, a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i &lt; n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">body</span>(<span class="params">i, a, b, c</span>):</span></span><br><span class="line">    c = c.write(i, a + b)</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>, b, a + b, c</span><br><span class="line"></span><br><span class="line">i, a, b, c = tf.while_loop(cond, body, (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, c))</span><br><span class="line"></span><br><span class="line">c = c.stack()</span><br><span class="line"></span><br><span class="line">print(tf.Session().run(c))</span><br></pre></td></tr></table></figure><p>TensorFlow 中的 <code>while_loop</code> 和张量数组是构建复杂的循环神经网络（RNN）的基本工具。 作为练习， 你可以尝试使用 <code>tf.while_loops</code> 实现 <a href="https://en.wikipedia.org/wiki/Beam_search">beam search</a> 。 你可以再尝试使用张量数组提高效率吗？ </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter7——理解执行顺序和控制依赖</title>
      <link href="p/5ed4.html"/>
      <url>p/5ed4.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#control_deps">《Understanding order of execution and control dependencies》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>正如我们刚开始提到的， TensorFlow不会立刻运行定义了的操作， 而是在计算图中创造一个相关的节点， 这个节点可以用 <code>Session.run()</code> 进行执行。 这个使得TensorFlow可以在运行时进行优化， 以此确定最佳执行顺序， 并且在运算中剔除一些不需要使用的节点。 如果你只是在计算图中使用 <code>tf.Tensors</code> ， 你就不需要担心依赖问题， 但是你更可能会使用 <code>tf.Variable()</code> ， 这个操作使得问题变得更加困难。 我的建议是如果张量不能满足这个工作需求， 那么仅仅使用 <code>Variables</code> 就足够了。 这个可能不够直观， 我们不妨先观察一个例子： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.constant(<span class="number">1</span>)</span><br><span class="line">b = tf.constant(<span class="number">2</span>)</span><br><span class="line">a = a + b</span><br><span class="line">tf.Session().run(a)</span><br></pre></td></tr></table></figure><p>正如我们期待的那样， “a”的计算结果是3。 注意下， 我们创建了3个张量， 其中包含两个常数张量和一个储存加法结果的张量。 务必注意我们不能重写一个张量的值， 如果我们想要改变张量的值， 我们就必须要创建一个新的张量， 就像我们刚才做的那样。 </p><blockquote><p>**小提示： **如果你没有定义一个新的计算图， TF将会自动地为你构建一个默认的计算图。 你可以使用 <code>tf.get_default_graph()</code> 去获得一个计算图的句柄（handle）， 然后， 你就可以查看这个计算图了。 比如， 打印这个计算图的所有张量： </p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(tf.contrib.graph_editor.get_tensors(tf.get_default_graph()))</span><br></pre></td></tr></table></figure><p>和 tensors 不同的是， 变量Variables可以更新， 所以让我们用变量去实现我们刚才的需求： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.Variable(<span class="number">1</span>)</span><br><span class="line">b = tf.constant(<span class="number">2</span>)</span><br><span class="line">assign = tf.assign(a, a + b)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line">print(sess.run(assign))</span><br></pre></td></tr></table></figure><p>同样， 正如预期一样， 我们又得到了3。 注意到 <code>tf.assign()</code> 返回的代表这个赋值操作的张量。 目前为止， 所有 的操作都没有问题， 但是让我们观察一个稍微有点复杂的例子吧： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.Variable(<span class="number">1</span>)</span><br><span class="line">b = tf.constant(<span class="number">2</span>)</span><br><span class="line">c = a + b</span><br><span class="line"></span><br><span class="line">assign = tf.assign(a, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run([assign, c]))</span><br></pre></td></tr></table></figure><p>注意到， 张量 <code>c</code> 并没有一个确定性的值。 这个值可能是3或者7， 取决于加法和赋值操作谁先运行。 </p><p>您应该注意， 在代码中定义的操作的顺序与TensorFlow运行时无关。 唯一会影响到执行顺序的是<strong>控制依赖</strong>。 控制依赖对于张量来说是直接的。 每一次你在操作中使用一个张量时， 操作将会定义一个对于这个张量来说的隐式的依赖。 但是如果你同时也使用了变量， 事情就变得更糟糕了， 因为变量可以取很多值。 </p><p>当处理这些变量时， 你可能需要显式地去通过使用 <code>tf.control_dependencies()</code> 去控制依赖， 如： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.Variable(<span class="number">1</span>)</span><br><span class="line">b = tf.constant(<span class="number">2</span>)</span><br><span class="line">c = a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([c]):</span><br><span class="line">    assign = tf.assign(a, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run([assign, c]))</span><br></pre></td></tr></table></figure><p>这会确保赋值操作在加法操作之后被调用。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter6——在TensorFlow中， 利用运算符重载</title>
      <link href="p/4efb.html"/>
      <url>p/4efb.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#overloaded_ops">《Take advantage of the overloaded operators》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>和 Numpy 一样， 为了使代码可读性更强， 更容易绘制一个计算图， TensorFlow重载了很多python中的运算符。 </p><p><strong>切片（slice）</strong>操作是众多重载运算符中的一个， 它可以使得索引张量变得很容易： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = x[begin:end]  <span class="comment"># z = tf.slice(x, [begin], [end-begin])</span></span><br></pre></td></tr></table></figure><p>但是在使用的时候还是需要注意。 切片操作的效率非常低， 因此最好避免使用， 特别是在切片的数量很大的时候。 为了更好地理解这个操作符有多么地低效， 我们先观察一个例子。 我们想要人工实现一个对矩阵的行进行reduce操作的代码： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">x = tf.random_uniform([<span class="number">500</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">z = tf.zeros([<span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    z += x[i]</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">start = time.time()</span><br><span class="line">sess.run(z)</span><br><span class="line">print(<span class="string">&quot;Took %f seconds.&quot;</span> % (time.time() - start))</span><br></pre></td></tr></table></figure><p>在我的MacBook Pro上， 这段代码执行了2.67秒！ 如此耗时的原因是我们调用了切片操作500次， 这个操作非常缓慢！ 一个更好的选择是使用 <code>tf.unstack()</code> 操作去将一个矩阵切成一个向量的列表， 而这只需要一次就行！ </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = tf.zeros([<span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> x_i <span class="keyword">in</span> tf.unstack(x):</span><br><span class="line">    z += x_i</span><br></pre></td></tr></table></figure><p>这个操作花费了0.18秒， 当然， 最正确的方式去实现这个需求是使用 <code>tf.reduce_sum()</code> 操作： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = tf.reduce_sum(x, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这个仅仅使用了0.008秒， 是原始实现的300倍！<br>TensorFlow除了切片操作， 也重载了一系列的数学逻辑运算， 如： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = -x  <span class="comment"># z = tf.negative(x)</span></span><br><span class="line">z = x + y  <span class="comment"># z = tf.add(x, y)</span></span><br><span class="line">z = x - y  <span class="comment"># z = tf.subtract(x, y)</span></span><br><span class="line">z = x * y  <span class="comment"># z = tf.mul(x, y)</span></span><br><span class="line">z = x / y  <span class="comment"># z = tf.div(x, y)</span></span><br><span class="line">z = x // y  <span class="comment"># z = tf.floordiv(x, y)</span></span><br><span class="line">z = x % y  <span class="comment"># z = tf.mod(x, y)</span></span><br><span class="line">z = x ** y  <span class="comment"># z = tf.pow(x, y)</span></span><br><span class="line">z = x @ y  <span class="comment"># z = tf.matmul(x, y)</span></span><br><span class="line">z = x &gt; y  <span class="comment"># z = tf.greater(x, y)</span></span><br><span class="line">z = x &gt;= y  <span class="comment"># z = tf.greater_equal(x, y)</span></span><br><span class="line">z = x &lt; y  <span class="comment"># z = tf.less(x, y)</span></span><br><span class="line">z = x &lt;= y  <span class="comment"># z = tf.less_equal(x, y)</span></span><br><span class="line">z = abs(x)  <span class="comment"># z = tf.abs(x)</span></span><br><span class="line">z = x &amp; y  <span class="comment"># z = tf.logical_and(x, y)</span></span><br><span class="line">z = x | y  <span class="comment"># z = tf.logical_or(x, y)</span></span><br><span class="line">z = x ^ y  <span class="comment"># z = tf.logical_xor(x, y)</span></span><br><span class="line">z = ~x  <span class="comment"># z = tf.logical_not(x)</span></span><br></pre></td></tr></table></figure><p>你也可以使用这些操作符的增强版， 如 <code>x += y</code> 和 <code>x **=2</code> 同样是合法的。<br>请注意python不允许重载 <code>and</code> , <code>or</code> 和 <code>not</code> 等关键字。<br>TensorFlow也不允许把张量当成 <code>boolean</code> 类型使用， 因为这个很容易出错： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.constant(<span class="number">1.</span>)</span><br><span class="line"><span class="keyword">if</span> x:  <span class="comment"># This will raise a TypeError error</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果你想检查这个张量的值， 你也可以使用 <code>tf.cond(x,...)</code> ， 或者使用 <code>if x is None</code> 去检查这个变量的值。<br>有些操作是不支持的， 比如说等于判断 <code>==</code> 和不等于判断 <code>!=</code> 运算符， 这些在numpy中得到了重载， 但在TensorFlow中没有重载。 如果需要使用， 请使用这些功能的函数版本 <code>tf.equal()</code> 和 <code>tf.not_equal()</code> 。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter5——在TensorFlow中， 给模型“喂”数据</title>
      <link href="p/4a8e.html"/>
      <url>p/4a8e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><blockquote><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#data">《Feeding data to TensorFlow》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p></blockquote><p>TensorFlow 被设计用于高效地处理大量数据。 所以你需要记住的是， 千万不要“饿着”你的TF模型， 这样才能得到最好的表现。 一般来说， 有三种方法可以给你的模型“喂”数据。 </p><h2 id="常量方式（Constants）"><a href="#常量方式（Constants）" class="headerlink" title="常量方式（Constants）"></a>常量方式（<strong>Constants</strong>）</h2><p>最简单的方式莫过于直接将数据当成常量嵌入你的计算图中， 如： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">actual_data = np.random.normal(size=[<span class="number">100</span>])</span><br><span class="line">data = tf.constant(actual_data)<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>这个方式非常高效， 但并不灵活。 一个很大的问题就是为了在其他数据集上复用你的模型， 你必须要重写你的计算图， 而且你必须同时加载所有数据， 并且一直保存在内存里， 这意味着这个方式仅仅适用于小数剧集的情况。 </p><h2 id="占位符方式（Placeholders）"><a href="#占位符方式（Placeholders）" class="headerlink" title="占位符方式（Placeholders）"></a>占位符方式（<strong>Placeholders</strong>）</h2><p>可以通过<strong>占位符</strong>(placeholder)的方式解决刚才常数喂养网络的问题， 如： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = tf.placeholder(tf.float32)</span><br><span class="line">prediction = tf.square(data) + <span class="number">1</span></span><br><span class="line">actual_data = np.random.normal(size=[<span class="number">100</span>])</span><br><span class="line">tf.Session().run(prediction, feed_dict=&#123;data: actual_data&#125;)<span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>占位符操作符返回一个张量， 他的值在会话中通过人工指定的 <code>feed_dict</code> 参数得到(<strong>fetch</strong>)。 </p><blockquote><p>也就是说占位符其实只是占据了数据喂养的位置而已， 而不是真正的数据， 所以在训练过程中， 如果真正需要使用这个数据， 就必须要指定合法的feed_dict， 否则将会报错。 </p></blockquote><h2 id="通过python操作（Python-ops）"><a href="#通过python操作（Python-ops）" class="headerlink" title="通过python操作（Python ops）"></a>通过python操作（Python ops）</h2><p>还可以通过利用python ops喂养数据： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">py_input_fn</span>():</span></span><br><span class="line">    actual_data = np.random.normal(size=[<span class="number">100</span>])</span><br><span class="line">    <span class="keyword">return</span> actual_data</span><br><span class="line"></span><br><span class="line">data = tf.py_func(py_input_fn, [], (tf.float32))<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>python ops允许你将一个常规的python函数转换成一个TF的操作。 </p><h2 id="数据集API（Dataset-API）"><a href="#数据集API（Dataset-API）" class="headerlink" title="数据集API（Dataset API）"></a>数据集API（<strong>Dataset API</strong>）</h2><p>最值得推荐的方式就是通过TF自带的数据集API进行喂养数据， 如： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">actual_data = np.random.normal(size=[<span class="number">100</span>])</span><br><span class="line">dataset = tf.contrib.data.Dataset.from_tensor_slices(actual_data)</span><br><span class="line">data = dataset.make_one_shot_iterator().get_next()<span class="number">123</span></span><br></pre></td></tr></table></figure><p>如果你需要从文件中读入数据， 以 <code>TFrecord</code> 格式读写， 并使用 <code>TFRecordDataset</code> 读取它可能会更有效， 如下所示： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = tf.contrib.data.Dataset.TFRecordDataset(path_to_data)<span class="number">1</span></span><br></pre></td></tr></table></figure><p>查看<a href="https://www.tensorflow.org/api_guides/python/reading_data#Reading_from_files">官方文档</a>， 了解如何将你的数据集转化为 <code>TFrecord</code> 格式。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = ...</span><br><span class="line">dataset = dataset.cache()</span><br><span class="line"><span class="keyword">if</span> mode == tf.estimator.ModeKeys.TRAIN:</span><br><span class="line">    dataset = dataset.repeat()</span><br><span class="line">    dataset = dataset.shuffle(batch_size * <span class="number">5</span>)</span><br><span class="line">dataset = dataset.map(parse, num_threads=<span class="number">8</span>)</span><br><span class="line">dataset = dataset.batch(batch_size)<span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>在读入数据之后， 我们使用 <code>Dataset.cache()</code> 方法， 将其缓存到内存中， 使其拥有更高的效率。 在训练过程中， 我们不断地重复数据集， 这使得我们可以多次处理整个数据集。 我们也需要打乱（<strong>shuffle</strong>）数据集得到batch， 这个batch将会有不同的样本分布。 下一步， 我们使用 <code>Dataset.map()</code> 方法， 对原始的数据（<strong>raw records</strong>）进行预处理， 将数据转换成一个模型可以识别， 利用的格式。 然后， 我们就可以通过 <code>Dataset.batch()</code> ， 创造样本的batch了。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter4——TensorFlow中的Broadcast机制的优缺点</title>
      <link href="p/87a1.html"/>
      <url>p/87a1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#broadcast">《Broadcasting the good and the ugly》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p><p>TensorFlow 支持广播元素操作。 通常， 当你想做加法或乘法的运算时， 你需要确保操作数的形状(shape)是匹配的， 例如： 你不能将一个形状为[3, 2]的张量和一个形状为[3, 4]的张量相加。 但是， 这里有一个特殊情况， 那就是当你的其中一个操作数是一个具有单独维度(<strong>singular dimension</strong>)的张量的时候， TF会隐式地在它的单独维度方向填满(<strong>tile</strong>)， 以确保和另一个操作数的形状相匹配。 所以， 对一个[3, 2]的张量和一个[3, 1]的张量相加在TF中是合法的。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">a &#x3D; tf.constant([</span><br><span class="line">    [1., 2.],</span><br><span class="line">    [3., 4.]</span><br><span class="line">])</span><br><span class="line">b &#x3D; tf.constant([</span><br><span class="line">    [1.],</span><br><span class="line">    [2.]</span><br><span class="line">])# c &#x3D; a + tf.tile(b, [1, 2])</span><br><span class="line">c &#x3D; a + b</span><br></pre></td></tr></table></figure><a id="more"></a><p>广播机制允许我们在隐式情况下进行填充（<strong>tile</strong>）， 这种操作可以使得我们的代码更加简洁， 并且更有效率地利用内存， 因为我们不需要储存填充操作的结果。 一个可以表现这个优势的应用场景就是在结合具有不同长度的特征向量的时候。 为了拼接具有不同长度的特征向量， 我们一般都先填充输入向量， 拼接这个结果然后进行之后的一系列非线性操作等。 这是各种神经网络架构的常见模式： ： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.random_uniform([5, 3, 5])</span><br><span class="line">b &#x3D; tf.random_uniform([5, 1, 6])</span><br><span class="line"></span><br><span class="line"># concat a and b and apply nonlinearity</span><br><span class="line">tiled_b &#x3D; tf.tile(b, [1, 3, 1])</span><br><span class="line">c &#x3D; tf.concat([a, tiled_b], 2)</span><br><span class="line">d &#x3D; tf.layers.dense(c, 10, activation &#x3D; tf.nn.relu)</span><br></pre></td></tr></table></figure><p>但如果利用了广播机制， 这种操作就可以更有效地完成。 举个例子， 因为我们知道$f(m(x+y))=f(mx+my)$的事实， 所以我们可以分别进行线性操作， 并使用广播进行隐式连接： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pa &#x3D; tf.layers.dense(a, 10, activation &#x3D; None)</span><br><span class="line">pb &#x3D; tf.layers.dense(b, 10, activation &#x3D; None)</span><br><span class="line">d &#x3D; tf.nn.relu(pa + pb)</span><br></pre></td></tr></table></figure><p>事实上， 这段代码是通用的， 只要张量之间能够进行广播， 就可以应用于任意形状的张量:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def merge(a, b, units, activation &#x3D; tf.nn.relu):</span><br><span class="line">    pa &#x3D; tf.layers.dense(a, units, activation &#x3D; None)</span><br><span class="line">pb &#x3D; tf.layers.dense(b, units, activation &#x3D; None)</span><br><span class="line">c &#x3D; pa + pb</span><br><span class="line">if activation is not None:</span><br><span class="line">    c &#x3D; activation(c)</span><br><span class="line">return c</span><br></pre></td></tr></table></figure><p>一个更通用的函数在<a href="https://github.com/vahidk/EffectiveTensorflow#merge">这</a>。 </p><p>目前为止， 我们讨论了广播机制的优点， 但是同样的广播机制也有其缺点， 隐式假设几乎总是使得调试变得更加困难， 考虑下面的例子： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.constant([</span><br><span class="line">    [1.],</span><br><span class="line">    [2.]</span><br><span class="line">])</span><br><span class="line">b &#x3D; tf.constant([1., 2.])</span><br><span class="line">c &#x3D; tf.reduce_sum(a + b)</span><br></pre></td></tr></table></figure><p>你猜这个结果是多少？ 如果你说是6， 那么你就错了， 答案应该是12。 这是因为当两个张量的<strong>秩</strong>不匹配的时候， TensorFlow将会在元素操作之前自动展开<strong>秩</strong>较低的张量的第一维， 所以这个加法的结果将会变为[[2, 3], [3, 4]]， 对所有参数进行约化后得到12。 </p><p>解决这种麻烦的方法就是尽可能地显示使用。 我们在需要reduce某些张量的时候， 显式地指定维度， 然后寻找这个bug就会变得简单： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.constant([</span><br><span class="line">    [1.],</span><br><span class="line">    [2.]</span><br><span class="line">])</span><br><span class="line">b &#x3D; tf.constant([1., 2.])</span><br><span class="line">c &#x3D; tf.reduce_sum(a + b, 0)</span><br></pre></td></tr></table></figure><p>这样， c的值就是[5, 7]， 我们就容易猜到其出错的原因。 一个更通用的法则就是： 在进行reduce操作和使用 <code>tf.squeeze</code> 时我们必须指定维度。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter3——理解变量域Scope以及何时应该使用它们</title>
      <link href="p/e376.html"/>
      <url>p/e376.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><p>**本文翻译自： <a href="https://github.com/vahidk/EffectiveTensorflow#scopes">《Scopes and when to use them》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p><p>在TensorFlow中， 变量(Variables)和张量(tensors)有一个名字（name）属性， 用于在符号图中标识它们。 如果在创建变量或张量时未指定名称， TensorFlow会自动为您指定名称： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant(<span class="number">1</span>)</span><br><span class="line">print(a.name)  <span class="comment"># prints &quot;Const:0&quot;</span></span><br><span class="line"></span><br><span class="line">b = tf.Variable(<span class="number">1</span>)</span><br><span class="line">print(b.name)  <span class="comment"># prints &quot;Variable:0&quot;</span></span><br></pre></td></tr></table></figure><p>您可以通过显式指定来覆盖默认名称： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.constant(1, name &#x3D; &quot;a&quot;)</span><br><span class="line">print(a.name)# prints &quot;a:0&quot;</span><br><span class="line"></span><br><span class="line">b &#x3D; tf.Variable(1, name &#x3D; &quot;b&quot;)</span><br><span class="line">print(b.name)# prints &quot;b:0&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p>TensorFlow引入了两个不同的上下文管理器来改变张量和变量的名称。 第一个是 <code>tf.name_scope</code> ： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&quot;scope&quot;</span>):</span><br><span class="line">  a = tf.constant(<span class="number">1</span>, name=<span class="string">&quot;a&quot;</span>)</span><br><span class="line">  print(a.name)  <span class="comment"># prints &quot;scope/a:0&quot;</span></span><br><span class="line"></span><br><span class="line">  b = tf.Variable(<span class="number">1</span>, name=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">  print(b.name)  <span class="comment"># prints &quot;scope/b:0&quot;</span></span><br><span class="line"></span><br><span class="line">  c = tf.get_variable(name=<span class="string">&quot;c&quot;</span>, shape=[])</span><br><span class="line">  print(c.name)  <span class="comment"># prints &quot;c:0&quot;</span></span><br></pre></td></tr></table></figure><p>请注意， 有两种方法可以在TensorFlow中定义新变量， 一是创建 <code>tf.Variable</code> 对象或是调用 <code>tf.get_variable</code> 方法。 使用新名称调用 <code>tf.get_variable</code> 会导致创建新变量， 但如果存在具有相同名称的变量， 则会引发ValueError异常， 告诉我们不允许重新声明变量。 </p><p> <code>tf.name_scope</code> 影响使用 <code>tf.Variable</code> 创建的张量和变量的名称， 但不影响使用 <code>tf.get_variable</code> 创建的变量。 </p><p>与 <code>tf.name_scope</code> 不同， <code>tf.variable_scope</code> 也修改了使用 <code>tf.get_variable</code> 创建的变量的名称： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;scope&quot;</span>):</span><br><span class="line">  a = tf.constant(<span class="number">1</span>, name=<span class="string">&quot;a&quot;</span>)</span><br><span class="line">  print(a.name)  <span class="comment"># prints &quot;scope/a:0&quot;</span></span><br><span class="line"></span><br><span class="line">  b = tf.Variable(<span class="number">1</span>, name=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">  print(b.name)  <span class="comment"># prints &quot;scope/b:0&quot;</span></span><br><span class="line"></span><br><span class="line">  c = tf.get_variable(name=<span class="string">&quot;c&quot;</span>, shape=[])</span><br><span class="line">  print(c.name)  <span class="comment"># prints &quot;scope/c:0&quot;</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;scope&quot;</span>):</span><br><span class="line">  a1 = tf.get_variable(name=<span class="string">&quot;a&quot;</span>, shape=[])</span><br><span class="line">  a2 = tf.get_variable(name=<span class="string">&quot;a&quot;</span>, shape=[])  <span class="comment"># Disallowed</span></span><br></pre></td></tr></table></figure><p>但是， 如果我们真的想要复用先前声明的变量呢？ 变量范围还提供了执行此操作的功能： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;scope&quot;</span>):</span><br><span class="line">  a1 = tf.get_variable(name=<span class="string">&quot;a&quot;</span>, shape=[])</span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;scope&quot;</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">  a2 = tf.get_variable(name=<span class="string">&quot;a&quot;</span>, shape=[])  <span class="comment"># OK</span></span><br></pre></td></tr></table></figure><p>这在使用内置神经网络层时变得很方便： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;my_scope&#x27;</span>):</span><br><span class="line">  features1 = tf.layers.conv2d(image1, filters=<span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Use the same convolution weights to process the second image:</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;my_scope&#x27;</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">  features2 = tf.layers.conv2d(image2, filters=<span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>或者， 您可以将 <code>reuse</code> 属性设置为 <code>tf.AUTO_REUSE</code> ， 这种操作告诉TensorFlow如果不存在具有相同名称的变量， 就创建新变量， 否则就复用： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;scope&quot;</span>, reuse=tf.AUTO_REUSE):</span><br><span class="line">  features1 = tf.layers.conv2d(image1, filters=<span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&quot;scope&quot;</span>, reuse=tf.AUTO_REUSE):</span><br><span class="line">  features2 = tf.layers.conv2d(image2, filters=<span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果你想共享很多变量， 跟踪定义新变量以及复用这些变量的时候可能很麻烦且容易出错。 <code>tf.AUTO_REUSE</code> 则简化了此任务， 但增加了共享不应共享的变量的风险。 TensorFlow模板是解决这一问题的另一种方法， 它没有这种风险： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv3x32 = tf.make_template(<span class="string">&quot;conv3x32&quot;</span>, <span class="keyword">lambda</span> x: tf.layers.conv2d(x, <span class="number">32</span>, <span class="number">3</span>))</span><br><span class="line">features1 = conv3x32(image1)</span><br><span class="line">features2 = conv3x32(image2)  <span class="comment"># Will reuse the convolution weights.</span></span><br></pre></td></tr></table></figure><p>您可以将任何功能转换为TensorFlow模板。 在第一次调用模板时， 在函数内部定义的变量会被声明， 并且在连续调用中， 它们将被自动复用。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter2——理解静态和动态形状</title>
      <link href="p/9793.html"/>
      <url>p/9793.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><p>**本文翻译自：  <a href="https://github.com/vahidk/EffectiveTensorflow#shapes">《Understanding static and dynamic shapes》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p><p>TensorFlow中的张量具有静态形状属性， 该属性在图形构造期间确定。 静态形状可能未指定。 例如， 我们可以定义一个形状张量[None， 128]： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">128</span>])</span><br></pre></td></tr></table></figure><p>这意味着第一个维度可以是任何大小， 并将在 <code>Session.run()</code> 期间动态确定。 您可以按如下方式查询Tensor的静态形状： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">static_shape = a.shape.as_list()  <span class="comment"># returns [None, 128]</span></span><br></pre></td></tr></table></figure><p>要获得张量的动态形状， 可以调用 <code>tf.shape</code> 方法， 它返回一个给定张量代表的形状： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dynamic_shape = tf.shape(a)</span><br></pre></td></tr></table></figure><a id="more"></a><p>可以使用 <code>Tensor.set_shape()</code> 方法设置张量的静态形状： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.set_shape([<span class="number">32</span>, <span class="number">128</span>])  <span class="comment"># static shape of a is [32, 128]</span></span><br><span class="line">a.set_shape([<span class="literal">None</span>, <span class="number">128</span>])  <span class="comment"># first dimension of a is determined dynamically</span></span><br></pre></td></tr></table></figure><p>您可以使用 <code>tf.reshape</code> 函数动态重塑给定的张量： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a =  tf.reshape(a, [<span class="number">32</span>, <span class="number">128</span>])</span><br></pre></td></tr></table></figure><p>一个在可用时返回静态形状， 不可用时返回动态形状的函数会很方便。 一个比较好的程序实现如下： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shape</span>(<span class="params">tensor</span>):</span></span><br><span class="line">  static_shape = tensor.shape.as_list()</span><br><span class="line">  dynamic_shape = tf.unstack(tf.shape(tensor))</span><br><span class="line">  dims = [s[<span class="number">1</span>] <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> s[<span class="number">0</span>]</span><br><span class="line">          <span class="keyword">for</span> s <span class="keyword">in</span> zip(static_shape, dynamic_shape)]</span><br><span class="line">  <span class="keyword">return</span> dims</span><br></pre></td></tr></table></figure><p>现在假设我们想通过将第二维和第三维折叠成一个来将三维张量转换为二维张量。 我们可以使用 <code>get_shape()</code> 函数来做到这一点:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>, <span class="number">32</span>])</span><br><span class="line">shape = get_shape(b)</span><br><span class="line">b = tf.reshape(b, [shape[<span class="number">0</span>], shape[<span class="number">1</span>] * shape[<span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p>值得注意的是， 无论形状是否静态指定， 这都有效。 </p><p>事实上， 我们可以编写一个通用的 <code>reshape()</code> 函数来折叠任何维度列表： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshape</span>(<span class="params">tensor, dims_list</span>):</span></span><br><span class="line">  shape = get_shape(tensor)</span><br><span class="line">  dims_prod = []</span><br><span class="line">  <span class="keyword">for</span> dims <span class="keyword">in</span> dims_list:</span><br><span class="line">    <span class="keyword">if</span> isinstance(dims, int):</span><br><span class="line">      dims_prod.append(shape[dims])</span><br><span class="line">    <span class="keyword">elif</span> all([isinstance(shape[d], int) <span class="keyword">for</span> d <span class="keyword">in</span> dims]):</span><br><span class="line">      dims_prod.append(np.prod([shape[d] <span class="keyword">for</span> d <span class="keyword">in</span> dims]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      dims_prod.append(tf.prod([shape[d] <span class="keyword">for</span> d <span class="keyword">in</span> dims]))</span><br><span class="line">  tensor = tf.reshape(tensor, dims_prod)</span><br><span class="line">  <span class="keyword">return</span> tensor</span><br></pre></td></tr></table></figure><p>然后折叠第二个维度就会变得非常容易： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>, <span class="number">32</span>])</span><br><span class="line">b = reshape(b, [<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Effective TensorFlow Chapter1——TensorFlow 基础</title>
      <link href="p/2f4d.html"/>
      <url>p/2f4d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzpym7tmc9j30u00gwjrj.jpg"></p><p>**本文翻译自：  <a href="https://github.com/vahidk/EffectiveTensorflow#basics">《TensorFlow Basics》</a>， 如有侵权请联系删除， 仅限于学术交流， 请勿商用。 如有谬误， 请联系指出。 **</p><hr><p>TensorFlow和其他数值计算库（如NumPy）之间最显著的区别在于TensorFlow中的操作是基于符号运算的。 这是一个强大的概念， 它允许TensorFlow执行命令式库（如NumPy）所不能做的所有事情（例如， 自动区分）。 但这也要付出更大的代价。 在我我试图揭秘TensorFlow， 并提供一些指导方针和最佳实践， 以便更有效地使用TensorFlow。<br>让我们从一个简单的例子开始， 我们要乘以两个随机矩阵。 首先， 我们看一个在NumPy完成的实施： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.random.normal(size=[<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">y = np.random.normal(size=[<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">z = np.dot(x, y)</span><br><span class="line"></span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure><p>现在我们在TensorFlow中执行完全相同的计算： </p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x = tf.random_normal([<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">y = tf.random_normal([<span class="number">10</span>, <span class="number">10</span>])</span><br><span class="line">z = tf.matmul(x, y)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">z_val = sess.run(z)</span><br><span class="line"></span><br><span class="line">print(z_val)</span><br></pre></td></tr></table></figure><p>与立即执行计算并生成结果的NumPy不同， tensorflow只向图中表示结果的节点提供一个handle（类型为Tensor）。 如果我们尝试直接打印Z值， 我们会得到这样的结果： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tensor(&quot;MatMul:0&quot;, shape &#x3D; (10, 10), dtype &#x3D; float32)</span><br></pre></td></tr></table></figure><p>由于两个输入都具有完全定义的形状， 所以tensorflow能够推断 <code>张量</code> 的形状及其类型。 为了计算张量的值， 我们需要创建一个 <code>会话</code> 并使用 <code>Session.run()</code> 方法评估它。 </p><hr><p>提示： 当使用Jupyter笔记本时， 请确保在定义新节点之前在开始调用 <code>tf.reset_default_graph()</code> 来清除符号图。 </p><hr><p>为了理解符号计算有多么强大， 让我们看看另一个例子。 假设我们有来自曲线（例如 <code>f(x)=5x^2+3</code> ）的样本， 并且我们希望基于这些样本预测 <code>f(x)</code> 。 我们定义一个参数函数 <code>g(x, w) = w0 x^2 + w1 x + w2</code> ， 它是输入x和潜在参数w的函数， 我们的目标是找到潜在的参数， 使得 <code>g(x，w)≈f(x)</code> 。 这可以通过最小化损失函数来完成： <code>L(w) = ∑ (f(x) - g(x, w))^2.</code> 。 虽然这个简单问题有一个闭合解(a closed form solution)， 但我们选择使用更通用的方法， 可以应用于任意的可微函数， 并且使用随机梯度下降。 我们简单地计算L(w)相对于一组采样点上的w的平均梯度， 并沿相反方向移动。 </p><p>以下是利用TensorFlow完成的代码： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Placeholders are used to feed values from python to TensorFlow ops. We define</span></span><br><span class="line"><span class="comment"># two placeholders, one for input feature x, and one for output y.</span></span><br><span class="line">x = tf.placeholder(tf.float32)</span><br><span class="line">y = tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assuming we know that the desired function is a polynomial of 2nd degree, we</span></span><br><span class="line"><span class="comment"># allocate a vector of size 3 to hold the coefficients. The variable will be</span></span><br><span class="line"><span class="comment"># automatically initialized with random noise.</span></span><br><span class="line">w = tf.get_variable(<span class="string">&quot;w&quot;</span>, shape=[<span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># We define yhat to be our estimate of y.</span></span><br><span class="line">f = tf.stack([tf.square(x), x, tf.ones_like(x)], <span class="number">1</span>)</span><br><span class="line">yhat = tf.squeeze(tf.matmul(f, w), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The loss is defined to be the l2 distance between our estimate of y and its</span></span><br><span class="line"><span class="comment"># true value. We also added a shrinkage term, to ensure the resulting weights</span></span><br><span class="line"><span class="comment"># would be small.</span></span><br><span class="line">loss = tf.nn.l2_loss(yhat - y) + <span class="number">0.1</span> * tf.nn.l2_loss(w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We use the Adam optimizer with learning rate set to 0.1 to minimize the loss.</span></span><br><span class="line">train_op = tf.train.AdamOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_data</span>():</span></span><br><span class="line">    x_val = np.random.uniform(<span class="number">-10.0</span>, <span class="number">10.0</span>, size=<span class="number">100</span>)</span><br><span class="line">    y_val = <span class="number">5</span> * np.square(x_val) + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x_val, y_val</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment"># Since we are using variables we first need to initialize them.</span></span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    x_val, y_val = generate_data()</span><br><span class="line">    _, loss_val = sess.run([train_op, loss], &#123;x: x_val, y: y_val&#125;)</span><br><span class="line">    print(loss_val)</span><br><span class="line">print(sess.run([w]))</span><br></pre></td></tr></table></figure><p>通过运行这段代码， 你应该看到接近这个的结果： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4.9924135, 0.00040895029, 3.4504161]</span><br></pre></td></tr></table></figure><p>这是我们参数的一个相对接近的近似值。 </p><p>对于TensorFlow来说， 这只是冰山一角。 许多问题， 例如优化具有数百万参数的大型神经网络， 只需几行代码就可以在TensorFlow中高效实现。 TensorFlow考虑到了多个设备和线程的扩展， 并支持各种平台。 </p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 其他翻译 </tag>
            
            <tag> Effective TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】一种有关艺术风格迁移的神经网络算法</title>
      <link href="p/7b87.html"/>
      <url>p/7b87.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g21aijzieij318g0mu79n.jpg"></p><p>**在艺术领域， 尤其是绘画创作上， 人们已经掌握了一种可以创造独一无二视觉体验的能力， 那就是通过将一张图片的内容和风格之间构成某种复杂的关系。 到目前为止， 该过程的算法基础是未知的， 并且不存在具有类似能力的人工系统。 然而， 受到一种名为深度神经网络的视觉模型的启发， 在视觉感知的其他关键领域， 例如物体和人脸识别， 仿生学的效果已经可以接近人类的表现。 这里我们将会介绍一个基于深度神经网络的人工系统， 它可以生成具有高感知品质的艺术图片。 该系统使用神经表示来分离和重组任意图像的内容和风格， 提供了一种创建艺术图像的神经算法。 而且, 按照要去表现最优的人工神经网络和生物视觉中找到相同. 我们的工作提供了人类是怎样创作和认知艺术图像的算法理解。 此外， 鉴于性能优化的人工神经网络与生物视觉之间惊人的相似性， 我们的工作为算法理解人类如何创造和感知艺术形象提供了一条前进的道路。 **</p><p>处理图像任务最有效的深度神经网络是卷积神经网络。 卷积神经网络由小型计算单元层组成， 以前馈方式分层处理视觉信息（图 1）。 每层单元可以理解为图像过滤器的集合（a collection of image filters）， 每个图像过滤器从输入图像中提取特定特征。 因此， 一个给定层的输出包括所谓的特征映射（feature maps）： 它们是对输入的图像进行不同类型的过滤得到的。</p><p>当卷积神经网络被训练用于物体识别时， 会生成一个图像的表征(representations) ， 随着处理层级的上升， 物体的信息越来越明确。 因此， 随着神经网络中的层级一级一级地被处理， 输入的图像会被转换成一种表征， 与图片的像素细节相比， 这种表征会越来越关注图片的实际内容。 通过对某一层的提取出来的 feaure map 的重塑， 我们可以直接看到该层包含的图片信息。 层级越高， 那么获取的图像中物体内容就越高质量， 并且没有确切的像素值的约束（层级越高， 像素丢失越多）。 相反， 在低层级中重塑的话， 其实像素丢失地很少。 所以我们参考的是神经网络高层的特征， 用它来作为图片内容的表征。</p><p>为了获取输入图像的风格表征， 我们用一个特征空间去捕获纹理的信息。 这个特征空间建立在每层神经网络的过滤响应之上（也就是上面提到的 feature map)。 在 feature map 的空间范围上(也就是同一层上的 feature map)， 过滤响应各有不同（feature map 关注的特征不同）， 而这个特征空间就是由这些差异构成。 通过对每一层 featute map 两两求相关性， 我们会获得一个静态的， 多尺度的图像表征， 这也就捕获到了图像的纹理信息， 但这纹理信息并非全局的。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g21b3t2kjqj30vi0m8k98.jpg"></p><blockquote><p>图 1 ： <strong>卷积神经网络 (CNN)**。 一张给定的输入图像， 会在卷积神经网络的各层以一系列过滤后的图像表示。 随着层级的一层一层处理， 过滤后的图片会通过向下取样的方式不断减小（比如通过池化层）。 这使得每层神经网络的神经元数量会逐步减少。 **内容重构。 **在只知道该层输出结果的情况下， 通过重塑输入图像， 我们可以看到 CNN 不同阶段的图像信息。 我们在原始的 VGG-Network 上的 5 个层级： <code>conv1_1,conv1_2,conv1_3,conv1_4,conv1_5</code> 上重塑了输入的图像。 （输入的图像是上图中的一排房子， 5 个层级分别是 a, b, c, d, e ）我们发现在较低层的图像重构（如 abc）非常完美； 在较高层（de）， 详细的像素信息丢失了。 也就是说， 在这个过程中， 我们提取出了图片的内容， 抛弃了像素。 **风格重构。 **在原始的 CNN 表征之上， 我们建立了一个新的特征空间(feature space)， 用于捕获输入图像的风格。 风格的表征计算了在 CNN 的不同层级间不用特征之间的相似性。 通过在 CNN 隐层的不同的</strong>子集**上建立起来的风格的表征， 我们重构输入图像的风格。 如此， 便创造了与输入图像一致的风格而丢弃了全局的内容。</p></blockquote><blockquote><p>Tips： 上述的子集为：</p></blockquote><blockquote></blockquote><blockquote><p><code>‘conv1 1’ (a)</code></p></blockquote><blockquote></blockquote><blockquote><p><code>‘conv1 1’ and ‘conv2 1’ (b)</code></p></blockquote><blockquote></blockquote><blockquote><p><code>‘conv1 1’, ‘conv2 1’ and ‘conv3 1’ (c)</code></p></blockquote><blockquote></blockquote><blockquote><p><code>‘conv1 1’, ‘conv2 1’, ‘conv3 1’ and ‘conv4 1’ (d)</code></p></blockquote><blockquote></blockquote><blockquote><p><code>‘conv1 1’, ‘conv2 1’, ‘conv3 1’, ‘conv4 1’and ‘conv5 1’ (e)</code></p></blockquote><p>于是， 我们也可以在 CNN 的各层中利用风格特征空间所捕获的信息来重构图像。 事实上， 重塑风格特征就是通过捕获图片的颜色、 结构等等生产出输入的图像的纹理的版本。 另外， 随着层级的增加， 图像结构的大小和复杂度也会增加。 我们将这多尺度的表征称为<strong>风格表征</strong>。</p><p>本文关键的发现是对于内容和风格的表征在 CNN 中是可以分开的。 也就是说， 我们可以独立地操作两个表征来产生新的、 可感知的有意义的图像。 为了展示这个发现， 我们生成了一些混合了不同源图片的内容和风格表征的图片。 确切的说， 我们将著名艺术画“星空”的风格， 和一张德国拍的照片的内容混合起来了。</p><p>我们寻找这样一张图片， 它同时符合照片的内容表征， 和艺术画的风格表征。 原始照片的整体布局被保留了， 而颜色和局部的结构却由艺术画提供。 如此一来， 原来的那张风景照旧像极了艺术作品。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g21b4vcbtpj30u00xzu0y.jpg"></p><blockquote><p>图 2:图中描述的是将照片内容与几种知名艺术品的风格相结合的图像。 通过找到同时匹配照片的内容表征和艺术品的风格表征的图像来创建新的图像。 （译者注： 下面都是图片的来源， 这里就直接省略了）</p></blockquote><p>正如概述所言, 风格表征是一个多层次的表征， 包含多层神经网络。 在图 2 中展示的图片中， 这个风格表征包括了整个神经网络结构的各个层次。 风格也可以被定义为更为局部化， 因为它只包含了少量的低层结构。 这些结构能产生不同的视觉效果(图 3, along the rows)。 若符合了较高层级中的风格表征， 局部的图像结构会大规模地增加， 从而使得图像在视觉上更平滑与连贯。 因此， 看起来美美的图片通常是来自于符合了较高层级的风格表征。</p><p>当然， 图片内容和风格不能被完全分离。 当风格与内容来自不同的两个图像时， 这个被合成的新图像并不存在在同一时刻完美地符合了两个约束。 但是， 在图像合成中最小化的损失函数分别包括了内容与风格两者， 它们被很好地分开了。 所以， 我们可以平滑地将重点既放在内容上又放在风格上（可以从图 3 的一列中看出）。 将重点过多地放在风格上会导致图像符合艺术画的外观， 有效地给出了画的纹理， 但是几乎看不到照片的内容了（图 3 第一列）。 而将重点过多地放在内容上， 我们可以清晰地看到照片， 但是风格就不那么符合艺术画了。 因此， 我们要不断协调图片的内容与风格， 这样才能产生视觉上有感染力的图片。</p><p>在这里， 我们提出了一种人工神经系统， 它实现了图像内容与风格的分离， 从而允许以任何其他图像的风格重铸一个图像的内容。 我们通过创造新的艺术图像来展示这一点， 这些图像将几种着名绘画的风格与任意选择的照片的内容相结合。 特别地， 我们从在物体识别上训练的高性能深度神经网络的特征响应来获取图像的内容和样式的神经表征。</p><p>在之前的研究中， 是通过评估复杂度小很多的感官输入来将内容与风格分离的。 比如说通过不同的手写字， 人脸图， 或者指纹。<br>而在我们的展示中， 我们给出了一个有着著名艺术作品风格的照片。 这个问题常常会更靠近与计算机视觉的一个分支–真实感渲染。 理论上更接近于利用纹理转换来获取艺术风格的转换。 但是， 这些以前的方法主要依赖于非参数的技术并且直接对图像表征的像素进行操作。 相反， 通过在物体识别上训练深度神经网络， 我们在特征空间上进行相关操作， 从而明确地表征了图像的高质量内容。</p><p>神经网络在物体识别中产生的特征先前就已经被用来做风格识别， 为的是根据艺术作品的创作时期来为作品分类。 分类器是在原始的网络上被训练的， 也就是我们现在叫的内容表征。 我们猜测静态特征空间的转换， 比如我们的风格表征也许可以在风格分类上有更好的表现。</p><p>通常来说， 我们这种合成图像的方法提供了一个全新的迷人的工具用于学习艺术， 风格和独立于内容的图像外观的感知与神经表征。 总之， 一个神经网络可以学习图像的表征， 是的图像内容与风格的分离成为可能， 是如此激动人心。 若要给出解释的话， 就是当学习物体识别到时候， 神经网络对所有图像的变化都能保持不变从而保留了物体的特性。</p><h1 id="方法（Methods）"><a href="#方法（Methods）" class="headerlink" title="方法（Methods）"></a>方法（Methods）</h1><p>本文展示的结果是基于 VGG 网络训练的。 他是一种卷积神经网络， 在常见的视觉对象识别基准任务上， 其表现可以和人类的表现相媲美， 因此广受好评并被多方介绍和使用。 我们使用由 19 层的 VGG 神经网络（16 个卷积和 5 个池化层）提供的特征空间， 并且没有使用到全连接层。 这个模型是开源的， 并且可以在 caffe 这个深度学习框架中使用。 对于图像合成， 我们发现用均值池化层代替最大值池化层会提高梯度流， 并且得到更加完美的结果。 所以本案例中我们用的是<strong>均值池化</strong>。</p><p>事实上网络的每一层都定义了一个非线性的过滤器组， 它的复杂性随着在网络中所在层的位置而增加。 因此一个给定的输入图片 $\vec{x}$ ， 在 CNN 的每层都会被过滤器编码。 一个有$N_l$个不同的过滤器的隐藏层有$N_l$个 feature map（每个神经元输出一个 feature map)。 每个 feature map 的大小是$M_l$， $M_l$是 feature map 高乘以宽的大小。 所以一个层 $l$ 的输出可以存储为矩阵： $F^{l} \in \mathcal{R}^{N_{l} \times M_{l}}$， 其中 $F_{i j}^{l}$ 表示在 $l$ 层的位置 $j$ 上的第 $i$ 个过滤器的激活结果。 为了可视化不同层级中的图像信息， 我们在一个白噪声上使用梯度下降来找到另一个图像， 它与原始图像的特征输出结果相符合(白噪声上的图像其实就是定义一个随机的新图， 然后通过梯度下降不断迭代， 不断更新这个新图）。 所以让 $\vec{p} \text { and } \vec{x}$ 作为原始图像和后来产生的图像， $P^{l} \text { and } F^{l}$ 是他们在层 $l$ 各自的特征表征。 然后我们定义两个特征表征之间的平方误差损失。</p><p>$$<br>\mathcal{L}<em>{\text {content}}(\vec{p}, \vec{x}, l)=\frac{1}{2} \sum</em>{i, j}\left(F_{i j}^{l}-P_{i j}^{l}\right)^{2}<br>$$</p><p>这个损失函数的导数是： （针对 F 求导）</p><p>$$<br>\frac{\partial \mathcal{L}<em>{\text {content}}}{\partial F</em>{i j}^{l}}=\left{\begin{array}{ll}{\left(F^{l}-P^{l}\right)<em>{i j}} &amp; {\text { if } F</em>{i j}^{l}&gt;0} \ {0} &amp; {\text { if } F_{i j}^{l}&lt;0}\end{array}\right.<br>$$</p><p>以上公式中， 图像 $\vec{x}$ 的梯度可以通过标准误差的后向计算传播。 因此我们可以改变初始的随机图像 $\vec{x}$ ， 直到它产生了在 CNN 中与原始图像 $\vec{p}$ 一样的输出结果。 在图 1 中的 5 个内容重构来自于原始 VGG 的 <code>‘conv1 1’ (a), ‘conv2 1’ (b), ‘conv3 1’ (c), ‘conv4 1’ (d) and ‘conv5 1’(e)</code></p><p>另外， 我们通过计算不同过滤器输出结果之间的差异， 来计算相似度。 我们期望获得输入图片空间上的衍生。 这些特征的相似性用 $G^{l} \in \mathcal{R}^{N_{l} \times N_{l}}$ 表示。 其中 $G_{i j}^{l}$ 来源于层 $l$ 中矢量的 feature map $i$ 和 $j$ 。</p><p>$$<br>G_{i j}^{l}=\sum_{k} F_{i k}^{l} F_{j k}^{l}<br>$$</p><blockquote><p>Tips： 解释一下上面讲的， 就是将艺术画也放进 CNN 中， 比如输出也是 14x14x256 的一个矩阵， 然后将 256 个 14x14 的 feature map 两两求相似性， 这里是两两相乘， 于是会得带 256x256 的一个特征空间矩阵， G 就是这个特征空间</p></blockquote><p>为了生成符合给定艺术作品风格的纹理， 我们对一个带有白噪声的图像（也就是我们定义的随机的新图）做梯度下降， 从而去寻找另一个图像， 使得这个图像符合艺术画的风格表征。 而这个梯度下降的过程是通过使得原始图像（艺术画）的 Gram 矩阵和被生成的图像（新图）的 Gram 矩阵的距离的均方误差最小化得到的。 因此， 令 $\vec{a} \text { and } \vec{x}$ 分别作为原始艺术图像与被生成的图像， $A^{l} \text { and } G^{l} $ 分别作为层 $l$ 的两个风格表征。 层 $l$ 对于总损失的贡献是：</p><p>$$<br>E_{l}=\frac{1}{4 N_{l}^{2} M_{l}^{2}} \sum_{i, j}\left(G_{i j}^{l}-A_{i j}^{l}\right)^{2}<br>$$</p><p>而总损失用公式表达为：</p><p>$$<br>\mathcal{L}<em>{s t y l e}(\vec{a}, \vec{x})=\sum</em>{l=0}^{L} w_{l} E_{l}<br>$$</p><p>其中 $w_l$ 表示每一层对于总损失的贡献的权重因子。 $E_t$的导数可以这样计算：</p><p>$$<br>\frac{\partial E_{l}}{\partial F_{i j}^{l}}=\left{\begin{array}{ll}{\frac{1}{N_{l}^{2} M_{l}^{2}}\left(\left(F^{l}\right)^{\mathrm{T}}\left(G^{l}-A^{l}\right)\right)<em>{j i}} &amp; {\text { if } F</em>{i j}^{l}&gt;0} \ {0} &amp; {\text { if } F_{i j}^{l}&lt;0}\end{array}\right.<br>$$</p><p>$E_l$ 在低层级的梯度可以很方便地通过标准误差后向传播计算出来。 在图 1 中 5 个风格的重塑可以通过满足一下这些层的风格表征来生成： <code>‘conv1 1’ (a), ‘conv2 1’ (b), ‘conv3 1’ (c), ‘conv4 1’ (d) and ‘conv5 1’(e)</code> 。</p><p>为了生成混合了照片内容和艺术画风格的新图像， 我们需要最小化风格损失与内容损失。 所以令$\vec{p}$ 表示内容图片， $\vec{a}$表示风格图片， 那么我们需要最小化的损失函数是：</p><p>$$<br>\mathcal{L}<em>{\text {total}}(\vec{p}, \vec{a}, \vec{x})=\alpha \mathcal{L}</em>{\text {content}}(\vec{p}, \vec{x})+\beta \mathcal{L}_{\text {style}}(\vec{a}, \vec{x})<br>$$</p><p>α 和 β 分别是内容和风格在图像重构中的权重因子。 对于在图像 2 中展示的图片， 我们在’conv4_2‘层匹配到了内容表征， 在‘conv1 1’, ‘conv2 1’, ‘conv3 1’, ‘conv4 1’ 和 ‘conv5 1’层匹配到了样式表征（在这些层， $w_l=1/5$， 在其他层$w_l=0$）。 在图 2 的 BCD 中， α/β 的比值为$1 \times 10^{-3}$， 在图二的 E， F 中， 这个比值为$1 \times 10^{-4}$， 图 3 展示了一个结果： 即沿着列不断调整内容和风格的损失， 相对应的风格表征在下面几个层所发生的变化。 这几个层分别是： <code>‘conv1 1’ (A), ‘conv1 1’ and ‘conv2 1’ (B), ‘conv1 1’, ‘conv2 1’ and ‘conv3 1’ (C),‘conv1 1’, ‘conv2 1’, ‘conv3 1’ and ‘conv4 1’ (D), ‘conv1 1’, ‘conv2 1’, ‘conv3 1’, ‘conv4 1’ 和 ‘conv5 1’ (E)</code> 。 因子 $w_l$ 总是等于 1 除以具有非零损失权值 $w_l$ 的活动层数。</p><blockquote><p>（参考）Tips： α+β=1。 如果 α 比较大， 那么输出后的新图会更多地倾向于内容上的吻合， 如果 β 较大， 那么输出的新图会更倾向于与风格的吻合。 这两个参数是一个 trade-off, 可以根据自己需求去调整最好的平衡。 论文的作者给出了它调整参数的不同结果， 如图 3， 从左到右四列分别是 α/β = 10^-5, 10^-4, 10^-3, 10^-2. 也就是 α 越来越大， 的确图像也越来越清晰地呈现出了照片的内容。</p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g21b7j4g9xj30vq0u0npe.jpg"></p><blockquote><p>图 3： Wassily Kandinsky 的作品 <em>Composition VII</em> 的风格的详细结果。 这些行显示了匹配 CNN 图层增加子集的样式表示的结果（详见 Methods）。 我们发现， 当包含来自网络较高层的样式特征时， 由风格表征捕获的局部图像结构在尺寸和复杂性上增加。 这可以解释为是由于沿成网络处理的结构感受域的大小和特征复杂性增加。 每一列展示了内容和样式重建之间取不同权重的结果。 每列上方的数字表示强调匹配照片内容和艺术品风格之间的比率 α/β（详见 Methods）。</p></blockquote><p><strong>鸣谢</strong> 这项工作由德国国家学术基金会(L. A. G.)， 伯恩斯坦计算神经科学中心（FKZ 01GQ1002）和德国国际神经科学研究中心（EXC307）（M. B., A. S. E, L. A. G）资助。</p><h1 id="References-and-Notes"><a href="#References-and-Notes" class="headerlink" title="References and Notes"></a>References and Notes</h1><ol><li><p>Krizhevsky, A., Sutskever, I. &amp; Hinton, G. E. Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems, 1097–1105(2012). URL <a href="https://link.jianshu.com/?t=http://papers.nips.cc/paper/4824-imagenet">http://papers.nips.cc/paper/4824-imagenet</a>.</p></li><li><p>Taigman, Y., Yang, M., Ranzato, M. &amp; Wolf, L. Deepface: Closing the gap to human-level performance in face verification. In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, 1701–1708 (IEEE, 2014). URL <a href="https://link.jianshu.com/?t=http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6909616">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6909616</a>.</p></li><li><p>G ̈uc ̧l ̈u, U. &amp; Gerven, M. A. J. v. Deep Neural Networks Reveal a Gradient in the Complexity of Neural Representations across the Ventral Stream. The Journal of Neuroscience 35, 10005–10014 (2015). URL <a href="https://link.jianshu.com/?t=http://www.jneurosci.org/content/35/27/10005">http://www.jneurosci.org/content/35/27/10005</a>.</p></li><li><p>Yamins, D. L. K. et al. Performance-optimized hierarchical models predict neural responses in higher visual cortex. Proceedings of the National Academy of Sciences 201403112 (2014). URL</p><p><a href="https://link.jianshu.com/?t=http://www.pnas.org/content/early/2014/05/08/1403112111">http: //www.pnas.org/content/early/2014/05/08/1403112111</a>.</p></li><li><p>Cadieu, C. F. et al. Deep Neural Networks Rival the Representation of Primate IT Cortex for Core Visual Object Recognition. PLoS Comput Biol 10, e1003963 (2014). URL</p><p><a href="https://link.jianshu.com/?t=http://dx.doi.org/10.1371/journal.pcbi.1003963">http: //dx.doi.org/10.1371/journal.pcbi.1003963</a>.</p></li><li><p>K ̈ummerer, M., Theis, L. &amp; Bethge, M. Deep Gaze I: Boosting Saliency Prediction with Feature Maps Trained on ImageNet. In ICLR Workshop (2015). URL /media/publications/1411.1045v4.pdf.</p></li><li><p>Khaligh-Razavi, S.-M. &amp; Kriegeskorte, N. Deep Supervised, but Not Unsupervised, Models May Explain IT Cortical Representation. PLoS Comput Biol 10, e1003915 (2014). URL</p><p><a href="https://link.jianshu.com/?t=http://dx.doi.org/10.1371/journal.pcbi.1003915">http: //dx.doi.org/10.1371/journal.pcbi.1003915</a>.</p></li><li><p>Gatys, L. A., Ecker, A. S. &amp; Bethge, M. Texture synthesis and the controlled generation of natural stimuli using convolutional neural networks. arXiv:1505.07376 <a href="2015">cs, q-bio</a>. URL <a href="https://link.jianshu.com/?t=http://arxiv.org/abs/1505.07376">http://arxiv.org/abs/1505.07376</a>. ArXiv: 1505.07376.</p></li><li><p>Mahendran, A. &amp; Vedaldi, A. Understanding Deep Image Representations by Inverting Them. arXiv:1412.0035 <a href="2014">cs</a>. URL <a href="https://link.jianshu.com/?t=http://arxiv.org/abs/1412.0035">http://arxiv.org/abs/1412.0035</a>. ArXiv: 1412.0035.</p></li><li><p>Heeger, D. J. &amp; Bergen, J. R. Pyramid-based Texture Analysis/Synthesis. In Proceedings of the 22Nd Annual Conference on Computer Graphics and Interactive Techniques, SIGGRAPH ’95, 229–238 (ACM, New York, NY, USA, 1995). URL <a href="https://link.jianshu.com/?t=http://doi.acm.org/10.1145/218380.218446">http://doi.acm.org/10.1145/218380.218446</a>.</p></li><li><p>Portilla, J. &amp; Simoncelli, E. P. A Parametric Texture Model Based on Joint Statistics of Complex Wavelet Coefficients. International Journal of Computer Vision 40, 49–70 (2000). URL</p><p><a href="https://link.jianshu.com/?t=http://link.springer.com/article/10.1023/A:1026553619983">http: //link.springer.com/article/10.1023/A%3A1026553619983</a>.</p></li><li><p>Tenenbaum, J. B. &amp; Freeman, W. T. Separating style and content with bilinear models. Neural computation 12, 1247–1283 (2000). URL <a href="https://link.jianshu.com/?t=http://www.mitpressjournals.org/doi/abs/10.1162/089976600300015349">http://www.mitpressjournals.org/doi/abs/10.1162/089976600300015349</a>.</p></li><li><p>Elgammal, A. &amp; Lee, C.-S. Separating style and content on a nonlinear manifold. In Computer Vision and Pattern Recognition, 2004. CVPR 2004. Proceedings of the 2004 IEEE Computer Society Conference on, vol. 1, I–478 (IEEE, 2004). URL <a href="https://link.jianshu.com/?t=http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1315070">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1315070</a>.</p></li><li><p>Kyprianidis, J. E., Collomosse, J., Wang, T. &amp; Isenberg, T. State of the ”Art”: A Taxonomy of Artistic Stylization Techniques for Images and Video. Visualization and Computer 14Graphics, IEEE Transactions on 19, 866–885 (2013). URL <a href="https://link.jianshu.com/?t=http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6243138">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6243138</a>.</p></li><li><p>Hertzmann, A., Jacobs, C. E., Oliver, N., Curless, B. &amp; Salesin, D. H. Image analogies. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques, 327–340 (ACM, 2001). URL</p><p><a href="https://link.jianshu.com/?t=http://dl.acm.org/citation.cfm?id=383295">http: //dl.acm.org/citation.cfm?id=383295</a>.</p></li><li><p>Ashikhmin, N. Fast texture transfer. IEEE Computer Graphics and Applications 23, 38–43(2003).</p></li><li><p>Efros, A. A. &amp; Freeman, W. T. Image quilting for texture synthesis and transfer. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques, 341–346 (ACM, 2001). URL <a href="https://link.jianshu.com/?t=http://dl.acm.org/citation.cfm?id=383296">http://dl.acm.org/citation.cfm?id=383296</a>.</p></li><li><p>Lee, H., Seo, S., Ryoo, S. &amp; Yoon, K. Directional Texture Transfer. In Proceedings of the 8th International Symposium on Non-Photorealistic Animation and Rendering, NPAR ’10, 43–48 (ACM, New York, NY, USA, 2010). URL <a href="https://link.jianshu.com/?t=http://doi.acm.org/10.1145/1809939.1809945">http://doi.acm.org/10.1145/1809939.1809945</a>.</p></li><li><p>Xie, X., Tian, F. &amp; Seah, H. S. Feature Guided Texture Synthesis (FGTS) for Artistic Style Transfer. In Proceedings of the 2Nd International Conference on Digital Interactive Media in Entertainment and Arts, DIMEA ’07, 44–49 (ACM, New York, NY, USA, 2007). URL <a href="https://link.jianshu.com/?t=http://doi.acm.org/10.1145/1306813.1306830">http://doi.acm.org/10.1145/1306813.1306830</a>.</p></li><li><p>Karayev, S. et al. Recognizing image style. arXiv preprint arXiv:1311.3715 (2013). URL</p><p><a href="https://link.jianshu.com/?t=http://arxiv.org/abs/1311.3715">http: //arxiv.org/abs/1311.3715</a>.</p></li><li><p>Adelson, E. H. &amp; Bergen, J. R. Spatiotemporal energy models for the perception of motion. JOSA A 2, 284–299 (1985). URL <a href="https://link.jianshu.com/?t=http://www.opticsinfobase.org/josaa/fulltext.cfm?uri=josaa-2-2-284">http://www.opticsinfobase.org/josaa/fulltext.cfm?uri=josaa-2-2-284</a>.</p></li><li><p>Simonyan, K. &amp; Zisserman, A. Very Deep Convolutional Networks for Large-Scale Image Recognition. arXiv:1409.1556 <a href="2014">cs</a>. URL <a href="https://link.jianshu.com/?t=http://arxiv.org/abs/1409.1556">http://arxiv.org/abs/1409.1556</a>. ArXiv: 1409.1556.</p></li><li><p>Russakovsky, O. et al. ImageNet Large Scale Visual Recognition Challenge. arXiv:1409.0575 <a href="2014">cs</a>. URL <a href="https://link.jianshu.com/?t=http://arxiv.org/abs/1409.0575">http://arxiv.org/abs/1409.0575</a>. ArXiv:1409.0575.</p></li><li><p>Jia, Y. et al. Caffe: Convolutional architecture for fast feature embedding. In Proceedings of the ACM International Conference on Multimedia, 675–678 (ACM, 2014). URL <a href="https://link.jianshu.com/?t=http://dl.acm.org/citation.cfm?id=2654889">http://dl.acm.org/citation.cfm?id=2654889</a>.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他翻译 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
